
using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Announcements;
using Beamable.Api.Autogenerated.Auth;
using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Calendars;
using Beamable.Api.Autogenerated.Cloudsaving;
using Beamable.Api.Autogenerated.Commerce;
using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.EventPlayers;
using Beamable.Api.Autogenerated.Events;
using Beamable.Api.Autogenerated.Groups;
using Beamable.Api.Autogenerated.GroupUsers;
using Beamable.Api.Autogenerated.Inventory;
using Beamable.Api.Autogenerated.Leaderboards;
using Beamable.Api.Autogenerated.Lobby;
using Beamable.Api.Autogenerated.Mail;
using Beamable.Api.Autogenerated.Mailbox;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Notification;
using Beamable.Api.Autogenerated.Party;
using Beamable.Api.Autogenerated.Payments;
using Beamable.Api.Autogenerated.Player;
using Beamable.Api.Autogenerated.Presence;
using Beamable.Api.Autogenerated.Push;
using Beamable.Api.Autogenerated.Realms;
using Beamable.Api.Autogenerated.Scheduler;
using Beamable.Api.Autogenerated.Session;
using Beamable.Api.Autogenerated.Social;
using Beamable.Api.Autogenerated.Stats;
using Beamable.Api.Autogenerated.Tournaments;
using Beamable.Api.Autogenerated.Trials;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Serialization;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

namespace Beamable.Api.Autogenerated
{
	public class OpenApiRegistration
	{
		public static void RegisterOpenApis(IDependencyBuilder builder)
		{
			// ApiSchedulerJobNextExecutionsGetSchedulerResponse
			// content requires special CSV parsing, and this allows us to inject an override.
			builder.AddSingleton<ICustomSerializer<ClientManifestCsvResponse>, ClientManifestCsvResponseSerializer>();
			builder.AddSingleton<ICustomSerializer<ApiSchedulerJobsGetSchedulerResponse>, ArrayResponseSerializer<ApiSchedulerJobsGetSchedulerResponse, JobDefinition>>();
			builder.AddSingleton<ICustomSerializer<ApiSchedulerJobActivityGetSchedulerResponse>, ArrayResponseSerializer<ApiSchedulerJobActivityGetSchedulerResponse, JobActivity>>();
			builder.AddSingleton<ICustomSerializer<ApiSchedulerJobNextExecutionsGetSchedulerResponse>, ArrayDateTimeResponseSerializer<ApiSchedulerJobNextExecutionsGetSchedulerResponse>>();
			builder.AddSingleton<ICustomSerializer<CloudStorage>, CloudStorageSerializer>();
			builder.AddOrOverrideScoped<IAccountsApi, AccountsApi>();
			builder.AddOrOverrideScoped<IContentApi, ContentApi>();
			builder.AddOrOverrideScoped<IAnnouncementsApi, AnnouncementsApi>();
			builder.AddOrOverrideScoped<IAuthApi, AuthApi>();
			builder.AddOrOverrideScoped<IBeamoApi, BeamoApi>();
			builder.AddOrOverrideScoped<ICalendarsApi, CalendarsApi>();
			builder.AddOrOverrideScoped<ICloudsavingApi, CloudsavingApi>();
			builder.AddOrOverrideScoped<ICommerceApi, CommerceApi>();
			builder.AddOrOverrideScoped<IEventPlayersApi, EventPlayersApi>();
			builder.AddOrOverrideScoped<IEventsApi, EventsApi>();
			builder.AddOrOverrideScoped<IGroupsApi, GroupsApi>();
			builder.AddOrOverrideScoped<IGroupUsersApi, GroupUsersApi>();
			builder.AddOrOverrideScoped<IInventoryApi, InventoryApi>();
			builder.AddOrOverrideScoped<ILeaderboardsApi, LeaderboardsApi>();
			builder.AddOrOverrideScoped<IMailApi, MailApi>();
			builder.AddOrOverrideScoped<INotificationApi, NotificationApi>();
			builder.AddOrOverrideScoped<IPaymentsApi, PaymentsApi>();
			builder.AddOrOverrideScoped<IPushApi, PushApi>();
			builder.AddOrOverrideScoped<IRealmsApi, RealmsApi>();
			builder.AddOrOverrideScoped<ISocialApi, SocialApi>();
			builder.AddOrOverrideScoped<IStatsApi, StatsApi>();
			builder.AddOrOverrideScoped<ITournamentsApi, TournamentsApi>();
			builder.AddOrOverrideScoped<ISessionApi, SessionApi>();
			builder.AddOrOverrideScoped<ITrialsApi, TrialsApi>();

			// proto-actor based services
			builder.AddOrOverrideScoped<IBeamAuthApi, BeamAuthApi>();
			builder.AddOrOverrideScoped<IBeamLobbyApi, BeamLobbyApi>();
			builder.AddOrOverrideScoped<IBeamMailboxApi, BeamMailboxApi>();
			builder.AddOrOverrideScoped<IBeamPartyApi, BeamPartyApi>();
			builder.AddOrOverrideScoped<IBeamPlayerApi, BeamPlayerApi>();
			builder.AddOrOverrideScoped<IBeamPresenceApi, BeamPresenceApi>();
			builder.AddOrOverrideScoped<IBeamSchedulerApi, BeamSchedulerApi>();
		}
	}

	static class OpenApiRegistrationExtensions
	{
		public static void AddOrOverrideScoped<TInterface, TImpl>(this IDependencyBuilder builder) where TImpl : TInterface
		{
			if (builder.Has<TInterface>())
			{
				builder.Remove<TInterface>();
			}
			if (builder.Has<TImpl>())
			{
				builder.Remove<TImpl>();
			}

			builder.AddScoped<TImpl>();
			builder.AddScoped<TInterface>(p => p.GetService<TImpl>());
		}
	}

	public interface ICustomSerializer<T>
	{
		T Deserialize(string data);
	}

	public class CloudStorageSerializer : ICustomSerializer<CloudStorage>
	{
		public CloudStorage Deserialize(string data)
		{
			var storage = new CloudStorage();
			var wrapper = JsonSerializable.FromJson<CloudStorageWrapper>(data);
			storage.reference = wrapper.reference;
			return storage;
		}

		public class CloudStorageWrapper : CloudStorage
		{
			public override void Serialize(JsonSerializable.IStreamSerializer s)
			{
				base.Serialize(s);
				if ((s.HasKey("ref")
					 || ((reference != default(OptionalString))
						 && reference.HasValue)))
				{
					s.Serialize("ref", ref reference.Value);
					reference.HasValue = true;
				}
			}
		}
	}

	public class ArrayDateTimeResponseSerializer<T> : ICustomSerializer<T>
		where T : List<DateTime>, new()
	{
		private readonly string[] formats = new[]
		{
			"yyyy-MM-ddTHH:mm:ssZ",
			"yyyy-MM-ddTHH:mm:ss.fZ",
			"yyyy-MM-ddTHH:mm:ss.ffZ",
			"yyyy-MM-ddTHH:mm:ss.fffZ"
		};
		public T Deserialize(string data)
		{
			const string jsonPrefix = "{\"" + nameof(SneakyArrayWrapper.data) + "\":";
			const string jsonSuffix = "}";
			var json = jsonPrefix + data + jsonSuffix;
			var wrapper = JsonSerializable.FromJson<SneakyArrayWrapper>(json);
			var res = new T();
			res.AddRange(wrapper.data.Select(d =>
			{
				for (var i = 0; i < formats.Length; i++)
				{
					try
					{
						var x = DateTime.ParseExact(d, formats[i], CultureInfo.InvariantCulture);
						return x;
					}
					catch (FormatException)
					{
						// continue...
					}
				}

				throw new FormatException("Could not handle " + d + " , was not any of " + string.Join(",", formats));
			}).ToList());
			return res;
		}


		[Serializable]
		class SneakyArrayWrapper : JsonSerializable.ISerializable
		{
			public string[] data;
			public void Serialize(JsonSerializable.IStreamSerializer s)
			{
				s.SerializeArray(nameof(data), ref data);
			}
		}
	}

	public class ArrayResponseSerializer<T, TElement> : ICustomSerializer<T>
		where T : List<TElement>, new()
	{
		private List<JsonSerializable.ISerializableFactory> _serializationFactories =
			new List<JsonSerializable.ISerializableFactory>();
		public ArrayResponseSerializer()
		{
			_serializationFactories.Add(new IOneOf_HttpCallOrPublishMessageOrServiceCallFactory());
			_serializationFactories.Add(new IOneOf_CronTriggerOrExactTriggerFactory());
			_serializationFactories.Add(new IOneOf_ContentOrTextOrBinaryFactory());
		}

		public T Deserialize(string data)
		{
			const string jsonPrefix = "{\"" + nameof(SneakyArrayWrapper.data) + "\":";
			const string jsonSuffix = "}";
			var json = jsonPrefix + data + jsonSuffix;
			var wrapper = JsonSerializable.FromJson<SneakyArrayWrapper>(json, _serializationFactories);
			var res = new T();
			res.AddRange(wrapper.data);
			return res;
		}


		[Serializable]
		class SneakyArrayWrapper : JsonSerializable.ISerializable
		{
			public TElement[] data;
			public void Serialize(JsonSerializable.IStreamSerializer s)
			{
				s.SerializeArray(nameof(data), ref data);
			}
		}
	}

	public class ClientManifestCsvResponseSerializer : ICustomSerializer<ClientManifestCsvResponse>
	{
		public ClientManifestCsvResponse Deserialize(string data)
		{
			var scanner = new CsvManifestScanner(data);
			var manifest = scanner.Parse();

			var response = new ClientManifestCsvResponse();
			response.itemsCsv = new Models.ClientContentInfo[manifest.entries.Count];
			for (var i = 0; i < response.itemsCsv.Length; i++)
			{
				response.itemsCsv[i] = new Models.ClientContentInfo
				{
					contentId = manifest.entries[i].contentId,
					tags = manifest.entries[i].tags,
					type = ContentType.Content,
					uri = manifest.entries[i].uri,
					version = manifest.entries[i].version,
				};
			}
			return response;
		}
	}
}
