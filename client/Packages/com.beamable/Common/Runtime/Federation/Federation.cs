// this file was copied from nuget package Beamable.Common@4.3.0-PREVIEW.RC2
// https://www.nuget.org/packages/Beamable.Common/4.3.0-PREVIEW.RC2

using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Api.Auth;
using Beamable.Common.BeamCli;
using Beamable.Common.Dependencies;
using BeamableReflection;
using System;
using System.Collections.Generic;
using System.Reflection;
using ItemProperty = Beamable.Common.Api.Inventory.ItemProperty;

namespace Beamable.Common
{
	/// <summary>
	/// All of our federations must inherit from this interface and have a type argument constrained to <see cref="IFederationId"/>.
	/// For example, ISomeFederation[T] : IFederation where T : IFederationId
	/// </summary>
	public interface IFederation
	{
		/// <summary>
		/// This interface should be implemented by all types that define the local service configurable options for a particular federation type.
		/// <see cref="IFederatedGameServer{T}"/> for an example of this. 
		/// </summary>
		public interface ILocalSettings
		{
		}
	}

	/// <summary>
	/// Uniquely identifies a federation implementation. 
	/// </summary>
	[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
	public class FederationIdAttribute : System.Attribute
	{
		public string FederationId { get; }

		public FederationIdAttribute(string federationId)
		{
			FederationId = federationId;
		}
	}

	public static class FederationIdUtil
	{

		/// <summary>
		/// Get the federation id string from a type of <see cref="IFederationId"/>.
		/// The FederationId is the unique name of a federation implementation. 
		/// </summary>
		/// <param name="federationIdType"></param>
		/// <returns></returns>
		public static string GetUniqueName(Type federationIdType)
		{
			var attribute = federationIdType.GetCustomAttribute<FederationIdAttribute>();
			if (attribute == null)
			{
#pragma warning disable CS0618 // Type or member is obsolete
				if (typeof(IThirdPartyCloudIdentity).IsAssignableFrom(federationIdType))

				{
					var thirdPartyType = (IThirdPartyCloudIdentity) Activator.CreateInstance(federationIdType);
					return thirdPartyType.UniqueName;
				}
#pragma warning restore CS0618 // Type or member is obsolete
				else
				{
					throw new Exception(
						$"{nameof(FederationIdAttribute)} is required on type {federationIdType.FullName}");
				}
			}
			return attribute.FederationId;
		}
				
		/// <summary>
		/// Get the federation id string from a type of <see cref="IFederationId"/>.
		/// The FederationId is the unique name of a federation implementation. 
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		public static string GetUniqueName<T>() where T : IFederationId
		{
			return GetUniqueName(typeof(T));
		}

		/// <summary>
		/// Get the federation id string from an instance of <see cref="IFederationId"/>.
		/// The FederationId is the the unique name of a federation implementation. 
		/// </summary>
		/// <param name="federationId"></param>
		/// <returns></returns>
		public static string GetUniqueName(this IFederationId federationId)
		{
			return GetUniqueName(federationId?.GetType());
		}
	}

	/// <summary>
	/// Uniquely identifies a federation implementation.
	/// This enables different implementations of the same federation to be active at the same time.
	///
	/// Must have the <see cref="FederationIdAttribute"/> on the class. 
	/// 
	/// For example, <see cref="IFederatedLogin{T}"/> is used to implement external auth. A game might want different implementations for `epic`, `steam`, or some other third-party account holder.  
	/// </summary>
	[Preserve]
	public interface IFederationId
	{

	}

	/// <summary>
	/// Old version of <see cref="IFederationId"/>. To be deleted at next major release.
	/// </summary>
	[Preserve, Obsolete("Please use " + nameof(IFederationId) + " instead.")]
	public interface IThirdPartyCloudIdentity : IFederationId
	{
		/// <summary>
		/// This should be a constant string: UniqueName => "my_federation_id".
		/// </summary>
		[Obsolete("Please use " + nameof(FederationIdUtil.GetUniqueName) + "() instead.")]
		string UniqueName { get; }
	}

	/// <summary>
	/// In various locations in code, we need a data structure to define all federations that exist for a particular <see cref="IFederationId"/>.
	/// This structure holds that data.
	/// </summary>
	[Serializable, CliContractType]
	public struct FederationInstance
	{
		/// <summary>
		/// The federation id for this federation instance.
		/// </summary>
		public string FederationId;

		/// <summary>
		/// The list of interface names of <see cref="IFederation"/> sub-interfaces.
		/// </summary>
		public string[] FederationTypes;

		/// <summary>
		/// The list of serialized <see cref="IFederation.ILocalSettings"/> for each federation type here.
		/// </summary>
		public string[] LocalSettings;
	}

	public interface IHaveServiceName
	{
		string ServiceName { get; }
	}

	public interface ISupportsFederatedLogin<T> : IHaveServiceName where T : IFederationId, new()
	{
		IDependencyProvider Provider { get; }
	}

	public interface ISupportsFederatedInventory<T> : ISupportsFederatedLogin<T>
		where T : IFederationId, new()
	{
	}

	/// <summary>
	/// Utility class to help enforce federation-related conventions.
	/// </summary>
	public static class FederationUtils
	{
		public static string BuildLocalSettingKey(Type fedType, string fedId) => BuildLocalSettingKey(fedType.GetNameWithoutGenericArity(), fedId);
		public static string BuildLocalSettingKey(string fedTypeName, string fedId) => $"LocalSetting₢{fedTypeName}₢{fedId}";

		public static bool TrySplitLocalSettingKey(string key, out FederationType type, out string federationId)
		{
			type = FederationType.IFederatedPlayerInit;
			federationId = string.Empty;

			// Validate the key format
			if (!key.Contains("₢")) return false;
			var parts = key.Split('₢');
			if (parts.Length != 3) return false;

			// Parse and validate the enum name
			if (!Enum.TryParse(parts[1], true, out type)) return false;

			federationId = parts[2];
			return true;
		}
	}
}
