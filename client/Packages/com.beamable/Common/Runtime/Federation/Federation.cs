// this file was copied from nuget package Beamable.Common@3.0.0-PREVIEW.RC6
// https://www.nuget.org/packages/Beamable.Common/3.0.0-PREVIEW.RC6

using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Api.Auth;
using Beamable.Common.BeamCli;
using Beamable.Common.Dependencies;
using BeamableReflection;
using System;
using System.Collections.Generic;
using ItemProperty = Beamable.Common.Api.Inventory.ItemProperty;

namespace Beamable.Common
{
	/// <summary>
	/// All of our federations must inherit from this interface and have a type argument constrained to <see cref="IFederationId"/>.
	/// For example, ISomeFederation[T] : IFederation where T : IFederationId
	/// </summary>
	public interface IFederation
	{
		/// <summary>
		/// This interface should be implemented by all types that define the local service configurable options for a particular federation type.
		/// <see cref="IFederatedGameServer{T}"/> for an example of this. 
		/// </summary>
		public interface ILocalSettings
		{
		}
	}

	/// <summary>
	/// Uniquely identifies a federation implementation.
	/// This enables different implementations of the same federation to be active at the same time.
	///
	/// For example, <see cref="IFederatedLogin{T}"/> is used to implement external auth. A game might want different implementations for `epic`, `steam`, or some other third-party account holder.  
	/// </summary>
	[Preserve]
	public interface IFederationId
	{
		/// <summary>
		/// This should be a constant string: UniqueName => "my_federation_id".
		/// </summary>
		string UniqueName { get; }
	}

	/// <summary>
	/// Old version of <see cref="IFederationId"/>. To be deleted at next major release.
	/// </summary>
	[Preserve, Obsolete("Please use IFederationId instead.")]
	public interface IThirdPartyCloudIdentity : IFederationId
	{
		// No longer used internally!!!
	}

	/// <summary>
	/// In various locations in code, we need a data structure to define all federations that exist for a particular <see cref="IFederationId"/>.
	/// This structure holds that data.
	/// </summary>
	[Serializable, CliContractType]
	public struct FederationInstance
	{
		/// <summary>
		/// The federation id for this federation instance.
		/// </summary>
		public string FederationId;

		/// <summary>
		/// The list of interface names of <see cref="IFederation"/> sub-interfaces.
		/// </summary>
		public string[] FederationTypes;

		/// <summary>
		/// The list of serialized <see cref="IFederation.ILocalSettings"/> for each federation type here.
		/// </summary>
		public string[] LocalSettings;
	}

	public interface IHaveServiceName
	{
		string ServiceName { get; }
	}

	public interface ISupportsFederatedLogin<T> : IHaveServiceName where T : IFederationId, new()
	{
		IDependencyProvider Provider { get; }
	}

	public interface ISupportsFederatedInventory<T> : ISupportsFederatedLogin<T>
		where T : IFederationId, new()
	{
	}

	/// <summary>
	/// Utility class to help enforce federation-related conventions.
	/// </summary>
	public static class FederationUtils
	{
		public static string BuildLocalSettingKey(Type fedType, string fedId) => BuildLocalSettingKey(fedType.GetNameWithoutGenericArity(), fedId);
		public static string BuildLocalSettingKey(string fedTypeName, string fedId) => $"LocalSetting₢{fedTypeName}₢{fedId}";

		public static bool TrySplitLocalSettingKey(string key, out FederationType type, out string federationId)
		{
			type = FederationType.IFederatedPlayerInit;
			federationId = string.Empty;

			// Validate the key format
			if (!key.Contains("₢")) return false;
			var parts = key.Split('₢');
			if (parts.Length != 3) return false;

			// Parse and validate the enum name
			if (!Enum.TryParse(parts[1], true, out type)) return false;

			federationId = parts[2];
			return true;
		}
	}
}
