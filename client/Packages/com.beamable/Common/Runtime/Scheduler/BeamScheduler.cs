using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Scheduler;
using Beamable.Common.Api;
using Beamable.Common.Content;
using Beamable.Common.Scheduler;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Beamable.Common.Scheduler
{
	public class BeamScheduler
	{
		private readonly IBeamSchedulerApi _api;

		public BeamScheduler(IBeamSchedulerApi api)
		{
			_api = api;
		}

		public async Promise<List<JobExecution>> GetJobActivity(string jobId, OptionalInt limit=null)
		{
			var res = await _api.GetJobActivity(jobId, limit);
			var executions = res.Select(Utility.Convert).ToList();
			return executions;
		}
		
		public async Promise GetJobUpcomingExecutions(string jobId)
		{
			throw new NotImplementedException(); // TODO: the auto-gen api doesn't handle this,
			/*
			 *       "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "date-time"
                  }
                }
              }
            }
          },
			 */
			// _api.GetJobNextExecutions()
		}


		public async Promise DeleteJob(Job job) => await DeleteJob(job?.id);
		public async Promise DeleteJob(string jobId)
		{
			await _api.DeleteJob(jobId);
		}

		public async Promise<List<Job>> GetJobs(
			OptionalInt limit=null, 
			OptionalString source=null, 
			OptionalString name=null)
		{
			var res = await _api.GetJobs(limit, name, source);
			var jobs = res.Select(Utility.Convert).ToList();
			return jobs;
		}

		public async Promise<Job> GetJob(Job job) => await GetJob(job?.id);
		public async Promise<Job> GetJob(string jobId)
		{
			var res = await _api.GetJob(jobId);
			var job = Utility.Convert(res);
			return job;
		}
		
		public async Promise<Job> CreateJob(
			string name, 
			string source, 
			ISchedulableAction action, 
			ISchedulerTrigger trigger,
			RetryPolicy retryPolicy=null)
		{
			var req = Utility.CreateSaveRequest(name, source, action, new ISchedulerTrigger[]{trigger}, retryPolicy);
			var res = await _api.PostJob(req);
			var job = Utility.Convert(res);
			return job;
		}

		public static class Utility
		{
			public static JobExecution Convert(JobActivity activity)
			{
				return new JobExecution
				{
					id = activity.id.GetOrThrow(() => new Exception("Job activity needs id")),
					jobId = activity.jobId.GetOrThrow(() => new Exception("Job activity needs jobId")),
					executionId =
						activity.executionId.GetOrThrow(() => new Exception("Job activity needs executionId")),
					state = activity.state.GetOrThrow(() => new Exception("Job activity needs state")),
					message = activity.message.Value,
					timestamp = activity.timestamp
				};
			}
			public static Job Convert(JobDefinition job)
			{
				var retry = job.retryPolicy.GetOrThrow(() => new Exception("Job definition has no retry policy"));
				var j = new Job()
				{
					id = job.id.GetOrThrow(() => new Exception("Job definition has no id.")),
					action = job.jobAction.Convert(),
					triggers = job.triggers.Select(t => t.Convert()).ToList(),
					source = job.source.GetOrThrow(() => new Exception("Job definition has no source")),
					name = job.name.GetOrThrow(() => new Exception("Job definition has no name")),
					owner = job.owner.GetOrThrow(() => new Exception("Job definition has no owner")),
					retryPolicy = new RetryPolicy
					{
						maxRetryCount = retry.maxRetryCount.GetOrThrow(()=> new Exception("Retry policy has no maxRetryCount")),
						retryDelayMs = retry.retryDelayMs.GetOrThrow(()=> new Exception("Retry policy has no retryDelayMs")),
						useExponentialBackoff = retry.useExponentialBackoff.GetOrThrow(()=> new Exception("Retry policy has no useExponentialBackoff")),
					}
				};

				return j;
			}

			public static JobDefinitionSaveRequest CreateSaveRequest(
				string name,
				string source,
				ISchedulableAction action,
				ISchedulerTrigger[] triggers,
				RetryPolicy retryPolicy = null)
			{
				retryPolicy ??= new RetryPolicy();
				return new JobDefinitionSaveRequest
				{
					name = new OptionalString(name),
					source = new OptionalString(source),
					jobAction = action.Convert(),
					triggers = triggers.Select(t => t.Convert()).ToArray(),
					retryPolicy = new OptionalJobRetryPolicy(new JobRetryPolicy
					{
						retryDelayMs = new OptionalInt(retryPolicy.retryDelayMs),
						maxRetryCount = new OptionalInt(retryPolicy.maxRetryCount),
						useExponentialBackoff = new OptionalBool(retryPolicy.useExponentialBackoff)
					})
				};
			}
		}
	}

	public interface ISchedulableAction : IConvertToSchedulerAction
	{
		
	}

	public interface ISchedulerTrigger : IConvertToSchedulerTrigger
	{
		
	}

	public interface IConvertToSchedulerAction
	{
		IOneOf_HttpCallOrPublishMessageOrServiceCall Convert();
	}

	public interface IConvertToSchedulerTrigger
	{
		IOneOf_CronTriggerOrExactTrigger Convert();
	}

	[Serializable]
	public class JobExecution
	{
		public string executionId;
		public string id;
		public string jobId;
		public string message;
		public JobState state;
		public string timestamp;
	}
	

	[Serializable]
	public class Job : ISerializationCallbackReceiver
	{
		public string id;

		public OptionalString lastUpdate;
		public string name;
		public string source;
		public string owner;
		public RetryPolicy retryPolicy;
		
		[NonSerialized]
		public ISchedulableAction action;

		[NonSerialized]
		public List<ISchedulerTrigger> triggers = new List<ISchedulerTrigger>();

		[SerializeField]
		private HttpAction _httpAction;
		
		[SerializeField]
		private ServiceAction _serviceAction;
		
		[SerializeField]
		private PublishAction _publishAction;

		[SerializeField]
		private List<CronEvent> _cronTriggers;
		
		[SerializeField]
		private List<ExactTimeEvent> _exactTimeTriggers;


		public void OnBeforeSerialize()
		{
			_httpAction = null;
			_serviceAction = null;
			_publishAction = null;
			_exactTimeTriggers = new List<ExactTimeEvent>();
			_cronTriggers = new List<CronEvent>();
			switch (action)
			{
				case HttpAction http:
					_httpAction = http;
					break;
				case ServiceAction service:
					_serviceAction = service;
					break;
				case PublishAction publish:
					_publishAction = publish;
					break;
			}

			if (triggers == null) return;
			foreach (var trigger in triggers)
			{
				switch (trigger)
				{
					case CronEvent cron:
						_cronTriggers.Add(cron);
						break;
					case ExactTimeEvent exact:
						_exactTimeTriggers.Add(exact);
						break;
				}
			}
		}

		public void OnAfterDeserialize()
		{
			if (_httpAction != null)
			{
				action = _httpAction;
			}
			if (_serviceAction != null)
			{
				action = _serviceAction;
			}
			if (_publishAction != null)
			{
				action = _publishAction;
			}

			triggers = new List<ISchedulerTrigger>();
			if (_cronTriggers != null)
			{
				triggers.AddRange(_cronTriggers);
			}

			if (_exactTimeTriggers != null)
			{
				triggers.AddRange(_exactTimeTriggers);
			}
		}
	}
	
	[Serializable]
	public class RetryPolicy
	{
		public int maxRetryCount = 10;
		public int retryDelayMs = 1000;
		public bool useExponentialBackoff = true;
	}
	
	[Serializable]
	public class ExactTimeEvent : ISchedulerTrigger
	{
		public DateTimeOffset executeAt = DateTimeOffset.UtcNow;
		
		public ExactTimeEvent(){}

		public ExactTimeEvent(DateTimeOffset executeAt)
		{
			this.executeAt = executeAt;
		}

		public IOneOf_CronTriggerOrExactTrigger Convert()
		{
			return new ExactTrigger
			{
				type = new OptionalString(nameof(ExactTrigger)), 
				executeAt = new OptionalString(executeAt.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ"))
			};
		}
	}
	
	[Serializable]
	public class CronEvent : ISchedulerTrigger
	{
		public string cronExpression = "* * * * * *";
		
		public CronEvent(){}

		public CronEvent(string cronExpression)
		{
			this.cronExpression = cronExpression;
		}
		
		IOneOf_CronTriggerOrExactTrigger IConvertToSchedulerTrigger.Convert()
		{
			return new Beamable.Api.Autogenerated.Models.CronTrigger
			{
				type = new OptionalString(nameof(Beamable.Api.Autogenerated.Models.CronTrigger)), expression = new OptionalString(cronExpression)
			};
		}
	}
	
	[Serializable]
	public class HttpAction : ISchedulableAction
	{
		public Method method = Method.GET;
		public string uri;
		public string contentType = "application/json";
		public string body;
		public List<HttpCallHeader> headers = new List<HttpCallHeader>();

		IOneOf_HttpCallOrPublishMessageOrServiceCall IConvertToSchedulerAction.Convert()
		{
			return new HttpCall
			{
				uri = new OptionalString(uri),
				method = new OptionalString(method.ToReadableString()),
				body = new OptionalString(body),
				type = new OptionalString(nameof(HttpCall)),
				contentType = new OptionalString(contentType),
				headers = new OptionalArrayOfStringStringKeyValuePair(headers.Select(h => new StringStringKeyValuePair
				{
					key = new OptionalString(h.key),
					value = new OptionalString(h.value)
				}).ToArray())
			};
		}
	}

	[Serializable]
	public class ServiceAction : ISchedulableAction
	{
		public string body;
		public Method method = Method.GET;
		public string uri;
		
		
		IOneOf_HttpCallOrPublishMessageOrServiceCall IConvertToSchedulerAction.Convert()
		{
			return new ServiceCall
			{
				body = new OptionalString(body),
				method = new OptionalString(method.ToReadableString()),
				uri = new OptionalString(uri),
				type = new OptionalString(nameof(ServiceCall))
			};
		}
	}
	
	[Serializable]
	public class PublishAction : ISchedulableAction
	{
		public string topic;
		public string message;
		public OptionalMapOfString headers;
		public bool persist;
		
		
		IOneOf_HttpCallOrPublishMessageOrServiceCall IConvertToSchedulerAction.Convert()
		{
			return new PublishMessage
			{
				topic = new OptionalString(topic),
				message = new OptionalString(message),
				headers = headers,
				persist = new OptionalBool(persist),
				type = new OptionalString(nameof(PublishMessage))
			};
		}
	}

	[Serializable]
	public class HttpCallHeader
	{
		public string key;
		public string value;
	}

}


namespace Beamable.Api.Autogenerated.Models
{
	public partial interface IOneOf_CronTriggerOrExactTrigger
	{
		ISchedulerTrigger Convert();
	}

	public partial class CronTrigger
	{
		public ISchedulerTrigger Convert()
		{
			return new CronEvent
			{
				cronExpression = expression.GetOrThrow(() => new Exception("CronEvent needs cron expression"))
			};
		}
	}

	public partial class ExactTrigger
	{
		public ISchedulerTrigger Convert()
		{
			if (!DateTimeOffset.TryParseExact(executeAt.GetOrThrow(() => new Exception("ExactTime needs exectAt")), "yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture, DateTimeStyles.None, out var date))
			{
				throw new Exception("ExactTime has invalid date string");
			}

			return new ExactTimeEvent { executeAt = date };
		}
	}
	
	public partial interface IOneOf_HttpCallOrPublishMessageOrServiceCall
	{
		ISchedulableAction Convert();
	}

	public partial class HttpCall
	{
		public ISchedulableAction Convert()
		{
			if (!MethodUtil.TryParseMethod(method.GetOrThrow(() => new Exception("HttpAction must have a method")),
				    out var parsedMethod))
			{
				throw new Exception("HttpAction method was not able to parse");
			}

			return new HttpAction
			{
				body = body.Value,
				uri = uri.GetOrThrow(() => new Exception("HttpAction must have uri")),
				contentType = contentType.GetOrThrow(() => new Exception("HttpAction must have contentType")),
				method = parsedMethod,
				headers = headers.GetOrElse(Array.Empty<StringStringKeyValuePair>()).Select(v => new HttpCallHeader
				{
					key = v.key.GetOrThrow(() => new Exception("Header must have a key")),
					value = v.value.GetOrThrow(() => new Exception("Header must have a value")),
				}).ToList()
			};
		}
	}
	public partial class PublishMessage
	{
		public ISchedulableAction Convert()
		{
			return new PublishAction
			{
				headers = headers,
				message = message.GetOrThrow(() => new Exception("PublishMessage must have message")),
				topic = topic.GetOrThrow(() => new Exception("PublishMessage must have topic")),
				persist = persist.GetOrThrow(() => new Exception("PublishMessage must have persist")),
			};
		}
	}
	public partial class ServiceCall
	{
		public ISchedulableAction Convert()
		{
			if (!MethodUtil.TryParseMethod(method.GetOrThrow(() => new Exception("ServiceCall must have a method")),
				    out var parsedMethod))
			{
				throw new Exception("ServiceCall method was not able to parse");
			}
			return new ServiceAction
			{
				body = body.GetOrThrow(() => new Exception("ServiceCall must have a body")),
				method = parsedMethod,
				uri = uri.GetOrThrow(() => new Exception("ServiceCall must have a uri")),
			};
		}
	}
}
