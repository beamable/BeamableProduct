using Beamable.Api;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Realms;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Realms;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Editor.BeamCli.Commands;
using Beamable.Editor.Modules.Account;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;
using CustomerView = Beamable.Common.Api.Realms.CustomerView;

namespace Beamable.Editor
{

	public interface IAccountService
	{
		EditorAccountInfo Account { get; }

		Promise<AccountServiceInitResult> TryInit();
		Promise<EditorAccountInfo> Login(string nextCid, AccessToken cidToken);
		void OnUserChanged(Func<EditorAccountInfo, Promise> cb);
		void Logout(bool clearRealmPid);
		ReadonlyOptionalString Cid { get; }
		void SetRealm(EditorAccountInfo editorAccount, RealmView game, string realmPid);
		void WriteUnsetConfigValues();
		Promise<bool> SwitchToConfigDefaults();
		void Clear();
	}
	
	public class AccountServerData
	{
		public OptionalString cid = new OptionalString();
		public List<EditorAccountInfo> editorAccounts = new List<EditorAccountInfo>();

		public EditorAccountInfo Account
		{
			get
			{
				if (!cid.HasValue) return null;
				return editorAccounts?.FirstOrDefault(a => a?.cid?.Equals(cid.Value) ?? false);
			}
		}
	}

	public class AccountService : AccountServerData, IAccountService, IStorageHandler<AccountService>, Beamable.Common.Dependencies.IServiceStorable, IUserContext
	{
		public long UserId => Account.user.id;
		public List<Func<EditorAccountInfo, Promise>> _onUserChangeCallbacks = new List<Func<EditorAccountInfo, Promise>>();
		private readonly IDependencyProviderScope _scope;

		public ReadonlyOptionalString Cid => new ReadonlyOptionalString(cid);


		private StorageHandle<AccountService> _saveHandle;
		private ConfigDefaultsService ConfigDefaultsService => _scope.GetService<ConfigDefaultsService>();
		private IPlatformRequester Requester => _scope.GetService<IPlatformRequester>();

		private BeamCli.BeamCli Cli => _scope.GetService<BeamCli.BeamCli>();
		
		public AccountService(IDependencyProviderScope scope)
		{
			_scope = scope;
		}

		/// <summary>
		/// Loads data from the config-defaults file and combines it with
		/// local state to create a CID/PID for the toolbox.
		/// </summary>
		/// <returns></returns>
		public async Promise<AccountServiceInitResult> TryInit()
		{
			await ConfigDefaultsService.LoadFromDisk();

			var account = new EditorAccountInfo();
			if (!cid.HasNonEmptyValue) // the local state cid has not been set yet, and it needs a value...
			{
				if (ConfigDefaultsService.Cid.HasValue)
				{
					// use the config-defaults cid if it exists.
					cid.Set(ConfigDefaultsService.Cid.Value);
				}
				else
				{
					// there is no cid, so we don't have any data :( 
					cid.Clear();
				}
			}

			if (cid.HasValue)
			{
				GetAccountForCid(cid.Value, out account);
				WriteUnsetConfigValues();

				return new AccountServiceInitResult { hasCid = true, account = account };
			}

			return new AccountServiceInitResult { hasCid = false, account = account };
		}

		// public async Promise SetCliWorkspace()
		// {
		// 	Cli.Command.Init(new InitArgs
		// 	{
		// 		
		// 	})
		//
		// }
		
		public async Promise<bool> SwitchToConfigDefaults()
		{
			await ConfigDefaultsService.LoadFromDisk();

			if (!ConfigDefaultsService.Cid.HasValue)
			{
				return false;
			}

			GetAccountForCid(ConfigDefaultsService.Cid, out var nextAccount);
			nextAccount.realmPid.Set(ConfigDefaultsService.Pid);
			var existingToken = await _scope.GetService<AccessTokenStorage>().LoadTokenForCustomer(ConfigDefaultsService.Cid);
			if (existingToken == null)
			{
				// the user has not signed into this CID before, and needs to. We can't continue.
				Logout(true);
				return true;
			}

			await Login(ConfigDefaultsService.Cid, existingToken);
			return false;
		}

		private bool GetAccountForCid(string cid, out EditorAccountInfo account)
		{
			account = editorAccounts.FirstOrDefault(a => a.cid == cid);
			if (account != null)
			{
				return true;
			}

			account = new EditorAccountInfo(cid);
			editorAccounts.Add(account);
			return false;
		}

		public void Clear()
		{
			cid?.Clear();
			editorAccounts?.Clear();
			_saveHandle?.Save();
		}

		public void OnUserChanged(Func<EditorAccountInfo, Promise> cb)
		{
			_onUserChangeCallbacks.Add(cb);
		}

		async Promise InvokeUserChangeCallbacks()
		{
			var promises = new List<Promise<Unit>>();
			foreach (var cb in _onUserChangeCallbacks)
			{
				promises.Add(cb(Account));
			}
			await Promise.Sequence(promises);
		}

		public async Promise<EditorAccountInfo> Login(string nextCid, AccessToken cidToken)
		{
			var requester = _scope.InstantiateService<IPlatformRequester>();
			requester.Cid = nextCid;
			requester.Token = cidToken;
			var api = new RealmsApi(requester);
			GetAccountForCid(nextCid, out var account);
			cid.Set(nextCid);

			var authService = new EditorAuthService(requester);

			var editorUser = await authService.GetUserForEditor();
			account.user = editorUser;

			if (editorUser.GlobalPermissions.IsAtLeastTester)
			{
				var customerViewResponse = await api.GetCustomer();
				account.SetCustomerViewResponse(customerViewResponse);
			}
			else
			{
				account.SetCustomerViewResponse(new CustomerViewResponse());
			}

			WriteUnsetConfigValues();
			_saveHandle?.Save();
			await InvokeUserChangeCallbacks();
			return account;
		}


		public void Logout(bool clearRealmPid)
		{
			Requester.DeleteToken();
			if (cid.HasValue)
			{
				GetAccountForCid(cid.Value, out var account);
				account.user = null;

				if (clearRealmPid)
				{
					account.realmPid.Clear();
					account.gamePid.DoIfExists(pid => account.gamePidToLatestRealmPid.Remove(pid));
				}
			}
			if (clearRealmPid)
			{
				Requester.Pid = null;
			}
			_saveHandle?.Save();
			var __ = Cli.Command.Logout().Run();
			var _ = InvokeUserChangeCallbacks();
		}

		public void WriteUnsetConfigValues()
		{
			var needsWrite = false;
			var nextCid = ConfigDefaultsService.Cid.GetNonEmptyOrElse(() =>
			{
				if (cid.HasValue)
				{
					needsWrite = true;
					return cid.Value;
				}


				return null;
			});

			var nextPid = ConfigDefaultsService.Pid.GetNonEmptyOrElse(() =>
			{
				if (GetAccountForCid(nextCid, out var account))
				{
					if (account.realmPid.HasValue)
					{
						needsWrite = true;
						return account.realmPid.Value;
					}
				}

				return null;
			});

			var nextAlias = ConfigDefaultsService.Alias.GetNonEmptyOrElse(() =>
			{
				if (GetAccountForCid(nextCid, out var account))
				{
					needsWrite = true;
					return account?.CustomerView?.Alias;
				}

				return null;
			});


			if (needsWrite)
			{
				ConfigDefaultsService.SaveConfig(nextAlias, nextCid, nextPid);
			}
		}



		public void ReceiveStorageHandle(StorageHandle<AccountService> handle)
		{
			_saveHandle = handle;
		}

		public void OnBeforeSaveState()
		{
			// WriteUnsetConfigValues();
		}

		public void OnAfterLoadState()
		{
			foreach (var account in editorAccounts)
			{
				account.Refresh();
			}
		}

		public void SetRealm(EditorAccountInfo editorAccount, RealmView game, string realmPid)
		{
			editorAccount.SetRealm(game.Pid, realmPid);
			_saveHandle?.Save();
			var _ = InvokeUserChangeCallbacks();
		}
	}

	[Serializable]
	public class EditorAccountInfo : ISerializationCallbackReceiver
	{
		public string cid;

		public SerializableDictionaryStringToString
			gamePidToLatestRealmPid = new SerializableDictionaryStringToString();
		public OptionalString gamePid = new OptionalString();
		public OptionalString realmPid = new OptionalString();
		public EditorUser user;

		public bool HasEmptyCustomerView =>
			customerViewResponse == null || customerViewResponse.customer == null ||
			customerViewResponse.customer.projects.Length == 0;

		[SerializeField]
		private CustomerViewResponse customerViewResponse;

		[field: NonSerialized]
		public List<RealmView> CustomerRealms { get; private set; }

		[field: NonSerialized]
		public CustomerView CustomerView { get; private set; }

		public List<RealmView> CustomerGames => CustomerRealms.Where(r => r.IsProduction).ToList(); // TODO: don't use linq.

		public List<RealmView> RealmsInCurrentGame =>
			CustomerRealms?.Where(r => r.GamePid == CurrentGame?.Value?.Pid)?.ToList() ?? new List<RealmView>();

		public OptionalRealmView CurrentRealm =>
			realmPid.Map<RealmView, OptionalRealmView>(pid => CustomerRealms?.FirstOrDefault(r => r.Pid == pid));

		public OptionalRealmView CurrentGame =>
			gamePid.Map<RealmView, OptionalRealmView>(pid => CustomerRealms?.FirstOrDefault(r => r.Pid == pid));

		public EditorAccountInfo()
		{

		}

		public EditorAccountInfo(string cid)
		{
			this.cid = cid;
		}


		public void SetCustomerViewResponse(CustomerViewResponse customer = null)
		{
			if (customer != null)
			{
				if (customer.customer.projects == null)
				{
					customer.customer.projects = Array.Empty<ProjectView>();
				}
				foreach (var proj in customer.customer.projects)
				{
					proj.secret.Clear(); // don't save sensitive info to disk.
				}
				customerViewResponse = customer;
			}

			Refresh();
		}


		public void Refresh()
		{
			var projects = new List<ProjectViewDTO>();
			foreach (var project in customerViewResponse.customer.projects)
			{
				projects.Add(new ProjectViewDTO
				{
					parent = project.parent,
					children = project.children.GetOrElse(Array.Empty<string>()).ToList(),
					projectName = project.projectName,
					pid = project.pid,
					archived = project.archived.GetOrElse(false),
				});
			}

			CustomerRealms = RealmsService.ProcessProjects(cid, projects);
			CustomerView = new CustomerView
			{
				Alias = customerViewResponse.customer.alias,
				Cid = customerViewResponse.customer.cid.ToString(),
				DisplayName = customerViewResponse.customer.name,
				Projects = CustomerRealms
			};

			if (CurrentRealm.HasValue)
			{
				gamePid.Set(CurrentRealm.Value.GamePid);
			}
		}

		public string GetRealmPidForGame(RealmView game)
		{
			if (!gamePidToLatestRealmPid.TryGetValue(game.Pid, out var realmPid))
			{
				realmPid = gamePidToLatestRealmPid[game.Pid] = game.Pid;
			}

			return realmPid;
		}

		public void SetRealm(string nextGamePid, string nextRealmPid)
		{
			gamePid.Set(nextGamePid);
			realmPid.Set(nextRealmPid);
			gamePidToLatestRealmPid[nextGamePid] = nextRealmPid;
		}

		public async Promise UpdateRealms(IPlatformRequester requester)
		{
			var api = new RealmsApi(requester);
			var res = await api.GetCustomer();
			SetCustomerViewResponse(res);
		}

		public void OnBeforeSerialize()
		{
		}

		public void OnAfterDeserialize()
		{
			Refresh();
		}
	}

	public class AccountServiceInitResult
	{
		public bool hasCid;
		public EditorAccountInfo account;
	}
}
