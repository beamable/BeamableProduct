using Beamable.AccountManagement;
using Beamable.Api;
using Beamable.Api.Analytics;
using Beamable.Api.Autogenerated;
using Beamable.Api.Caches;
using Beamable.Api.Connectivity;
using Beamable.Avatars;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Auth;
using Beamable.Common.Api.Realms;
using Beamable.Common.BeamCli;
using Beamable.Common.Content;
using Beamable.Common.Content.Validation;
using Beamable.Common.Dependencies;
using Beamable.Common.Reflection;
using Beamable.Config;
using Beamable.Console;
using Beamable.Content;
using Beamable.Coroutines;
using Beamable.Editor;
using Beamable.Editor.BeamCli;
using Beamable.Editor.BeamCli.Commands;
using Beamable.Editor.Content;
using Beamable.Editor.Dotnet;
using Beamable.Editor.Environment;
using Beamable.Editor.Modules.Account;
using Beamable.Editor.Modules.EditorConfig;
using Beamable.Editor.ToolbarExtender;
using Beamable.Editor.UI;
using Beamable.Inventory.Scripts;
using Beamable.Reflection;
using Beamable.Sessions;
using Beamable.Shop;
using Beamable.Sound;
using Beamable.Theme;
using Beamable.Tournaments;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Beamable.Server;
using Beamable.Server.Editor;
using Beamable.Server.Editor.Usam;
using Beamable.Editor.ContentService;
using Beamable.Editor.Utility;
using UnityEditor;
using UnityEditor.AddressableAssets;
using UnityEditor.VersionControl;
using UnityEngine;
using static Beamable.Common.Constants;
using Debug = UnityEngine.Debug;
using Task = System.Threading.Tasks.Task;
#if UNITY_2019_3_OR_NEWER
#endif

namespace Beamable
{
	[BeamContextSystem]
	public static class BeamEditorDependencies
	{
		public static IDependencyBuilder DependencyBuilder;


		static BeamEditorDependencies()
		{
			DependencyBuilder = new DependencyBuilder();
			DependencyBuilder.AddSingleton(provider => new AccessTokenStorage(provider.GetService<BeamEditorContext>().PlayerCode));
			DependencyBuilder.AddSingleton<IPlatformRequester>(provider => new PlatformRequester(provider)
			{
				RequestTimeoutMs = $"{30 * 1000}",
				ErrorHandler = provider.CanBuildService<IPlatformRequesterErrorHandler>() ? provider.GetService<IPlatformRequesterErrorHandler>() : null
			}.RemoveConnectivityChecks()
			);
			DependencyBuilder.AddSingleton<IPlatformRequesterFactory, BeamableRequestFactory>();
			DependencyBuilder.AddSingleton(provider => provider.GetService<IPlatformRequester>() as IHttpRequester);
			DependencyBuilder.AddSingleton(provider => provider.GetService<IPlatformRequester>() as PlatformRequester);
			DependencyBuilder.AddSingleton(provider => provider.GetService<IPlatformRequester>() as IBeamableRequester);
			DependencyBuilder.AddSingleton<IRequester>(provider => provider.GetService<IPlatformRequester>());
			DependencyBuilder.AddSingleton<IEditorAuthApi>(provider => new EditorAuthService(provider.GetService<IPlatformRequester>()));
			DependencyBuilder.AddSingleton<IAuthApi>(provider => provider.GetService<IEditorAuthApi>());
			DependencyBuilder.AddScoped<AliasService>();
			DependencyBuilder.AddSingleton(provider => new RealmsService(provider.GetService<PlatformRequester>()));

			DependencyBuilder.AddSingleton<BeamableDispatcher>();

			DependencyBuilder.AddSingleton<IEditorHttpRequester>(provider => new BeamableEditorWebRequester());

			
			// DependencyBuilder.AddSingleton<IRuntimeConfigProvider>(p => p.GetService<BeamCli>());
			DependencyBuilder.AddSingleton<OfflineCache>(p => new OfflineCache(p.GetService<IRuntimeConfigProvider>(), CoreConfiguration.Instance.UseOfflineCache));

			DependencyBuilder.AddSingleton<ServiceStorage>();
			DependencyBuilder.AddSingleton(() => BeamableEnvironment.Data);
			DependencyBuilder.AddSingleton<IPlatformRequesterHostResolver>(p => p.GetService<BeamCli>());
			DependencyBuilder.AddSingleton<IConnectivityService>(() => null); // TODO: We should come up with an actual editor connectivity checker... https://disruptorbeam.atlassian.net/browse/BEAM-3487

			DependencyBuilder.AddSingleton<IAnalyticsTracker, NoOpAnalyticsTracker>();
			DependencyBuilder.AddSingleton<ITokenEventSettings>(() => CoreConfiguration.Instance);
			DependencyBuilder.AddSingleton(() => ContentConfiguration.Instance);
			
			DependencyBuilder.AddSingleton<IValidationContext>(provider => provider.GetService<ValidationContext>());
			DependencyBuilder.AddSingleton<ValidationContext>();

			DependencyBuilder.AddSingleton<ConfigDatabaseProvider>();

			DependencyBuilder.AddSingleton<IPlatformRequesterErrorHandler, EditorPlatformRequesterErrorHandler>();
			DependencyBuilder.AddSingleton<EditorAuthServiceFactory>();
			DependencyBuilder.AddSingleton<EditorStorageLayer>();
			DependencyBuilder.AddSingleton<SessionStorageLayer>();
			DependencyBuilder.AddSingleton<IBeamableFilesystemAccessor, EditorFilesystemAccessor>();

			DependencyBuilder.AddGlobalStorage<LibraryService, SessionStorageLayer>();
			DependencyBuilder.AddSingleton<IUserContext>(p => p.GetService<BeamCli>());
			DependencyBuilder.AddSingleton<BeamCommands>();
			
			DependencyBuilder.AddGlobalStorage<BeamWebCliCommandHistory, SessionStorageLayer>();
			DependencyBuilder.AddGlobalStorage<BeamWebCommandFactoryOptions, SessionStorageLayer>(instanceGenerator: ScriptableObject.CreateInstance<BeamWebCommandFactoryOptions>);
			DependencyBuilder.AddSingleton<IBeamCommandFactory>(p => p.GetService<BeamWebCommandFactory>());
			DependencyBuilder.AddSingleton<BeamWebCommandFactory>();
			
			DependencyBuilder.AddGlobalStorage<BeamCli, SessionStorageLayer>();
			DependencyBuilder.AddSingleton<DotnetService>();
			DependencyBuilder.AddSingleton<IRuntimeConfigProvider>(p => p.GetService<BeamCli>());

			DependencyBuilder.AddGlobalStorage<UsamService, SessionStorageLayer>();
			DependencyBuilder.AddGlobalStorage<CliContentService, SessionStorageLayer>();
			DependencyBuilder.AddSingleton(() => MicroserviceConfiguration.Instance);
			DependencyBuilder.AddSingleton<CommonAreaService>();
			DependencyBuilder.AddScoped<MicroserviceClients>();
			DependencyBuilder.AddSingleton<SingletonDependencyList<ILoadWithContext>>();
			DependencyBuilder.AddSingleton<UnityOtelManager>();
			OpenApiRegistration.RegisterOpenApis(DependencyBuilder);
		}

		[RegisterBeamableDependencies(-999, RegistrationOrigin.RUNTIME_GLOBAL)]
		public static void RegisterGlobalRuntime(IDependencyBuilder builder)
		{
			builder.RemoveIfExists<ICoroutineService>();
			builder.AddSingleton<ICoroutineService, BeamableDispatcher>();
		}

		[RegisterBeamableDependencies(-999, RegistrationOrigin.RUNTIME_GLOBAL)]
		public static void RegisterRuntime(IDependencyBuilder builder)
		{
			builder.AddSingleton(_ => new EditorStorageLayer(new EditorFilesystemAccessor()));
		
			builder.RemoveIfExists<IRuntimeConfigProvider>();
			builder.AddSingleton<IRuntimeConfigProvider>(() => BeamEditorContext.Default.BeamCli);
			builder.RemoveIfExists<IPlatformRequesterHostResolver>();
			builder.AddSingleton<IPlatformRequesterHostResolver>(() => BeamEditorContext.Default.BeamCli);
			builder.RemoveIfExists<IBeamDeveloperAuthProvider>();
			builder.AddSingleton<IBeamDeveloperAuthProvider>(() => BeamEditorContext.Default.BeamCli);
		}
	}

	[InitializeOnLoad, BeamContextSystem]
	public static class BeamEditor
	{
		public static CoreConfiguration CoreConfiguration { get; private set; }
		public static ReflectionCache EditorReflectionCache { get; private set; }
		public static bool IsInitialized { get; private set; }

		public static IDependencyBuilder BeamEditorContextDependencies;

		static BeamEditor()
		{
			// if (!HasDependencies())
			// {
			// 	_dependenciesLoadPromise = ImportDependencies();
			// 	_dependenciesLoadPromise.Then(_ =>
			// 	{
			// 		Debug.Log("Beamable is requesting a script reload because the beamable editor dependencies were not detected yet.");
			// 		EditorUtility.RequestScriptReload();
			// 		AssetDatabase.Refresh();
			// 		Initialize();
			// 	}).Error(_ =>
			// 	{
			// 		Initialize();
			// 	});
			// }
			// else
			{
				Initialize();
			}
			
			AssemblyReloadEvents.beforeAssemblyReload += () =>
			{
				BeamEditorContext.StopAll().Wait();
			};
			
		}

		private static int initializeAttemptCount = 0;
		private static List<Exception> initializationExceptions = new List<Exception>();
		private const int WARN_ON_INITIALIZE_ATTEMPT = 10; // could be 50?

		// private static Promise _dependenciesLoadPromise = null;

		static void Initialize()
		{
			if (IsInitialized) return;
#if !DISABLE_BEAMABLE_TOOLBAR_EXTENDER
			// Initialize toolbar
			BeamableToolbarExtender.LoadToolbarExtender();
#endif
			initializeAttemptCount++;

			if (initializeAttemptCount > WARN_ON_INITIALIZE_ATTEMPT)
			{
				Debug.LogWarning($"Beamable Editor is struggling to initialize. Attempt=[{initializeAttemptCount}] exception-count=[{initializationExceptions.Count}]");
				foreach (var ex in initializationExceptions)
				{
					Debug.LogWarning($"-- {ex.GetType().Name}: {ex.Message}\n{ex.StackTrace}");
				}
			}

			// Attempts to load all Module Configurations --- If they fail, we delay BeamEditor initialization until they don't fail.
			// The ONLY fail case is:
			//   - On first import or "re-import all", Resources and AssetDatabase don't know about the existence of these instances when this code runs for a couple of frames.
			//   - Empirically, we noticed this takes 2~3 attempts (frames) until this is done. So it's an acceptable and unnoticeable wait.
			// Doing this loading in this manner and making our windows delay their initialization until this is initialized (see BeamableAssistantWindow.OnEnable), we can
			// never have to care about this UnityEditor problem in our code that actually does things and we can have a guarantee that these will never throw.
			CoreConfiguration coreConfiguration;
			try
			{
				coreConfiguration = CoreConfiguration = CoreConfiguration.Instance;
				_ = AccountManagementConfiguration.Instance;
				_ = AvatarConfiguration.Instance;
				_ = ConsoleConfiguration.Instance;
				_ = ContentConfiguration.Instance;
				_ = EditorConfiguration.Instance;
				_ = InventoryConfiguration.Instance;
				_ = SessionConfiguration.Instance;
				_ = ShopConfiguration.Instance;
				_ = SoundConfiguration.Instance;
				_ = ThemeConfiguration.Instance;
				_ = TournamentsConfiguration.Instance;
			}
			// Solves a specific issue on first installation of package ---
			catch (ModuleConfigurationNotReadyException ex)
			{
				initializationExceptions.Add(ex);
				EditorApplication.delayCall += () =>
				{
					Initialize();
				};
				return;
			}
			
			FixPathVariable(EditorConfiguration.Instance);
			
			// Ensures we have the latest assembly definitions and paths are all correctly setup.
			CoreConfiguration.OnValidate();
			// Apply the defined configuration for how users want to uncaught promises (with no .Error callback attached) in Beamable promises.
			if (!Application.isPlaying)
			{
				var promiseHandlerConfig = CoreConfiguration.Instance.DefaultUncaughtPromiseHandlerConfiguration;
				switch (promiseHandlerConfig)
				{
					case CoreConfiguration.EventHandlerConfig.Guarantee:
					{
						if (!PromiseBase.HasUncaughtErrorHandler)
							PromiseExtensions.RegisterBeamableDefaultUncaughtPromiseHandler();
			
						break;
					}
					case CoreConfiguration.EventHandlerConfig.Replace:
					case CoreConfiguration.EventHandlerConfig.Add:
					{
						PromiseExtensions.RegisterBeamableDefaultUncaughtPromiseHandler(promiseHandlerConfig == CoreConfiguration.EventHandlerConfig.Replace);
						break;
					}
					default:
						throw new ArgumentOutOfRangeException();
				}
			}
			//
			// Reload the current environment data
			BeamableEnvironment.ReloadEnvironment();
			//
			try
			{
				BeamCliUtil.InitializeBeamCli();
			}
			catch (Exception ex)
			{
				initializationExceptions.Add(ex);
				EditorApplication.delayCall += () =>
				{
					Initialize();
				};
				return;
			}
			//
			// If we ever get to this point, we are guaranteed to run the initialization until the end so we...
			// Initialize Editor instances of Reflection service
			EditorReflectionCache = new ReflectionCache();
			
			// Load up all Asset-based IReflectionSystem (injected via ReflectionSystemObject instances). This was made to solve a cross-package injection problem.
			// It doubles as a no-code way for users to inject their own IReflectionSystem into our pipeline.
			var reflectionCacheSystemGuids = BeamableAssetDatabase.FindAssets<ReflectionSystemObject>(
				coreConfiguration.ReflectionSystemPaths
								 .Where(Directory.Exists)
								 .ToArray());
			
			// Get ReflectionSystemObjects and sort them
			var reflectionSystemObjects = reflectionCacheSystemGuids.Select(reflectionCacheSystemGuid =>
																	{
																		var assetPath = AssetDatabase.GUIDToAssetPath(reflectionCacheSystemGuid);
																		return AssetDatabase.LoadAssetAtPath<ReflectionSystemObject>(assetPath);
																	})
																	.Union(Resources.LoadAll<ReflectionSystemObject>("ReflectionSystems"))
																	.Where(system => system.Enabled)
																	.ToList();
			if (reflectionSystemObjects.Count < 1)
			{
				EditorApplication.delayCall += () =>
				{
					Initialize();
				};
				return;
			}
			reflectionSystemObjects.Sort((reflectionSys1, reflectionSys2) => reflectionSys1.Priority.CompareTo(reflectionSys2.Priority));
			
			// Inject them into the ReflectionCache system in the correct order.
			foreach (var reflectionSystemObject in reflectionSystemObjects)
			{
				EditorReflectionCache.RegisterTypeProvider(reflectionSystemObject.TypeProvider);
				EditorReflectionCache.RegisterReflectionSystem(reflectionSystemObject.System);
			}
			
			// Add non-ScriptableObject-based Reflection-Cache systems into the pipeline.
			var contentReflectionCache = new ContentTypeReflectionCache();
			EditorReflectionCache.RegisterTypeProvider(contentReflectionCache);
			EditorReflectionCache.RegisterReflectionSystem(contentReflectionCache);
			
			// Also initializes the Reflection Cache system with it's IBeamHintGlobalStorage instance
			// (that gets propagated down to any IReflectionSystem that also implements IBeamHintProvider).
			// Finally, calls the Generate Reflection cache
			EditorReflectionCache.GenerateReflectionCache(coreConfiguration.AssembliesToSweep);
			
			// Initialize BeamEditorContext dependencies
			BeamEditorContextDependencies = BeamEditorDependencies.DependencyBuilder.Clone();
			BeamEditorContextDependencies.AddSingleton(_ => EditorReflectionCache);
			
			GetReflectionSystem<BeamReflectionCache.Registry>()
				.LoadCustomDependencies(BeamEditorContextDependencies, RegistrationOrigin.EDITOR);
			
			// Set flag of SocialsImporter
			BeamableSocialsImporter.SetFlag();
			

			async Promise InitDefaultContext()
			{
				try
				{
					await BeamEditorContext.Default.InitializePromise;

#if BEAMABLE_DEVELOPER
					Debug.Log($"Initialized Default Editor Context [{BeamEditorContext.Default.PlayerCode}] - " +
					          $"[{BeamEditorContext.Default.ServiceScope.GetService<PlatformRequester>().Cid}] - " +
					          $"[{BeamEditorContext.Default.ServiceScope.GetService<PlatformRequester>().Pid}]");
#endif

					IsInitialized = true;

				}
				catch (Exception ex)
				{
					Debug.Log("Failed in initialize beam editor context. ");
					Debug.LogError(ex);
					throw;
				}
			}

			BeamEditorContext.Default.ServiceScope.GetService<UnityOtelManager>(); // TODO: Check if it is the best place to init, or switch to a Interface
			InitDefaultContext().Error(Debug.LogError);
		}

		public static bool HasDependencies()
		{
			var hasAddressables = AddressableAssetSettingsDefaultObject.GetSettings(false) != null;
			var hasTextmeshPro = TextMeshProImporter.EssentialsLoaded;

			return hasAddressables && hasTextmeshPro;
		}

		[Obsolete]
		public static async Promise ImportDependencies()
		{
			AddressableAssetSettingsDefaultObject.GetSettings(false);
			await TextMeshProImporter.ImportEssentials();
		}
		
		/// <summary>
		/// UnityHub will sometimes erase the PATH variable, which means when we launch sub-processes, they won't
		/// work because the PATH is bad. This function will patch up the PATH variable based on configured items.C
		/// </summary>
		/// <param name="configuration"></param>
		static void FixPathVariable(EditorConfiguration configuration)
		{
			const string PATH = "PATH";
			
			string PATH_DELIM = ";"; // WINDOWS
			if (Application.platform == RuntimePlatform.OSXEditor  || Application.platform == RuntimePlatform.LinuxEditor || Application.platform == RuntimePlatform.LinuxPlayer || Application.platform == RuntimePlatform.LinuxServer)
			{
				PATH_DELIM = ":"; // mac and linux
			}
			var inclusions = configuration.CustomPathInclusions.GetOrElse(() => new List<string>
			{
				"/usr/local/bin", // the default path on macOs
				"/usr/local/share/dotnet" // default path on mac for dotnet
			});
			var path = System.Environment.GetEnvironmentVariable(PATH) ?? "";

			var anyChanges = false;
			foreach (var include in inclusions)
			{
				var inclusionWithDelim = PATH_DELIM + include;
				if (path.Contains(inclusionWithDelim))
				{
					continue;
				}

				path = $"{path}{PATH_DELIM}{include}";
				anyChanges = true;
			}

			if (!anyChanges) return;
			System.Environment.SetEnvironmentVariable(PATH, path, EnvironmentVariableTarget.Process);
		}

		public static T GetReflectionSystem<T>() where T : IReflectionSystem => EditorReflectionCache.GetFirstSystemOfType<T>();

		/// <summary>
		/// Utility function to delay an initialization call (from within any of Unity's callbacks) until we have initialized our default <see cref="BeamEditorContext"/>.
		/// This must be used to wrap any logic dependent on <see cref="BeamEditorContext"/> or <see cref="BeamEditor"/> systems that is being executed from within a unity event function that initializes things.
		/// These are: OnEnable, OnValidate, OnAfterDeserialize and others like it. Essentially, this guarantees our initialization has finished running, before the given action runs.
		/// <para/>
		/// This is especially used to handle first-import cases and several other edge-cases that happen when these unity event functions are called with our windows opened. In these cases, if we don't delay
		/// our windows cases, the following issues have arisen in the past:
		/// <list type="bullet">
		/// <item><see cref="BeamEditorContext.Default"/> is null; which should be impossible, but happens (probably has to do with DomainReloads)</item>
		/// <item>The window tries to make calls to a partially initialized <see cref="BeamEditorContext"/> and throws.</item>
		/// </list>
		/// </summary>
		/// <param name="onInitializationFinished">
		/// The that must be scheduled to run from a Unity callback, but is dependent on our initialization being done.
		/// </param>
		/// <param name="forceDelay">
		/// Whether or not we should force the call to be delayed. This is used to guarantee that the callback in <see cref="BeamEditorWindow{TWindow}.OnEnable"/> is
		/// called only after the <see cref="BeamEditorWindow{TWindow}.InitializedConfig"/> was set during the <see cref="BeamEditorWindow{TWindow}.InitBeamEditorWindow"/> flow.
		/// </param>
		public static void DelayedInitializationCall(Action onInitializationFinished, bool forceDelay, BeamEditorInitializedDelayClause customDelay = null)
		{
			var hasCustomDelay = customDelay != null;
			if (!IsInitialized || forceDelay || (hasCustomDelay && customDelay()))
			{
				EditorApplication.delayCall += () => DelayedInitializationCall(onInitializationFinished, false);
				return;
			}

			onInitializationFinished?.Invoke();
		}
	}

	public delegate bool BeamEditorInitializedDelayClause();

	public class BeamEditorContext
	{
		public const string EDITOR_PLAYER_CODE_TEMPLATE = "editor.{0}.";
		private const int LOGIN_RETRY_AMOUNT = 3;

		public static Dictionary<string, BeamEditorContext> EditorContexts = new Dictionary<string, BeamEditorContext>();
		public static List<BeamEditorContext> All => EditorContexts.Values.ToList();
		public static BeamEditorContext Default => Instantiate(string.Format(EDITOR_PLAYER_CODE_TEMPLATE, "0"));
		public static BeamEditorContext ForEditorUser(int idx) => Instantiate(string.Format(EDITOR_PLAYER_CODE_TEMPLATE, idx));
		public static BeamEditorContext ForEditorUser(string code) => Instantiate(code);

		private int _loginRetries;

		public static bool ConfigFileExists { get; private set; }

		/// <summary>
		/// Create or retrieve a <see cref="BeamContext"/> for the given <see cref="PlayerCode"/>. There is only one instance of a context per <see cref="PlayerCode"/>.
		/// A <see cref="BeamableBehaviour"/> is required because the context needs to attach specific Unity components to a GameObject, and the given <see cref="BeamableBehaviour"/>'s GameObject will be used.
		/// If no <see cref="BeamableBehaviour"/> is given, then a new GameObject will be instantiated at the root transform level named, "Beamable (playerCode)"
		/// </summary>
		/// <param name="beamable">A component that will invite other Beamable components to exist on its GameObject</param>
		/// <param name="playerCode">A named code that represents a player slot on the device. The <see cref="Default"/> context uses an empty string. </param>
		/// <returns></returns>
		public static BeamEditorContext Instantiate(string playerCode = null, IDependencyBuilder dependencyBuilder = null)
		{
			dependencyBuilder = dependencyBuilder ?? BeamEditor.BeamEditorContextDependencies;
			playerCode = playerCode ?? string.Format(EDITOR_PLAYER_CODE_TEMPLATE, All.Count.ToString());

			// there should only be one context per playerCode.
			if (EditorContexts.TryGetValue(playerCode, out var existingContext))
			{
				if (existingContext.IsStopped)
				{
					existingContext.Init(playerCode, dependencyBuilder);
				}

				return existingContext;
			}

			var ctx = new BeamEditorContext();
			ctx.Init(playerCode, dependencyBuilder);
			All.Add(ctx);
			EditorContexts[playerCode] = ctx;
			return ctx;
		}

		public string PlayerCode { get; private set; }
		public bool IsStopped { get; private set; }
		public bool IsAuthenticated => ServiceScope.GetService<PlatformRequester>().Token != null;
		public long UserId => BeamCli.latestAccount.id;

		public CliContentService CliContentService => ServiceScope.GetService<CliContentService>();
		public IDependencyProviderScope ServiceScope { get; private set; }
		public Promise InitializePromise { get; private set; }
		public Promise OnReady => InitializePromise;
		public Promise<BeamEditorContext> Instance => InitializePromise?.Map(_ => this);


		public IPlatformRequester Requester => ServiceScope.GetService<PlatformRequester>();
		public BeamableDispatcher Dispatcher => ServiceScope.GetService<BeamableDispatcher>();
		public BeamCommands Cli => BeamCli.Command;
		public BeamCli BeamCli => ServiceScope.GetService<BeamCli>();
		public AliasService AliasService => ServiceScope.GetService<AliasService>();
		public IEditorAuthApi AuthService => ServiceScope.GetService<IEditorAuthApi>();

		/// <summary>
		/// The permissions for the <see cref="CurrentUser"/> in the <see cref="CurrentRealm"/>.
		/// If either the user or realm are null, the <see cref="Permissions"/> will be at the lowest level.
		/// </summary>
		public UserPermissions Permissions => BeamCli.Permissions;
		public MicroserviceClients Microservices => ServiceScope.GetService<MicroserviceClients>();

		public bool HasToken => Requester.Token != null;

#pragma warning disable CS0067
		public event Action<RealmView> OnRealmChange;
		public event Action<CustomerView> OnCustomerChange;
		public event Action<EditorUser> OnUserChange;
#pragma warning restore CS0067

		public Action OnServiceDeleteProceed;
		public Action OnServiceArchived;
		public Action OnServiceUnarchived;

		public OptionalString RealmSecret { get; private set; } = new OptionalString();
		
		public void Init(string playerCode, IDependencyBuilder builder)
		{
			PlayerCode = playerCode;
			IsStopped = false;

			builder = builder.Clone();
			builder.AddSingleton(this);

			var oldScope = ServiceScope;
			ServiceScope = builder.Build();
			oldScope?.Hydrate(ServiceScope);

			ServiceScope.GetService<BeamableDispatcher>();
			
			// TODO: Handle faulty API
			// TODO: Handle offline?

			async Promise Initialize()
			{
				try
				{
					// fetch latest CLI data, 
					await BeamCli.Refresh();
					
					if (!BeamCli.HasCid)
					{
						// the user is not signed in...
						await BeamCli.Logout();
						ApplyRequesterToken();
						return;
					}
					
					ApplyRequesterToken();
					var _ = ServiceScope.GetService<SingletonDependencyList<ILoadWithContext>>();
				}
				catch (Exception ex)
				{
					Debug.LogError("Failed to init Beam Editor Context");
					Debug.LogError(ex);
					throw ex;
				}
			}

			InitializePromise = Initialize().ToPromise();
		}

		public void ApplyRequesterToken()
		{
			Requester.Cid = BeamCli.Cid;
			Requester.Pid = BeamCli.Pid;
			Requester.Token = BeamCli.latestToken;
		}

		/// <summary>
		/// Erase the toolbox's authorization. 
		/// </summary>
		/// <param name="clearRealmPid">
		/// If true, the local PID will be erased. This should not change the config-defaults PID.
		/// </param>
		public void Logout(bool clearRealmPid)
		{
			changeRealmPromise?.CompleteSuccess();
			BeamCli.Logout().Then(_ =>
			{
				OnUserChange?.Invoke(null);
				ApplyRequesterToken();
				BeamableEnvironment.ReloadEnvironment();

			});
		}

		public async Promise Login(string host, string cid, string email, string password)
		{
			await BeamCli.Login(host, cid, email, password);
			ApplyRequesterToken();
			OnUserChange?.Invoke(BeamCli.latestUser);

			if (!ConfigDatabaseProvider.HasConfigFile())
			{
				CommitConfigDefaults();
			}
		}

		public void CommitConfigDefaults()
		{
			var config = new ConfigData()
			{
				cid = BeamCli.Cid,
				pid = BeamCli.Pid,
				alias = BeamCli.Alias,
				host = BeamCli.HostUrl,
				portalUrl = BeamCli.PortalUrl
			};
			
			
			var path = ConfigDatabaseProvider.GetFullPath();
			var asJson = JsonUtility.ToJson(config, true);

			var writeConfig = true;
			if (File.Exists(path))
			{
				var existingJson = File.ReadAllText(path);
				if (string.Equals(existingJson, asJson))
				{
					writeConfig = false;
				}
			}

			if (writeConfig)
			{
				string directoryName = Path.GetDirectoryName(path);
				if (!string.IsNullOrWhiteSpace(directoryName))
				{
					Directory.CreateDirectory(directoryName);
				}

				if (File.Exists(path))
				{
					var fileInfo = new FileInfo(path);
					fileInfo.IsReadOnly = false;
				}

				if (Provider.enabled)
				{
					var vcTask = Provider.Checkout(path, CheckoutMode.Asset);
					vcTask.Wait();
					if (!vcTask.success)
					{
						Debug.LogWarning($"Unable to checkout: {path}");
					}
				}

				File.WriteAllText(path, asJson);
				ServiceScope.GetService<ConfigDatabaseProvider>().Reload();
			}
		}

		
		
		private Promise changeRealmPromise;

		public bool IsSwitchingRealms
		{
			get
			{
				if (changeRealmPromise == null) return false;
				if (changeRealmPromise.IsCompleted) return false;
				if (changeRealmPromise.IsFailed) return false;
				return true;
			}
		} 
		public async Promise SwitchRealm(RealmView realm)
		{
			await SwitchRealm(realm.Pid);
		}
		public async Promise SwitchRealm(string pid)
		{
			if (changeRealmPromise != null)
			{
				changeRealmPromise.CompleteSuccess();
			}
			changeRealmPromise = new Promise();
			try
			{
				await BeamCli.SwitchRealms(pid);

				ApplyRequesterToken();

				await CliContentService.Reload();

				OnRealmChange?.Invoke(BeamCli.CurrentRealm);
			}
			finally
			{
				changeRealmPromise.CompleteSuccess();
			}
		}

		public static async Task StopAll()
		{
			foreach (var ctx in All)
			{
				await ctx.Stop();
			}
		}

		private async Promise Stop()
		{
			IsStopped = true;
			await ServiceScope.Dispose();
		}
	}

	[Serializable]
	public class ConfigData
	{
		public string cid;
		public string alias;
		public string pid;
		public string host;
		public string portalUrl;
	}
}
