using Beamable.Api.Autogenerated.Inventory;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Common.Inventory;
using Beamable.Coroutines;
using Beamable.Platform.Tests.Inventory;
using Beamable.Player;
using Beamable.Serialization.SmallerJSON;
using NUnit.Framework;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using UnityEngine.TestTools;
using EmptyResponse = Beamable.Common.Api.EmptyResponse;

namespace Beamable.Tests.Runtime
{
	public class PlayerInventoryPSDKGetItems : BeamContextTest
	{
		[UnityTest]
		public IEnumerator CanGetPlayerItems_Simple()
		{
			const string itemName = "test";

			async Promise<InventoryView> ObjectPost(long objectid, InventoryQueryRequest gsreq, bool includeauthheader)
			{
				await Promise.Success;
				return new InventoryView
				{
					currencies = Array.Empty<CurrencyView>(),
					items = new ItemGroup[]
					{
						new ItemGroup()
						{
							id = InventoryTestItem.FULL_CONTENT_ID + "." + itemName,
							items = new Item[]
							{
								new Item
								{
									id = 1,
									properties = Array.Empty<ItemProperty>()
								}
							}
						}
					}
				};
			}

			MockContent.Provide(new InventoryTestItem().SetContentName(itemName));
			TriggerContextInit(b =>
			{
				OnRegister(b);
				b.ReplaceSingleton<IInventoryApi>(new MockInventoryApi()
				{
					ObjectPost = ObjectPost
				});
			});
			yield return Context.OnReady.ToYielder();
			Assert.IsTrue(Context.OnReady.IsCompleted);

			var items = Context.Inventory.GetItems(InventoryTestItem.FULL_CONTENT_ID);
			yield return items.OnReady.ToYielder();

			Assert.AreEqual(1, items.Count);
		}

		[UnityTest]
		public IEnumerator CanGetPlayerItems_ReadFromCache_Empty()
		{
			const string itemName = "test";

			MockContent.Provide(new InventoryTestItem().SetContentName(itemName));
			TriggerContextInit(b =>
			{
				OnRegister(b);
				b.ReplaceSingleton<IInventoryApi>(new MockInventoryApi()
				{
					ObjectPost = (id, req, auth) => throw new NoConnectivityException("simulated lack of internet")
				});
			});
			yield return Context.OnReady.ToYielder();
			Assert.IsTrue(Context.OnReady.IsCompleted);

			var items = Context.Inventory.GetItems(InventoryTestItem.FULL_CONTENT_ID);
			yield return items.OnReady.ToYielder();

			Assert.AreEqual(0, items.Count);
		}


		[UnityTest]
		public IEnumerator CanGetPlayerItems_ReadFromCache_NotEmpty()
		{
			const string itemName = "test";

			MockContent.Provide(new InventoryTestItem().SetContentName(itemName));
			TriggerContextInit(b =>
			{
				OnRegister(b);

				b.ReplaceSingleton<IInventoryApi>(new MockInventoryApi()
				{
					ObjectPost = (id, req, auth) => throw new NoConnectivityException("simulated lack of internet")
				});
			});
			yield return Context.OnReady.ToYielder();
			Assert.IsTrue(Context.OnReady.IsCompleted);

			// pre-populate the disk cache
			var layer = DependencyBuilder.Instantiate<ScopedServiceStorage<OfflineCacheStorageLayer>>(Context.ServiceProvider);
			var inventory = new PlayerInventory();
			inventory.LocalItems.Insert(InventoryTestItem.FULL_CONTENT_ID + "." + itemName, new PlayerItem
			{
				ItemId = 1,
				ContentId = InventoryTestItem.FULL_CONTENT_ID + "." + itemName
			});
			layer.Save(inventory);

			// actually do the test where we get the items.
			var items = Context.Inventory.GetItems(InventoryTestItem.FULL_CONTENT_ID);
			yield return items.OnReady.ToYielder();

			Assert.AreEqual(1, items.Count);
		}


		[UnityTest]
		public IEnumerator CanHandleNetworkUpdate_OneItemType()
		{
			const string itemName = "test";

			MockContent.Provide(new InventoryTestItem().SetContentName(itemName));
			TriggerContextInit(b =>
			{
				OnRegister(b);

				var getRequestCount = 0;
				b.ReplaceSingleton<IInventoryApi>(new MockInventoryApi()
				{
					ObjectPost = async (id, req, auth) =>
					{
						await Promise.Success; // syntax to make Unity warnings shutup.
						getRequestCount++;
						switch (getRequestCount)
						{
							case 2:
								return new InventoryView
								{
									currencies = Array.Empty<CurrencyView>(),
									items = new ItemGroup[]
									{
										new ItemGroup()
										{
											id = InventoryTestItem.FULL_CONTENT_ID + "." + itemName,
											items = new Item[]
											{
												new Item
												{
													id = 1,
													properties = Array.Empty<ItemProperty>()
												}
											}
										}
									}
								};
							case 1:
								throw new NoConnectivityException("simulated lack of internet");
							default:
								throw new NotImplementedException("Unexpected get to inventory");
						}
					}
				});
			});
			yield return Context.OnReady.ToYielder();
			Assert.IsTrue(Context.OnReady.IsCompleted);

			var items = Context.Inventory.GetItems(InventoryTestItem.FULL_CONTENT_ID);
			yield return items.OnReady.ToYielder();
			var callbackInvocationCount = 0;
			items.OnDataUpdated += (nextItems) =>
			{
				callbackInvocationCount++;
			};
			Assert.AreEqual(0, items.Count);
			Assert.AreEqual(0, callbackInvocationCount);

			// simulate a notification!


			Context.Api.NotificationService.Publish("inventory.refresh",
													Json.Deserialize(JsonUtility.ToJson(
														new PlayerInventory.InventoryScopeNotification()
														{
															scopes = new string[]
															{
																InventoryTestItem.FULL_CONTENT_ID
															}
														})));

			// simulate a bit of time...
			yield return new WaitForSecondsRealtime(DebounceService.DEFAULT_DEBOUNCE_TIME_SECONDS + .1f);

			Assert.AreEqual(1, callbackInvocationCount);
		}



		[UnityTest]
		public IEnumerator CanHandle_LastDeletion()
		{
			MockContent.Provide(new InventoryTestItem().SetContentName("a"));
			MockContent.Provide(new InventoryTestItem().SetContentName("b"));
			MockContent.Provide(new InventoryTestItem().SetContentName("will-be-deleted"));
			TriggerContextInit(b =>
			{
				OnRegister(b);

				var getRequestCount = 0;
				b.ReplaceSingleton<IInventoryApi>(new MockInventoryApi()
				{
					ObjectPost = async (id, request, auth) =>
					{
						await Promise.Success; // syntax to make Unity warnings shutup.
						getRequestCount++;
						Debug.Log($"[{getRequestCount}] REQUESTING INVENTORY FOR " + string.Join(", ", request.scopes.Value ?? Array.Empty<string>()));
						switch (getRequestCount)
						{
							case 1: // on the first call, make the system use its disk cache...
								throw new NoConnectivityException("simulated lack o nets");
							case 2:
								return new InventoryView
								{
									currencies = Array.Empty<CurrencyView>(),
									items = new ItemGroup[]
									{
										new ItemGroup()
										{
											id = InventoryTestItem.FULL_CONTENT_ID + ".a",
											items = new Item[]
											{
												new Item
												{
													id = 1,
													properties = Array.Empty<ItemProperty>()
												},
												new Item
												{
													id = 2,
													properties = Array.Empty<ItemProperty>()
												}
											}
										}
									}
								};
							default:
								throw new NotImplementedException("Unexpected get to inventory");
						}
					}
				});
			});
			yield return Context.OnReady.ToYielder();
			Assert.IsTrue(Context.OnReady.IsCompleted);

			// pre-populate the disk cache
			var layer = DependencyBuilder.Instantiate<ScopedServiceStorage<OfflineCacheStorageLayer>>(Context.ServiceProvider);
			var inventory = new PlayerInventory();
			inventory.LocalItems.Insert(InventoryTestItem.FULL_CONTENT_ID + ".a", new PlayerItem
			{
				ItemId = 1,
				ContentId = InventoryTestItem.FULL_CONTENT_ID + ".a"
			});
			inventory.LocalItems.Insert(InventoryTestItem.FULL_CONTENT_ID + ".a", new PlayerItem
			{
				ItemId = 2,
				ContentId = InventoryTestItem.FULL_CONTENT_ID + ".a"
			});
			inventory.LocalItems.Insert(InventoryTestItem.FULL_CONTENT_ID + ".will-be-deleted", new PlayerItem
			{
				ItemId = 3,
				ContentId = InventoryTestItem.FULL_CONTENT_ID + ".will-be-deleted"
			});
			layer.Save(inventory);

			var items = Context.Inventory.GetItems("items");
			var callbackInvocationCount = 0;
			items.OnDataUpdated += (nextItems) =>
			{
				callbackInvocationCount++;
			};
			yield return items.OnReady.ToYielder();

			Assert.AreEqual(3, items.Count);
			Assert.AreEqual(1, callbackInvocationCount);

			// // simulate a notification!
			Context.Api.NotificationService.Publish("inventory.refresh",
													Json.Deserialize(JsonUtility.ToJson(
																		 new PlayerInventory.InventoryScopeNotification()
																		 {
																			 scopes = new string[]
																			 {
																				 "items",
																				 InventoryTestItem.FULL_CONTENT_ID + ".will-be-deleted"
																			 }
																		 })));
			//
			// simulate a bit of time...
			yield return new WaitForSecondsRealtime(DebounceService.DEFAULT_DEBOUNCE_TIME_SECONDS + .1f);
			//
			// Assert.AreEqual(2, callbackInvocationCount);
			Assert.AreEqual(2, items.Count); // there are two .a items

		}

		[UnityTest]
		public IEnumerator CanHandle_EmptyCallback()
		{

			MockContent.Provide(new InventoryTestItem().SetContentName("a"));
			MockContent.Provide(new InventoryTestItem().SetContentName("b"));
			// var putCalled = false;
			TriggerContextInit(b =>
			{
				OnRegister(b);

				var getRequestCount = 0;


				b.ReplaceSingleton<IInventoryApi>(new MockInventoryApi()
				{
					ObjectPost = async (id, request, auth) =>
					{
						await Promise.Success; // syntax to make Unity warnings shutup.
						getRequestCount++;
						var scopeString = string.Join(",", request.scopes.Value);

						Debug.Log($"[{scopeString}] REQUESTING INVENTORY FOR " + string.Join(", ", request.scopes.Value ?? Array.Empty<string>()));

						if (scopeString == "currency")
						{
							return new InventoryView { currencies = Array.Empty<CurrencyView>(), items = Array.Empty<ItemGroup>() };
						}

						if (getRequestCount < 3)
						{
							return new InventoryView
							{
								currencies = Array.Empty<CurrencyView>(),
								items = new ItemGroup[]
								{
									new ItemGroup
									{
										id = InventoryTestItem.FULL_CONTENT_ID + ".a",
										items = new Item[]
										{
											new Item
											{
												id = 1, properties = Array.Empty<ItemProperty>()
											}
										}
									},
									new ItemGroup
									{
										id = InventoryTestItem.FULL_CONTENT_ID + ".b",
										items = new Item[]
										{
											new Item
											{
												id = 2, properties = Array.Empty<ItemProperty>()
											}
										}
									}
								}
							};
						}

						if (scopeString == "items.inventoryTestItem.b" ||
							scopeString == "items,items.inventoryTestItem.b")
						{
							return new InventoryView
							{
								currencies = Array.Empty<CurrencyView>(),
								items = new ItemGroup[]
								{
									new ItemGroup
									{
										id = InventoryTestItem.FULL_CONTENT_ID + ".b",
										items = new Item[]
										{
											new Item
											{
												id = 2, properties = new ItemProperty[]
												{
													new ItemProperty
													{
														name = "a", value = "b"
													}
												}
											}
										}
									}
								}
							};
						}
						throw new NotImplementedException("Unexpected call to get inventory");
					}
				});
			});
			yield return Context.OnReady.ToYielder();
			Assert.IsTrue(Context.OnReady.IsCompleted);

			// mock the request to save the inventory.
			Requester.MockRequest<EmptyResponse>(Method.PUT, $"/object/inventory/{Context.PlayerId}")
								   .WithResponse(new EmptyResponse())

				;

			#region setup basic item callbacks

			var itemGroupA = Context.Inventory.GetItems(InventoryTestItem.FULL_CONTENT_ID + ".a");
			var callbackInvocationCountGroupA = 0;
			var itemGroupASizes = new List<int>();
			itemGroupA.OnDataUpdated += (nextItems) =>
			{
				callbackInvocationCountGroupA++;
				itemGroupASizes.Add(nextItems.Count);
			};
			yield return itemGroupA.OnReady.ToYielder();

			var itemGroupB = Context.Inventory.GetItems(InventoryTestItem.FULL_CONTENT_ID + ".b");
			var callbackInvocationCountGroupB = 0;
			itemGroupB.OnDataUpdated += (nextItems) =>
			{
				callbackInvocationCountGroupB++;
			};
			yield return itemGroupB.OnReady.ToYielder();

			#endregion

			#region trigger update calls

			var updateCall = Context.Inventory.Update(b =>
			{
				b.UpdateItem(InventoryTestItem.FULL_CONTENT_ID + ".b", 2, new Dictionary<string, string> { ["a"] = "b" });
			});

			// wait some time...
			yield return new WaitForSecondsRealtime(.1f);

			yield return updateCall.ToYielder();
			// simulate a notification to let the PSDK know there was an update.
			Context.Api.NotificationService.Publish("inventory.refresh",
													Json.Deserialize(JsonUtility.ToJson(
																		 new PlayerInventory.InventoryScopeNotification()
																		 {
																			 scopes = new string[]
																			 {
																				 "items",
																				 InventoryTestItem.FULL_CONTENT_ID + ".b"
																			 }
																		 })));

			// simulate a bit of time...
			yield return new WaitForSecondsRealtime(DebounceService.DEFAULT_DEBOUNCE_TIME_SECONDS + .1f);

			#endregion


			Assert.AreEqual(1, itemGroupA.Count); // there is only one .a
			Assert.AreEqual(1, itemGroupB.Count); // and only one .b

			Assert.AreEqual(1, callbackInvocationCountGroupA); // .a's cb only gets called once, because it never changes
			Assert.AreEqual(2, callbackInvocationCountGroupB); // .b's cb gets called twice

			Assert.AreEqual(1, itemGroupASizes.Count);
			Assert.AreEqual(1, itemGroupASizes[0]); // and the size of .a's callback was 1.
		}
	}
}
