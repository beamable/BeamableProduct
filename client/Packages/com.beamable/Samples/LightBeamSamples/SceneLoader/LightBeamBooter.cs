using Beamable.Runtime.LightBeams;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Beamable;
using Beamable.Api;
using Beamable.Api.Autogenerated;
using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Realms;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Common.Docs;
using Beamable.Config;
using Beamable.Serialization;
using Beamable.Serialization.SmallerJSON;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.SceneManagement;
using AuthApi = Beamable.Api.Autogenerated.Auth.AuthApi;
using TokenResponse = Beamable.Common.Api.Auth.TokenResponse;

[BeamContextSystem]
public class LightBeamBooter : MonoBehaviour
{
	[Header("Custom Configuration")]
	public SerializableDictionaryStringToString defaultArgs;
	
	[Header("Asset References")]
	public LightBeamSceneConfigObject config;
	public SceneDisplayBehaviour sceneDisplayTemplate;

	[Header("Scene References")]
	public RectTransform sceneContainer;
	public CanvasGroup loadingBlocker;

	// Start is called before the first frame update
	async void Start()
	{
		loadingBlocker.gameObject.SetActive(true);
		loadingBlocker.alpha = 1;


		var args = GetArgs(defaultArgs);
		LightBeamUtilExtensions.Hints = args;
		SetBeamEnv(args);
		
		// TODO: find the textAsset for the selected scene.
		// if it exists, resolve the realm name & pid. 
		// apply the realm settings 
		await PrepareRealm(args, config);
		var index = GetSceneName(args, config);

		Debug.Log("LIGHTBEAM_BOOT_COMPLETE");
		if (string.IsNullOrEmpty(index))
		{
			loadingBlocker.alpha = 0;
			loadingBlocker.gameObject.SetActive(false);

			sceneContainer.Clear();
			for (var i = 1; i < config.scenes.Count; i++)
			{
				if (!config.scenes[i].includeInToc) continue;
				
				var instance = Instantiate(sceneDisplayTemplate, sceneContainer);
				instance.Configure(config.scenes[i]);
			}
		}
		else
		{
			var _ = SceneManager.LoadSceneAsync(index);
		}
	}

	static Dictionary<string, string> GetArgs(SerializableDictionaryStringToString fallbackArgs)
	{
		var url = Application.absoluteURL;
		var queryStartIndex = url.IndexOf("?", StringComparison.Ordinal);
		if (queryStartIndex == -1)
		{
			Debug.LogWarning("no query args");
			return fallbackArgs;
		}

		var queryStr = url.Substring(queryStartIndex + 1); // consume the ?
		var queryArgStrs = queryStr.Split(new char[] { '&' }, StringSplitOptions.RemoveEmptyEntries);

		var queryArgs = new Dictionary<string, string>();

		foreach (var query in queryArgStrs)
		{
			var parts = query.Split(new char[] { '=' }, StringSplitOptions.RemoveEmptyEntries);
			switch (parts.Length)
			{
				case 1:
					queryArgs[parts[0]] = "";
					break;
				case 2:
					queryArgs[parts[0]] = UnityWebRequest.UnEscapeURL(parts[1]);
					break;
				default:
					break;
			}
		}

		return queryArgs;
	}

	static string GetSampleHint(Dictionary<string, string> args)
	{
		return args.TryGetValue("hint", out var hint) ? hint : null;
	}

	static void SetBeamEnv(Dictionary<string, string> args)
	{
		if (args.TryGetValue("cid", out var cid))
		{
			wrapper.SetCid(cid);
		}

		if (args.TryGetValue("pid", out var pid))
		{
			wrapper.SetPid(pid);
		}

		if (args.TryGetValue("host", out var host))
		{
			wrapper.SetHost(host);
		}

		if (args.TryGetValue("refresh_token", out var refresh))
		{
			wrapper.RefreshToken = refresh;
		}
		if (args.TryGetValue("access_token", out var access))
		{
			wrapper.AccessToken = refresh;
		}
	}

	public static CidPidWrapper wrapper = new CidPidWrapper();


#if BEAM_LIGHTBEAM
	[RegisterBeamableDependencies(origin: RegistrationOrigin.RUNTIME_GLOBAL)]
	public static void Configure(IDependencyBuilder builder)
	{
		builder.RemoveIfExists<IRuntimeConfigProvider>();
		builder.AddSingleton<IRuntimeConfigProvider, CidPidWrapper>(wrapper);

		builder.RemoveIfExists<IBeamDeveloperAuthProvider>();
		builder.AddSingleton<IBeamDeveloperAuthProvider>(wrapper);
	}
#endif

	public class CidPidWrapper : IRuntimeConfigProvider, IBeamDeveloperAuthProvider
	{
		private ConfigDatabaseProvider _fileBased;

		private string customCid, customPid, customHost;

		public string Cid => customCid ?? _fileBased.Cid;
		public string Pid => customPid ?? _fileBased.Pid;
		public string HostUrl
		{
			get
			{
				return customHost ?? _fileBased.HostUrl;
			}
		}

		public string PortalUrl => _fileBased.PortalUrl;

		public CidPidWrapper()
		{
			_fileBased = new ConfigDatabaseProvider();
		}

		public void SetCid(string value)
		{
			Debug.Log("Overriding cid to " + value);
			customCid = value;
		}

		public void SetPid(string value)
		{
			Debug.Log("Overriding pid to " + value);
			customPid = value;
		}

		public void SetHost(string value)
		{
			Debug.Log("Overriding host to " + value);
			customHost = value;
		}

		public string AccessToken { get; set; }
		public string RefreshToken { get; set; }
	}

	public static string GetSceneName(Dictionary<string, string> args, LightBeamSceneConfigObject config)
	{
		if (!args.TryGetValue("scene", out var sceneName))
		{
			Debug.LogWarning("no scene arg");
			return null;
		}

		if (config.TryGetScene(sceneName, out var scene))
		{
			return scene.sceneName;
		}

		Debug.LogWarning($"no parsable scene arg- There are {config.scenes} scenes...");
		foreach (var existing in config.scenes)
		{
			Debug.LogWarning("\t" + existing.label);
		}
		return null;

	}

	public static async Promise PrepareRealm(Dictionary<string, string> args, LightBeamSceneConfigObject config)
	{
		// we can only do this operation when there is a supplied developer refresh token
		if (string.IsNullOrEmpty(wrapper.RefreshToken))
		{
			return;
		}
		
		// opt in
		if (!args.ContainsKey("prepare-realm"))
		{
			return;
		}
		
		// we need to know what scene we are prepping for
		if (!args.TryGetValue("scene", out var sceneName))
		{
			return;
		}

		// that scene name must be a valid name that maps to a config object
		if (!config.TryGetScene(sceneName, out var scene))
		{
			return;
		}

		// the config object needs to actually have some configuration...
		if (scene.realmRequirements == null)
		{
			return;
		}
		
		// finally; we know the required declaration for the realm.
		var decl = RealmSettingDeclaration.FromAsset(scene.realmRequirements);

		var token = new SimpleAccessToken
		{
			Cid = wrapper.Cid,
			Pid = null, // explicitly, there is no pid yet.
			RefreshToken = wrapper.RefreshToken,
			Token = null, // do not trust the access token, we need to refresh it
		};
		
		var requester = new SimpleRequester(wrapper.HostUrl)
		{
			AccessToken = token
		};
		await requester.PrepareAccess();

		var realmApi = new RealmsApi(requester);
		var requiredProjectName = $"BeamSample_{decl.uniqueRealmName}";
		var requiredGameName = "BeamSample-dev";
		ProjectView matchingGame = null, matchingRealm = null;
		CustomerViewResponse customer = null;
		
		async Promise RefreshRealms()
		{
			Debug.Log("Fetching customer information...");
			customer = await realmApi.GetCustomer();
			matchingGame = customer.customer.projects.FirstOrDefault(p => p.projectName == requiredGameName);
			matchingRealm = customer.customer.projects.FirstOrDefault(p => p.projectName == requiredProjectName);
			Debug.Log($"Found game=[{matchingGame?.pid}] realm=[{matchingRealm?.pid}]");
		}

		await RefreshRealms();
		Debug.Log("got realms " + customer.customer.projects.Length);
		
		
		if (matchingGame == null)
		{
			// need to create the game first.
			// TODO: make this a hidden realm
			Debug.Log("Creating sample game...");
			await realmApi.PostGame(new RealmsBasicNewGameRequest()
			{
				gameName = "BeamSample"
			});
			await RefreshRealms();
		}
		
		if (matchingRealm == null)
		{
			// need to create the realm!
			// TODO: This is failing with an auth issue; not sure why...
			Debug.Log($"Creating sample realm... name=[{requiredProjectName}] parent=[{matchingGame.pid}]");
			await realmApi.PostProject(new CreateProjectRequest
			{
				name = requiredProjectName,
				parent = matchingGame.pid
			});
			await RefreshRealms();
		}
		
		// now we have the right pid!
		wrapper.SetPid(matchingRealm.pid);
		token.Pid = matchingRealm.pid;
		
		// we need to validate that the content on the realm is correct... 
		var contentApi = new ContentApi(requester);
		ContentBasicManifest manifest = null;
		var attempts = 3;
		while (manifest == null && attempts-- > 0)
		{
			try
			{
				manifest = await contentApi.GetManifest();
			}
			catch (RequesterException ex) when (ex.Status == 504)
			{
				Debug.Log("content manifest time out... waiting.");
				await Task.Delay(TimeSpan.FromSeconds(2)); // wait 2 seconds and try again...
			}
			catch (RequesterException ex) when (ex.Status == 404)
			{
				manifest = new ContentBasicManifest(); // blank manifest.
			}
		}

		if (manifest == null)
		{
			throw new Exception("Failed to locate content manifest.");
		}
		
		var serializedEntries = decl.contentEntries.Select(c =>
		{
			var contentJson = JsonSerializable.ToJson(c);
			var def = JsonSerializable.FromJson<ContentDefinition>(contentJson);
			def.checksum = BeamoExtensions.GetHash(contentJson); // TODO: this is the wrong checksum. We should be using SHA-1 of minified json.
			return def;
		}).ToArray();
		
		var contentRes = await contentApi.Post(new SaveContentRequest
		{
			content = serializedEntries
		});
		var manifestPostRes = await contentApi.PostManifest(new SaveManifestRequest
		{
			id = "global", references = contentRes.content.Select(c =>
			{

				return new ReferenceSuperset
				{
					checksum = c.checksum,
					id = c.id,
					tags = new OptionalArrayOfString(c.tags),
					type = "content",
					uri = c.uri,
					version = c.version,
					visibility = c.visibility.ToString().ToLowerInvariant()
				};

			}).ToArray()
		});
		Debug.Log("Saved manifest.");
		
		// TODO: also need to set realm config...
	}

	class SimpleAccessToken : IAccessToken
	{
		public string Token { get; set; }
		public string RefreshToken { get; set; }
		public DateTime ExpiresAt { get; set; }
		public long ExpiresIn { get; set; }
		public DateTime IssuedAt { get; set; }
		public string Cid { get; set; }
		public string Pid { get; set; }
	}
	class SimpleRequester : IBeamableRequester
	{
		private readonly string _host;

		public string EscapeURL(string url)
		{
			return UnityWebRequest.EscapeURL(url);
		}
		public IAccessToken AccessToken { get; set; }
		public string Cid => AccessToken.Cid;
		public string Pid => AccessToken.Pid;

		private HttpClient _client;
		private Beamable.Api.Autogenerated.Models.TokenResponse _resolvedToken;

		public SimpleRequester(string host)
		{
			_host = host;
			_client = new HttpClient();
		}

		public async Promise PrepareAccess()
		{
			var api = new AuthApi(this);
			_resolvedToken = await api.PostToken(new TokenRequestWrapper
			{
				grant_type = "refresh_token", 
				refresh_token = AccessToken.RefreshToken,
				customerScoped = true
			}, false);
		}

		public async Promise<T> Request<T>(Method method,
		                             string uri,
		                             object body = null,
		                             bool includeAuthHeader = true,
		                             Func<string, T> parser = null,
		                             bool useCache = false)
		{
			var httpMethod = HttpMethod.Get;
			switch (method)
			{
				case Method.PUT:
					httpMethod = HttpMethod.Put;
					break;
				case Method.POST:
					httpMethod = HttpMethod.Post;
					break;
				case Method.DELETE:
					httpMethod = HttpMethod.Delete;
					break;
			}

			var req = new HttpRequestMessage(httpMethod, _host + uri);
			if (includeAuthHeader)
			{
				req.Headers.Authorization =
					AuthenticationHeaderValue.Parse($"Bearer {_resolvedToken.access_token.Value}");
			}
			

			req.Headers.Add("X-BEAM-SCOPE", string.IsNullOrEmpty(Pid) ? Cid : $"{Cid}.{Pid}");
			req.Content = new StringContent(body as string ?? JsonUtility.ToJson(body));
			req.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

			Debug.Log($"Sending request... {uri}, {body}, {Cid}, {Pid}, {includeAuthHeader}, {_resolvedToken?.access_token?.Value}");
			var res = await _client.SendAsync(req);
			var jsonResponse = await res.Content.ReadAsStringAsync();

			if (!res.IsSuccessStatusCode)
			{
				throw new RequesterException("simple", method.ToString(), uri, (int)res.StatusCode, jsonResponse );
			}
			else
			{
				T parsedResult = parser == null
					? JsonUtility.FromJson<T>(jsonResponse)
					: parser(jsonResponse);
				return parsedResult;
			}
		}

		public IBeamableRequester WithAccessToken(TokenResponse tokenResponse)
		{
			throw new NotImplementedException("The simple requester does not support this method.");
		}
	}
}
