using Beamable.Api;
using Beamable.Api.Connectivity;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Auth;
using Beamable.Common.Spew;
using System;
using System.Text;
using UnityEngine;
using UnityEngine.Networking;

namespace Core.Platform.SDK
{
	public interface IBeamableApiRequester : IBeamableRequester
	{
		AccessToken Token { get; set; }
	}

	// Since the new access tokens are short lived, no need to store them. We can use the same refresh tokens
	// in AccessTokenStorage and store the JWT in memory until it expires and we need to fetch a new one.
	public class BeamableApiRequester : IBeamableApiRequester, IDisposable
	{
		public string Host { get; set; }
		public AccessToken Token { get; set; }
		public IAccessToken AccessToken => Token;
		public string TimeOverride { get; set; }

		[Obsolete("This field has been removed. Please use the IAuthApi.SetLanguage function instead.")]
		public string Language { get; set; }
		public string Cid => Token.Cid;
		public string Pid => Token.Pid;

		private bool _disposed;

		// Needed for routing to the new C# service. This should eventually be handled/generated by the version of a
		// particular resource.
		private const string AcceptHeader = "application/vnd.beamable.v1+json";
		private readonly IConnectivityService _connectivityService;
		private readonly AccessTokenStorage _accessTokenStorage;

		public BeamableApiRequester(string host, AccessTokenStorage accessTokenStorage,
		  IConnectivityService connectivityService)
		{
			Host = host;
			_accessTokenStorage = accessTokenStorage;
			_connectivityService = connectivityService;
		}

		public void Dispose()
		{
			_disposed = true;
		}

		public Promise<T> Request<T>(
		  Method method,
		  string uri,
		  object body = null,
		  bool includeAuthHeader = true,
		  Func<string, T> parser = null,
		  bool useCache = false)
		{
			byte[] bodyBytes = null;

			if (body != null)
			{
				bodyBytes = body is string json
				  ? Encoding.UTF8.GetBytes(json)
				  : Encoding.UTF8.GetBytes(JsonUtility.ToJson(body));
			}

			return MakeRequestWithTokenRefresh<T>(method, uri, bodyBytes, includeAuthHeader);
		}

		private Promise<T> MakeRequestWithTokenRefresh<T>(
		  Method method,
		  string uri,
		  byte[] body,
		  bool includeAuthHeader
		)
		{
			return MakeRequest<T>(method, uri, body, includeAuthHeader).RecoverWith(error =>
			{
				switch (error)
				{
					case PlatformRequesterException e when e.Status == 401:
						var authBody = new BeamableApiTokenRequest
						{
							refreshToken = Token.RefreshToken,
							customerId = Token.Cid,
							realmId = Token.Pid
						};
						return Request<BeamableApiTokenResponse>(Method.POST, "/auth/refresh-token", authBody, false).Map(rsp =>
					{
						Token = new AccessToken(_accessTokenStorage, Token.Cid, Token.Pid, rsp.accessToken,
												rsp.refreshToken, long.MaxValue - 1);
						return PromiseBase.Unit;
					})
					.FlatMap(_ => MakeRequest<T>(method, uri, body, includeAuthHeader));
				}

				return Promise<T>.Failed(error);
			});
		}

		private Promise<T> MakeRequest<T>(
		  Method method,
		  string uri,
		  byte[] body,
		  bool includeAuthHeader)
		{
			var result = new Promise<T>();
			var request = BuildWebRequest(method, uri, body, includeAuthHeader);
			var op = request.SendWebRequest();
			op.completed += _ => HandleResponse(result, request);
			return result;
		}

		private void HandleResponse<T>(Promise<T> promise, UnityWebRequest request)
		{
			// swallow any responses if already disposed
			if (_disposed)
			{
				PlatformLogger.Log("BeamableAPI REQUESTER: Disposed, Ignoring Response");
				return;
			}

			try
			{
				if (request.responseCode >= 300 || request.IsNetworkError())
				{
					// Handle errors
					var payload = request.downloadHandler.text;

					PlatformError platformError = null;
					try
					{
						platformError = JsonUtility.FromJson<PlatformError>(payload);
					}
					catch (Exception)
					{
						// Swallow the exception and let the error be null
					}

					promise.CompleteError(new PlatformRequesterException(platformError, request, payload));

				}
				else
				{
					// Parse JSON object and resolve promise
					PlatformLogger.Log($"BeamableAPI RESPONSE: {request.downloadHandler.text}");

					try
					{
						if (typeof(T) == typeof(Unit))
						{
							promise.CompleteSuccess(default);
						}
						var result = JsonUtility.FromJson<T>(request.downloadHandler.text);
						promise.CompleteSuccess(result);
					}
					catch (Exception ex)
					{
						promise.CompleteError(ex);
					}
				}
			}
			finally
			{
				request.Dispose();
			}
		}

		private UnityWebRequest BuildWebRequest(Method method, string uri, byte[] body, bool includeAuthHeader)
		{
			var address = uri.Contains("://") ? uri : $"{Host}{uri}";

			// Prepare the request
			var request = new UnityWebRequest(address)
			{
				downloadHandler = new DownloadHandlerBuffer(),
				method = method.ToString()
			};

			// Set the body
			if (body != null)
			{
				var upload = new UploadHandlerRaw(body) { contentType = "application/json" };
				request.uploadHandler = upload;
			}

			// Set headers
			request.SetRequestHeader("Accept", AcceptHeader);

			if (includeAuthHeader)
			{
				var authHeader = GenerateAuthorizationHeader();
				if (authHeader != null)
				{
					request.SetRequestHeader("Authorization", authHeader);
				}
			}

			if (TimeOverride != null)
			{
				request.SetRequestHeader("Time-Override", TimeOverride);
			}

			request.SetRequestHeader(Constants.Requester.HEADER_ACCEPT_LANGUAGE, "");

			return request;
		}

		private string GenerateAuthorizationHeader()
		{
			if (Token == null || string.IsNullOrEmpty(Token?.Token))
			{
				return null;
			}
			return $"Bearer {Token.Token}";
		}

		public IBeamableRequester WithAccessToken(TokenResponse tokenResponse)
		{
			throw new NotImplementedException();
		}

		public string EscapeURL(string url)
		{
			throw new NotImplementedException();
		}
	}

	[Serializable]
	public class BeamableApiTokenRequest
	{
		public string refreshToken;
		public string customerId;
		public string realmId;
	}

	[Serializable]
	public class BeamableApiTokenResponse
	{
		public string accessToken;
		public string refreshToken;
	}
}
