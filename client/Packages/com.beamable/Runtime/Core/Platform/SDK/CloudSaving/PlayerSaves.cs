using Beamable.Api.Autogenerated.Cloudsaving;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Notifications;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Common.Player;
using Beamable.Common.Runtime.Collections;
using Beamable.Coroutines;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using UnityEngine;
using UnityEngine.Networking;

namespace Beamable.Api.CloudSaving
{
	[Serializable]
	public class PlayerSaves : AbsObservableReadonlyDictionary<string, SerializableDictionaryStringToString>, IStorageHandler<PlayerSaves>
	{
		/// <summary>
		/// An event with a <see cref="CloudSavingError"/> parameter.
		/// This event triggers anytime there is an error in the <see cref="CloudSavingService"/>
		/// </summary>
		public Action<CloudSavingError> OnError;

		private readonly IPlatformService _platform;
		private readonly INotificationService _notificationService;
		private readonly PlatformRequester _requester;
		private readonly ICloudsavingApi _cloudsavingApi;
		private CoroutineService _coroutineService;
		private IEnumerator _fileWebRequestRoutine;
		private StorageHandle<PlayerSaves> _saveHandle;
		private ManifestResponse _localManifest;
		private ConcurrentDictionary<string, string> _pendingUploads = new ConcurrentDictionary<string, string>();
		[SerializeField]
		private SerializableDictionaryStringToString _saves = new SerializableDictionaryStringToString();
		[NonSerialized]
		public ConcurrentDictionary<string, string> _pendingDownloads = new ConcurrentDictionary<string, string>();
		
		public PlayerSaves(IPlatformService platform,
		                   INotificationService notificationService,
		                   PlatformRequester requester,
		                   IDependencyProvider provider,
		                   ICloudsavingApi cloudsavingApi,
		                   CoroutineService coroutineService)
		{
			_platform = platform;
			_notificationService = notificationService;
			_requester = requester;
			_cloudsavingApi = cloudsavingApi;
			_coroutineService = coroutineService;

		}

		public T Get<T>(string id, Func<string, T> deserializer = null)
		{
			deserializer ??= JsonUtility.FromJson<T>;
			
			return _saves.TryGetValue(id, out string data) ? deserializer(data) : default;
		}
		
		public async Promise Set<T>(string key, T content, Func<T, string> serializer = null, bool autoUpload = false)
		{
			if (serializer == null) serializer = (raw) => JsonUtility.ToJson(raw);

			var serialized = serializer(content);
			_saves[key] = serialized;
			await AfterSaveChecks(key, autoUpload);
		}
		
		
		private async Promise AfterSaveChecks(string key, bool autoUpload)
		{
			_saveHandle.Save();
			
			bool isPendingUpload = await CheckAndAddPendingUpload(key);
			if (!autoUpload || !isPendingUpload)
			{
				return;
			}

			await UploadUserData();
		}

		private Promise<bool> CheckAndAddPendingUpload(string id)
		{
			
			return GenerateChecksum(_saves[id]).FlatMap(checksum =>
			{
				// var checksumEqual = _previouslyProcessedFiles.ContainsKey(filePath) &&
				//                     !string.IsNullOrEmpty(_previouslyProcessedFiles[filePath]) &&
				//                     _previouslyProcessedFiles[filePath].Equals(checksum);
				// var missingKey = !_previouslyProcessedFiles.ContainsKey(filePath) ||
				//                  string.IsNullOrEmpty(_previouslyProcessedFiles[filePath]);
				// var fileLengthNotZero = new FileInfo(filePath).Length > 0;
				bool shouldBeUploaded = true;//(!checksumEqual || missingKey) && fileLengthNotZero;
				if (shouldBeUploaded)
				{
					_pendingUploads[id] = checksum;
				}

				return Promise<bool>.Successful(shouldBeUploaded);
			});
		}
		
		private Promise<ManifestResponse> UploadUserData()
		{
			return GenerateUploadObjectRequestWithMapping().FlatMap(response =>
			{
				var uploadManifestRequest = response.Item1;
				var fileNameToChecksum = response.Item2;

				if (uploadManifestRequest.request.Count <= 0)
				{
					return Promise<ManifestResponse>.Failed(new Exception("Upload is empty"));
				}

				return HandleRequest(uploadManifestRequest,
				                     fileNameToChecksum,
				                     Method.PUT,
				                     "/data/uploadURL"
					).FlatMap(_ => CommitManifest(uploadManifestRequest))
					 .Error(_ =>
						 {
							 //Clear local known state so we reprocess these files
							 foreach (var filename in fileNameToChecksum)
							 {
								 //Clear the known checksum
								 // _previouslyProcessedFiles[filename.Key] = null;
							 }

							 ProvideErrorCallback(nameof(UploadUserData));
						 }
					 );
			});
		}
		
		private Promise<(UploadManifestRequest, ConcurrentDictionary<string, string>)>
			GenerateUploadObjectRequestWithMapping()
		{
			Promise<(UploadManifestRequest, ConcurrentDictionary<string, string>)> response =
				new Promise<(UploadManifestRequest, ConcurrentDictionary<string, string>)>();
			var uploadRequest = new List<ManifestEntry>();
			var uploadMap = new ConcurrentDictionary<string, string>();
			var allFilesAndDirectories = new List<string>();

			if (_pendingUploads != null && _pendingUploads.Count > 0)
			{
				foreach (var item in _pendingUploads)
				{
					allFilesAndDirectories.Add(item.Key);
				}
			}

			foreach (var key in allFilesAndDirectories)
			{
				var contentLength = _saves[key].Length;
				var lastModified =
					long.Parse(DateTime.Now.ToString("yyyyMMddHHmmss", CultureInfo.InvariantCulture));
				GenerateChecksum(_saves[key]).Then(checksum =>
				{
					var uploadObjectRequest = new ManifestEntry(key,
					                                            (int)contentLength,
					                                            checksum,
					                                            null,
					                                            _platform.User.id,
					                                            lastModified);
					// _previouslyProcessedFiles[fullPathToFile] = checksum;
					uploadRequest.Add(uploadObjectRequest);
				});
			}

			response.CompleteSuccess((new UploadManifestRequest(uploadRequest), uploadMap));
			return response;
		}
		private Promise<string> GenerateChecksum(string content)
		{
			using (var md5 = MD5.Create())
			{
					return Promise<string>.Successful(BitConverter.ToString(md5.ComputeHash(Encoding.UTF8.GetBytes(content)))
					                                              .Replace("-", string.Empty));
			}
		}

		/// <summary>
		/// <b> You shouldn't need to call this method, because this will be called by the constructor. </b>
		/// This method will be marked as Obsolete in the future.
		/// </summary>
		/// <returns></returns>
		/// <exception cref="Exception"></exception>
		public Promise<ManifestResponse> EnsureRemoteManifest()
		{
			return FetchUserManifest().RecoverWith(error =>
			{
				if (error is PlatformRequesterException notFound && notFound.Status == 404)
				{
					return CreateEmptyManifest();
				}

				throw error;
			});
		}

		private Promise<ManifestResponse> CreateEmptyManifest()
		{
			var emptyManifest = new UploadManifestRequest(new List<ManifestEntry>());
			return CommitManifest(emptyManifest);
		}

		private void OnReplacedNtf(object _)
		{
			EnsureRemoteManifest()
				.FlatMap(SyncRemoteContent);
		}

		private Promise<Unit> SyncRemoteContent(ManifestResponse manifestResponse)
		{
			// Replacement is essentially a "force sync". Therefore we want to ensure that we
			// blow away everything.
			if (manifestResponse.replacement)
			{
				DeleteLocalUserData();
			}

			// This method will also commit a new remote manifest AND store the manifest locally.
			return DownloadUserData(manifestResponse);
		}

		private static Promise<List<GetS3ObjectRequest>> GenerateDownloadRequest(ConcurrentDictionary<string, string> missingFiles)
		{
			var downloadRequest = new List<GetS3ObjectRequest>();

			foreach (var s3ObjectKey in missingFiles)
			{
				downloadRequest.Add(new GetS3ObjectRequest(s3ObjectKey.Value));
			}

			return Promise<List<GetS3ObjectRequest>>.Successful(downloadRequest);
		}

		private Promise<Unit> DownloadUserData(ManifestResponse manifestResponse)
		{
			var missingLocalFiles = DiffManifest(manifestResponse);
			return GenerateDownloadRequest(missingLocalFiles).FlatMap(downloadRequest =>
			{

				return HandleRequest(new GetS3DownloadURLsRequest(downloadRequest),
				                     missingLocalFiles,
				                     Method.GET,
				                     "/data/downloadURL"
				       )
				       .Error(ProvideErrorCallback(nameof(DownloadUserData)))
				       .FlatMap(__ =>
				       {
					       if (manifestResponse.replacement)
					       {
						       var upload = new UploadManifestRequest(new List<ManifestEntry>());
						       foreach (var r in manifestResponse.manifest)
						       {
							       upload.request.Add(new ManifestEntry(r.key,
							                                            r.size,
							                                            r.eTag,
							                                            null,
							                                            _platform.User.id,
							                                            r.lastModified)
							       );
						       }

						       return CommitManifest(upload).FlatMap(_ =>
						       {
							       // We want to ensure that we explicitly invoke the event with the ORIGINAL manifest.
							       // UpdateReceived?.Invoke(manifestResponse);
							       return PromiseBase.SuccessfulUnit;
						       });
					       }
					       else
					       {
						       if (downloadRequest.Count > 0)
						       {
							       return WriteManifest(manifestResponse).FlatMap(manifest => PromiseBase.SuccessfulUnit);
						       }
					       }
					       return PromiseBase.SuccessfulUnit;
				       });
			});
		}
		

		private ConcurrentDictionary<string, string> DiffManifest(ManifestResponse response)
		{
			var newManifestDict = new ConcurrentDictionary<string, string>();

			if (_localManifest == null || response.replacement)
			{
				foreach (var s3Object in response.manifest)
				{
					newManifestDict[s3Object.key] = s3Object.eTag;
				}
			}
			else
			{
				var oldManifestDict = new ConcurrentDictionary<string, string>();
				foreach (var s3Object in _localManifest.manifest)
				{
					oldManifestDict[s3Object.key] = s3Object.eTag;
				}

				foreach (var s3Object in response.manifest)
				{

					var hasBeenDownloaded = oldManifestDict.TryGetValue(s3Object.key, out string hash);
					var localContentMatchesServer = !string.IsNullOrWhiteSpace(hash) && s3Object.eTag.Equals(hash);

					if (!hasBeenDownloaded || !localContentMatchesServer)
					{
						newManifestDict[s3Object.key] = s3Object.eTag;
					}
				}
			}

			_localManifest = response;
			return newManifestDict;
		}

		private Promise<Unit> HandleRequest<T>(T request,
											   ConcurrentDictionary<string, string> fileNameToKey,
											   Method method,
											   string endpoint)
		{
			var promiseList = new ConcurrentDictionary<string, Func<Promise<Unit>>>();
			return GetPresignedURL(request, endpoint).FlatMap(presignedURLS =>
			{
				int responseAmount = presignedURLS.response.Count;
				if (responseAmount == 0)
				{
					return PromiseBase.SuccessfulUnit;
				}
				var s3Response = new Dictionary<string, PreSignedURL>(responseAmount);
				for (int i = 0; i < responseAmount; i++)
				{
					//MD5_Checksum : PresignedURL
					s3Response[presignedURLS.response[i].objectKey] = presignedURLS.response[i];
				}

				foreach (var kv in fileNameToKey)
				{
					PreSignedURL s3PresignedURL;
					bool isSuccessful = s3Response.TryGetValue(kv.Value, out s3PresignedURL);

					if (isSuccessful)
					{
						var fullPathToFile = kv.Key;
						isSuccessful = promiseList.TryAdd(s3PresignedURL.url,
														  new Func<Promise<Unit>>(
															  () => GetOrPostObjectInS3(
																  fullPathToFile, s3PresignedURL, method)));
					}

					if (!isSuccessful)
					{
						Debug.LogWarning($"Key in manifest does not match a value on the server, Key {kv.Value}");
					}
				}

				if (promiseList.Count != responseAmount)
				{
					return Promise<Unit>.Failed(new Exception("Some of the keys in manifest does not match a values on the server"));
				}

				return Promise.ExecuteInBatch(10, promiseList.Values.ToList()).Map(_ => PromiseBase.Unit);
			}).Error(delete =>
			{
				// Directory.Delete(localCloudDataPath.temp, true);
			});
		}

		private Promise<Unit> GetOrPostObjectInS3(string fullPathToDestinationFile, PreSignedURL url, Method method)
		{
			//var request = _requester.Request(method,url.url,)
			var s3Request = BuildS3Request(method, url.url, fullPathToDestinationFile);
			return MakeRequestToS3(fullPathToDestinationFile, s3Request);
		}

		private Promise<Unit> MakeRequestToS3(string filename, UnityWebRequest request)
		{
			var result = new Promise<Unit>();
			_fileWebRequestRoutine = HandleResponse(filename, result, request);
			_coroutineService.StartCoroutine(_fileWebRequestRoutine);
			return result;
		}

		private IEnumerator HandleResponse(string filename, Promise<Unit> promise, UnityWebRequest request)
		{
			UnityWebRequest currentRequest = request;
			var isGet = currentRequest.method == Method.GET.ToString();
			var isError = false;

			for (var retryCount = 0; retryCount < 4; retryCount++)
			{
				var activeWebRequest = currentRequest.SendWebRequest();
				isError = false;

				while (!activeWebRequest.isDone)
				{
					yield return new WaitForSecondsRealtime(1f);
				}

				if (activeWebRequest.webRequest.IsHttpError())
				{
					isError = true;
					yield return new WaitForSecondsRealtime(retryCount);
					//The presignedURL did not find an object that matches
					//The previous request was made, Unity destroys it, so we need to create a new one with the same parameters.
					currentRequest = new UnityWebRequest(currentRequest.url, currentRequest.method);
				}
				else
				{
					//Not an error, lets get out of the loop
					break;
				}
			}
			if (isError)
			{
				promise.Error(ProvideErrorCallback(nameof(HandleResponse)));
				promise.CompleteError(new Exception($"Failed to process {filename}, stopping service."));
				yield return promise;
				yield break;
			}

			if (isGet)
			{
				if(currentRequest.result != UnityWebRequest.Result.Success){
					promise.Error(ProvideErrorCallback(nameof(HandleResponse)));
					promise.CompleteError(new Exception($"Failed to process {filename}, stopping service"));
					yield return promise;
					yield break;
				}

				_pendingDownloads[filename] = currentRequest.downloadHandler.text;
				promise.CompleteSuccess(PromiseBase.Unit);
				yield return promise;
			}
			else
			{
				promise.CompleteSuccess(PromiseBase.Unit);
				yield return promise;
			}

			request.Dispose();
		}

		private UnityWebRequest BuildS3Request(Method method, string uri, string id)
		{
			var request = new UnityWebRequest(uri)
			{
				method = method.ToString()
			};

			if (method == Method.GET)
			{
				request.downloadHandler = new DownloadHandlerBuffer();
			}
			else
			{
				request.uploadHandler = new UploadHandlerRaw(Encoding.UTF8.GetBytes(_pendingUploads[id]));
			}

			return request;
		}

		private void ClearQueuesAndLocalManifest()
		{
			_pendingUploads.Clear();
			_localManifest = null;
		}

		private Promise<Unit> DeleteLocalUserData()
		{
			_saves = new SerializableDictionaryStringToString();
			ClearQueuesAndLocalManifest();
			_saveHandle.Save();
			return Promise<Unit>.Successful(new Unit());
		}

		public void OnBeforeSaveState()
		{
		}

		public void OnAfterLoadState()
		{
		}

		private Promise<ManifestResponse> FetchUserManifest()
		{
			// return _cloudsavingApi.Get().Map(ManifestResponse.FromOpenApi);
			return _requester.Request<ManifestResponse>(
				                 Method.GET,
				                 string.Format($"/basic/cloudsaving?playerId={_platform.User.id}"),
				                 null)
			                 .Error(ProvideErrorCallback(nameof(FetchUserManifest)));
		}

		private Promise<URLResponse> GetPresignedURL<T>(T request, string endpoint)
		{
			return _requester.Request<URLResponse>(
				                 Method.POST,
				                 string.Format($"/basic/cloudsaving{endpoint}"),
				                 request)
			                 .Error(ProvideErrorCallback(nameof(GetPresignedURL)));
		}

		private Promise<ManifestResponse> CommitManifest(UploadManifestRequest request)
		{
			// return _cloudsavingApi.PutDataCommitManifest(new UploadRequests()
			// {
			// 	request = request.request
			// })
		return _requester.Request<ManifestResponse>(
				Method.PUT,
				string.Format($"/basic/cloudsaving/data/commitManifest"),
				request
			).FlatMap(res =>
				{
					res.replacement = false;
					return WriteManifest(res).Map(_ => res);
				}
			).Error(ProvideErrorCallback(nameof(CommitManifest)));
		}

		private Promise<Unit> WriteManifest(ManifestResponse response)
		{
			try
			{
				_localManifest = response;
				_saveHandle.Save();
				return Promise<Unit>.Successful(new Unit());
			}
			catch (Exception ex)
			{
				return Promise<Unit>.Failed(ex).Error(ProvideErrorCallback(nameof(WriteManifest)));
			}
		}

		private string NormalizeS3Path(string key, string path)
		{
			return key.Remove(0, path.Length + 1).Replace(@"\", "/");
		}

		private void InvokeError(string reason, Exception inner)
		{
			OnError?.Invoke(new CloudSavingError(reason, inner));
		}

		private Action<Exception> ProvideErrorCallback(string methodName)
		{
			return (ex) => { InvokeError($"{methodName} Failed: {ex?.Message ?? "unknown reason"}", ex); };
		}

		public void ReceiveStorageHandle(StorageHandle<PlayerSaves> handle)
		{
			_saveHandle = handle;
		}

		protected override async Promise PerformRefresh()
		{
			var response = await EnsureRemoteManifest();
			await SyncRemoteContent(response);

			_notificationService.Subscribe(
				"cloudsaving.datareplaced",
				OnReplacedNtf
			);
			_notificationService.Subscribe(
				"cloudsaving.refresh",
				OnReplacedNtf
			);
		}
	}
}
