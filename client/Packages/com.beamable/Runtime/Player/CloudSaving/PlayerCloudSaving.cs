using Beamable.Api;
using Beamable.Api.Autogenerated.Cloudsaving;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.CloudSaving;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Auth;
using Beamable.Common.Api.Notifications;
using Beamable.Coroutines;
using Beamable.Utility;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using UnityEngine;
using UnityEngine.Networking;

namespace Beamable.Player.CloudSaving
{
	public class PlayerCloudSaving : ICloudSavingService
	{
		private const string DATA_REPLACED_NOTIFICATION = "cloudsaving.refresh";
		private readonly IPlatformService _platformService;
		private readonly PlayerCloudSavingConfiguration _configuration;
		private readonly CoroutineService _coroutineService;
		private readonly ICloudsavingApi _cloudSavingApi;
		private readonly BeamContext _beamContext;
		private readonly INotificationService _notificationService;
		private readonly LocalSavePathDetail _localSaveInformation;
		
		private CloudSavingManifest _localManifest;
		private CloudSavingManifest _cloudManifest;
		private WaitForSecondsRealtime _routineWaitInterval;
		private Coroutine _watcherRoutine;
		private List<DataConflictDetail> _currentConflicts = new();
		private Promise<Unit> _updatePromise;
		private Promise<Unit> _downloadPromise;
		private int _pollingIntervalSeconds;
		
		public string LocalDataFullPath => _localSaveInformation.DataPath;
		public Action<CloudSavingManifest> OnManifestUpdated { get; set; }
		public Action<CloudSavingError> OnCloudSavingError { get; set; }
		public CloudSaveStatus ServiceStatus { get; private set; }
		private CloudSavingManifest CloudManifest
		{
			get => _cloudManifest;
			set
			{
				OnManifestUpdated?.Invoke(value);
				_cloudManifest = value;
			}
		}

		public PlayerCloudSaving(IPlatformService platformService, 
		                         PlayerCloudSavingConfiguration configuration, 
		                         CoroutineService coroutineService,
		                         ICloudsavingApi cloudSavingApi, 
		                         BeamContext beamContext,
		                         INotificationService notificationService) 
		{
			_platformService = platformService;
			_configuration = configuration;
			_coroutineService = coroutineService;
			_cloudSavingApi = cloudSavingApi;
			_beamContext = beamContext;
			_notificationService = notificationService;
			_localSaveInformation =  new LocalSavePathDetail(_platformService);
			ServiceStatus = CloudSaveStatus.Inactive;
		}

		public async Promise<CloudSaveStatus> Init(int pollingIntervalSeconds = 10)
		{
			if (ServiceStatus != CloudSaveStatus.Inactive)
			{
				Debug.LogWarning("PlayerCloudSaving is already initialized. To ReInitialize use the ReInit method.");
				return ServiceStatus;
			}

			_pollingIntervalSeconds = pollingIntervalSeconds;

			ServiceStatus = CloudSaveStatus.Initializing;

			_routineWaitInterval = new WaitForSecondsRealtime(pollingIntervalSeconds);

			SetupFolders();

			await LoadLocalManifest();

			await GetCloudData();

			bool resolved = await TryResolveConflicts();
			if (!resolved)
			{
				ServiceStatus = CloudSaveStatus.ConflictedData;
			}
			else
			{
				FinishInitService();
			}

			return ServiceStatus;
		}

		public Promise<CloudSaveStatus> ReInit(int pollingIntervalSeconds = 10)
		{
			if (ServiceStatus is not CloudSaveStatus.Initialized)
			{
				Debug.LogError("Service isn't initialized yet. It isn't possible to ReInit yet");
				return Promise<CloudSaveStatus>.Successful(ServiceStatus);
			}

			StopService();
			ServiceStatus = CloudSaveStatus.Inactive;
			return Init(pollingIntervalSeconds);
		}

		public async Promise<Unit> ForceUploadLocalData()
		{
			if (ServiceStatus != CloudSaveStatus.Initialized)
			{
				var exception = new Exception($"Could not do Operation, Cloud Saving Status is {ServiceStatus}");
				return await Promise<Unit>.Failed(exception);
			}
			
			if (_updatePromise is {IsCompleted: false})
			{
				await _updatePromise;
			}

			if (_configuration.UseAutoCloud)
			{
				CheckFolderFiles();
			}

			_updatePromise = CheckAndApplyChangedEntries();
			return await _updatePromise;
		}
		public async Promise<Unit> ForceDownloadCloudData()
		{
			if (ServiceStatus != CloudSaveStatus.Initialized)
			{
				var exception = new Exception($"Could not do Operation, Cloud Saving Status is {ServiceStatus}");
				return await Promise<Unit>.Failed(exception);
			}

			await GetCloudData(true);
			
			UpdateLocalManifest();

			return PromiseBase.Unit;
		}

		public IReadOnlyList<DataConflictDetail> GetDataConflictDetails()
		{
			return _currentConflicts.AsReadOnly();
		}

		public void ResolveDataConflict(DataConflictDetail conflictDetail, ConflictResolveType resolveType)
		{
			string fileName = conflictDetail.FileName;
			if (_currentConflicts.Count == 0)
			{
				Debug.LogWarning("No Conflict Found, ignoring this method call.");
				return;
			}

			int index = _currentConflicts.FindIndex(
				x => x.FileName.Equals(fileName, StringComparison.InvariantCultureIgnoreCase));
			if (index == -1)
			{
				Debug.LogWarning($"No Conflict Found for {fileName}, ignoring this method call.");
				return;
			}
			
			try
			{
				ResolveConflict(_currentConflicts[index], resolveType);
			}
			catch (Exception e)
			{
				Debug.LogWarning($"Couldn't apply resolve for {fileName}");
				Debug.LogException(e);
				return;
			}

			_currentConflicts.RemoveAt(index);

			if (_currentConflicts.Count != 0 || ServiceStatus is CloudSaveStatus.Initializing or CloudSaveStatus.Initialized)
			{
				return;
			}

			// Conflicts are resolved, start Watcher files and Enable Service if it isn't initializing already
			FinishInitService();
		}

		public async Promise<Unit> SaveData(string fileName, string content)
		{
			return await BaseSaveData(fileName, content);
		}
		
		public async Promise<Unit> SaveData(string fileName, byte[] content)
		{
			return await BaseSaveData(fileName, content);
		}
		public async Promise<Unit> SaveData<T>(string fileName, T contentData)
		{
			return await BaseSaveData(fileName, contentData);
		}
		
		public Promise<string> LoadDataString(string fileName)
		{
			return BaseLoadData<string>(fileName);
		}
		public Promise<byte[]> LoadDataByte(string fileName)
		{
			return BaseLoadData<byte[]>(fileName);
		}
		public Promise<T> LoadData<T>(string fileName)
		{
			return BaseLoadData<T>(fileName);
		}

		public Promise<Unit> Update(Action<CloudDataUpdateBuilder> builder)
		{
			if (ServiceStatus is not CloudSaveStatus.Initialized)
			{
				throw new Exception($"Cloud Saving Status is {ServiceStatus}");
			}
			
			var cloudDataUpdateBuilder = new CloudDataUpdateBuilder();
			builder?.Invoke(cloudDataUpdateBuilder);
			
			return Update(cloudDataUpdateBuilder);
		}

		private async Promise Update(CloudDataUpdateBuilder cloudDataUpdateBuilder)
		{
			if (_updatePromise is {IsCompleted: false})
			{
				await _updatePromise;
			}
			
			RenameSaves(cloudDataUpdateBuilder.FilesToRename);

			ArchiveSaves(cloudDataUpdateBuilder.FilesToArchive);

			ForgetSaves(cloudDataUpdateBuilder.FilesToForget);
			
			_updatePromise = CheckAndApplyChangedEntries();
			await _updatePromise;
		}

		private void ArchiveSaves(List<string> saveNames)
		{
			foreach (string saveName in saveNames)
			{
				int findIndex = FindEntryFileInList(saveName, _localManifest.manifest);
				if(findIndex == -1)
					continue;

				_localManifest.manifest[findIndex].isDeleted = true;
				string filePath = Path.Combine(_localSaveInformation.DataPath, saveName);
				BeamUnityFileUtils.ArchiveFile(filePath, _localSaveInformation.ArchivePath);
			}
			
		}
		private void RenameSaves(Dictionary<string, string> renameValues)
		{
			foreach ((string oldName, string newName) in renameValues)
			{
				int findIndex = FindEntryFileInList(oldName, _localManifest.manifest);
				if (findIndex == -1)
				{
					continue;
				}

				try
				{
					string filePath = Path.Combine(_localSaveInformation.DataPath, oldName);
					var fileInfo = BeamUnityFileUtils.RenameFile(filePath, newName);
					
					// Mark item to be deleted from Manifest
					_localManifest.manifest[findIndex].isDeleted = true;
					// Add new Entry if the new Name
					AddOrUpdateLocalManifestEntry(fileInfo);
					
				}
				catch (Exception e)
				{
					Debug.LogError($"Could not rename file: {oldName} -> {newName}. Skipping it.\nException: {e}");
				}
			}
		}

		private void ForgetSaves(List<string> saveNames)
		{
			if(saveNames.Count == 0)
				return;
			
			if (_configuration.UseAutoCloud)
			{
				Debug.LogWarning("This functions doesn't work well when UseAutoCloud is enabled as it will automatically " +
				                 "adds the file to the manifest again when checking for files on AutoCloud.");
			}
			else
			{
				foreach (string saveName in saveNames)
				{
					int findIndex = FindEntryFileInList(saveName, _localManifest.manifest);
					if (findIndex != -1)
					{
						_localManifest.manifest[findIndex].isDeleted = true;
					}	
				}
			}
		}
		
		private void SetupFolders()
		{
			Directory.CreateDirectory(_localSaveInformation.DataPath);
			Directory.CreateDirectory(_localSaveInformation.ArchivePath);
			Directory.CreateDirectory(_localSaveInformation.TempFolderPath);
		}
		
		private async Promise<Unit> LoadLocalManifest()
		{
			_localManifest = await BeamUnityFileUtils.ReadJsonContent(_localSaveInformation.ManifestPath, defaultObject: new CloudSavingManifest());
			return PromiseBase.Unit;
		}

		private async Promise<Unit> GetCloudManifest()
		{
			var manifestResponse = await _cloudSavingApi.Get(_platformService.User.id).RecoverWith(exception =>
			{
				if (exception is not PlatformRequesterException {Status: 404})
				{
					throw exception;
				}

				return CommitEmptyManifest();
			}).Error(ProvideErrorCallback(nameof(GetCloudManifest)));

			var manifestData = ParseServerManifest(manifestResponse);

			CloudManifest = new CloudSavingManifest { manifest = manifestData};
			return PromiseBase.Unit;
		}

		private Promise<CloudsavingBasicManifest> CommitEmptyManifest()
		{
			var uploadRequests = new UploadRequests()
			{
				playerId = _platformService.User.id,
				request = Array.Empty<UploadRequest>(),
			};
			return _cloudSavingApi.PutDataCommitManifest(uploadRequests)
			                      .Error(ProvideErrorCallback(nameof(CommitEmptyManifest)));
		}

		private async Promise<Unit> DownloadCloudData(List<EntryDownloadDetail> downloadDetails)
		{
			if (_downloadPromise is {IsCompleted: false})
			{
				await _downloadPromise;
			}
			
			CleanTempFolder();
			
			ObjectRequests uploadRequests = GenerateDownloadRequest(downloadDetails);

			_downloadPromise = _cloudSavingApi.PostDataDownloadURL(uploadRequests).FlatMap(response =>
			{
				var downloadUrls = response.response;

				if (downloadUrls.Length < downloadDetails.Count)
				{
					// Missing Download URLs, return error
					return Promise<Unit>.Failed(new Exception($"Missing Download URLs. Server returned {downloadUrls.Length}" +
					                                          $" and we need to download {downloadDetails.Count}"));
				}

				List<Func<Promise<Unit>>> downloadPromises = new List<Func<Promise<Unit>>>();

				for (int index = 0; index < downloadUrls.Length; index++)
				{
					var url = downloadUrls[index];
					var downloadDetail = downloadDetails[index];
					downloadPromises.Add(() => DownloadFileRequest(url, downloadDetail));
				}

				if (downloadPromises.Count == 0)
				{
					return PromiseBase.SuccessfulUnit;
				}
				
				return PromiseExtensions.ExecuteOnGameObjectRoutines(10, _coroutineService, downloadPromises)
				                        .Map(_ => PromiseBase.Unit);
			}).Error(ProvideErrorCallback(nameof(DownloadCloudData)));

			return await _downloadPromise;
		}

		private void CleanTempFolder()
		{
			foreach (string file in Directory.GetFiles(_localSaveInformation.TempFolderPath))
			{
				BeamUnityFileUtils.ArchiveFile(file, _localSaveInformation.ArchivePath);
			}
		}

		private Promise<Unit> DownloadFileRequest(CloudsavingBasicURLResponse preSignedUrl, EntryDownloadDetail downloadDetail)
		{
			// Check if it is new, save it on final folder with correct name. If not (It is a conflict), save it on TempFolder for now
			string basePath = downloadDetail.IsNew ? _localSaveInformation.DataPath : _localSaveInformation.TempFolderPath;
			string saveFileName = downloadDetail.IsNew ? downloadDetail.FileName : GetTempFileName(downloadDetail.FileName, preSignedUrl.objectKey);
			string pathToTempDownload = Path.Combine(basePath, saveFileName);
			var downloadHandler = new DownloadHandlerFile(pathToTempDownload);
			return Promise.RetryPromise(() => SendDownloadRequest(preSignedUrl.url, downloadHandler), _ => true, 10)
			              .Error(ProvideErrorCallback(nameof(DownloadFileRequest)));
		}

		private Promise<Unit> SendDownloadRequest(string url, DownloadHandlerFile downloadHandler)
		{
			var result = new Promise<Unit>();
			var request = new UnityWebRequest(url)
			{
				downloadHandler = downloadHandler, 
				method = Method.GET.ToString()
			};

			var operation = request.SendWebRequest();
			operation.completed += _ =>
			{
				try
				{
					if (request.result != UnityWebRequest.Result.Success)
					{
						result.CompleteError(
							new Exception($"Could not upload file, error message: {request.error}"));
					}
					else
					{
						result.CompleteSuccess(PromiseBase.Unit);
					}
				}
				finally
				{
					request.Dispose();
				}
			};

			return result;
		}

		private ObjectRequests GenerateDownloadRequest(List<EntryDownloadDetail> downloadDetails)
		{
			var objectRequests = new ObjectRequest[downloadDetails.Count];
			
			for (int index = 0; index < downloadDetails.Count; index++)
			{
				var downloadDetail = downloadDetails[index];
				objectRequests[index] = new ObjectRequest()
				{
					objectKey = downloadDetail.CheckSum
				};
			}
			
			var downloadRequest = new ObjectRequests()
			{
				playerId = _platformService.User.id, 
				request = new OptionalArrayOfObjectRequest(objectRequests)
			};
			return downloadRequest;
		}

		

		private List<CloudSaveEntry> ParseServerManifest(CloudsavingBasicManifest manifestResponse)
		{
			List<CloudSaveEntry> cloudManifest = new List<CloudSaveEntry>();

			foreach (CloudsavingBasicReference reference in manifestResponse.manifest)
			{
				cloudManifest.Add(ParseEntry(reference));
			}

			return cloudManifest;
		}

		private CloudSaveEntry ParseEntry(CloudsavingBasicReference reference)
		{
			return new CloudSaveEntry(
				reference.key,
				(int)reference.size,
				reference.lastModified,
				reference.eTag,
				false);
		}
		
		private Promise<bool> TryResolveConflicts()
		{
			if (_currentConflicts.Count <= 0)
			{
				// No Conflicts to resolve, just return Promise
				return Promise<bool>.Successful(true);
			}

			// Get Conflict resolver

			var resolver = _configuration.HandleConflicts ?? DefaultResolver;
			resolver.Invoke(new CloudServiceConflictResolver(this));
			
			// Check if all conflicts were solved
			return Promise<bool>.Successful(_currentConflicts.Count == 0);
		}
		

		private List<EntryDownloadDetail> CheckCloudEntries(bool forceDownloadAll = false)
		{
			List<DataConflictDetail> conflicts = new List<DataConflictDetail>();
			var downloadDetails = new List<EntryDownloadDetail>();
			var localSaveEntries = new List<CloudSaveEntry>(_localManifest.manifest);
			
			foreach (CloudSaveEntry cloudEntry in CloudManifest.manifest)
			{
				int findIndex = FindEntryFileInList(cloudEntry.key, localSaveEntries);
				if (forceDownloadAll || findIndex == -1)
				{
					downloadDetails.Add(GenerateEntryDownloadDetail(cloudEntry, true));
					continue;
				}
				
				var localEntry = localSaveEntries[findIndex];
				if (localEntry.eTag == cloudEntry.eTag)
				{
					// No Conflict for this key
					localSaveEntries.RemoveAt(findIndex);
					continue;
				}

				conflicts.Add(new DataConflictDetail()
				{
					FileName = localEntry.key,
					LocalSaveEntry = localEntry,
					LocalFilePath = Path.Join(_localSaveInformation.DataPath, localEntry.key),
					CloudSaveEntry = cloudEntry,
					CloudFilePath = Path.Join(_localSaveInformation.TempFolderPath, GetTempFileName(cloudEntry.key, cloudEntry.eTag))
				});
				
				downloadDetails.Add(GenerateEntryDownloadDetail(cloudEntry, false));
					
				// Conflict detected, we can remove entry
				localSaveEntries.RemoveAt(findIndex);
			}

			_currentConflicts = conflicts;
			return downloadDetails;
		}

		private static EntryDownloadDetail GenerateEntryDownloadDetail(CloudSaveEntry cloudEntry, bool isNew)
		{
			return new  EntryDownloadDetail()
			{
				CheckSum = cloudEntry.eTag,
				FileName = cloudEntry.key,
				IsNew = isNew,
			};
		}

		private void DefaultResolver(IConflictResolver conflictResolver)
		{
			conflictResolver.ResolveAllByNewest();
		}

		private void ResolveConflict(DataConflictDetail dataConflictDetail, ConflictResolveType response)
		{
			string fileName = dataConflictDetail.FileName;
			switch (response)
			{
				case ConflictResolveType.UseLocal:
					// If we're using local we just need to Archive the Temp File for Cloud and Update Cloud Info
					// because later the Cloud info will override Local Changes.
					BeamUnityFileUtils.ArchiveFile(dataConflictDetail.CloudFilePath, _localSaveInformation.ArchivePath);
					ReplaceEntry(CloudManifest.manifest, fileName, dataConflictDetail.LocalSaveEntry);
					break;
				case ConflictResolveType.UseCloud:
					// If it is supposed to use Cloud, we should Archive Local File, replace local with cloud entry as safety
					// And then move the Cloud File (while renaming it as well) to the previous local file path.
					BeamUnityFileUtils.ArchiveFile(dataConflictDetail.LocalFilePath, _localSaveInformation.ArchivePath);
					ReplaceEntry(_localManifest.manifest, fileName, dataConflictDetail.CloudSaveEntry);
					BeamUnityFileUtils.MoveFile(dataConflictDetail.CloudFilePath, dataConflictDetail.LocalFilePath);
					break;
			}
		}

		private void ReplaceEntry(List<CloudSaveEntry> entries, string fileName, CloudSaveEntry newEntry)
		{
			int entryIndex = FindEntryFileInList(fileName, entries);
			if (entryIndex != -1)
			{
				newEntry.isModified = true;
				entries[entryIndex] = newEntry;
			}
		}
		
		private async Promise<Unit> BaseSaveData<T>(string fileName, T contentData)
		{
			fileName = BeamUnityFileUtils.SanitizeFileName(fileName);
			// Parse and check fileName
			if (ServiceStatus is not CloudSaveStatus.Initialized and not CloudSaveStatus.ConflictedData)
			{
				var exception = new Exception($"Could not do Operation, Cloud Saving Status is {ServiceStatus}");
				return await Promise<Unit>.Failed(exception);
			}
			
			string filePath = Path.Combine(_localSaveInformation.DataPath, fileName);

			Promise<FileInfo> promise = contentData switch
			{
				string stringContent => BeamUnityFileUtils.WriteStringFile(filePath, stringContent),
				byte[] byteContent => BeamUnityFileUtils.WriteBytesFile(filePath, byteContent),
				_ => BeamUnityFileUtils.WriteJsonContent(filePath, contentData, _configuration.CustomSerializer)
			};
			
			FileInfo fileInfo = await promise.Error(ProvideErrorCallback(nameof(BaseSaveData)));
			
			AddOrUpdateLocalManifestEntry(fileInfo);
			return PromiseBase.Unit;
		}
		
		private Promise<T> BaseLoadData<T>(string fileName)
		{
			fileName = BeamUnityFileUtils.SanitizeFileName(fileName);
			// Parse and Check file name
			if (ServiceStatus is not CloudSaveStatus.Initialized and not CloudSaveStatus.ConflictedData)
			{
				var exception = new Exception($"Could not do Operation, Cloud Saving Status is {ServiceStatus}");
				return Promise<T>.Failed(exception);
			}
			
			string filePath = Path.Combine(_localSaveInformation.DataPath, fileName);
			
			Type type = typeof(T);
			Promise<T> promise =type switch
			{
				not null when type == typeof(string) => BeamUnityFileUtils.ReadStringFile(filePath).Map(resultFile => (T)(object)resultFile),
				not null when type == typeof(byte[]) => BeamUnityFileUtils.ReadBytesFile(filePath).Map(resultFile => (T)(object)resultFile),
				not null => BeamUnityFileUtils.ReadJsonContent<T>(filePath, _configuration.CustomDeserializer)
			};
			
			return promise.Error(ProvideErrorCallback(nameof(BaseLoadData)));
		}

		private void AddOrUpdateLocalManifestEntry(FileInfo fileInfo)
		{
			string fileName = fileInfo.Name;
			int contentLength = (int) fileInfo.Length;
			long lastModified = long.Parse(fileInfo.LastWriteTime.ToString("yyyyMMddHHmmss", CultureInfo.InvariantCulture));
			string checkSum = GenerateCheckSum(fileInfo);
			
			// Find Manifest Entries ignoring case and using invariant culture.
			int findIndex = FindEntryFileInList(fileName, _localManifest.manifest);
			if (findIndex == -1)
			{
				_localManifest.manifest.Add(new CloudSaveEntry(fileName, contentLength, lastModified, checkSum, true));
			}
			else if(_localManifest.manifest[findIndex].eTag != checkSum)
			{
				CloudSaveEntry cloudSaveEntry = _localManifest.manifest[findIndex];
				cloudSaveEntry.isModified = true;
				cloudSaveEntry.eTag = checkSum;
				cloudSaveEntry.size = contentLength;
				cloudSaveEntry.lastModified = lastModified;
			}
		}

		private int FindEntryFileInList(string fileName, List<CloudSaveEntry> entries)
		{
			return entries.FindIndex(x => string.Equals(x.key, fileName, StringComparison.InvariantCultureIgnoreCase));
		}

		private string GenerateCheckSum(FileInfo fileInfo)
		{
			using (var md5 = MD5.Create())
			{
				using (var stream = new FileStream(fileInfo.FullName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
				{
					return BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", string.Empty);
				}
			}
		}

		private IEnumerator AutoCloudFileWatcherRoutine()
		{
			while (true)
			{
				yield return _routineWaitInterval;

				CheckFolderFiles();
				yield return CheckAndApplyChangedEntries().Error(ProvideErrorCallback(nameof(AutoCloudFileWatcherRoutine)));
			}
		}

		private void CheckFolderFiles()
		{
			string[] savedFiles = Directory.GetFiles(_localSaveInformation.DataPath, "*.*", SearchOption.TopDirectoryOnly);
			foreach (string savedFilePath in savedFiles)
			{
				var fileInfo = new FileInfo(savedFilePath);
				AddOrUpdateLocalManifestEntry(fileInfo);
			}
		}

		private IEnumerator ManifestWatcherRoutine()
		{
			while (true)
			{
				yield return _routineWaitInterval;

				yield return CheckAndApplyChangedEntries().Error(ProvideErrorCallback(nameof(ManifestWatcherRoutine)));
			}
		}

		private async Promise<Unit> CheckAndApplyChangedEntries()
		{
			if (_updatePromise is {IsCompleted: false})
			{
				await _updatePromise;
			}
			var changedEntries = _localManifest.manifest.Where(entry => entry.isModified || entry.isDeleted).ToList();

			if (changedEntries.Count == 0)
				return PromiseBase.Unit;

			_updatePromise = UpdateChangedEntries(changedEntries);
			
			return await _updatePromise;
		}

		private Promise<Unit> UpdateChangedEntries(List<CloudSaveEntry> changedEntries)
		{
			(UploadRequests uploadRequest, UploadRequests updateRequest) = GenerateUploadUpdateRequests(changedEntries);

			int itemsToUploadCount = uploadRequest.request.Length;
			return _cloudSavingApi.PostDataUploadURL(uploadRequest).FlatMap(response =>
			{
				var urls = response.response;

				if (urls.Length < itemsToUploadCount)
				{
					// Missing urls from, return error
					return Promise<Unit>.Failed(new Exception(
						                            $"Missing PreSigned URLs. Server returned {urls.Length} and we need to upload {itemsToUploadCount}"));
				}

				List<Func<Promise<Unit>>> uploadPromises = new List<Func<Promise<Unit>>>();
				foreach (CloudsavingBasicURLResponse preSignedUrl in urls)
				{
					uploadPromises.Add(() => UploadFileRequest(preSignedUrl));
				}
				
				if (uploadPromises.Count == 0)
				{
					return PromiseBase.SuccessfulUnit;
				}

				return PromiseExtensions.ExecuteOnGameObjectRoutines(10, _coroutineService, uploadPromises).Map(_ => PromiseBase.Unit);
			}).FlatMap(_ =>
			{
				return _cloudSavingApi.PutDataCommitManifest(updateRequest)
				                      .Then(response =>
				                      {
					                      CloudManifest.manifest = ParseServerManifest(response);
					                      UpdateLocalManifest();
				                      })
				                      .Map(_ => PromiseBase.Unit);
			}).Error(ProvideErrorCallback(nameof(UpdateChangedEntries)));
		}

		private Promise<Unit> UploadFileRequest(CloudsavingBasicURLResponse preSignedUrl)
		{
			string filePath = Path.Combine(_localSaveInformation.DataPath, preSignedUrl.objectKey);
			var uploadHandler = new UploadHandlerRaw(BeamUnityFileUtils.ReadFileWithoutLock(filePath))
			{
				contentType = "application/octet-stream"
			};
			return Promise.RetryPromise(() => SendUploadRequest(preSignedUrl.url, uploadHandler), 
			                            _ => true,
			                            10).Error(ProvideErrorCallback(nameof(UploadFileRequest)));
		}

		private (UploadRequests uploadRequest, UploadRequests updateRequest) GenerateUploadUpdateRequests(List<CloudSaveEntry> changedEntries)
		{
			List<UploadRequest> uploadRequestList = new List<UploadRequest>();
			List<UploadRequest> updateRequestList = new List<UploadRequest>();
			foreach (var cloudSaveEntry in changedEntries)
			{
				var uploadRequest = new UploadRequest()
				{
					objectKey = cloudSaveEntry.key,
					sizeInBytes = cloudSaveEntry.size,
					checksum = cloudSaveEntry.eTag,
					lastModified = cloudSaveEntry.lastModified,
					deleted = cloudSaveEntry.isDeleted,
				};
				updateRequestList.Add(uploadRequest);
				if (!cloudSaveEntry.isDeleted)
				{
					uploadRequestList.Add(uploadRequest);
				}
			}
			
			var uploadRequests = new UploadRequests
			{
				playerId = _platformService.User.id, 
				request = uploadRequestList.ToArray(),
			};
			
			var updateRequest = new UploadRequests()
			{
				playerId = _platformService.User.id,
				request = updateRequestList.ToArray(),
			};

			return (uploadRequests, updateRequest);
		}

		private Promise<Unit> SendUploadRequest(string url, UploadHandlerRaw uploadHandler)
		{
			var result = new Promise<Unit>();
			var request = new UnityWebRequest(url)
			{
				uploadHandler = uploadHandler, 
				method = Method.PUT.ToString(),
			};
			var operation = request.SendWebRequest();
			operation.completed += _ =>
			{
				try
				{
					if (request.result != UnityWebRequest.Result.Success)
					{
						result.CompleteError(
							new Exception($"Could not upload file, error message: {request.error}"));
					}
					else
					{
						result.CompleteSuccess(PromiseBase.Unit);
					}
				}
				finally
				{
					request.Dispose();
				}
			};
			return result;
		}
		
		private void FinishInitService()
		{
			UpdateLocalManifest();
			SetupWatcher();
			SubscribeToEvents();
			ServiceStatus = CloudSaveStatus.Initialized;
		}
		
		private async void UpdateLocalManifest(bool force = false)
		{
			if (!force && ServiceStatus is CloudSaveStatus.ConflictedData)
			{
				Debug.LogError("Trying to commit local manifest when have conflicted data.");
			}
			_localManifest = CloudManifest;
			await BeamUnityFileUtils.WriteJsonContent(_localSaveInformation.ManifestPath, _localManifest,
			                                          prettyPrint: true);
		}

		private void StopUpdateAndDownloadPromise()
		{
			_updatePromise.CompleteSuccess(PromiseBase.Unit);
			_downloadPromise.CompleteSuccess(PromiseBase.Unit);
		}
		
		private void SetupWatcher()
		{
			StopWatcherRoutine();
			IEnumerator watcherRoutine = _configuration.UseAutoCloud
				? AutoCloudFileWatcherRoutine()
				: ManifestWatcherRoutine();
			_watcherRoutine = _coroutineService.StartNew("FileWatcher", watcherRoutine);
		}
		
		private void StopService()
		{
			UnsubscribeToEvents();
			StopWatcherRoutine();
			StopUpdateAndDownloadPromise();
		}

		private void StopWatcherRoutine()
		{
			if (_watcherRoutine == null)
			{
				return;
			}

			_coroutineService.StopCoroutine(_watcherRoutine);
			_watcherRoutine = null;
		}

		private void SubscribeToEvents()
		{
			_notificationService.Subscribe(DATA_REPLACED_NOTIFICATION, OnDataReplaced);
			_beamContext.OnUserLoggedIn += OnUserLogged;
			_beamContext.OnReloadUser += OnReloadUser;
		}

		private void UnsubscribeToEvents()
		{
			_notificationService.Unsubscribe(DATA_REPLACED_NOTIFICATION, OnDataReplaced);
			_beamContext.OnUserLoggedIn -= OnUserLogged;
			_beamContext.OnReloadUser -= OnReloadUser;
		}

		private void OnUserLogged(User _)
		{
			ReInit(_pollingIntervalSeconds);
		}
		
		private void OnReloadUser()
		{
			ReInit(_pollingIntervalSeconds);
		}

		private async void OnDataReplaced(object _)
		{
			await GetCloudData();

			bool resolved = await TryResolveConflicts();
			if (!resolved)
			{
				Debug.LogError("Could not resolve conflicts generated by new Cloud Data.");
				ServiceStatus = CloudSaveStatus.ConflictedData;
				StopService();
			}
		}
		
		private async Promise GetCloudData(bool forceDownloadAll = false)
		{
			await GetCloudManifest();
			
			var downloadDetails = CheckCloudEntries(forceDownloadAll);

			await DownloadCloudData(downloadDetails);
		}
		
		private Action<Exception> ProvideErrorCallback(string methodName)
		{
			return (ex) => { InvokeError($"{methodName} Failed: {ex?.Message ?? "unknown reason"}", ex); };
		}
		
		private void InvokeError(string reason, Exception inner)
		{
			OnCloudSavingError?.Invoke(new CloudSavingError(reason, inner));
		}

		private string GetTempFileName(string fileName, string checkSum) => $"{fileName}-{checkSum}";

		private class LocalSavePathDetail
		{
			private const string BEAMABLE_FOLDER = "beamable";
			private const string PLAYER_CLOUD_SAVE_FOLDER = "playercloudsave";
			private const string DATA_FOLDER = "data";
			private const string TEMP_FOLDER = "temp";
			private const string ARCHIVE_FOLDER = "archive";
			private const string MANIFEST_NAME = "cloudDataManifest.json";
			
			private readonly IPlatformService _platformService;

			public LocalSavePathDetail(IPlatformService platformService)
			{
				_platformService = platformService;
			}

			private string RootPath => Path.Combine(Application.persistentDataPath, BEAMABLE_FOLDER, PLAYER_CLOUD_SAVE_FOLDER);
			private string BasePath =>
				Path.Combine(RootPath, _platformService.Cid, _platformService.Pid, _platformService.User.id.ToString());
		
			public string ManifestPath => Path.Combine(BasePath, MANIFEST_NAME);
			public string TempFolderPath => Path.Combine(BasePath, TEMP_FOLDER);
			public string ArchivePath => Path.Combine(BasePath, ARCHIVE_FOLDER);
			public string DataPath => Path.Combine(BasePath, DATA_FOLDER);
		}
		
	}
}
