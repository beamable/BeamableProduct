using Beamable.Api.Autogenerated.Leaderboards;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Coroutines;
using System;

namespace Beamable.Player
{

	[Serializable]
	public class PlayerFriendScoresList : PlayerScoreList
	{

		// public OptionalPlayerLeaderboardScore CurrentScore = new OptionalPlayerLeaderboardScore();
		
		public PlayerFriendScoresList(IPlayerLeaderboardFriend board, ILeaderboardsApi api, IUserContext ctx, CoroutineService coroutineService)
			: base(board, api, ctx, coroutineService)
		{
		}
		
		protected override async Promise<LeaderBoardViewResponse> CreateRequest(LeaderboardAssignmentInfo info)
		{
			var promiseSeq = await Promise.Sequence(
				_api.ObjectGetFriends(info.leaderboardId),
				_api.ObjectGetView(info.leaderboardId, max: 0, outlier: _ctx.UserId)
			);

			var self = promiseSeq[1].lb.rankgt;
			var friends = promiseSeq[0].lb.rankings;
			var selfRankFound = false;

			foreach (var friend in friends)
			{
				friend.rank++; // for some reason, the server uses rank index
			}
			
			if (self.HasValue)
			{
				for (var i = 0; i < friends.Length; i++)
				{
					if (!selfRankFound && self.Value.score > friends[i].score)
					{
						self.Value.rank = friends[i].rank;
						selfRankFound = true;
					}
			
					if (selfRankFound)
					{
						friends[i].rank++; // account for inserted player rank
					}
				}
			
				if (!selfRankFound)
				{
					self.Value.rank = friends.Length;
				}
				_board.SetCurrentFriendScore(self.Value);
			}

			return promiseSeq[0];
		}

		public PlayerFriendScoresList LoadCount(int totalSize)
		{
			_size = totalSize;
			var _ = Refresh();
			return this;
		}

		public new async Promise<PlayerFriendScoresList> Refresh()
		{
			await base.Refresh();
			return this;
		}
	}


}
