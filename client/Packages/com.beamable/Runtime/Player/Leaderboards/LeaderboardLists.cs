using Beamable.Api.Autogenerated.Leaderboards;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Dependencies;
using Beamable.Common.Player;
using Beamable.Coroutines;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

namespace Beamable.Player
{
	public interface IPlayerScoreListFriend
	{
		void Hydrate(IPlayerLeaderboardFriend board,
					 IDependencyProvider provider);
	}

	[Serializable]
	public abstract class PlayerScoreList :
		AbsObservableReadonlyList<PlayerLeaderboardEntry>, IPlayerScoreListFriend
	{
		protected IPlayerLeaderboardFriend _board;
		protected ILeaderboardsApi _api;
		protected IUserContext _ctx;
		protected CoroutineService _coroutineService;

		[SerializeField]
		protected int _viewSize = 10;

		/// <summary>
		/// The number of entries in the leaderboard view list
		/// </summary>
		public int viewSize => _viewSize;

		/// <summary>
		/// The leaderboard id of the view list
		/// </summary>
		public string boardId => _board.boardId;


		protected PlayerScoreList(IPlayerLeaderboardFriend board, IDependencyProvider provider) : base()
		{
			Hydrate(board, provider);
		}

		protected void Hydrate(IPlayerLeaderboardFriend board,
							IDependencyProvider provider)
		{
			SetupDataListener();
			_board = board;
			_api = provider.GetService<ILeaderboardsApi>();
			_ctx = provider.GetService<IUserContext>();
			_coroutineService = provider.GetService<CoroutineService>();
			OnHydrate();
		}

		protected virtual void OnHydrate()
		{

		}

		void IPlayerScoreListFriend.Hydrate(IPlayerLeaderboardFriend board, IDependencyProvider provider) =>
			Hydrate(board, provider);

		protected override async Promise PerformRefresh()
		{
			var info = await _board.GetAssignment(false);
			var p = new Promise();
			_coroutineService.StartNew("leaderboard-get-data", Routine());

			IEnumerator Routine()
			{
				yield return null; // delay 1 frame to allow for request configuration.
				var response = CreateRequest(info);
				response.Then(Apply).Merge(p);
			}
			await p;
		}

		protected abstract Promise<LeaderBoardViewResponse> CreateRequest(LeaderboardAssignmentInfo info);

		protected void Apply(LeaderBoardViewResponse result)
		{
			_board.SetSize(result.lb.boardSize);

			if (result.lb.rankgt.HasValue)
			{
				_board.SetCurrentScore(result.lb.rankgt);
			}

			var dict = new Dictionary<long, PlayerLeaderboardEntry>();
			foreach (var curr in this)
			{
				dict[curr.playerId] = curr;
			}

			var next = new List<PlayerLeaderboardEntry>();

			foreach (var rank in result.lb.rankings)
			{
				if (dict.TryGetValue(rank.gt, out var existing))
				{
					existing.score = rank.score;
					existing.rank = rank.rank;
					existing.stats = rank.stats;
					existing.Update();
					next.Add(existing);
				}
				else
				{
					var newScore = new PlayerLeaderboardEntry(rank);
					next.Add(newScore);
				}
			}

			SetData(next);
			_board.Save();
		}

		public bool TryUpdateEntryIfExists(long playerId, double score, out long rank)
		{
			// we know that the list is sorted best rank to worst rank
			List<PlayerLeaderboardEntry> clone = null;
			PlayerLeaderboardEntry entry = null;
			var playerStartIndex = -1;
			for (var i = 0; i < Count; i++)
			{
				if (playerId == this[i].playerId)
				{
					// we found the player in this list, so we can update it.
					playerStartIndex = i;
					break;
				}
			}

			rank = -1;
			if (playerStartIndex == -1)
			{
				// the player is not in the list, but maybe given their score, they should be?
				// if the score is greater than the last score, then the player will get inserted at the bottom
				if (Count > 0 && this[Count - 1].score < score)
				{
					clone = this.ToList();
					var last = clone[Count - 1];
					clone.RemoveAt(Count - 1);
					entry = new PlayerLeaderboardEntry
					{
						playerId = playerId,
						rank = last.rank,
						score = score
					};
					clone.Add(entry);
					playerStartIndex = Count - 1;
				}
				else
				{
					return false;
				}
			}


			/* there are only three cases
			   1. the player stays in the same rank, and we just update the score&stats
			   2. the player moves up in rank, and we need to downshift N players
			   3. the player moves down in rank, and we need to upshift N players

			   but importantly, this method never needs to resort the entire list
			*/

			entry ??= this[playerStartIndex];
			entry.score = score;
			// maybe we need to move the rank up towards the front
			var moveIndex = -1;
			for (var i = playerStartIndex - 1; i >= 0 && score > this[i].score; i--)
			{
				this[i].rank++;
				entry.rank--;
				// TODO: signal an update
				moveIndex = i;
				this[i].Update();
			}

			if (moveIndex == -1)
			{
				// maybe we need to move lower
				for (var i = playerStartIndex + 1; i < Count && score < this[i].score; i++)
				{
					this[i].rank--;
					entry.rank++;
					moveIndex = i;
					this[i].Update();
				}
			}

			entry.Update();
			rank = entry.rank;
			if (moveIndex == -1)
			{
				return true; // no move needed!
			}

			clone ??= this.ToList();
			clone.RemoveAt(playerStartIndex);
			clone.Insert(moveIndex, entry);
			SetData(clone);
			return true;
		}
	}


}
