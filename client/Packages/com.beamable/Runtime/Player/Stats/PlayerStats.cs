using Beamable.Api;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Stats;
using Beamable.Api.Stats;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Notifications;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Common.Player;
using Beamable.Common.Pooling;
using Beamable.Coroutines;
using Beamable.Serialization.SmallerJSON;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Beamable.Player
{
	/// <summary>
	/// A <see cref="PlayerStat"/> is a named value associated with a player.
	/// </summary>
	[Serializable]
	public class PlayerStat
	{

		/// <summary>
		/// The unique stat key. The stat key is only unique per stat domain.
		/// While it is possible for multiple stat domains to have the same key, it is not recommended.
		/// For example, there can be a stat domain for "client.public" stats, and a stat domain for "client.private", and each domain can
		/// have a stat key called "Alias". 
		/// </summary>
		public string Key { get; }

		/// <summary>
		/// The <see cref="PlayerStats"/> that this stat was created from.
		/// </summary>
		public PlayerStats Group { get; }

		/// <summary>
		/// The value of the stat
		/// </summary>
		public string Value { get; }

		public PlayerStat(string key, string value, PlayerStats group)
		{
			Key = key;
			Value = value;
			Group = group;
		}

		public static implicit operator string(PlayerStat self) => self.Value;

		/// <summary>
		/// Set the value of the stat for the current player.
		/// If multiple calls to this method are issued per frame, all set operations will be baked into one network operation.
		/// </summary>
		/// <param name="nextValue">
		/// The desired stat value. This will override the existing value.
		/// </param>
		/// <returns>
		/// A <see cref="Promise"/> representing the work. The promise won't complete until the stat value has been successfully set.
		/// </returns>
		public Promise Set(string nextValue) => Group.Set(Key, nextValue);

		public override string ToString() => Value;

		#region auto generated equality members

		protected bool Equals(PlayerStat other)
		{
			return Key == other.Key && Value == other.Value;
		}

		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj))
			{
				return false;
			}

			if (ReferenceEquals(this, obj))
			{
				return true;
			}

			if (obj.GetType() != this.GetType())
			{
				return false;
			}

			return Equals((PlayerStat)obj);
		}

		public override int GetHashCode()
		{
			unchecked
			{
				return ((Key != null ? Key.GetHashCode() : 0) * 397) ^ (Value != null ? Value.GetHashCode() : 0);
			}
		}
		#endregion

	}

	[Serializable]
	public class SerializableDictionaryStringToPlayerStat : SerializableDictionaryStringToSomething<PlayerStat> { }

	public interface IPlayerStatsFriend
	{
		Promise RequestPlayerUpdate(ReadonlyPlayerStatCollection collection);
		IDependencyProvider Provider { get; }
	}

	[Serializable]
	public abstract class PlayerStat<TVal> : DefaultObservable
	{
		[SerializeField]
		[HideInInspector]
		private string key;

		public string Key => key;
		
		public TVal value;

		public static implicit operator TVal(PlayerStat<TVal> stat) => stat.value;

		public event Action<TVal> OnDataUpdated;

		public PlayerStat()
		{
			OnUpdated += () => OnDataUpdated?.Invoke(value);
		}
		
		public void Set(TVal next)
		{
			value = next;
			TriggerUpdate();
		}

		public void Set(TVal next, string key)
		{
			value = next;
			this.key = key;
		}

		public override int GetBroadcastChecksum()
		{
			return BeamUtil.CombineHashCodes(key.GetHashCode(), value.GetHashCode());
		}
	}

	public class SerializableDictionaryStringToPlayerStatCollection<TStat, TVal> : SerializableDictionaryStringToSomething<TStat>
		where TStat : PlayerStat<TVal>
	{
		
	}
	
	[Serializable]
	public class SerializableDictionaryStringToPlayerStatCollection : SerializableDictionaryStringToSomething<ReadonlyPlayerStatCollection>
	{
		
	}

	public class PlayerStatTypedCollection<TStat, TVal, TDict, TInputDict> 
		: AbsObservableReadonlyDictionary<TStat, TDict>
		where TStat : PlayerStat<TVal>, new()
		where TDict : SerializableDictionaryStringToPlayerStatCollection<TStat, TVal>, new()
		where TInputDict : SerializableDictionary<string, TVal>
	{
		private readonly IRefreshable _refreshable;

		public PlayerStatTypedCollection(IRefreshable refreshable)
		{
			_refreshable = refreshable;
		}
		
		public void Set(TInputDict input)
		{
			var next = new TDict();

			foreach (var kvp in input)
			{
				if (this.TryGetValue(kvp.Key, out var existing))
				{
					existing.Set(kvp.Value);
					next[kvp.Key] = existing;
				}
				else
				{
					next[kvp.Key] = new TStat();
					next[kvp.Key].Set(kvp.Value, kvp.Key);
				}
			}
			
			SetData(next);
			TriggerUpdate();
		}

		public override int GetBroadcastChecksum()
		{
			var checksum = 0;
			foreach (var kvp in this)
			{
				checksum = BeamUtil.CombineHashCodes(checksum, kvp.Key.GetHashCode());
				checksum = BeamUtil.CombineHashCodes(checksum, kvp.Value.GetBroadcastChecksum());
			}

			return checksum;
		}

		protected override async Promise PerformRefresh()
		{
			await _refreshable.Refresh();
		}
	}

	[Serializable]
	public class PlayerStringStat : PlayerStat<string>
	{
		
	}
	
	[Serializable]
	public class PlayerLongStat : PlayerStat<long>
	{
		
	}

	[Serializable]
	public class PlayerStringStatDictionary 
		: SerializableDictionaryStringToPlayerStatCollection<PlayerStringStat, string>
	{
		
	}
	
	
	[Serializable]
	public class PlayerLongStatDictionary 
		: SerializableDictionaryStringToPlayerStatCollection<PlayerLongStat, long>
	{
		
	}

	[Serializable]
	public class PlayerStringStats : PlayerStatTypedCollection<PlayerStringStat, string, PlayerStringStatDictionary, SerializableDictionaryStringToString>
	{
		public PlayerStringStats(IRefreshable refreshable) : base(refreshable) { }
	}
	
	
	[Serializable]
	public class PlayerLongStats : PlayerStatTypedCollection<PlayerLongStat, long, PlayerLongStatDictionary, SerializableDictionaryStringToLong>
	{
		public PlayerLongStats(IRefreshable refreshable) : base(refreshable) { }
	}

	[Serializable]
	public class ReadonlyPlayerStatCollection : AbsRefreshableObservableRoot
	{
		protected readonly IPlayerStatsFriend _statsFriend;

		public PlayerStringStats stringStats;
		
		public PlayerLongStats longStats;
		
		[SerializeField]
		private long _playerId;
		
		[SerializeField]
		private PlayerStatType _type;

		[SerializeField]
		private string[] _listeningStats;

		public long PlayerId => _playerId;
		public PlayerStatType StatType => _type;
		
		public ReadonlyPlayerStatCollection(IPlayerStatsFriend statsFriend, PlayerStatType type, long playerId)
		{
			_statsFriend = statsFriend;
			_type = type;
			_playerId = playerId;

			stringStats = new PlayerStringStats(this);
			longStats = new PlayerLongStats(this);

			var notifications = _statsFriend.Provider.GetService<INotificationService>();
			notifications.Subscribe("stats.update", (raw) =>
			{
				Debug.Log("got data?");
				if (!(raw is ArrayDict data)) return;
				Debug.Log("Got array dict data!");
				
			});
		}

		public async Promise Listen(params string[] stats)
		{
			_listeningStats = stats;
			var api = _statsFriend.Provider.GetService<IStatsApi>();
			await api.PutSubscribe(new StatsSubscribeRequest
			{
				service = StatType.GetBeamableObjectId(PlayerId),
				subscriptions = _listeningStats
			});
		}
		
		public void Provide(BatchReadStatsPlayerResponse response)
		{
			stringStats.Set(response.stringStats);
			longStats.Set(response.longStats);
		}

		protected override async Promise PerformRefresh()
		{
			await _statsFriend.RequestPlayerUpdate(this);
		}

		public override int GetBroadcastChecksum()
		{
			return BeamUtil.CombineHashCodes(stringStats.GetBroadcastChecksum(), longStats.GetBroadcastChecksum());
		}
	}

	[Serializable]
	public class PlayerStatCollection : AbsRefreshableObservableRoot
	{
		private readonly IPlayerStatsFriend _friend;
		private readonly ReadonlyPlayerStatCollection _collection;
		private StatUpdateTypedRequest _pendingRequest = new StatUpdateTypedRequest();
		private Promise _inflightWrite;
		
		public PlayerStringStats stringStats;
		
		public PlayerLongStats longStats;
		
		public long PlayerId => _collection.PlayerId;
		public PlayerStatType StatType => _collection.StatType;

		public PlayerStatCollection(IPlayerStatsFriend friend, ReadonlyPlayerStatCollection collection)
		{
			_friend = friend;
			_collection = collection;
			stringStats = _collection.stringStats;
			longStats = _collection.longStats;

		}

		public async Promise SetString(string key, string value)
		{
			if (!_pendingRequest.setStrings.HasValue)
			{
				_pendingRequest.setStrings.Set(new MapOfString());
			}

			_pendingRequest.setStrings.Value[key] = value;
			await WaitForWrite();
		}

		public async Promise SetString(Dictionary<string, string> stats)
		{
			if (!_pendingRequest.setStrings.HasValue)
			{
				_pendingRequest.setStrings.Set(new MapOfString());
			}

			foreach (var kvp in stats)
			{
				_pendingRequest.setStrings.Value[kvp.Key] = kvp.Value;
			}
			await WaitForWrite();
		}
		
		
		public async Promise SetLong(string key, long value)
		{
			if (!_pendingRequest.setLongs.HasValue)
			{
				_pendingRequest.setLongs.Set(new MapOfLong());
			}

			_pendingRequest.setLongs.Value[key] = value;
			await WaitForWrite();
		}
		
		public async Promise SetLong(Dictionary<string, long> longStats)
		{
			if (!_pendingRequest.setLongs.HasValue)
			{
				_pendingRequest.setLongs.Set(new MapOfLong());
			}

			foreach (var kvp in longStats)
			{
				_pendingRequest.setLongs.Value[kvp.Key] = kvp.Value;
			}
			await WaitForWrite();
		}

		public async Promise IncrementLong(string key, long increment)
		{
			if (!_pendingRequest.setLongs.HasValue)
			{
				_pendingRequest.setLongs.Set(new MapOfLong());
			}

			_pendingRequest.addLongs.Value[key] += increment;
			await WaitForWrite();
		}
		
		
		public async Promise IncrementLong(Dictionary<string, long> increments)
		{
			if (!_pendingRequest.setLongs.HasValue)
			{
				_pendingRequest.setLongs.Set(new MapOfLong());
			}

			foreach (var kvp in increments)
			{
				_pendingRequest.addLongs.Value[kvp.Key] += kvp.Value;
			}
			await WaitForWrite();
		}
		
		async Promise WaitForWrite()
		{
			var debouncer = _friend.Provider.GetService<Debouncer>();
			await (_inflightWrite = debouncer.SetTimeout(DoWrite));
		}
		
		/// <summary>
		/// A <see cref="Promise"/> that completes when calls to <see cref="UpdateDelayed"/> are completed.
		/// </summary>
		public async Promise WaitForSet()
		{
			if (_inflightWrite != null)
			{
				await _inflightWrite;
			}
		}

		async Promise DoWrite()
		{
			var api = _friend.Provider.GetService<IStatsApi>();
			var request = api.Write(true, PlayerId, _pendingRequest);

			_pendingRequest = new StatUpdateTypedRequest();
			await request;
			await Refresh();
		}

		protected override async Promise PerformRefresh()
		{
			await _collection.Refresh();
		}

		public override int GetBroadcastChecksum()
		{
			return _collection.GetBroadcastChecksum();
		}
	}


	[Serializable]
	public class PlayerStats2 : IPlayerStatsFriend
	{
		private readonly IDependencyProvider _provider;
		private readonly IUserContext _userContext;

		public SerializableDictionaryStringToPlayerStatCollection playerStatTable =
			new SerializableDictionaryStringToPlayerStatCollection();

		private PlayerStatCollection _myPublicStats;
		
		private HashSet<ReadonlyPlayerStatCollection> _playersToRefresh = new HashSet<ReadonlyPlayerStatCollection>();
		private Promise _syncPromise;
		
		public PlayerStats2(IDependencyProvider provider)
		{
			_provider = provider;
			
			_userContext = _provider.GetService<IUserContext>();
		}

		public PlayerStatCollection MyPublicStats
		{
			get
			{
				if (_myPublicStats == null)
				{
					var readonlyStats = GetStatCollection(PlayerStatType.PUBLIC, _userContext.UserId);

					_myPublicStats = new PlayerStatCollection(this, readonlyStats);
					
				}

				return _myPublicStats;
			}
		} 
		public ReadonlyPlayerStatCollection MyPrivateStats => GetStatCollection(PlayerStatType.PRIVATE, _userContext.UserId);
		public ReadonlyPlayerStatCollection MySecuredStats => GetStatCollection(PlayerStatType.SECURE, _userContext.UserId);
		
		public ReadonlyPlayerStatCollection ForPlayer(long playerId) =>
			GetStatCollection(PlayerStatType.PUBLIC, playerId);

		IDependencyProvider IPlayerStatsFriend.Provider => _provider;
		
		private ReadonlyPlayerStatCollection GetStatCollection(PlayerStatType type, long playerId)
		{
			if (!playerStatTable.TryGetValue(type.GetBeamableObjectId(playerId), out var stats))
			{
				playerStatTable[type.GetBeamableObjectId(playerId)] = stats = new ReadonlyPlayerStatCollection(this, type, playerId);
				var _ = stats.Refresh();
			}

			return stats;
		}


		Promise IPlayerStatsFriend.RequestPlayerUpdate(ReadonlyPlayerStatCollection collection) =>
			RequestPlayerUpdate(collection);
		async Promise RequestPlayerUpdate(ReadonlyPlayerStatCollection collection)
		{
			_playersToRefresh.Add(collection);

			await _provider.GetService<Debouncer>().SetTimeout(LoadAllPlayers);
			
			// if (_syncPromise == null)
			// {
			// 	_syncPromise = LoadAllPlayers(); // TODO: Delay a frame
			// }
			//
			// await _syncPromise;
		}


		
		async Promise LoadAllPlayers()
		{
			var api = _provider.GetService<IStatsApi>();
			var copy = new HashSet<ReadonlyPlayerStatCollection>(_playersToRefresh);

			var splitGroups = SplitIntoTypeGroups(copy);
			var promises = new List<Promise<BatchReadStatsResponse>>();
			
			foreach (var group in splitGroups)
			{
				var data = GetGroupData(api, group.Value);
				promises.Add(data);
			}

			var results = await Promise.Sequence(promises);
			for (var i = 0; i < splitGroups.Count; i++)
			{
				var type = splitGroups[i].Key;
				var statData = results[i];

				foreach (var kvp in statData.playerIdToStats)
				{
					var playerId = kvp.Key;
					var objectId = type.GetBeamableObjectId(playerId);
					if (playerStatTable.TryGetValue(objectId, out var collection))
					{
						collection.Provide(kvp.Value);
					}
				}
			}
			
		}
		
		
		
		static async Promise<BatchReadStatsResponse> GetGroupData(IStatsApi api, HashSet<ReadonlyPlayerStatCollection> copy)
		{
			using var sb = StringBuilderPool.StaticPool.Spawn();
			foreach (var collection in copy)
			{
				sb.Builder.Append(collection.StatType.GetBeamableObjectId(collection.PlayerId));
				sb.Builder.Append(",");
			}
			var query = sb.Builder.ToString();
			var result = await api.GetClientBatch(query);

			return result;
		}
		
		static List<KeyValuePair<PlayerStatType, HashSet<ReadonlyPlayerStatCollection>>> SplitIntoTypeGroups(HashSet<ReadonlyPlayerStatCollection> collections)
		{
			var dict = new Dictionary<PlayerStatType, HashSet<ReadonlyPlayerStatCollection>>();
			foreach (var collection in collections)
			{
				if (!dict.TryGetValue(collection.StatType, out var list))
				{
					dict[collection.StatType] = list = new HashSet<ReadonlyPlayerStatCollection>();
				}

				list.Add(collection);
			}

			return dict.ToList();
		}
		
	}
	
	
	[Serializable]
	public class PlayerStats : AbsObservableReadonlyDictionary<PlayerStat, SerializableDictionaryStringToPlayerStat>, IBeamableDisposable
	{
		private readonly IPlatformService _platform;
		private readonly IUserContext _userContext;
		private readonly StatsService _statService;
		private readonly ISdkEventService _eventService;
		private readonly CoroutineService _coroutineService;

		private readonly SdkEventConsumer _consumer;
		private readonly Coroutine _updateRoutine;

		private Promise _commitSync = new Promise();
		private Dictionary<string, string> _pendingUpdates = new Dictionary<string, string>();


		public PlayerStats(IPlatformService platform, IUserContext userContext, StatsService statService, ISdkEventService eventService, CoroutineService coroutineService)
		{
			_platform = platform;
			_userContext = userContext;
			_statService = statService;
			_eventService = eventService;
			_coroutineService = coroutineService;

			_updateRoutine = _coroutineService.StartNew("playerStatLoop", Update());
			_consumer = _eventService.Register(nameof(PlayerStats), HandleEvent);

			var _ = Refresh(); // automatically start.
			IsInitialized = true;
		}

		private IEnumerator Update()
		{
			while (true)
			{
				yield return null;
				if (_pendingUpdates.Count > 0)
				{
					_eventService.Add(new SdkEvent(nameof(PlayerStats), "commit"));
				}
			}
		}

		private async Promise HandleEvent(SdkEvent evt)
		{
			switch (evt.Event)
			{
				case "set":
					_pendingUpdates[evt.Args[0]] = evt.Args[1];
					await _commitSync;
					break;

				case "commit":
					if (_pendingUpdates.Count == 0) return;

					var network = _statService.SetStats("public", _pendingUpdates);
					_pendingUpdates.Clear();
					await network;
					await Refresh();
					_commitSync?.CompleteSuccess();
					_commitSync = new Promise();

					break;
			}
		}

		protected override async Promise PerformRefresh()
		{
			await _platform.OnReady;

			var stats = await _statService.GetStats("client", "public", "player", _userContext.UserId);

			var nextData = new SerializableDictionaryStringToPlayerStat();
			foreach (var kvp in stats)
			{
				nextData.Add(kvp.Key, new PlayerStat(kvp.Key, kvp.Value, this));
			}

			SetData(nextData);
		}

		/// <summary>
		/// Set the value of a <see cref="PlayerStat"/>.
		/// If multiple calls to this method are issued per frame, all set operations will be baked into one network operation.
		/// </summary>
		/// <param name="key">The stat key</param>
		/// <param name="value">The desired stat value. This will override the existing value.</param>
		/// <returns>
		/// A <see cref="Promise"/> representing the work. The promise won't complete until the set is complete.
		/// </returns>
		public Promise Set(string key, string value)
		{
			return _eventService.Add(new SdkEvent(nameof(PlayerStats), "set", key, value));
		}

		public Promise OnDispose()
		{
			_coroutineService.StopCoroutine(_updateRoutine);
			_eventService.Unregister(_consumer);
			return Promise.Success;
		}

		public void GetOtherPlayer()
		{
			
		}
	}
}
