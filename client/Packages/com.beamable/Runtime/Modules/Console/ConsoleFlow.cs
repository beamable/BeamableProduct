using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Text;using Beamable.ConsoleCommands;using Beamable.InputManagerIntegration;using Beamable.Service;using UnityEngine;using UnityEngine.UI;namespace Beamable.Console{    [HelpURL(BeamableConstants.URL_FEATURE_ADMIN_FLOW)]    public class ConsoleFlow : MonoBehaviour    {        public static ConsoleFlow Instance;        private static readonly Dictionary<string, ConsoleCommand> ConsoleCommandsByName =            new Dictionary<string, ConsoleCommand>();        public Canvas canvas;        public Text txtOutput;        public InputField txtInput;        public Text txtAutoCompleteSuggestion;        private bool _isInitialized;        private bool _showNextTick;        private bool _isActive;        private int _fingerCount;        private bool _waitForRelease;        private Vector2 _averagePositionStart;        private IBeamableAPI _beamable;        private TextAutoCompleter _textAutoCompleter;#if UNITY_ANDROID // webGL doesn't support the touchscreen keyboard.        private bool _isMobileKeyboardOpened = false;#endif        [SerializeField] private RectTransform consolePortrait;        [SerializeField] private RectTransform consoleLandscape;        [Space] [Header("Text auto complete settings")] [SerializeField]        private KeyCode previousSuggestionKey = KeyCode.UpArrow;        [SerializeField] private KeyCode nextSuggestionKey = KeyCode.DownArrow;        [SerializeField] private KeyCode acceptSuggestionKey = KeyCode.Tab;        private void Start()        {            if (Instance)            {                Destroy(gameObject);                Instance.InitializeConsole();                return;            }            Instance = this;            DontDestroyOnLoad(gameObject);            InitializeConsole();        }        private void Awake()        {            HideConsole();#if UNITY_ANDROID || UNITY_IOS            StartCoroutine(CheckMobileKeyboardState());#endif        }        private void Update()        {            if (!_isInitialized) return;            if (_showNextTick)            {                DoShow();                _showNextTick = false;            }            if (ConsoleShouldToggle() && ConsoleIsEnabled()) ToggleConsole();#if UNITY_EDITOR            if (Input.GetKeyDown(previousSuggestionKey))                _textAutoCompleter.PreviousCommand();            else if (Input.GetKeyDown(nextSuggestionKey))                _textAutoCompleter.NextCommand();            else if (Input.GetKeyDown(acceptSuggestionKey)) _textAutoCompleter.AcceptSuggestedCommand();#endif        }        private async void InitializeConsole()        {            _isInitialized = false;            txtInput.interactable = false;            // We want to ensure that we create the instance of the Beamable API if the console is the only thing            // in the scene.            _beamable = await API.Instance;            _textAutoCompleter = new TextAutoCompleter(ref txtInput, ref txtAutoCompleteSuggestion);            ServiceManager.ProvideWithDefaultContainer(new BeamableConsole());            var console = ServiceManager.Resolve<BeamableConsole>();            console.OnLog += Log;            console.OnExecute += ExecuteCommand;            console.OnCommandRegistered += RegisterCommand;            try            {                console.LoadCommands();            }            catch (Exception)            {                Debug.LogError("Unable to load console commands.");            }            txtInput.onValueChanged.AddListener(_textAutoCompleter.FindMatchingCommands);            txtInput.onEndEdit.AddListener(evt =>            {                if (txtInput.text.Length > 0) Execute(txtInput.text);            });            txtInput.interactable = true;            if (canvas.isActiveAndEnabled) txtInput.Select();            _isInitialized = true;            Log("Console ready");        }        /// <summary>        ///     Console should toggle if the toggle key was pressed OR a 3 finger swipe occurred on device.        /// </summary>        private bool ConsoleShouldToggle()        {            var shouldToggle = BeamableInput.IsActionTriggered(ConsoleConfiguration.Instance.ToggleAction);#if !ENABLE_INPUT_SYSTEM || ENABLE_LEGACY_INPUT_MANAGER            if (shouldToggle)                // Early out if we already know we must toggle.                return true;            var fingerCount = 0;            var averagePosition = Vector2.zero;            var touchCount = Input.touchCount;            for (var i = 0; i < touchCount; ++i)            {                var touch = Input.GetTouch(i);                if (touch.phase != TouchPhase.Ended && touch.phase != TouchPhase.Canceled)                {                    fingerCount++;                    averagePosition += touch.position;                }            }            switch (fingerCount)            {                case 3 when !_waitForRelease:                {                    averagePosition /= 3;                    if (_fingerCount != 3)                    {                        _averagePositionStart = averagePosition;                    }                    else                    {                        if ((_averagePositionStart - averagePosition).magnitude > 20.0f)                        {                            _waitForRelease = true;                            shouldToggle = true;                        }                    }                    break;                }                case 0 when _waitForRelease:                    _waitForRelease = false;                    break;            }            _fingerCount = fingerCount;#endif            return shouldToggle;        }        private bool ConsoleIsEnabled()        {#if UNITY_EDITOR            return true;#else            return ConsoleConfiguration.Instance.ForceEnabled || _beamable.User.HasScope("cli:console");#endif        }        private void Execute(string txt)        {            if (!_isActive) return;            var parts = txt.Split(' ');            txtInput.text = "";            txtInput.Select();            txtInput.ActivateInputField();            if (parts.Length == 0) return;            var args = new string[parts.Length - 1];            for (var i = 1; i < parts.Length; i++) args[i - 1] = parts[i];            Log(ServiceManager.Resolve<BeamableConsole>().Execute(parts[0], args));        }        private static void RegisterCommand(BeamableConsoleCommandAttribute command, ConsoleCommandCallback callback)        {            foreach (var name in command.Names)            {                var cmd = new ConsoleCommand { Command = command, Callback = callback };                ConsoleCommandsByName[name.ToLower()] = cmd;            }        }        private string ExecuteCommand(string command, string[] args)        {            if (command == "help") return OnHelp(args);            if (ConsoleCommandsByName.TryGetValue(command.ToLower(), out var cmd))            {                var echoLine = "> " + command;                foreach (var arg in args) echoLine += " " + arg;                Log(echoLine);                return cmd.Callback(args);            }            return "Unknown command";        }        private string OnHelp(params string[] args)        {            if (args.Length == 0)            {                var builder = new StringBuilder();                builder.AppendLine("Listing commands:");                var uniqueCommands = new HashSet<ConsoleCommand>();                var commands = ConsoleCommandsByName.Values;                foreach (var command in commands)                {                    if (uniqueCommands.Contains(command)) continue;                    uniqueCommands.Add(command);                    var line = $"{command.Command.Usage} - {command.Command.Description}\n";                    Debug.Log(line);                    builder.Append(line);                }                return builder.ToString();            }            var commandToGetHelpAbout = args[0].ToLower();            if (ConsoleCommandsByName.TryGetValue(commandToGetHelpAbout, out var found))                return                    $"Help information about {commandToGetHelpAbout}\n\tDescription: {found.Command.Description}\n\tUsage: {found.Command.Usage}";            return $"Cannot find help information about {commandToGetHelpAbout}. Are you sure it is a valid command?";        }        public void Log(string line)        {            Debug.Log(line);            txtOutput.text += Environment.NewLine + line;        }        public void ToggleConsole()        {            if (_isActive) HideConsole();            else ShowConsole();        }        public void HideConsole()        {            _isActive = false;            txtInput.DeactivateInputField();            txtInput.text = "";            canvas.enabled = false;        }        public void ShowConsole()        {            if (!enabled)            {                Debug.LogWarning("Cannot open the console, because it isn't enabled");                return;            }            _showNextTick = true;        }        private void DoShow()        {            _isActive = true;            canvas.enabled = true;            txtInput.text = "";            txtInput.Select();            txtInput.ActivateInputField();        }        private struct ConsoleCommand        {            public BeamableConsoleCommandAttribute Command;            public ConsoleCommandCallback Callback;        }        private WaitForSeconds _mobileCheckWaiter = new WaitForSeconds(0.1f);        private WaitForSeconds _keyboardOpenWaiter = new WaitForSeconds(0.5f);        private IEnumerator CheckMobileKeyboardState()        {#if UNITY_ANDROID // webGL doesn't support the touchscreen keyboard.            while (true)            {                if (TouchScreenKeyboard.visible && !_isMobileKeyboardOpened)                {                    yield return _keyboardOpenWaiter;                    var keyboardHeight = GetKeyboardHeight() * Screen.height + 225;                    consolePortrait.sizeDelta = new Vector2(0, -keyboardHeight);                    consoleLandscape.sizeDelta = new Vector2(0, -keyboardHeight);                    _isMobileKeyboardOpened = true;                }                else if (!TouchScreenKeyboard.visible && _isMobileKeyboardOpened)                {                    consolePortrait.sizeDelta = Vector2.zero;                    consoleLandscape.sizeDelta = Vector2.zero;                    _isMobileKeyboardOpened = false;                }                yield return _mobileCheckWaiter;            }#else            yield return null;#endif        }        private float GetKeyboardHeight()        {            if (Application.isEditor) return txtInput.isFocused ? 0.25f : 0;#if UNITY_ANDROID            using (AndroidJavaClass UnityClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))            {                if (!txtInput.isFocused)                {                    return 0f;                }                var unityPlayer = UnityClass.GetStatic<AndroidJavaObject>("currentActivity")                    .Get<AndroidJavaObject>("mUnityPlayer");                var view = unityPlayer.Call<AndroidJavaObject>("getView");                var dialog = unityPlayer.Get<AndroidJavaObject>("mSoftInputDialog");                var decorHeight = 0;                if (view != null && dialog != null)                {                    if (!txtInput.shouldHideMobileInput)                    {                        var decorView = dialog.Call<AndroidJavaObject>("getWindow")                            .Call<AndroidJavaObject>("getDecorView");                        if (decorView != null)                            decorHeight = decorView.Call<int>("getHeight");                    }                    using (AndroidJavaObject rect = new AndroidJavaObject("android.graphics.Rect"))                    {                        view.Call("getWindowVisibleDisplayFrame", rect);                        return (float) (Screen.height - rect.Call<int>("height") + decorHeight) / Screen.height;                    }                }                return 0.25f;            }#elif UNITY_IOS                return TouchScreenKeyboard.area.height / Screen.height;#else            return 0.0f;#endif        }        private class TextAutoCompleter        {            private int _commandIndex;            private string _currentSuggestedCommand = string.Empty;            private List<string> _foundCommands = new List<string>();            private readonly InputField _inputField;            private string _previousInput = string.Empty;            private readonly Text _textSuggestion;            public TextAutoCompleter(ref InputField inputField, ref Text textSuggestion)            {                _inputField = inputField;                _textSuggestion = textSuggestion;            }            public void FindMatchingCommands(string input)            {                if (string.IsNullOrWhiteSpace(input))                {                    _textSuggestion.text = string.Empty;                    _previousInput = string.Empty;                    return;                }                _foundCommands = input.Length < _previousInput.Length || _previousInput.Length == 0                    ? ConsoleCommandsByName.Keys.Where(x => x.StartsWith(input)).ToList()                    : _foundCommands.Where(x => x.StartsWith(input)).ToList();                _commandIndex = 0;                _previousInput = input;                _currentSuggestedCommand = _foundCommands.Count > 0 ? _foundCommands[0] : string.Empty;                SuggestCommand();            }            private void SuggestCommand()            {                if (string.IsNullOrWhiteSpace(_currentSuggestedCommand))                {                    _textSuggestion.text = string.Empty;                    return;                }                _textSuggestion.text = _currentSuggestedCommand;                _inputField.caretPosition = _currentSuggestedCommand.Length;            }            public void AcceptSuggestedCommand()            {                _inputField.text = _currentSuggestedCommand;                _inputField.caretPosition = _currentSuggestedCommand.Length;                _textSuggestion.text = string.Empty;            }            public void PreviousCommand()            {                _commandIndex--;                if (_commandIndex < 0)                {                    _inputField.caretPosition = _inputField.text.Length;                    _commandIndex = 0;                    return;                }                _currentSuggestedCommand = _foundCommands[_commandIndex];                SuggestCommand();            }            public void NextCommand()            {                _commandIndex++;                if (_commandIndex > _foundCommands.Count - 1)                {                    _inputField.caretPosition = _inputField.text.Length;                    _commandIndex = _foundCommands.Count - 1;                    return;                }                _currentSuggestedCommand = _foundCommands[_commandIndex];                SuggestCommand();            }        }    }}