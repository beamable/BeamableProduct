using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Runtime;
using Beamable.Server;
using Beamable.Server.Editor;

namespace beamable.tooling.common.Microservice;

public static class FederatedComponentGenerator
{
	public static FederationType GetFederationType(string federationName)
	{
		switch (federationName)
		{
			case "IFederatedLogin":
				return FederationType.IFederatedLogin;
			case "IFederatedInventory":
				return FederationType.IFederatedInventory;
			case "IFederatedCommerce":
				return FederationType.IFederatedCommerce;
			case "IFederatedGameServer":
				return FederationType.IFederatedGameServer;
			case "IFederatedPlayerInit":
				return FederationType.IFederatedPlayerInit;
			default:
				throw new InvalidOperationException(
					$"the given federation name=[{federationName}] is not mapped to a federation enum value");
		}
	}

	public static List<FederationComponent> FindFederatedComponents(StartupContext startupContext)
	{
		var components = new List<FederationComponent>();
		foreach (var route in startupContext.routeSources)
		{
			var serviceType = route.InstanceType;
			var interfaces = serviceType.GetInterfaces();
			foreach (var it in interfaces)
			{
				// Skip non-generic types while we look for IFederation-derived implementations
				if (!it.IsGenericType)
					continue;

				// Make sure we found an IFederation interface
				if (!it.GetGenericTypeDefinition().GetInterfaces().Contains(typeof(IFederation)))
					continue;

				// Get the cleaned-up type name (IFederatedGameServer`1 => IFederatedGameServer) 
				var typeName = it.GetGenericTypeDefinition().Name;
				typeName = typeName.Substring(0, typeName.IndexOf("`", StringComparison.Ordinal));

				// Get the IFederationId 
				var federatedType = it.GetGenericArguments()[0];
				if (Activator.CreateInstance(federatedType) is IFederationId identity)
				{
					var component = new FederationComponent
					{
						identity = identity,
						interfaceType = it,
						typeName = typeName
					};
					components.Add(component);
				}
			}

		}

		return components;
	}
	
	public static List<FederationComponent> FindFederatedComponents(Type serviceType)
	{
		var components = new List<FederationComponent>();
		var interfaces = serviceType.GetInterfaces();
		foreach (var it in interfaces)
		{
			// Skip non-generic types while we look for IFederation-derived implementations
			if (!it.IsGenericType) 
				continue;

			// Make sure we found an IFederation interface
			if (!it.GetGenericTypeDefinition().GetInterfaces().Contains(typeof(IFederation)))
				continue;

			// Get the cleaned-up type name (IFederatedGameServer`1 => IFederatedGameServer) 
			var typeName = it.GetGenericTypeDefinition().Name;
			typeName = typeName.Substring(0, typeName.IndexOf("`", StringComparison.Ordinal));
			
			// Get the IFederationId 
			var federatedType = it.GetGenericArguments()[0];
			if (Activator.CreateInstance(federatedType) is IFederationId identity)
			{
				var component = new FederationComponent
				{
					identity = identity,
					interfaceType = it,
					typeName = typeName
				};
				components.Add(component);
			}
		}

		return components;
	}
}
