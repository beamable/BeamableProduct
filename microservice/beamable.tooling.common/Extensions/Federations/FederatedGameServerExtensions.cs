using Beamable.Api.Autogenerated.Lobby;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Dependencies;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Beamable.Server
{
	public static class FederatedGameServerExtensions
	{
		public const string RESERVED_LOBBY_FROM_EDITOR_PLAY_MODE_PROPERTY = "__beam_lobby_from_editor_play_mode_settings__";

		public const string RESERVED_GAME_SERVER_READY_PROPERTY = "__beam_game_server_ready_lobby__";
		public const string RESERVED_GAME_SERVER_URL = "__beam_game_server_url_lobby__";
		public const string RESERVED_GAME_SERVER_PORT = "__beam_game_server_port_lobby__";

		public const string RESERVED_DEDICATED_SERVER_PROPERTY = "__beam_dedicated_server_lobby__";
	

		public static IDisposable AddToTelemetry(this Lobby lobby, LobbyPlayer p = null)
		{
			var scope = new TelemetryAttributeCollection();
			scope.Add(TelemetryAttribute.String("lobbyId", "The id of the Beamable Lobby over which we are working.", lobby.lobbyId.Value, TelemetryImportance.ESSENTIAL));
			if (p != null) scope.Add(TelemetryAttribute.String("lobbyPlayerId", "The GamerTag of the player in the lobby over which we are working.", p.playerId.Value, TelemetryImportance.ESSENTIAL));
			return Log.Default.BeginScope(scope);
		}

		public static bool IsLobbyFromEditorPlayMode(this Lobby lobby) => lobby.data.TryGet(out var m) && m.ContainsKey(RESERVED_LOBBY_FROM_EDITOR_PLAY_MODE_PROPERTY);

		public static void SetConnectionString(this ServerInfo info, string url, string port)
		{
			info.SetConnectionUrl(url);
			info.SetConnectionPort(port);
		}

		public static void SetConnectionUrl(this ServerInfo info, string url) => info.globalData[RESERVED_GAME_SERVER_URL] = url;
		public static void SetConnectionPort(this ServerInfo info, string port) => info.globalData[RESERVED_GAME_SERVER_PORT] = port;

		public static String GetConnectionUrl(this ServerInfo info) => info.globalData[RESERVED_GAME_SERVER_URL];
		
		public static String GetConnectionPort(this ServerInfo info) => info.globalData[RESERVED_GAME_SERVER_URL];
		
		// Override the properties in a server info using a prioritized one
		public static void PrioritizedMerge(this ServerInfo info, IEnumerable<ServerInfo> prioritizedInfos)
		{
			foreach (ServerInfo sortedInfo in prioritizedInfos)
			{
				// Override global properties in priority
				foreach (var kvp in sortedInfo.globalData)
				{
					info.globalData[kvp.Key] = kvp.Value;
				}

				// Override per-player properties in priority
				foreach (var kvpPlayer in sortedInfo.playerData)
				{
					foreach (var kvp in kvpPlayer.Value)
					{
						if (!info.playerData.TryAdd(kvpPlayer.Key, new Dictionary<string, string>() { { kvp.Key, kvp.Value } }))
						{
							info.playerData[kvpPlayer.Key][kvp.Key] = kvp.Value;
						}
					}
				}
			}
		}
		/// <summary>
		/// Utility function that allows you to do parallel operations for the player/global data when you are creating the server.
		/// </summary>
		/// <param name="lobby"></param>
		/// <param name="returningInfo"></param>
		/// <param name="provisionServer">In this function you should request you provision server asking for a new instance.</param>
		/// <param name="globalFunc">A function that you can use to modify/add any key pair to lobby global data</param>
		/// <param name="perPlayerFunc">A function that you can use to add any key pair to the player lobby data</param>
		public static async Promise PrepareLobbyAsDedicatedServer(this Lobby lobby,
			ServerInfo returningInfo,
			Func<Lobby, Task<ServerInfo>> provisionServer,
			Func<Lobby, Task<ServerInfo>> globalFunc = null,
			Func<LobbyPlayer, Task<Dictionary<string, string>>> perPlayerFunc = null)
		{
			var players = lobby.players.GetOrThrow();

			var allPromises = new List<Task<ServerInfo>>();
			allPromises.Add(RunGlobalFunc());
			allPromises.AddRange(players.Select(RunPlayersFunc));
			allPromises.Add(SetAsGameServer());
			
			// Let's merge all the infos into the returning info
			var allInfos = await Task.WhenAll(allPromises);
			returningInfo.PrioritizedMerge(allInfos);
			return;

			// Adding the flat to lobby global data, so game server knows it is a dedicated server.
			async Task<ServerInfo> SetAsGameServer()
			{
				using var _ = lobby.AddToTelemetry();
				var serverInfo = await provisionServer(lobby);
				serverInfo.globalData[RESERVED_DEDICATED_SERVER_PROPERTY] = "true";
				return serverInfo;
			}
			
			// The global function will make updates in the lobby global data parallel to the updates in the RunPlayersFunc
			async Task<ServerInfo> RunGlobalFunc()
			{
				using var _ = lobby.AddToTelemetry();
				var info = await (globalFunc?.Invoke(lobby) ?? Task.FromResult(new ServerInfo()));
				return info;
			}

			// the RunPlayersFunc will be used to edit per player lobby data in parallel to the RunGlobalFunc
			async Task<ServerInfo> RunPlayersFunc(LobbyPlayer p)
			{
				using var _ = lobby.AddToTelemetry(p);
				var dict = await (perPlayerFunc?.Invoke(p) ?? Task.FromResult(new Dictionary<string, string>()));
				return new ServerInfo() { playerData = new Dictionary<string, Dictionary<string, string>>() { { p.playerId.Value, dict } } };
			}
		}
		
		/// <summary>
		/// Wait until the lobby receive the flag ready from the game server.
		/// </summary>
		/// <param name="lobby"></param>
		/// <param name="beamLobbyApi"></param>
		/// <param name="millisecondsDelay"></param>
		public static async Promise WaitForGameServerReady(this Lobby lobby, IBeamLobbyApi beamLobbyApi, int millisecondsDelay = 500)
		{
			var lobbyApi = beamLobbyApi;
			while (lobby.data.TryGet(out var d) && d.ContainsKey(RESERVED_GAME_SERVER_READY_PROPERTY))
			{
				var id = lobby.lobbyId.GetOrThrow();
				var guid = Guid.Parse(id);
				lobby = await lobbyApi.Get(guid);
				await Task.Delay(millisecondsDelay);
			}
		}
	}
}
