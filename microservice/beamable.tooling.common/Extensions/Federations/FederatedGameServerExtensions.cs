using Beamable.Api.Autogenerated.Lobby;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api.Stats;
using Beamable.Common.Dependencies;
using Beamable.Server.Api.Stats;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;

namespace Beamable.Server
{
	public static class FederatedGameServerExtensions
	{
		public static class StatsConstants
		{
			public const string StatRegionPingKey = "beam.region.pings";
		}
		public const string RESERVED_LOBBY_FROM_EDITOR_PLAY_MODE_PROPERTY = "__beam_lobby_from_editor_play_mode_settings__";

		public const string RESERVED_GAME_SERVER_READY_PROPERTY = "__beam_game_server_ready_lobby__";
		public const string RESERVED_GAME_SERVER_URL = "__beam_game_server_url_lobby__";
		public const string RESERVED_GAME_SERVER_PORT = "__beam_game_server_port_lobby__";

		public const string RESERVED_DEDICATED_SERVER_PROPERTY = "__beam_dedicated_server_lobby__";
	

		public static IDisposable AddToTelemetry(this Lobby lobby, LobbyPlayer p = null)
		{
			var scope = new TelemetryAttributeCollection();
			scope.Add(TelemetryAttribute.String("lobbyId", "The id of the Beamable Lobby over which we are working.", lobby.lobbyId.Value, TelemetryImportance.ESSENTIAL));
			if (p != null) scope.Add(TelemetryAttribute.String("lobbyPlayerId", "The GamerTag of the player in the lobby over which we are working.", p.playerId.Value, TelemetryImportance.ESSENTIAL));
			return Log.Default.BeginScope(scope);
		}

		public static bool IsLobbyFromEditorPlayMode(this Lobby lobby) => lobby.data.TryGet(out var m) && m.ContainsKey(RESERVED_LOBBY_FROM_EDITOR_PLAY_MODE_PROPERTY);

		public static void SetConnectionString(this ServerInfo info, string url, string port)
		{
			info.SetConnectionUrl(url);
			info.SetConnectionPort(port);
		}

		public static void SetConnectionUrl(this ServerInfo info, string url) => info.globalData[RESERVED_GAME_SERVER_URL] = url;
		public static void SetConnectionPort(this ServerInfo info, string port) => info.globalData[RESERVED_GAME_SERVER_PORT] = port;

		public static string GetConnectionUrl(this ServerInfo info) => info.globalData[RESERVED_GAME_SERVER_URL];
		public static string GetConnectionPort(this ServerInfo info) => info.globalData[RESERVED_GAME_SERVER_PORT];

		/// <summary>
		/// Override the properties in a server info using a prioritized one. This ONLY affects <see cref="ServerInfo.globalData"/> and <see cref="ServerInfo.playerData"/>.
		/// </summary>
		public static void PrioritizedMerge(this ServerInfo info, IEnumerable<ServerInfo> prioritizedInfos)
		{
			foreach (ServerInfo sortedInfo in prioritizedInfos)
			{
				// Override global properties in priority
				foreach (var kvp in sortedInfo.globalData)
				{
					info.globalData[kvp.Key] = kvp.Value;
				}

				// Override per-player properties in priority
				foreach (var kvpPlayer in sortedInfo.playerData)
				{
					foreach (var kvp in kvpPlayer.Value)
					{
						if (!info.playerData.TryAdd(kvpPlayer.Key, new Dictionary<string, string>() { { kvp.Key, kvp.Value } }))
						{
							info.playerData[kvpPlayer.Key][kvp.Key] = kvp.Value;
						}
					}
				}
			}
		}

		/// <summary>
		/// Utility function that allows you to do parallel operations for the player/global data when you are creating the server.
		/// The returning <see cref="ServerInfo"/>/<see cref="Dictionary{TKey,TValue}"/> of each function is merged together in the following fashion:
		///  - First, <paramref name="returningInfo"/> is merged with the result from <see cref="globalFunc"/>.
		///  - Then, the result's set of <see cref="ServerInfo.playerData"/>'s is merged-by-id with the returning <see cref="Dictionary{TKey,TValue}"/> from <paramref name="perPlayerFunc"/>.
		///  - Finally, the resulting <see cref="ServerInfo"/> is merged with the result from <paramref name="provisionServer"/>.
		///  - The merge is defined in <see cref="PrioritizedMerge"/>.
		/// 
		/// </summary>
		/// <param name="lobby">The lobby you are preparing.</param>
		/// <param name="returningInfo">This object will be modified --- it'll be <see cref="PrioritizedMerge"/> with the results of the various functions passed in here.</param>
		/// <param name="provisionServer">In this function you should request you provision server asking for a new instance.</param>
		/// <param name="globalFunc">A function that you can use to modify/add any key pair to lobby global data</param>
		/// <param name="perPlayerFunc">A function that you can use to add any key pair to the player lobby data</param>
		/// <returns>The modified <paramref name="returningInfo"/> object.</returns>
		public static async Promise<ServerInfo> PrepareLobbyAsDedicatedServer(this Lobby lobby,
			ServerInfo returningInfo,
			Func<Lobby, Task<ServerInfo>> provisionServer,
			Func<Lobby, Task<ServerInfo>> globalFunc = null,
			Func<LobbyPlayer, Task<Dictionary<string, string>>> perPlayerFunc = null)
		{
			var players = lobby.players.GetOrThrow();
			var perPlayerTasks = players.Select(RunPlayersFunc).ToArray();
			
			var allPromises = new List<Task<ServerInfo>>();
			allPromises.Add(RunGlobalFunc());
			allPromises.AddRange(perPlayerTasks);
			allPromises.Add(SetAsGameServer());

			// Let's merge all the infos into the returning info
			try
			{
				var allInfos = await Task.WhenAll(allPromises);
				returningInfo.PrioritizedMerge(allInfos);
				return returningInfo;
			}
			catch (Exception e)
			{
				BeamableLogger.LogError(e);
				throw;
			}

			// Adding the flat to lobby global data, so game server knows it is a dedicated server.
			async Task<ServerInfo> SetAsGameServer()
			{
				using var _ = lobby.AddToTelemetry();
				var serverInfo = await provisionServer(lobby);
				serverInfo.globalData[RESERVED_DEDICATED_SERVER_PROPERTY] = "true";
				return serverInfo;
			}

			// The global function will make updates in the lobby global data parallel to the updates in the RunPlayersFunc
			async Task<ServerInfo> RunGlobalFunc()
			{
				using var _ = lobby.AddToTelemetry();
				var info = await (globalFunc?.Invoke(lobby) ?? Task.FromResult(new ServerInfo()));
				return info;
			}

			// the RunPlayersFunc will be used to edit per player lobby data in parallel to the RunGlobalFunc
			async Task<ServerInfo> RunPlayersFunc(LobbyPlayer p)
			{
				using var _ = lobby.AddToTelemetry(p);
				var dict = await (perPlayerFunc?.Invoke(p) ?? Task.FromResult(new Dictionary<string, string>()));
				return new ServerInfo() { playerData = new Dictionary<string, Dictionary<string, string>>() { { p.playerId.Value, dict } } };
			}
		}

		/// <summary>
		/// Wait until the lobby receive the flag ready from the game server. This method does nothing if the lobby comes from PIE/Playmode.
		/// </summary>
		public static async Promise WaitForGameServerReady(this Lobby lobby, IBeamLobbyApi beamLobbyApi, int millisecondsDelay = 500)
		{
			if (!lobby.IsLobbyFromEditorPlayMode())
			{
				var lobbyApi = beamLobbyApi;
				while (lobby.data.TryGet(out var d) && d.ContainsKey(RESERVED_GAME_SERVER_READY_PROPERTY))
				{
					var id = lobby.lobbyId.GetOrThrow();
					var guid = Guid.Parse(id);
					lobby = await lobbyApi.Get(guid);
					await Task.Delay(millisecondsDelay);
				}
			}
		}
		
		public static async Task<string> GetBestRegionFromLobby(this Lobby lobby, IMicroserviceStatsApi statsApi)
		{
			// get the gamer tags of the players in the lobby
			var gamerTags = lobby.players.Value.Select(p => long.Parse(p.playerId)).ToArray();

			// get the ping times for each player
			var tasks = new List<Promise<Dictionary<string, string>>>(gamerTags.Length);
			tasks.AddRange(gamerTags.Select(tag =>statsApi.GetFilteredStats(StatsDomainType.Client, StatsAccessType.Public, tag, new string[] { StatsConstants.StatRegionPingKey })));
			var pingStats = await Promise.Sequence(tasks);

			if (pingStats.Count != 0)
			{
				List<Dictionary<string,int>> pings = new List<Dictionary<string,int>>();
				foreach (var ping in pingStats)
				{
					if (ping.TryGetValue(FederatedGameServerExtensions.StatsConstants.StatRegionPingKey, out var value))
					{
						var beamPingStats = JsonUtility.FromJson<Dictionary<string, int>>(value);
						if (beamPingStats != null && beamPingStats.Count > 0)
						{
							pings.Add(beamPingStats);
						}
					}
				}

				var averagePings = CalculateAveragePingPerRegion(pings);

				var sortedPings = SortByLowestPing(averagePings);
				
				// Find the best region for this match based on the players in it.
				return sortedPings.First().Key;
			}

			return "";
		}

		public static Dictionary<string, double> CalculateAveragePingPerRegion(List<Dictionary<string, int>> pingStatsList)
		{
			var regionPingValues = new Dictionary<string, List<int>>();

			foreach (var stats in pingStatsList)
			{
				foreach (var kvp in stats)
				{
					if (!regionPingValues.ContainsKey(kvp.Key))
						regionPingValues[kvp.Key] = new List<int>();

					regionPingValues[kvp.Key].Add(kvp.Value);
				}
			}

			return regionPingValues.ToDictionary(
				kvp => kvp.Key,
				kvp => kvp.Value.Average()
			);
		}

		public static List<KeyValuePair<string, double>> SortByLowestPing(Dictionary<string, double> averagePings)
		{
			return averagePings
				.OrderBy(kvp => kvp.Value) // Sort ascending by average ping
				.ToList();
		}
	}
}
