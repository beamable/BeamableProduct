using System.Runtime.CompilerServices;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Content;
using Beamable.Common.Scheduler;

namespace beamable.tooling.common.Scheduler;

public static class BeamSchedulerExtensions
{
    
    // public static async IAsyncEnumerable<JobExecution> GetJobActivity(
    //     this InternalBeamScheduler self,
    //     string jobId
    //     )
    // {
    //     
    //     OptionalString cursor = OptionalString.Empty;
    //     int pageNumber = 0;
    //
    //     while (pageNumber == 0 || cursor?.HasNonEmptyValue == true)
    //     {
    //         pageNumber++;
    //
    //         var page = await self.Api.GetJobActivityPaged(jobId, cursor);
    //         cursor = page.nextCursor;
    //
    //         var results = page.records.GetOrElse(Array.Empty<JobActivityView>());
    //         var events = results.Select(x => BeamScheduler.Utility.Convert(x)).ToList();
    //     }
    //
    //     var res = await self.Api.GetJobActivity(jobId, limit);
    //     // var events = res.Select(Utility.Convert).ToList();
    //     // var executions = events.GroupBy(e => e.executionId).Select(g => new JobExecution
    //     // {
    //     //     events = g.ToList(),
    //     //     executionId = g.Key,
    //     //     jobId = g.FirstOrDefault().jobId,
    //     // }).ToList();
    //     // return executions;
    // }
    
    /// <summary>
    /// Fetch a list of scheduled <see cref="Job"/>s. 
    /// </summary>
    /// <param name="self">The BeamScheduler instance</param>
    /// <param name="source">Filter <see cref="Job"/>s by the <see cref="Job.source"/> field.</param>
    /// <param name="name">Filter <see cref="Job"/>s by the <see cref="Job.name"/> field.</param>
    /// <param name="onlyUnique">Filter <see cref="Job"/>s that have unique names.</param>
    /// <param name="cancellationToken"></param>
    /// <returns>A list of <see cref="Job"/></returns>
    public static async IAsyncEnumerable<Job> GetAllJobs(
        this InternalBeamScheduler self,
        OptionalString source = null,
        OptionalString name = null,
        OptionalBool onlyUnique = null,
        [EnumeratorCancellation] CancellationToken cancellationToken=default
        )
    {
        OptionalString cursor = OptionalString.Empty;
        int pageNumber = 0;

        while (pageNumber == 0 || cursor?.HasNonEmptyValue == true)
        {
            pageNumber++;

            if (cancellationToken.IsCancellationRequested) yield break;

            var page = await self.Api.GetJobsPaged(
                cursor, 
                name: name, 
                source: source,
                onlyUnique: onlyUnique
            );
            cursor = page.nextCursor;

            var records = page.records;
            if (records.HasValue)
            {
                var convertedRecords = records.Value.Select(BeamScheduler.Utility.Convert).ToList();
                foreach (var convertedRecord in convertedRecords)
                {
                    if (cancellationToken.IsCancellationRequested) yield break;
                    yield return convertedRecord;
                }
            }

        }
    }
}