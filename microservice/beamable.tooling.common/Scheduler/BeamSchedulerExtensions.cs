using System.Runtime.CompilerServices;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Content;
using Beamable.Common.Scheduler;
using JobExecutionEvent = Beamable.Common.Scheduler.JobExecutionEvent;

namespace beamable.tooling.common.Scheduler;

/// <summary>
/// The scheduler lives in beamable.common, which is Unity shared netstandard2.0.
/// However, in order to use async enumerables, we need higher dotnet capabilities.
/// Thus, those methods are stored in an extension class available for CLI / Microservices
/// </summary>
public static class BeamSchedulerExtensions
{
    public delegate Task<(OptionalString, List<T>)> PagedOperation<T>(OptionalString cursor);
    
    /// <summary>
    /// A utility method for using paginated api calls. 
    /// </summary>
    /// <param name="operation"></param>
    /// <param name="cancellationToken"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static async IAsyncEnumerable<T> UsePagedOperation<T>(
        PagedOperation<T> operation,
        [EnumeratorCancellation] CancellationToken cancellationToken=default
        )
    {
        OptionalString cursor = OptionalString.None;
        int pageNumber = 0;

        while (pageNumber == 0 || cursor?.HasNonEmptyValue == true)
        {
            if (cancellationToken.IsCancellationRequested) yield break;

            pageNumber++;
            (cursor, var results) = await operation(cursor);

            if (results == null) continue;
            
            foreach (var res in results)
            {
                if (cancellationToken.IsCancellationRequested) yield break;
                yield return res;
            }
        }
    }
    
    /// <summary>
    /// Get all jobs that are in a recently suspended state
    /// </summary>
    /// <param name="self"></param>
    /// <param name="fromDate">An optional date to use as a filter</param>
    /// <param name="cancellationToken"></param>
    /// <returns>A list of <see cref="Job"/></returns>
    public static IAsyncEnumerable<Job> GetSuspendedJobs(
        this InternalBeamScheduler self,
        OptionalDateTime fromDate=null,
        CancellationToken cancellationToken=default)
    {
        return UsePagedOperation<Job>(async (cursor) =>
        {
            var res = await self.Api.GetJobsSuspended(cursor, fromDate);
            var convertedRecords = res.records.Value.Select(BeamScheduler.Utility.Convert).ToList();
            return (res.nextCursor, convertedRecords);
        }, cancellationToken);
    }
    
    /// <summary>
    /// Fetch execution events for a given job, or all jobs
    /// </summary>
    /// <param name="self">The BeamScheduler instance</param>
    /// <param name="jobId">
    ///  The <see cref="Job.id"/> to find execution events for.
    ///  If the value is null or empty, then execution events will be returned for all recent jobs
    /// </param>
    /// <param name="cancellationToken"></param>
    /// <returns>A list of <see cref="JobExecutionEvent"/></returns>
    public static IAsyncEnumerable<JobExecutionEvent> GetAllJobActivity(
        this InternalBeamScheduler self,
        string jobId=null,
        CancellationToken cancellationToken=default
        )
    {
    
        Func<OptionalString, Promise<JobActivityViewCursorPagedResult>> apiCall = currentCursor => self.Api.GetJobActivityPaged(jobId, currentCursor);
        if (string.IsNullOrEmpty(jobId))
        {
            apiCall = (currentCursor) => self.Api.GetJobsActivityPaged(currentCursor);
        }

        return UsePagedOperation(async (cursor) =>
        {
            var page = await apiCall(cursor);
            var results = page.records.GetOrElse(Array.Empty<JobActivityView>());
            var events = results.Select(BeamScheduler.Utility.Convert).ToList();

            return (page.nextCursor, events);
        }, cancellationToken);
    }
    
    
    /// <summary>
    /// Fetch a list of scheduled <see cref="Job"/>s. 
    /// </summary>
    /// <param name="self">The BeamScheduler instance</param>
    /// <param name="source">Filter <see cref="Job"/>s by the <see cref="Job.source"/> field.</param>
    /// <param name="name">Filter <see cref="Job"/>s by the <see cref="Job.name"/> field.</param>
    /// <param name="onlyUnique">Filter <see cref="Job"/>s that have unique names.</param>
    /// <param name="cancellationToken"></param>
    /// <returns>A list of <see cref="Job"/></returns>
    public static IAsyncEnumerable<Job> GetAllJobs(
        this InternalBeamScheduler self,
        OptionalString source = null,
        OptionalString name = null,
        OptionalBool onlyUnique = null,
        CancellationToken cancellationToken=default
        )
    {
        return UsePagedOperation(async cursor =>
        {
            var page = await self.Api.GetJobsPaged(
                cursor,
                name: name,
                source: source,
                onlyUnique: onlyUnique
            );
            
            var convertedRecords = page.records.Value.Select(BeamScheduler.Utility.Convert).ToList();
            return (page.nextCursor, convertedRecords);
        }, cancellationToken);
    }
}