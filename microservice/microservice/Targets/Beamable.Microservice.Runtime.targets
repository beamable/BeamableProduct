<Project>
    <!-- If the user has not set an OutputType, then we need to set one-->
    <PropertyGroup Condition="'$(OutputType)'=='' OR '$(OutputType)'=='Library' OR '$(OutputType)'=='library'">
        <!-- It is only our responsibility to set an outputtype if the user has configured their project correctly, meaning they must have a valid beamProjectType, or have created their own OutputType to begin with.-->
        <OutputType Condition="'$(BeamProjectType)'=='storage'">Library</OutputType>
        <OutputType Condition="'$(BeamProjectType)'=='service'">Exe</OutputType>
    </PropertyGroup>

    <PropertyGroup>
        <BeamBuildCacheInvalidationTimeout Condition="'$(BeamBuildCacheInvalidationTimeout)'==''">1</BeamBuildCacheInvalidationTimeout>
        <BeamIsDevVersion Condition="$(BeamableVersion.Contains('0.0.123'))==true">true</BeamIsDevVersion>
        
        <BeamCollectorVersion Condition="'$(BeamIsDevVersion)'=='true'">0.0.123</BeamCollectorVersion>
        
        <BeamBaseDownloadUrl>https://collectors.beamable.com/version/$(BeamCollectorVersion)"</BeamBaseDownloadUrl>
        <BeamCollectorBinaryDownloadUrl>$(BeamBaseDownloadUrl)/$(BeamCollectorFileName).gz</BeamCollectorBinaryDownloadUrl>
        <BeamCollectorConfigDownloadUrl>$(BeamBaseDownloadUrl)/$(BeamCollectorConfigFileName).gz</BeamCollectorConfigDownloadUrl>
        
        <BeamCollectorFolder>$(LOCALAPPDATA)/beam/collectors/$(BeamCollectorVersion)</BeamCollectorFolder>
        <BeamCollectorBinaryFilepath>$(BeamCollectorFolder)/$(BeamCollectorFileName)</BeamCollectorBinaryFilepath>
        <BeamCollectorConfigFilepath>$(BeamCollectorFolder)/$(BeamCollectorConfigFileName)</BeamCollectorConfigFilepath>
        
        <BeamCollectorExists>false</BeamCollectorExists>
        <BeamCollectorExists Condition="Exists($(BeamCollectorBinaryFilepath))">true</BeamCollectorExists>
    </PropertyGroup>

    <!-- This imports customer specific csproj files in the .beamable/temp/localDev project -->
    <Import Label="Load Beamable Local Developer Settings"
            Condition="'$(BeamProjectType)'=='storage' OR '$(BeamProjectType)'=='service'"
            Project="$(BeamableLocalDevProjectsGlob)"/>
    
    <Target Name="beam-invalidate-build-cache" AfterTargets="AfterBuild" Condition="'$(BeamProjectType)'=='service' AND '$(BeamPublish)' != 'true' AND '$(BeamPreventBuildCacheInvalidation)'!='true'">
        <Exec Condition="'$(BeamPlatform)'=='osx'"
              EchoOff="true"
              IgnoreExitCode="true"
              EnvironmentVariables="MSBUILDTERMINALLOGGER=off"
              Command="nohup sh -c 'sleep $(BeamBuildCacheInvalidationTimeout) &amp;&amp; touch $(MSBuildProjectFullPath)' &gt;/dev/null 2&gt;&amp;1 &amp;" 
        />
        <Exec Condition="'$(BeamPlatform)'=='win'"
              EchoOff="true"
              IgnoreExitCode="true"
              EnvironmentVariables="MSBUILDTERMINALLOGGER=off"
              Command="powershell -NoProfile -Command &quot;Start-Process powershell -ArgumentList '-NoProfile -Command &quot;Start-Sleep -Seconds $(BeamBuildCacheInvalidationTimeout); (Get-Item ''$(MSBuildProjectFullPath)'').LastWriteTime = Get-Date&quot;' -WindowStyle Hidden&quot;" 
        />
    </Target>
    
    <!-- After the build completes, we should generate OAPI specifications for the Microservices-->
    <Target Name="generate-oapi" AfterTargets="AfterBuild" Condition="'$(BeamProjectType)'=='service' AND '$(BeamPublish)' != 'true' AND '$(BeamPreventOapiGen)'!='true'">
        <Message Text="Generating OAPI specifications" Importance="high" />
        <Exec Command="dotnet &quot;$(TargetPath)&quot; --generate-oapi --tl:off" 
              EnvironmentVariables="OPEN_API_OUTPUT_PATH=$(OutputPath);MSBUILDTERMINALLOGGER=off"/>
        <WriteLinesToFile File="$(IntermediateOutputPath)/generateClientFlag.txt" Lines="flag" Overwrite="true"/>
    </Target>
    
    <Target Name="BeamableBuildAttrs" BeforeTargets="BeforeResGen" Condition="'$(BeamProjectType)'=='service' AND '$(BeamGenProps)'!='disable'">
        <Message Importance="high" Text="Bundling Beamable Properties..."/>
        <PropertyGroup>
            <BeamPropertiesFile>$(IntermediateOutputPath)/beamableProps.txt</BeamPropertiesFile>
        </PropertyGroup>
        <Delete Files="$(BeamPropertiesFile)"/>
        <WriteLinesToFile File="$(BeamPropertiesFile)" Overwrite="false" Lines="%(BeamableSetting.Identity)=%(BeamableSetting.Value)__BEAM__SETTING__SPLIT__"/>
        <ItemGroup>
            <EmbeddedResource Include="$(BeamPropertiesFile)" Type="Non-Resx" WithCulture="false" LogicalName="Beamable.properties"/>
        </ItemGroup>
    </Target>
    
    <Target Name="BeamableSettings" BeforeTargets="BeforeResGen" Condition="'$(BeamProjectType)'=='service'">
        <Message Importance="high" Text="Bundling Beamable Settings..."/>
        <PropertyGroup>
            <BeamSettingsFile>$(IntermediateOutputPath)/beamableSettings.txt</BeamSettingsFile>
            
        </PropertyGroup>
        <Delete Files="$(BeamSettingsFile)"/>

        <WriteLinesToFile File="$(BeamSettingsFile)" Overwrite="false" Lines="BeamId=$(BeamId)"/>
<!--        TODO: add more settings?   -->
<!--        <WriteLinesToFile File="$(BeamSettingsFile)" Overwrite="false" Lines="BeamId=$(BeamId)"/>-->
        
        <ItemGroup>
            <EmbeddedResource Include="$(BeamSettingsFile)" Type="Non-Resx" WithCulture="false" LogicalName="Beamable.settings"/>
        </ItemGroup>
    </Target>

    <!--
        Pre-build validation (Windows only): detect if any files in the output
        folder are locked and abort the build with a helpful message.
        This helps users who try to build while the microservice is still running.
        To skip this check set the MSBuild property: /p:BeamDisableOutputLockCheck=true
    -->
    <Target Name="BeamablePreBuildOutputLockCheck" BeforeTargets="BeforeBuild" Condition="'$(BeamProjectType)'=='service' AND '$(BeamPlatform)'=='win' AND '$(BeamDisableOutputLockCheck)'!='true'">
        <PropertyGroup>
            <ActualOutputDir>$(OutputPath)</ActualOutputDir>
            <ActualOutputDir Condition="'$(BeamPublish)' == 'true'">$(PublishDir)</ActualOutputDir>
        </PropertyGroup>

        <PropertyGroup>
            <BeamOutputDirFullPath>$([System.IO.Path]::GetFullPath('$(ActualOutputDir)', '$(MSBuildProjectDirectory)'))</BeamOutputDirFullPath>
            <BeamOutputDirNormalized>$([System.IO.Path]::TrimEndingDirectorySeparator('$(BeamOutputDirFullPath)'))</BeamOutputDirNormalized>
            <BeamOutputDirNormalized Condition="'$(BeamOutputDirNormalized)'==''">$(BeamOutputDirFullPath)</BeamOutputDirNormalized>
        </PropertyGroup>

        <PropertyGroup>
            <BeamOutputLockCheckExitCode>0</BeamOutputLockCheckExitCode>
            <BeamHasLockedFiles>false</BeamHasLockedFiles>
            <BeamAfterHasLockedFiles>false</BeamAfterHasLockedFiles>
        </PropertyGroup>

        <Message Importance="normal" Text="Checking output folder for locked files: [$(BeamOutputDirNormalized)]"/>
        <Exec EchoOff="true" IgnoreExitCode="true" EnvironmentVariables="MSBUILDTERMINALLOGGER=off" ConsoleToMSBuild="true" StandardOutputImportance="Low" StandardErrorImportance="Low"
              Command="dotnet beam checks locked-files &quot;$(BeamOutputDirNormalized)&quot; --pattern=&quot;*.dll&quot;">
            <Output TaskParameter="ConsoleOutput" PropertyName="BeamLockCheckOutput"/>
        </Exec>
        <PropertyGroup>
            <BeamHasLockedFiles Condition="$([System.String]::Copy('$(BeamLockCheckOutput)').Contains('LockingFiles')) Or $([System.String]::Copy('$(BeamLockCheckOutput)').Contains('ProcessId'))">true</BeamHasLockedFiles>
        </PropertyGroup>
        
        <Message Condition="'$(BeamHasLockedFiles)'=='true'" Importance="high" Text="Locked files detected. Stopping service and re-checking output folder."/>

        <Exec Condition="'$(BeamHasLockedFiles)'=='true'" EchoOff="true" IgnoreExitCode="true" EnvironmentVariables="MSBUILDTERMINALLOGGER=off"
              Command="dotnet beam project stop --ids $(BeamId) --reason &quot;Stopped service to generate new build.&quot;" />

        <Exec Condition="'$(BeamHasLockedFiles)'=='true'" EchoOff="true" IgnoreExitCode="true" EnvironmentVariables="MSBUILDTERMINALLOGGER=off" ConsoleToMSBuild="true" StandardOutputImportance="Low" StandardErrorImportance="Low"
              Command="dotnet beam checks locked-files &quot;$(BeamOutputDirNormalized)&quot; --pattern=&quot;*.dll&quot;">
            <Output TaskParameter="ConsoleOutput" PropertyName="BeamLockCheckAfterOutput"/>
        </Exec>
        <PropertyGroup Condition="'$(BeamHasLockedFiles)'=='true'">
            <BeamAfterHasLockedFiles Condition="$([System.String]::Copy('$(BeamLockCheckAfterOutput)').Contains('LockingFiles')) Or $([System.String]::Copy('$(BeamLockCheckAfterOutput)').Contains('ProcessId'))">true</BeamAfterHasLockedFiles>
        </PropertyGroup>

        

        <PropertyGroup Condition="'$(BeamAfterHasLockedFiles)'=='true'">
            <BeamLockProcId>$([System.Text.RegularExpressions.Regex]::Match('$(BeamLockCheckAfterOutput)','\"ProcessId\"\s*:\s*(\d+)').Groups[1].Value)</BeamLockProcId>
            <BeamLockCommandLine>$([System.Text.RegularExpressions.Regex]::Match('$(BeamLockCheckAfterOutput)','\"CommandLine\"\s*:\s*\"((?:[^\"\\]|\\.)*)\"').Groups[1].Value)</BeamLockCommandLine>
        </PropertyGroup>
        <PropertyGroup Condition="'$(BeamAfterHasLockedFiles)'=='true' AND '$(BeamLockProcId)'==''">
            <BeamLockProcId>unknown</BeamLockProcId>
        </PropertyGroup>
        <PropertyGroup Condition="'$(BeamAfterHasLockedFiles)'=='true' AND '$(BeamLockCommandLine)'==''">
            <BeamLockCommandLine>unknown</BeamLockCommandLine>
        </PropertyGroup>
        <PropertyGroup Condition="'$(BeamAfterHasLockedFiles)'=='true'">
            <BeamLockDetails>Some files in the output folder ($(ActualOutputDir)) are locked by the process: $(BeamLockProcId). (command line: $(BeamLockCommandLine))</BeamLockDetails>
            <BeamOutputLockCheckExitCode>1</BeamOutputLockCheckExitCode>
        </PropertyGroup>

        <Error Condition="'$(BeamOutputLockCheckExitCode)'!='0'" Text="$(BeamLockDetails)"/>
        <Error Condition="'$(BeamOutputLockCheckExitCode)'!='0' AND '$(BeamLockDetails)'==''" Text="Some files in the output folder are locked."/>
    </Target>

    <Target Name="ResolveAndCopyCollectorFiles" BeforeTargets="Build;Publish" Condition="'$(BeamProjectType)'=='service' AND '$(BeamDisableCollectorResolution)'!='true'">

        <PropertyGroup>
            <ActualOutputDir>$(OutputPath)</ActualOutputDir>
            <ActualOutputDir Condition="'$(BeamPublish)' == 'true'">$(PublishDir)</ActualOutputDir>
        </PropertyGroup>

        <Message Importance="high" Text="resolving collector... $(ActualOutputDir)"/>
        <Message Importance="normal" Text="collector exists=[$(BeamCollectorExists)]"/>
        <Message Importance="normal" Text="disable collector resolution=[$(BeamDisableCollectorResolution)]"/>
        <Message Importance="normal" Text="collector bin path=[$(BeamCollectorBinaryFilepath)]"/>
        <Message Condition="'$(BeamCollectorExists)'!='true' AND '$(BeamDisableCollectorResolution)'!='true'"
                 Importance="high"
                 Text="Downloading collector... $(BeamCollectorVersion) --- $(BeamCollectorPlatformArchArg)"
        />
        <Exec   Condition="'$(BeamCollectorExists)'!='true' AND '$(BeamDisableCollectorResolution)'!='true'"
                Command="$(BeamableDotnetPath) $(BeamableTool) telemetry collector get $(BeamCollectorPlatformArchArg) --quiet"
                EnvironmentVariables="MSBUILDTERMINALLOGGER=off"/>

        <Message
                Importance="high"
                Text="Copying collector to output folder from path = [$(BeamCollectorFolder)]"
        />
        <Copy   Condition="'$(BeamDisableCollectorResolution)'!='true'"
                SourceFiles="$(BeamCollectorBinaryFilepath);$(BeamCollectorConfigFilepath)"
                DestinationFolder="$(ActualOutputDir)"
                SkipUnchangedFiles="true"
        />

    </Target>

</Project>
