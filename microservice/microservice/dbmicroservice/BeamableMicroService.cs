/*
 *  Simple CustomMicroservice example
 */

using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Dependencies;
using Beamable.Server.Api.RealmConfig;
using beamable.tooling.common.Microservice;
using Core.Server.Common;
using microservice;
using ContentService = Beamable.Server.Content.ContentService;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Beamable.Common.Api.Content;
using Beamable.Common.Reflection;
using Beamable.Serialization;
using Beamable.Server.Api.Logs;
using Beamable.Server.Common;
using Beamable.Server.Editor;
using microservice.Common;
using microservice.dbmicroservice;
using Newtonsoft.Json;
using Microsoft.Extensions.DependencyInjection;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using ZLogger;
using Otel = Beamable.Common.Constants.Features.Otel;

#pragma warning disable CS8632 // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.

namespace Beamable.Server
{
  

   public class MicroserviceServiceProviderRequest
   {
	   public string type = "basic";
	   public string name; // the routable name of the service, which means it includes "micro_". Ex: "micro_Tuna"
	   public string beamoName; // the name of the service, as written by the user. Ex: "Tuna"
	   public string? routingKey; // Option[String] = None, // Arbitrary unique key. This should only be used for locally running services
	   public long? startedById; //: Option[Long] = None, // accountId of the user who started this service. This should only be used for locally running services
	   public string microServiceId; // the unique id for the microservice in question

	   public string ToJson()
	   {
		   return System.Text.Json.JsonSerializer.Serialize(this, new JsonSerializerOptions { IncludeFields = true });
	   }
   }

   public class MicroserviceServiceProviderFederationComponent
   {
	   public string type;
	   public string nameSpace;
	   public Dictionary<string, string> settings;
   }
   
   // case class SupportedFederation(
   //  `type`: String,
   // namespace: Option[String],
   // // Optional JSON Blob of extra settings to be used by the underlying Federation
   // settings: Option[JsonNode]
   //  ) extends MongoSerializable with NetworkSerializable



   public class BeamableMicroService : IBeamableService
   {
      public string MicroserviceName => _serviceAttribute.MicroserviceName;
	  public static string MicroserviceID => _microServiceId;

      public string QualifiedName => _serviceAttribute.GetQualifiedName();
      
      private ConcurrentDictionary<long, Task> _runningTaskTable = new ConcurrentDictionary<long, Task>();
      private const int EXIT_CODE_PENDING_TASKS_STILL_RUNNING = 11;
      private const int EXIT_CODE_FAILED_AUTH = 12;
      private const int EXIT_CODE_FAILED_CUSTOM_INITIALIZATION_HOOK = 110;
      private const int HTTP_STATUS_GONE = 410;
      private const int ShutdownLimitSeconds = 5;
      private const int ShutdownMinCycleTimeMilliseconds = 100;
      private Promise<Unit> _serviceInitialized = new Promise<Unit>();
      private IConnection _connection;
      private Promise<IConnection> _webSocketPromise;
      private MicroserviceRequester _requester;
      private IActivityProvider _activityProvider;
      private static readonly string _microServiceId = Guid.NewGuid().ToString();
      public SocketRequesterContext SocketContext => _socketRequesterContext;
      private SocketRequesterContext _socketRequesterContext;
      public ServiceMethodCollection ServiceMethods { get; private set; }
      public List<FederationComponent> FederationComponents => Provider.GetService<FederationMetadata>().Components;
      public MicroserviceAuthenticationDaemon AuthenticationDaemon => _socketRequesterContext?.Daemon;
      private IMicroserviceAttributes _serviceAttribute;

      // default is false, set 1 for true.
      private int _refuseNewClientMessageFlag = 0; // https://stackoverflow.com/questions/29411961/c-sharp-and-thread-safety-of-a-bool
      public bool RefuseNewClientMessages
      {
         get => (Interlocked.CompareExchange(ref _refuseNewClientMessageFlag, 1, 1) == 1);
         set
         {
            if (value) Interlocked.CompareExchange(ref _refuseNewClientMessageFlag, 1, 0);
            else Interlocked.CompareExchange(ref _refuseNewClientMessageFlag, 0, 1);
         }
      }

      // default is false, set 1 for true.
      private int _shutdownStarted = 0; // https://stackoverflow.com/questions/29411961/c-sharp-and-thread-safety-of-a-bool
      public bool IsShuttingDown
      {
         get => (Interlocked.CompareExchange(ref _shutdownStarted, 1, 1) == 1);
         set
         {
            if (value) Interlocked.CompareExchange(ref _shutdownStarted, 1, 0);
            else Interlocked.CompareExchange(ref _shutdownStarted, 0, 1);
         }
      }

      public bool HasInitialized { get; private set; }


      public IMicroserviceArgs InstanceArgs;
      private CancellationTokenSource _serviceShutdownTokenSource;
      private Task _socketDaemen;
      private string Host => InstanceArgs.Host;
      private int[] _retryIntervalsInSeconds = new[]
      {
         5,
         5,
         10,
         10,
         15,
         45,
         60
      };

      /// <summary>
      /// We need to guarantee <see cref="ResolveCustomInitializationHook"/> only gets run once when we <see cref="SetupWebsocket"/>.
      /// </summary>
      private bool _ranCustomUserInitializationHooks = false;


      public IDependencyProvider Provider => InstanceArgs.ServiceScope;

      public readonly string ConnectionId = Guid.NewGuid().ToString();
      private SingletonDependencyList<ITelemetryAttributeProvider> _telemetryProviders;
      private StartupContext _startupContext;

      private string _adminPrefix;

      public async Task Start(IMicroserviceArgs args, StartupContext startupContext)
      {
	      _startupContext = startupContext;
	      if (HasInitialized) return;
         
         _serviceAttribute = startupContext.attributes;
         _adminPrefix = _serviceAttribute.GetQualifiedName() + "/admin/";

         _socketRequesterContext = new SocketRequesterContext(GetWebsocketPromise);
         InstanceArgs = args.Copy(conf =>
         {
	         conf.ServiceScope = conf.ServiceScope.Fork(builder =>
	         {
				// do we need instance specific services? They'd go here.
				builder.AddScoped(_socketRequesterContext);
				builder.AddScoped(_socketRequesterContext.Daemon);
	         });
	         _socketRequesterContext.ActivityProvider = conf.ServiceScope.GetService<IActivityProvider>();
         });


         _telemetryProviders = InstanceArgs.ServiceScope.GetService<SingletonDependencyList<ITelemetryAttributeProvider>>();
         var connectionOtelTags = _telemetryProviders.CreateConnectionAttributes(InstanceArgs, ConnectionId);
         var _serviceLogScope = BeamableZLoggerProvider.LogContext.Value.BeginScope(connectionOtelTags);

         
         Log.Debug(Constants.Features.Services.Logs.STARTING_PREFIX + " {host} {prefix} {cid} {pid} {sdkVersionBuild} {disableCustomHooks}", args.Host, args.NamePrefix, args.CustomerID, args.ProjectName, args.SdkVersionBaseBuild, args.DisableCustomInitializationHooks);
         
         RebuildRouteTable();

         _activityProvider = Provider.GetService<IActivityProvider>();

         _requester = new MicroserviceRequester(InstanceArgs, null, _socketRequesterContext, false, _activityProvider);
         _serviceShutdownTokenSource = new CancellationTokenSource();
         (_socketDaemen, _socketRequesterContext.Daemon) = MicroserviceAuthenticationDaemon.Start(InstanceArgs, _requester, _serviceShutdownTokenSource);

         _ = _serviceInitialized.Error(ex =>
         {
            Log.Error("Service failed to initialize {message} {stack}", ex.Message, ex.StackTrace);
         });
         
         // the first time this runs, it'll complete, but due to how promises work, all of the next times, it'll no-op.
         var contentService = Provider.GetService<ContentService>();
         ContentApi.Instance.CompleteSuccess(contentService);

         
         // Connect and Run
         _webSocketPromise = AttemptConnection();
         var socket = await _webSocketPromise;
         
         if (!InstanceArgs.DisableCustomInitializationHooks && !_ranCustomUserInitializationHooks)
         {
	         await SetupStorage();
         }

         await SetupWebsocket(socket, _serviceAttribute.EnableEagerContentLoading);
         if (!_serviceAttribute.EnableEagerContentLoading)
         {
	         _ = contentService.Init();
         }
      }
      
      private async Promise SetupStorage()
      {
	      var reflectionCache = Provider.GetService<ReflectionCache>();
	      var mongoIndexesReflectionCache = reflectionCache.GetFirstSystemOfType<MongoIndexesReflectionCache>();
		
	      IStorageObjectConnectionProvider connectionProvider =
		      Provider.GetService<IStorageObjectConnectionProvider>();

	      await mongoIndexesReflectionCache.SetupStorage(connectionProvider);
      }

      public async Task RunForever()
      {
         AppDomain.CurrentDomain.ProcessExit += async (sender, args) =>
         {
            await OnShutdown(sender, args);
         };

         await Task.Delay(-1);
      }

      public async Task OnShutdown(object sender, EventArgs args)
      {
         IsShuttingDown = true;

         // need to wait for all tasks to complete...
         Log.Debug("Shutdown started... {runningTaskCount} tasks running.", _runningTaskTable.Count);

         var sw = new System.Diagnostics.Stopwatch();
         sw.Start();

         // remove the service, so that no new messages are accepted
         try
         {
            var promise = RemoveService(QualifiedName);
            var startedWaitingAt = sw.ElapsedMilliseconds;
            while (!promise.IsCompleted)
            {
               if (sw.ElapsedMilliseconds > startedWaitingAt + 1000 * 5)
               {
                  throw new Exception("Waited for 5 seconds");
               }
               Thread.Sleep(5);
            }
         }
         catch (Exception ex)
         {
            Log.Fatal("Could not drain service provider. {message}", ex.Message);
         }


         var startTime = sw.ElapsedMilliseconds;
         var expectedEndTime = startTime + ShutdownLimitSeconds * 1000;
         while (_runningTaskTable.Count > 0 && sw.ElapsedMilliseconds < expectedEndTime)
         {
            var millisecondsLeft = expectedEndTime - sw.ElapsedMilliseconds;
            var secondsLeft = millisecondsLeft / 1000;
            Log.Debug("Waiting up to {shutdownTimeLimit} seconds for tasks to complete.", secondsLeft);
            var pendingTasks = _runningTaskTable.Values.ToArray();
            var startedWaitingAt = sw.ElapsedMilliseconds;
            Task.WaitAll(pendingTasks, TimeSpan.FromMilliseconds(millisecondsLeft));
            /* we need to wait a minimum number of moments in this loop so we don't exhaust the task cycle.
             What can happen is that all the tasks are DONE, so, the WaitAll completes. However, the task hasn't removed itself from the _runningTaskTable yet,
             because its continuation hasn't been executed. And then, if that happens, we enter a scenario where this method just loops and loops, and since the Task.WaitAll
             is always complete, the other continuation takes a long time to get scheduled.
             */
            var stoppedWaitingAt = sw.ElapsedMilliseconds;
            var waitedForMilliseconds = stoppedWaitingAt - startedWaitingAt;
            var requiredWaitTimeLeft = Math.Max(0, ShutdownMinCycleTimeMilliseconds - waitedForMilliseconds);
            await Task.Delay(TimeSpan.FromMilliseconds(requiredWaitTimeLeft));
         }
         if (_runningTaskTable.Count > 0)
         {
            Log.Fatal("Shutting Down with {runningTaskCount} pending task(s) still processing after the {shutdownTimeLimit} second shutdown grace period. This produces inconsistent behaviour. ", _runningTaskTable.Count, ShutdownLimitSeconds);
            Environment.ExitCode = EXIT_CODE_PENDING_TASKS_STILL_RUNNING;
         }
         else
         {
            Log.Debug("All pending tasks completed.");
         }

         // stop the daemon from trying to re-authenticate
         _socketRequesterContext.Daemon.KillAuthThread();
         await _socketDaemen;

         // close the connection itself
         await _connection.Close();

         sw.Stop();
         Log.Information("Service shutting down. Shutdown took {shutdownTime} seconds.", sw.ElapsedMilliseconds / 1000f);

      }

      public void RebuildRouteTable()
      {
	      ServiceMethods = RouteSourceUtil.BuildRoutes(_startupContext, InstanceArgs);
      }

      async Task SetupWebsocket(IConnection socket, bool initContent = false)
      {
         _connection = socket;

         socket.OnDisconnect((s, wasClean) => CloseConnection(s, wasClean).Wait());

         socket.OnMessage(async void (s, message, messageNumber, sw) =>
         {
	         try
	         {
		         await MonitorTask(messageNumber, () => HandleWebsocketMessage(socket, message, sw));
	         }
	         catch (Exception ex)
	         {
		         BeamableLogger.LogException(ex);
	         }
         });

         try
         {
	         _socketRequesterContext.Daemon.WakeAuthThread();
            await _requester.WaitForAuthorization(TimeSpan.FromMinutes(2), "Registering services event.");
            // We can disable custom initialization hooks from running. This is so we can verify the image works (outside of the custom hooks) before a publish.
            // TODO This is not ideal. There's an open ticket with some ideas on how we can improve the publish process to guarantee it's impossible to publish an image
            // TODO that will not boot correctly.
            if (!InstanceArgs.DisableCustomInitializationHooks)
            {
                // Custom Initialization hook for C#MS --- will terminate MS user-code throws.
                // Only gets run once --- if we need to setup the websocket again, we don't run this a second time.
                if (!_ranCustomUserInitializationHooks)
                {
	                if (initContent)
	                {
		                await Provider.GetService<ContentService>().Init(preload:true);
	                }

                    await ResolveCustomInitializationHook();
                    _ranCustomUserInitializationHooks = true;
                }
            }

            var realmService = InstanceArgs.ServiceScope.GetService<IRealmConfigService>();
            
            var loggingContextService = InstanceArgs.ServiceScope.GetService<ILoggingContextService>();
            
            await realmService.GetRealmConfigSettings();
            await loggingContextService.GetAllLoggingContexts();
            await ProvideService();

            HasInitialized = true;

            var portalUrlLogline = "";
            if (TryBuildPortalUrl(out string url))
            {
	            portalUrlLogline = $"portalURL={url}";
            }
            
            Log.Information(Constants.Features.Services.Logs.READY_FOR_TRAFFIC_PREFIX + "baseVersion={baseVersion} executionVersion={executionVersion} " + portalUrlLogline, InstanceArgs.SdkVersionBaseBuild, InstanceArgs.SdkVersionExecution);
            realmService.UpdateLogLevel();

            _serviceInitialized.CompleteSuccess(PromiseBase.Unit);
         }
         catch (Exception ex)
         {
            Log.Fatal("Service failed to provide services. {message} {stack}", ex.Message, ex.StackTrace);
            _serviceInitialized.CompleteError(ex);
            Environment.Exit(EXIT_CODE_FAILED_AUTH);
         }

      }
      
      private bool TryBuildPortalUrl(out string portalUrl)
      {
	      var cid = InstanceArgs.CustomerID;
	      var pid = InstanceArgs.ProjectName;
	      var microName = QualifiedName;
	      var refreshToken = InstanceArgs.RefreshToken;

	      if (string.IsNullOrEmpty(refreshToken))
	      {
		      Log.Verbose("not generating portal url, because no refresh token exists.");
		      portalUrl = "";
		      return false;
	      }
	      
	      var queryArgs = new List<string>
	      {
		      $"refresh_token={refreshToken}",
		      $"routingKey={InstanceArgs.NamePrefix}"
	      };
	      var joinedQueryString = string.Join("&", queryArgs);
	      var treatedHost = InstanceArgs.Host.Replace("/socket", "")
		      .Replace("wss", "https")
		      .Replace("dev.", "dev-")
		      .Replace("api", "portal");
	      portalUrl = $"{treatedHost}/{cid}/games/{pid}/realms/{pid}/microservices/{microName}/docs?{joinedQueryString}";
	      
	      Log.Verbose("portal url " + portalUrl);

	      return true;
      }



      /// <summary>
      /// Handles custom initialization hooks. Makes the following assumptions:
      ///   - User defined at least one <see cref="InitializeServicesAttribute"/> over a static async method that returns a <see cref="Promise{Unit}"/> or a <see cref="Promise"/> and receives a <see cref="IServiceInitializer"/>.
      ///   - Any exception will fail loudly and prevent the C#MS from receiving traffic.
      /// <para/>
      /// </summary>
      private async Task ResolveCustomInitializationHook()
      {
	      // TODO: extract all this mumbo jumbo into startupContext.
	      
         // Gets Service Initialization Methods
         var serviceInitialization = _startupContext.routeSources
	         .SelectMany(t => t.InstanceType.GetMethods(BindingFlags.Static | BindingFlags.Public))
	         .Where(method => method.GetCustomAttribute<InitializeServicesAttribute>() != null)
	         .Select(method =>
	         {
		         var attr = method.GetCustomAttribute<InitializeServicesAttribute>();
		         return (method, attr);
	         })
	         .ToList();

         // Sorts them by an user-defined order. By default (and tie-breaking), is sorted in file declaration order.
         // TODO: Add reflection utility that sorts (MemberInfo, ISortableByType<>) tuples to ReflectionCache and replace this usage.
         serviceInitialization.Sort(delegate((MethodInfo method, InitializeServicesAttribute attr) t1, (MethodInfo method, InitializeServicesAttribute attr) t2)
         {
            var (_, attr1) = t1;
            var (_, attr2) = t2;
            return attr1.ExecutionOrder.CompareTo(attr2.ExecutionOrder);
         });

         // Invokes each Service Initialization Method --- skips any that do not match the void(IServiceInitializer) signature.
         var serviceInitializers = new DefaultServiceInitializer(InstanceArgs.ServiceScope.Parent, InstanceArgs);
         foreach (var (initializationMethod, _) in serviceInitialization)
         {
            // TODO: Add compile-time check for this signature so we can educate our users on this without them having to deep dive into docs
            var parameters = initializationMethod.GetParameters();
            if (parameters.Length != 1 || parameters[0].ParameterType != typeof(IServiceInitializer))
            {
               BeamableLogger.LogWarning($"Skipping method with [{nameof(InitializeServicesAttribute)}] since it does not take a single [{nameof(IServiceInitializer)}] parameter.");
               continue;

            }

            var resultType = initializationMethod.ReturnType;
            Promise<Unit> promise;
            if (resultType == typeof(void))
            {
               var isAsync = null != initializationMethod.GetCustomAttribute<AsyncStateMachineAttribute>();
               if (isAsync)
               {
                  BeamableLogger.LogWarning($"Skipping method [{initializationMethod.DeclaringType?.FullName}.{initializationMethod.Name}] " +
                                            $"with [{nameof(InitializeServicesAttribute)}] since it is an async void method. Since these do not return a Task or Promise, " +
                                            $"we can't await it's return and using this may cause non-deterministic behaviour depending on your implementation. " +
                                            $"We recommend not using this unless you know exactly what you are doing.");
                  continue;
               }

               promise = Task.FromResult(initializationMethod.Invoke(null, new object[] { serviceInitializers })).ToPromise().ToUnit();
            }
            else if (resultType == typeof(Task))
            {
               promise = ((Task)initializationMethod.Invoke(null, new object[] { serviceInitializers })).ToPromise();
            }
            else if (resultType == typeof(Promise<Unit>))
            {
               promise = (Promise<Unit>)initializationMethod.Invoke(null, new object[] { serviceInitializers });
            }
            else if (resultType == typeof(Promise))
            {
	            promise = (Promise)initializationMethod.Invoke(null, new object[] { serviceInitializers });
            }
            else
            {
               BeamableLogger.LogWarning($"Skipping method with [{nameof(InitializeServicesAttribute)}] since it isn't a synchronous [void] method, a [{nameof(Task)}], a [{nameof(Promise)}] or a [{nameof(Promise<Unit>)}]");
               continue;
            }

            try
            {
               await promise;
               BeamableLogger.Log($"Custom service initializer [{initializationMethod.DeclaringType?.FullName}.{initializationMethod.Name}] succeeded.\n");
            }
            catch (Exception ex)
            {
               BeamableLogger.LogError($"Custom service initializer [{initializationMethod.DeclaringType?.FullName}.{initializationMethod.Name}] failed.\n" +
                                       $"{ex.Message}\n" +
                                       $"{{stacktrace}}", ex.StackTrace);

               BeamableLogger.LogException(ex);
               Environment.Exit(EXIT_CODE_FAILED_CUSTOM_INITIALIZATION_HOOK);
            }
         }


         foreach (var initializer in _startupContext.initializers)
         {
	         var task = initializer?.Invoke(InstanceArgs.ServiceScope);
	         if (task != null)
	         {
		         await task;
	         }
         }
      }



      public Promise<IConnection> GetWebsocketPromise()
      {
         return _webSocketPromise;
      }

      Promise<IConnection> AttemptConnection()
      {
         var connectionAttempt = 0;
         var promise = new Promise<IConnection>();

         Log.Debug("starting ws connection");
         void Attempt()
         {
            Log.Debug($"connecting to ws ({Host}) ... ");
            var ws = Provider.GetService<IConnectionProvider>().Create(Host, InstanceArgs);
            ws.OnConnect(socket =>
            {
               Log.Debug("connection made.");
               promise.CompleteSuccess(socket);
            });
            ws.OnDisconnect(async (socket, wasClean) =>
            {
               if (promise.IsCompleted) return; // ignore, this handler has no purpose anymore.
               if (wasClean) return;

               // try again!
               var retryDelay = connectionAttempt < _retryIntervalsInSeconds.Length
                  ? _retryIntervalsInSeconds[connectionAttempt]
                  : _retryIntervalsInSeconds[^1]; // last one.
               connectionAttempt++;
               Log.Error("connection could not be re-established. Will attempt connection {attempt} in {delay} seconds", connectionAttempt, retryDelay);
               await Task.Delay(retryDelay * 1000);
               Attempt();
            });

            ws.Connect();
         }

         Attempt();
         return promise;
      }

      Task MonitorTask(long messageNumber, Func<Task> taskProducer)
      {
         var task = taskProducer();

         try
         {
	         if (!_runningTaskTable.TryAdd(messageNumber, task))
	         {
		         BeamableLogger.LogWarning("Could not monitor task. {id} {status}", messageNumber, task.Status);
	         }

	         // watch the task...
	         _ = task.ContinueWith(finishedTask =>
	         {
		         if (!_runningTaskTable.TryRemove(messageNumber, out _))
		         {
			         BeamableLogger.LogWarning("Could not discard monitored task {id}", messageNumber);
		         }

		         if (finishedTask.IsFaulted)
		         {
			         BeamableLogger.LogException(finishedTask.Exception);
		         }
	         });
         }
         catch (Exception ex)
         {
	         if (!_runningTaskTable.TryRemove(messageNumber, out _))
	         {
		         Log.Warning("[Exception] Could not discard monitored task {message} {stack}", ex.Message,
			         ex.StackTrace);
	         }

	         throw;
         }

         return task;
      }


      async Task HandlePlatformMessage(MicroserviceRequestContext ctx, BeamActivity activity)
      {
	      // using var activity = _activityProvider.Create(Constants.Features.Otel.TRACE_WS_BEAM, parentActivity);
	      // activity.Start();
	      
	      try
	      {
		      _socketRequesterContext.HandleMessage(ctx, activity);
		      await _requester.Acknowledge(ctx);
		      activity.SetStatus(ActivityStatusCode.Ok);
	      }
	      catch (Exception ex)
	      {
		      activity.SetStatus(ActivityStatusCode.Error);
				
		      BeamableLogger.LogException(ex);
		      await _requester.Acknowledge(ctx, new WebsocketErrorResponse
		      {
			      status = 500, // TODO: Catch a special type of exception, NackException?
			      error = ex.GetType().Name,
			      message = ex.Message,
			      service = QualifiedName
		      });
	      }
      }
      
      async Task HandleClientMessage(MicroserviceRequestContext ctx, Stopwatch sw, BeamActivity activity)
      {
	      // using var activity = _activityProvider.Create(Constants.Features.Otel.TRACE_WS_CLIENT,
		     //  parentActivity);
	      // activity.Start();
	      if (RefuseNewClientMessages)
	      {
		      Log.Warning("Received a message after service began draining. id={id}", ctx.Id);
		      // TODO modify activity.
		      activity.SetStatus(ActivityStatusCode.Error);
		      return; // let this message die.
	      }

	      try
	      {
		      var route = ctx.Path.Substring(QualifiedName.Length + 1);
		      var parameterProvider = new AdaptiveParameterProvider(ctx);
		      var responseJson = await ServiceMethods.Handle(ctx, route, parameterProvider, activity);
		      BeamableZLoggerProvider.LogContext.Value.LogTrace("Responding with " + responseJson);
		      await _socketRequesterContext.SendMessageSafely(responseJson, sw: sw);

		      activity.SetStatus(ActivityStatusCode.Ok);
		      // TODO: Kill Scope
	      }
	      catch (MicroserviceException ex)
	      {
		      activity.SetStatus(ActivityStatusCode.Error);

		      var failResponse = new GatewayErrorResponse
		      {
			      id = ctx.Id,
			      status = ex.ResponseStatus,
			      body = ex.GetErrorResponse(_serviceAttribute.MicroserviceName)
		      };
		      var failResponseJson = JsonConvert.SerializeObject(failResponse);
		      // BeamableZLoggerProvider.Instance.(ex);

		      BeamableZLoggerProvider.LogContext.Value.LogError("Exception {exception.type}: {exception.message} - {source} {json} \n {exception.stacktrace}",
			      ex.GetType().Name, ex.Message,
			      ex.Source, failResponseJson, ex.StackTrace);
		      await _socketRequesterContext.SendMessageSafely(failResponseJson, sw: sw);
	      }
	      catch (TargetInvocationException ex)
	      {
		      var inner = ex.InnerException;
		      var failResponse = new GatewayResponse()
		      {
			      id = ctx.Id,
		      };

		      string failResponseJson;

		      if (inner is MicroserviceException msException)
		      {
			      failResponse.status = msException.ResponseStatus;
			      failResponse.body = msException.GetErrorResponse(_serviceAttribute.MicroserviceName);

			      failResponseJson = JsonConvert.SerializeObject(failResponse);
			      
			      BeamableZLoggerProvider.LogContext.Value.LogError(
				      "Exception {exception.type}: {exception.message} - {source} {json} \n {exception.stacktrace}", msException.GetType().Name,
				      msException.Message,
				      msException.Source, failResponseJson, msException.StackTrace);
		      }
		      else
		      {
			      failResponse = new GatewayResponse
			      {
				      id = ctx.Id,
				      status = 500,
				      body = new ClientResponse
				      {
					      payload = ""
				      }
			      };

			      failResponseJson = JsonConvert.SerializeObject(failResponse);
			      // BeamableZLoggerProvider.Instance.Error(inner);

			      BeamableZLoggerProvider.LogContext.Value.LogError("Exception {exception.type}: {exception.message} - {source} \n {exception.stacktrace}",
				      inner.GetType().Name,
				      inner.Message,
				      inner.Source, inner.StackTrace);
		      }

		      await _socketRequesterContext.SendMessageSafely(failResponseJson, sw: sw);
	      }
	      catch (Exception ex) // TODO: Catch a general PlatformException type sort of thing.
	      {
		      BeamableZLoggerProvider.Instance.Error(ex);
		      // var failResponse = new GatewayErrorResponse
		      // {
		      //    id = ctx.Id,
		      //    status = ex.ResponseStatus,
		      //    body = ex.GetErrorResponse(_serviceAttribute.MicroserviceName)
		      // };
		      var failResponse = new GatewayResponse
		      {
			      id = ctx.Id,
			      status = 500,
			      body = new ClientResponse
			      {
				      payload = ex.Message // TODO: Format this into a better response.
			      }
		      };
		      var failResponseJson = JsonConvert.SerializeObject(failResponse);
		      await _socketRequesterContext.SendMessageSafely(failResponseJson, sw: sw);
	      }
	      finally
	      {
		      activity.Stop();
	      }
      }

      async Task HandleWebsocketMessage(IConnection ws, JsonDocument document, Stopwatch sw)
      {
	
	      MicroserviceRequestContext ctx = null;
	      using (var requestActivity = _activityProvider.Create(Otel.TRACE_CONSTRUCT_CTX, importance: TelemetryImportance.VERBOSE))
	      {
		      if (!document.TryBuildRequestContext(InstanceArgs, out ctx))
		      {
			      requestActivity.SetStatus(ActivityStatusCode.Error);
			      Log.Debug("WS Message contains no data. Cannot handle. Skipping message.");
			      return;
		      }
		      requestActivity.SetStatus(ActivityStatusCode.Ok);
	      }

	      BeamActivity parentActivity = BeamActivity.Noop;
	      if (_socketRequesterContext.TryGetListener(ctx.Id, out var existingListener))
	      {
		      parentActivity = existingListener.Activity;
	      }
	      
	      
	      using var activity = _activityProvider.Create(Otel.TRACE_WS, parentActivity);
	      MicroserviceRequester.ContextActivity.Value = activity;
	      ctx.ActivityContext = activity;
	      

		  var extraOtelTags = _telemetryProviders.CreateRequestAttributes(InstanceArgs, ctx, ConnectionId);
	      activity.SetTags(extraOtelTags);


	      // First get the Global Realm Config Log Level and apply it by running UpdateLogLevel
	      var configService = InstanceArgs.ServiceScope.GetService<IRealmConfigService>();
	      if (ctx.Path?.StartsWith(_adminPrefix) ?? false)
	      {
		      // when the path starts with admin, use warning.
		      MicroserviceBootstrapper.ContextLogLevel.Value = LogLevel.Warning;
	      }
	      else
	      {
		      // otherwise, allow default behaviour.
		      configService.UpdateLogLevel();
	      }

	      string routingKey = InstanceArgs.GetRoutingKey().GetOrElse(string.Empty);
	      try
	      {
		      var loggingContextService = Provider.GetService<ILoggingContextService>();
		      BeamoV2ServiceLoggingContext loglevelContext = loggingContextService.GetLogLevelContext(MicroserviceName, routingKey);
		      
		      if (loglevelContext != null)
		      {
			      LogLevel contextLogLevel = loglevelContext.defaultLogLevel.ToMicrosoftLogLevel();
			      BeamoV2LogContextRule[] rules = loglevelContext.rules.GetOrElse(Array.Empty<BeamoV2LogContextRule>());
			      foreach (BeamoV2LogContextRule contextRule in rules)
			      { 
				      if(!contextRule.enabled)
					      continue;
				      
				      if (contextRule.expiresAt.HasValue)
				      {
					      var expiresAtDate = DateTimeOffset.FromUnixTimeMilliseconds(contextRule.expiresAt.Value).ToUniversalTime();
					      if (expiresAtDate <= DateTimeOffset.UtcNow)
					      {
						      // This rule is expired, continue to the next one
						      continue;
					      }
				      }
				      
				      LogLevel contextRuleLogLevel = contextRule.logLevel.ToMicrosoftLogLevel();
				      if (contextRule.ruleFilters.Length == 0)
				      {
					      // We're using Try To Set new Log Level to use always the minimum possible log level from each rule.
					      TryToSetNewLogLevel(contextRuleLogLevel);
					      continue;
				      }

				      bool hasValidFilter = false;
				      foreach (BeamoV2ContextRuleFilter ruleFilter in contextRule.ruleFilters)
				      {
					      // For each rule filter we need to check if the Path filter and User filter matches, both needs to be true for the filter to be valid
					      // if the filter for any is not set we consider it as true as well.

					      bool isPathFilterNotSet = !ruleFilter.paths.HasValue || !ruleFilter.pathsOperationType.HasValue || ruleFilter.paths.Value.Length == 0;
					      bool isPathFilterValid = isPathFilterNotSet || CheckRule(ruleFilter.paths, ruleFilter.pathsOperationType, ctx.Path);

					      bool isUserFilterNotSet = !ruleFilter.playerIds.HasValue || !ruleFilter.playerIdOperationType.HasValue  || ruleFilter.playerIds.Value.Length == 0;

					      // the account id is only available on some requests from beamable. 
					      bool isAccountFilterValid = false;
					      if (ctx.TryGetBeamContext(out var beamCtx, out _))
					      {
						      isAccountFilterValid = isUserFilterNotSet || CheckRule(ruleFilter.playerIds, ruleFilter.playerIdOperationType, beamCtx.accountId);
					      }
					      
					      bool isGamerTagFilterValid = isUserFilterNotSet || CheckRule(ruleFilter.playerIds, ruleFilter.playerIdOperationType, ctx.UserId);

					     hasValidFilter |= isPathFilterValid && (isAccountFilterValid || isGamerTagFilterValid);
				      }

				      if (hasValidFilter)
				      {
					      TryToSetNewLogLevel(contextRule.logLevel.ToMicrosoftLogLevel());
				      }
			      }

			   
			      MicroserviceBootstrapper.ContextLogLevel.Value = contextLogLevel;

			      void TryToSetNewLogLevel(LogLevel newLogLevel)
			      {
				      if (contextLogLevel > newLogLevel)
				      {
					      contextLogLevel = newLogLevel;
				      }
			      }

			      
		      }
	      }
	      catch (Exception ex)
	      {
		      BeamableZLoggerProvider.Instance.Error(ex);
	      }

	      
		  var logger = BeamableZLoggerProvider.LogContext.Value = InstanceArgs.ServiceScope.GetLogger<BeamableMicroService>();
	      using var scope = logger.BeginScope(extraOtelTags.ToDictionary());
	      
	      try
	      {
		      using var tokenSource = new CancellationTokenSource();
		      ctx.CancellationToken = tokenSource.Token;
		      tokenSource.CancelAfter(TimeSpan.FromSeconds(InstanceArgs.RequestCancellationTimeoutSeconds));
		      if (_socketRequesterContext.IsPlatformMessage(ctx))
		      {
			      // the request is a platform request.
			      await HandlePlatformMessage(ctx, activity);
		      }
		      else
		      {
			      // this is a client request. Handle the service method.
			      await HandleClientMessage(ctx, sw, activity);
		      }

		      // activity.SetStatus(ActivityStatusCode.Ok);
	      }
	      finally
	      {
		      // empty block?
	      }
      }
      
      private bool CheckRule(string[] values, BeamoV2PathRuleOperationType operationType, string valueToCheck)
      {
	      switch (operationType)
	      {
		      case BeamoV2PathRuleOperationType.Include:
			      return values.Contains(valueToCheck);
		      case BeamoV2PathRuleOperationType.Contain:
			      return values.Any(valueToCheck.Contains);
		      case BeamoV2PathRuleOperationType.StartsWith:
			      return values.Any(item => item.StartsWith(valueToCheck));
		      case BeamoV2PathRuleOperationType.EndsWith:
			      return values.Any(item => item.EndsWith(valueToCheck));
		      default:
			      return false;
	      }
      }
      
      private bool CheckRule(long[] values, BeamoV2PlayerRuleOperationType operationType, long valueToCheck)
      {
	      switch (operationType)
	      {
		      case BeamoV2PlayerRuleOperationType.Include:
			      return values.Contains(valueToCheck);
		      case BeamoV2PlayerRuleOperationType.GreaterThan:
			      return values.Any(item => valueToCheck > item);
		      case BeamoV2PlayerRuleOperationType.LesserThan:
			      return values.Any(item => valueToCheck < item);
		      default:
			      return false;
	      }
      }

      [Obsolete("this value is no longer available.")]
      public Type MicroserviceType { get; private set; }


      private async Task CloseConnection(IConnection ws, bool wasClean)
      {
         Log.Debug("Closing socket connection... clean=[{clean}] isShuttingDown=[{shuttingDown}]", wasClean, IsShuttingDown);
         if (!IsShuttingDown)
         {
            Log.Debug("ws connection dropped...");
            _webSocketPromise = AttemptConnection();
            var socket = await _webSocketPromise;
            await SetupWebsocket(socket);
         }
         else
         {
            _socketRequesterContext.HandleCloseConnection();
         }
      }

      private async Promise ProvideService()
      {
	      var req = new MicroserviceServiceProviderRequest
	      {
		      type = "basic", 
		      name = QualifiedName,
		      beamoName = MicroserviceName,
		      microServiceId = _microServiceId,
	      };
	      if (InstanceArgs.TryGetRoutingKey(out var routingKey))
	      {
		      req.routingKey = routingKey;
	      }

	      if (InstanceArgs.AccountId > 0)
	      {
		      req.startedById = InstanceArgs.AccountId;
	      }

	      var serviceProviderTask = _requester.Request<MicroserviceProviderResponse>(
		      method: Method.POST,
		      uri: "gateway/provider",
		      body: req.ToJson());
	      _ = serviceProviderTask.Then(_ => Log.Debug(Constants.Features.Services.Logs.SERVICE_PROVIDER_INITIALIZED));

	      var eventProvider = _serviceAttribute.DisableAllBeamableEvents
		      ? PromiseBase.SuccessfulUnit
		      : _requester.InitializeSubscription().Then(res =>
		      {
			      Log.Debug(Constants.Features.Services.Logs.EVENT_PROVIDER_INITIALIZED);
		      }).ToUnit();

	      await serviceProviderTask;
	      await RegisterFederation(routingKey);
	      await eventProvider;
      }

      private async Promise RegisterFederation(string routingKey)
      {
	      if (InstanceArgs.DisableCustomInitializationHooks) 
		      return; // if this is a health-check, then we aren't going to auto-register federation at all.
	      
	      
	      IBeamoApi api = new BeamoApi(_requester);
	      var federationRequest = new MicroserviceRegistrationRequest
	      {
		      serviceName = QualifiedName, 
		      trafficFilterEnabled = true,
		      federation = new OptionalArrayOfSupportedFederation(FederationComponents.Select(component =>
		      {
			      var idToUse = component.identity.GetUniqueName();
			      var typeToUse = FederatedComponentGenerator.GetFederationType(component.typeName);
			      var settingsToUse = new OptionalJsonString();
			      if (!string.IsNullOrEmpty(routingKey))
			      {
				      var builtSettings = BuiltSettings.ReadBuiltSettings();
				      foreach (var kvp in builtSettings)
				      {
					      if (FederationUtils.TrySplitLocalSettingKey(kvp.Key, out FederationType fedType, out var fedId) &&
					          (fedType == typeToUse && fedId == idToUse))
					      {
						      settingsToUse.Set(JsonString.FromJson(kvp.Value));
					      }
				      }
			      }
			      
			      return new SupportedFederation
			      {
				      nameSpace = idToUse, type = typeToUse, settings = settingsToUse
			      };
		      }).ToArray())
	      };
	      if (!string.IsNullOrEmpty(routingKey))
	      {
		      federationRequest.routingKey = routingKey;
	      }

	      try
	      {
		      var response = await api.PutMicroserviceFederationTraffic(federationRequest);
		      Log.Verbose($"Registered federation. result=[{response.result}], routes=[{string.Join(",",response.data.Select(kvp => $"{kvp.Key}->{kvp.Value}"))}]");
	      }
	      catch (Exception ex)
	      {
		      Log.Error($"Failed to register federation components. {ex.Message}");
	      }
      }

      private Promise<Unit> RemoveService(string name)
      {
         var req = new MicroserviceServiceProviderRequest
         {
            type = "basic",
            name = name
         };
         var serviceProvider = _requester.Request<MicroserviceProviderResponse>(Method.DELETE, "gateway/provider", req.ToJson()).Then(res =>
         {
            RefuseNewClientMessages = true;
            Log.Debug("Service provider removed");
         }).ToUnit();
         return Promise.Sequence(serviceProvider).ToUnit();
      }
   }
}
