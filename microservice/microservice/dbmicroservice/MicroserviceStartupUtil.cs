using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated;
using Beamable.Api.Autogenerated.Beamootel;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Content;
using Beamable.Common.Api.Leaderboards;
using Beamable.Common.Api.Realms;
using Beamable.Common.Api.Stats;
using Beamable.Common.BeamCli;
using Beamable.Common.BeamCli.Contracts;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Common.Reflection;
using Beamable.Common.Scheduler;
using beamable.microservice.otel.exporter;
using Beamable.Server.Api;
using Beamable.Server.Api.Analytics;
using Beamable.Server.Api.Announcements;
using Beamable.Server.Api.Calendars;
using Beamable.Server.Api.Chat;
using Beamable.Server.Api.CloudData;
using Beamable.Server.Api.Commerce;
using Beamable.Server.Api.Content;
using Beamable.Server.Api.Events;
using Beamable.Server.Api.Groups;
using Beamable.Server.Api.Inventory;
using Beamable.Server.Api.Leaderboards;
using Beamable.Server.Api.Logs;
using Beamable.Server.Api.Mail;
using Beamable.Server.Api.Notifications;
using Beamable.Server.Api.Payments;
using Beamable.Server.Api.Push;
using Beamable.Server.Api.RealmConfig;
using Beamable.Server.Api.Scheduler;
using Beamable.Server.Api.Social;
using Beamable.Server.Api.Stats;
using Beamable.Server.Api.Tournament;
using Beamable.Server.Api.Usage;
using Beamable.Server.Common;
using Beamable.Server.Content;
using Beamable.Server.Ecs;
using Beamable.Tooling.Common;
using beamable.tooling.common.Microservice;
using Beamable.Tooling.Common.OpenAPI;
using microservice;
using microservice.dbmicroservice;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.OpenApi;
using Microsoft.OpenApi.Extensions;
using Newtonsoft.Json;
using OpenTelemetry;
using OpenTelemetry.Exporter;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using ZLogger;
using ZLogger.Formatters;
using Debug = UnityEngine.Debug;

namespace Beamable.Server;

public static class MicroserviceStartupUtil
{
	public static async Task<MicroserviceResult> Begin(IBeamServiceConfig configurator)
	{
		// de-duplicate any route information.
		configurator.RouteSources = configurator.RouteSources.DistinctBy(d => d.InstanceType).ToList();
		
		var configuredArgs = configurator.Args.Copy();

		var startupCtx = new StartupContext
		{
			args = configuredArgs,
			routeSources = configurator.RouteSources.ToArray(),
			attributes = configurator.Attributes,
			
#pragma warning disable CS0618 // Type or member is obsolete
			localEnvArgs = configurator.LocalEnvCustomArgs,
#pragma warning restore CS0618 // Type or member is obsolete
			
			generateLocalEnvInvocationModifier = configurator.LocalEnvModifier ?? (_ => { }),
			initializers = configurator.ServiceInitializers.ToList()
		};

		ConfigureLogging(configurator, startupCtx, includeOtel: false, string.Empty);

		if (startupCtx.IsGeneratingOapi)
		{
			LogUtil.TryParseSystemLogLevel(configuredArgs.OapiGenLogLevel, out var defaultLevel, LogLevel.Information);
			MicroserviceBootstrapper.ContextLogLevel.Value = defaultLevel;
			await GenerateOpenApiSpecification(startupCtx, configurator);
			startupCtx.result.GeneratedClient = true;
			return startupCtx.result;
		}
		
		// TODO: Insert Break

		startupCtx.logger.LogInformation($"Starting Prepare");

		if (!startupCtx.args.SkipLocalEnv && !startupCtx.InDocker)
		{
			await GetLocalEnvironment(startupCtx);
			var freshEnvArgs = new EnvironmentArgs();
			configuredArgs.Host = freshEnvArgs.Host;
			configuredArgs.LogLevel = freshEnvArgs.LogLevel;
			configuredArgs.CustomerID = freshEnvArgs.CustomerID;
			configuredArgs.ProjectName = freshEnvArgs.ProjectName;
			configuredArgs.Secret = freshEnvArgs.Secret;
			configuredArgs.NamePrefix = freshEnvArgs.NamePrefix;
			configuredArgs.BeamInstanceCount = freshEnvArgs.BeamInstanceCount;
			configuredArgs.RefreshToken = freshEnvArgs.RefreshToken;
			configuredArgs.AccountId = freshEnvArgs.AccountId;
			configuredArgs.AccountEmail = freshEnvArgs.AccountEmail;
		}

		ConfigureRequiredProcessIdWatcher(startupCtx);

		await ConfigureOtelCollector(startupCtx);

		ConfigureOtelData(startupCtx);
		ConfigureLogging(configurator, startupCtx, includeOtel: true,
			otlpEndpoint: startupCtx.otlpEndpoint);
		ConfigureTelemetry(startupCtx);


		ConfigureUncaughtExceptions(startupCtx);
		ConfigureUnhandledError();
		_ = ConfigureDiscovery(startupCtx);
		await ConfigureUsageService(startupCtx);
		startupCtx.reflectionCache = ConfigureReflectionCache(startupCtx);

		// configure the root service scope, and then build the root service provider.
		var serviceBuilder = ConfigureServices(startupCtx, configurator);


		// TODO: Insert Break

		var rootServiceScope = serviceBuilder.Build(new BuildOptions
		{
			allowHydration = false
		});

		InitializeServices(rootServiceScope);
		rootServiceScope.GetService<FederationMetadata>().Components =
			FederatedComponentGenerator.FindFederatedComponents(startupCtx);


		var resolvedCid = await ConfigureCid(startupCtx.args);
		var args = startupCtx.args.Copy(conf =>
		{
			conf.ServiceScope = rootServiceScope;
			conf.CustomerID = resolvedCid;
		});

		// TODO: Insert Break


		for (var i = 0; i < args.BeamInstanceCount; i++)
		{
			var isFirstInstance = i == 0;
			var beamableService = new BeamableMicroService();
			var instanceArgs = args.Copy(conf =>
			{
				// only the first instance needs to run, if anything should run at all.
				conf.DisableCustomInitializationHooks |= !isFirstInstance;
			});
			startupCtx.services.Add(beamableService);

			if (isFirstInstance)
			{
				configurator.FirstConnectionHandler?.Invoke(beamableService);
				var localDebug = new ContainerDiagnosticService(instanceArgs, beamableService, startupCtx.debugLogProcessor);
				var runningDebugTask = localDebug.Run();
			}

			//In case that SdkVersionExecution is null or empty, we are executing it locally with dotnet and
			//therefore getting dependencies through nuget, so not required to check versions mismatch.
			if (!string.IsNullOrEmpty(args.SdkVersionExecution) &&
			    !string.Equals(args.SdkVersionExecution, args.SdkVersionBaseBuild))
			{
				startupCtx.logger.ZLogCritical(
					$"Version mismatch. Image built with {args.SdkVersionBaseBuild}, but is executing with {args.SdkVersionExecution}. This is a fatal mistake.");
				throw new Exception(
					$"Version mismatch. Image built with {args.SdkVersionBaseBuild}, but is executing with {args.SdkVersionExecution}. This is a fatal mistake.");
			}

			try
			{
				await beamableService.Start(instanceArgs, startupCtx);
				if (isFirstInstance && (startupCtx.attributes?.EnableEagerContentLoading ?? false))
				{
					await rootServiceScope.GetService<ContentService>().initializedPromise;
				}
			}
			catch (Exception ex)
			{
				var message = new StringBuilder(1024 * 10);

				if (ex is not BeamableMicroserviceException beamEx)
					message.AppendLine(
						$"[BeamErrorCode=BMS{BeamableMicroserviceException.kBMS_UNHANDLED_EXCEPTION_ERROR_CODE}]" +
						$" Unhandled Exception Found! Please notify Beamable of your use case that led to this.");
				else
					message.AppendLine($"[BeamErrorCode=BMS{beamEx.ErrorCode}] " +
					                   $"Beamable Exception Found! If the message is unclear, please contact Beamable with your feedback.");

				message.AppendLine("Exception Info:");
				message.AppendLine($"Name={ex.GetType().Name}, Message={ex.Message}");
				message.AppendLine("Stack Trace:");
				message.AppendLine(ex.StackTrace);
				startupCtx.logger.LogCritical(message.ToString());
				throw;
			}

			var _ = beamableService.RunForever();
		}

		startupCtx.result.Success = true;
		return startupCtx.result;

	}


	private static async Task GenerateOpenApiSpecification(StartupContext startupCtx, IBeamServiceConfig configurator)
	{
		var builder = ConfigureServices(startupCtx, configurator);
		var provider = builder.Build(new BuildOptions
		{
			allowHydration = false
		});
		
		var generator = new ServiceDocGenerator();
		var doc = generator.Generate(startupCtx, provider);

		var outputString = doc.Serialize(OpenApiSpecVersion.OpenApi3_0, OpenApiFormat.Json);

		var beamableFolderPath = Environment.GetEnvironmentVariable("OPEN_API_OUTPUT_PATH")
		                         ?? throw new InvalidOperationException(
			                         "OPEN_API_OUTPUT_PATH environment variable not set");

		Log.Information($"Generating Open API document. beam-path=[{beamableFolderPath}]");

		string directoryPath = Path.GetFullPath(beamableFolderPath);
		if (!Directory.Exists(directoryPath))
		{
			Directory.CreateDirectory(directoryPath);
		}

		Log.Information($"Generating Open API document at path=[{directoryPath}]");
		await File.WriteAllTextAsync(Path.Combine(directoryPath, Constants.OPEN_API_FILE_NAME), outputString);
	}

	private static async Task ConfigureOtelCollector(StartupContext ctx)
	{
		if (ctx.args.OtelExporterStandardEnabled)
		{
			CancellationTokenSource tokenSource = new CancellationTokenSource();
			var status = await CollectorManager.IsCollectorRunning(tokenSource.Token, ctx.logger);

			if (status.isRunning)
			{
				ctx.otlpEndpoint = $"http://{status.otlpEndpoint}";
			}
			else
			{
				ctx.otlpEndpoint = PortUtil.FreeEndpoint();
			}

			if (!status.isRunning)
			{
				var existing = CollectorManager.GetAuthFromEnvironment();
				if (!existing.HasAll)
				{
					ctx.logger.ZLogInformation($"Sending request to get clickhouse credentials...");
					var requester = GenerateTemporarySignedRequester(new EnvironmentArgs());
					var otelApi = new BeamBeamootelApi(requester);
					var res = await otelApi.GetOtelAuthWriterConfig();

					CollectorManager.AddAuthEnvironmentVars(res);
				}
				else
				{
					ctx.logger.ZLogInformation($"Reading environment to get clickhouse credentials...");
				}
				CollectorManager.AddCollectorConfigurationToEnvironment();
			}

			ctx.logger.ZLogInformation($"Starting otel collector discovery event...");
			await CollectorManager.StartCollector("", false, false, tokenSource, ctx.logger, ctx.otlpEndpoint);
		}

	}

	private static void ConfigureOtelData(StartupContext startupCtx)
	{
		var activityProvider =
			DefaultActivityProvider.CreateMicroServiceProvider(startupCtx.args, startupCtx.attributes);
		startupCtx.activityProvider = activityProvider;

		var ctx = new DefaultAttributeContext
		{
			Attributes = new TelemetryAttributeCollection(),
			Args = startupCtx.args
		};
		// TODO: allow customer to override the attributes

		// run the standard provider *AFTER* the user level stuff, so that
		//  standard beamable attributes overwrite conflicting user attributes.
		//  Ex: It is not valid for a user to override what "cid" does. 
		startupCtx.standardBeamTelemetryAttributes.CreateDefaultAttributes(ctx);

		startupCtx.resourceProvider = ResourceBuilder.CreateEmpty()
			.AddService(activityProvider.ServiceName, activityProvider.ServiceNamespace,
				autoGenerateServiceInstanceId: false,
				serviceInstanceId: activityProvider.ServiceId)
			.AddAttributes(ctx.Attributes.ToDictionary());
	}


	private static IBeamableRequester GenerateTemporarySignedRequester(EnvironmentArgs args)
	{
		var userContext = new SingleUseUserContext();
		var config = new DefaultSignedRequesterConfig
		{
			Host = args.Host
				.Replace("ws://", "http://")
				.Replace("wss://", "https://")
				.Replace("/socket/", "")
				.Replace("/socket", ""),
			RealmSecretGenerator = () => Promise<string>.Successful(args.Secret)
		};

		return new HttpSignedRequester(config, args, userContext);
	}


	public static ZLoggerOptions UseBeamJsonFormatter(ZLoggerOptions options)
	{
		return options.UseJsonFormatter(x =>
		{
			// these settings mirror what the default Serilog settings did in CLI 4.x
			//  but in CLI 5, we migrated to ZLogger. For compat reasons, we want
			//  the log settings to be as similar as possible. 
			x.UseUtcTimestamp = true;
			x.IncludeProperties = IncludeProperties.LogLevel
			                      | IncludeProperties.Message
			                      | IncludeProperties.Timestamp
			                      | IncludeProperties.Exception
				;
			x.JsonPropertyNames = JsonPropertyNames.Default with
			{
				LogLevel = JsonEncodedText.Encode("__l"),
				Message = JsonEncodedText.Encode("__m"),
				Timestamp = JsonEncodedText.Encode("__t"),
				Exception = JsonEncodedText.Encode("__e"),
			};
		});
	}

	private static void ConfigureLogging(IBeamServiceConfig configurator, StartupContext ctx, bool includeOtel,
		string otlpEndpoint)
	{
		if (configurator.LogFactory != null)
		{
			BeamableLogProvider.Provider = new BeamableZLoggerProvider();
			Debug.Instance = new MicroserviceDebug();
			ctx.logger = configurator.LogFactory();
			BeamableZLoggerProvider.SetLogger(ctx.logger);
			return;
		}

		if (!LogUtil.TryParseSystemLogLevel(ctx.args.LogLevel, out var defaultLogLevel))
		{
			defaultLogLevel = LogLevel.Warning;
		}

		MicroserviceBootstrapper.ContextLogLevel.Value = defaultLogLevel;

		var debugLogOptions = UseBeamJsonFormatter(new ZLoggerOptions());
		ctx.debugLogProcessor = new DebugLogProcessor(debugLogOptions);
		
		ctx.logFactory = LoggerFactory.Create(builder =>
		{
			// TODO: handle per-route / config options

			// all logs are valid, but may not pass the filter. 
			builder.SetMinimumLevel(LogLevel.Trace);

			builder.AddFilter(level => level >= MicroserviceBootstrapper.ContextLogLevel.Value);
			if (!ctx.InDocker)
			{
				builder.AddZLoggerLogProcessor(ctx.debugLogProcessor);
			}

			var shouldIncludeOtel = ctx.InDocker || ctx.args.UseLocalOtel;
			
			if (includeOtel && shouldIncludeOtel)
			{
				builder.AddOpenTelemetry(logging =>
				{
					// https://signoz.io/blog/opentelemetry-dotnet-logs/
					logging.IncludeScopes = true;
					logging
						.SetResourceBuilder(ctx.resourceProvider)
						.AddMicroserviceExporter(option =>
						{

							if (!string.IsNullOrEmpty(ctx.args.OtelExporterOtlpEndpoint) &&
							    !string.IsNullOrEmpty(ctx.args.OtelExporterOtlpProtocol))
							{
								option.Protocol = (OtlpExportProtocol)Enum.Parse(typeof(OtlpExportProtocol),
									ctx.args.OtelExporterOtlpProtocol);
								option.OtlpEndpoint = ctx.args.OtelExporterOtlpEndpoint;
							}
							else if (ctx.args.OtelExporterStandardEnabled)
							{
								option.Protocol = OtlpExportProtocol.HttpProtobuf;
								option.OtlpEndpoint = otlpEndpoint;
							}

							option.ShouldRetry = ctx.args.OtelExporterShouldRetry;

							if (!string.IsNullOrEmpty(ctx.args.OtelExporterRetryMaxSize))
							{
								option.RetryQueueMaxSize = int.Parse(ctx.args.OtelExporterRetryMaxSize);
							}
						});
				});
			}

			switch (ctx.args.LogOutputType)
			{
				case LogOutputType.DEFAULT when !ctx.InDocker:
				case LogOutputType.UNSTRUCTURED:
					builder.AddZLoggerConsole(opts => { opts.UsePlainTextFormatter(); });

					break;

				case LogOutputType.FILE:
					builder.AddZLoggerFile(ctx.args.LogOutputPath ?? "./service.log");
					break;

				case LogOutputType.STRUCTURED_AND_FILE:

					builder.AddZLoggerConsole(opts => { UseBeamJsonFormatter(opts); });
					builder.AddZLoggerFile(ctx.args.LogOutputPath ?? "./service.log");

					break;
				case LogOutputType.DEFAULT
					: // when inDocker: // logically, think of this as having inDocker==true, but technically because the earlier case checks for !inDocker, its redundant.
				case LogOutputType.STRUCTURED:
				default:
					builder.AddZLoggerConsole(opts => { UseBeamJsonFormatter(opts); });
					break;
			}

		});


		// use newtonsoft for JsonUtility
		JsonUtilityConverter.Init();

		BeamableLogProvider.Provider = new BeamableZLoggerProvider();
		Debug.Instance = new MicroserviceDebug();
		ctx.logger = ctx.logFactory.CreateLogger<Microservice>();
		BeamableZLoggerProvider.SetLogger(ctx.logger);
	}

	public static void ConfigureUnhandledError()
	{
		PromiseBase.SetPotentialUncaughtErrorHandler((promise, exception) =>
		{
			async Task DelayedCheck()
			{
				await Task.Delay(1);
				;
				if (promise?.HadAnyErrbacks ?? true) return;

				BeamableLogger.LogError("Uncaught promise error. {promiseType} {message} {stack}", promise.GetType(),
					exception.Message, exception.StackTrace);
				throw exception;
			}

			_ = Task.Run(DelayedCheck);
		});
	}

	public static void ConfigureUncaughtExceptions(StartupContext ctx)
	{
		AppDomain.CurrentDomain.UnhandledException += (sender, args) =>
		{
			Console.Error.WriteLine($"Uncaught exception error!!! {args.ExceptionObject.GetType().Name}");
			if (args.ExceptionObject is Exception ex)
			{
				Console.Error.WriteLine($"{ex.Message} -- {ex.StackTrace}");
			}

			ctx.logger.ZLogCritical($"Unhandled exception. type=[{args.ExceptionObject?.GetType()?.Name}]");
		};
	}

	public static ReflectionCache ConfigureReflectionCache(StartupContext ctx)
	{

		{
			// unless the referenced assemblies are explicitly loaded, 
			//  it is likely that content types will be missed when. 
			//  dotnet has not _loaded_ those assemblies yet, so the 
			//  reflection cache sweep will miss them. 
			var referencedAssemblies = Assembly.GetEntryAssembly().GetReferencedAssemblies();
			foreach (var asm in referencedAssemblies)
			{
				Assembly.Load(asm);
			}
		}

		var reflectionCache = new ReflectionCache();
		var contentTypeReflectionCache = new ContentTypeReflectionCache();
		var mongoIndexesReflectionCache = new MongoIndexesReflectionCache();

		reflectionCache.RegisterTypeProvider(contentTypeReflectionCache);
		reflectionCache.RegisterReflectionSystem(contentTypeReflectionCache);
		reflectionCache.RegisterTypeProvider(mongoIndexesReflectionCache);
		reflectionCache.RegisterReflectionSystem(mongoIndexesReflectionCache);

		var relevantAssemblyNames = AppDomain.CurrentDomain.GetAssemblies()
			.Select(asm => asm.GetName().Name)
			.Where(asmName =>
			{
				if (string.IsNullOrEmpty(asmName))
				{
					return false;
				}

				return !asmName.StartsWith("System.") &&
				       !asmName.StartsWith("nunit.") &&
				       !asmName.StartsWith("JetBrains.") &&
				       !asmName.StartsWith("Microsoft.") &&
				       !asmName.StartsWith("MongoDB.") &&
				       !asmName.StartsWith("Serilog.")
				       ;
			})
				
			.ToList();
		ctx.logger.ZLogDebug(
			$"Generating Reflection Cache over Assemblies => {string.Join('\n', relevantAssemblyNames)}");
		reflectionCache.GenerateReflectionCache(relevantAssemblyNames);

		return reflectionCache;
	}

	public static IDependencyBuilder ConfigureServices(StartupContext startupContext, IBeamServiceConfig configurator)
	{
		startupContext.logger.LogDebug(Constants.Features.Services.Logs.REGISTERING_STANDARD_SERVICES);
		var attribute = startupContext.attributes;
		var envArgs = startupContext.args;
		try
		{
			var collection = new DependencyBuilder();
			foreach (var type in startupContext.routeSources)
			{
				collection.AddScoped(type.InstanceType);
			}

			collection
				.AddSingleton(startupContext)
				.AddSingleton(attribute)

				// for legacy reasons, we should keep the MicroserviceAttribute in DI.
				//  it existed for a long time, and customers could be relying on it in their
				//  custom DI containers. 
				.AddSingleton<MicroserviceAttribute>(() =>
				{
					return new MicroserviceAttribute(attribute.MicroserviceName)
					{
						CustomAutoGeneratedClientPath = attribute.CustomAutoGeneratedClientPath,
						DisableAllBeamableEvents = attribute.DisableAllBeamableEvents,
						EnableEagerContentLoading = attribute.EnableEagerContentLoading,
#pragma warning disable CS0618 // Type or member is obsolete
						UseLegacySerialization = attribute.UseLegacySerialization
#pragma warning restore CS0618 // Type or member is obsolete
					};
				})
				.AddSingleton<IActivityProvider>(startupContext.activityProvider)
				.AddSingleton<ILoggerFactory>(startupContext.logFactory)
				.AddSingleton<IBeamSchedulerContext, SchedulerContext>()
				.AddSingleton<BeamScheduler>()
				.AddSingleton<FederationMetadata>()
				.AddSingleton<IUsageApi>(startupContext.ecsService)
				.AddScoped<IDependencyProvider>(provider => new MicrosoftServiceProviderWrapper(provider))
				.AddScoped<IRealmInfo>(provider => provider.GetService<IMicroserviceArgs>())
				.AddScoped<IBeamableRequester>(p => p.GetService<MicroserviceRequester>())
				.AddScoped<IRequester>(p => p.GetService<MicroserviceRequester>())
				.AddScoped<IHttpRequester, MicroserviceHttpRequester>(() =>
				{
					HttpClientHandler handler = new HttpClientHandler()
					{
						AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
					};
					return new MicroserviceHttpRequester(envArgs, new HttpClient(handler));
				})
				.AddSingleton<IMicroserviceArgs>(envArgs)
				.AddSingleton<SocketRequesterContext>(_ => { return startupContext.services[0].SocketContext; })
				.AddScoped<MicroserviceRequester>(provider =>
					new MicroserviceRequester(
						provider.GetService<IMicroserviceArgs>(),
						provider.GetService<RequestContext>(),
						provider.GetService<SocketRequesterContext>(),
						true,
						provider.GetService<IActivityProvider>()))
				.AddScoped<IUserContext>(provider => provider.GetService<RequestContext>())
				.AddScoped<IMicroserviceAuthApi, ServerAuthApi>()
				.AddScoped<IMicroserviceStatsApi, MicroserviceStatsApi>()
				.AddScoped<IStatsApi, MicroserviceStatsApi>()
				.AddSingleton(new RequestContext(envArgs.CustomerID, envArgs.ProjectName))
				.AddSingleton<ContentService>(p => CreateNewContentService(
					p.GetService<MicroserviceRequester>(),
					p.GetService<SocketRequesterContext>(),
					p.GetService<IContentResolver>(),
					p.GetService<ReflectionCache>()
				))
				.AddSingleton<ISignedRequesterConfig, DefaultSignedRequesterConfig>(() =>
					new DefaultSignedRequesterConfig
					{
						Host = envArgs.Host
							.Replace("ws://", "http://")
							.Replace("wss://", "https://")
							.Replace("/socket/", "")
							.Replace("/socket", ""),
						RealmSecretGenerator = () => Promise<string>.Successful(envArgs.Secret)
					})
				.AddScoped(p => new HttpSignedRequester(p.GetService<ISignedRequesterConfig>(),
					p.GetService<IRealmInfo>(), p.GetService<RequestContext>()))
				.AddScoped<ISignedRequester>(p => p.GetService<HttpSignedRequester>())
				.AddSingleton<IMicroserviceContentApi>(p => p.GetService<ContentService>())
				.AddSingleton<IContentApi>(p => p.GetService<ContentService>())
				.AddSingleton<IContentResolver, DefaultContentResolver>()
				.AddSingleton<IConnectionProvider, EasyWebSocketProvider>()
				.AddSingleton<IAliasService, AliasService>()
				.AddScoped<IMicroserviceInventoryApi, MicroserviceInventoryApi>()
				.AddScoped<IMicroserviceGroupsApi, MicroserviceGroupsApi>()
				.AddScoped<IMicroserviceAnalyticsService, MicroserviceAnalyticsService>(p =>
					new MicroserviceAnalyticsService(p.GetService<RequestContext>(), p.GetService<ISignedRequester>()))
				.AddScoped<IMicroserviceTournamentApi, MicroserviceTournamentApi>()
				.AddScoped<IMicroserviceLeaderboardsApi, MicroserviceLeaderboardApi>()
				.AddScoped<IMicroserviceAnnouncementsApi, MicroserviceAnnouncementsApi>()
				.AddScoped<IMicroserviceCalendarsApi, MicroserviceCalendarsApi>()
				.AddScoped<IMicroserviceEventsApi, MicroserviceEventsApi>()
				.AddScoped<IMicroserviceMailApi, MicroserviceMailApi>()
				.AddScoped<IMicroserviceNotificationsApi, MicroserviceNotificationApi>()
				.AddScoped<IMicroserviceSocialApi, MicroserviceSocialApi>()
				.AddScoped<IMicroserviceCloudDataApi, MicroserviceCloudDataApi>()
				.AddSingleton<IMicroserviceRealmConfigService>(p => p.GetService<RealmConfigService>())
				.AddSingleton<IRealmConfigService>(p => p.GetService<RealmConfigService>())
				.AddSingleton<RealmConfigService>()
				.AddScoped<IMicroserviceCommerceApi, MicroserviceCommerceApi>()
				.AddScoped<IMicroservicePaymentsApi, MicroservicePaymentsApi>()
				.AddScoped<IMicroservicePushApi, MicroservicePushApi>()
				.AddSingleton<IStorageObjectConnectionProvider, StorageObjectConnectionProvider>()
				.AddSingleton<MongoSerializationService>()
				.AddSingleton<IMongoSerializationService>(p => p.GetService<MongoSerializationService>())
				.AddScoped<IMicroserviceChatApi, MicroserviceChatApi>()
				.AddSingleton(startupContext.reflectionCache)
				.AddSingleton<IBeamBeamootelApi, BeamBeamootelApi>()

				.AddScoped<UserDataCache<Dictionary<string, string>>.FactoryFunction>(provider =>
					StatsCacheFactory)
				.AddScoped<UserDataCache<RankEntry>.FactoryFunction>(provider => LeaderboardRankEntryFactory)
				.AddScoped<IBeamableServices>(ExtractSdks)

				// allow the DI system to get a list of all telemetry attribute providers...
				//  _INCLUDING_ the standard Beamable one, which should be registered _LAST_
				.AddSingleton<SingletonDependencyList<ITelemetryAttributeProvider>>()
				.AddSingleton<ILoggingContextService, LoggingContextService>()
				;
			OpenApiRegistration.RegisterOpenApis(collection);

			startupContext.logger.LogDebug(Constants.Features.Services.Logs.REGISTERING_CUSTOM_SERVICES);
			var builder = new DefaultServiceBuilder(collection);

			// Gets Service Configuration Methods

			var configurationMethods = startupContext.routeSources
				.Select(t => t.InstanceType)
				.SelectMany(type =>
				{
					return type.GetMethods(BindingFlags.Static | BindingFlags.Public)
						.Where(method => method.GetCustomAttribute<ConfigureServicesAttribute>() != null)
						.Select(method =>
						{
							var attr = method.GetCustomAttribute<ConfigureServicesAttribute>();
							return (method, attr);
						})
						.ToList();
				}).ToList();

			// Sorts them by an user-defined order. By default (and tie-breaking), is sorted in file declaration order.
			configurationMethods.Sort(delegate((MethodInfo method, ConfigureServicesAttribute attr) t1,
				(MethodInfo method, ConfigureServicesAttribute attr) t2)
			{
				var (_, attr1) = t1;
				var (_, attr2) = t2;
				return attr1.ExecutionOrder.CompareTo(attr2.ExecutionOrder);
			});

			// Invokes each Service Configuration Method --- skips any that do not match the void(IServiceBuilder) signature.
			foreach (var (configurationMethod, _) in configurationMethods)
			{
				// TODO: Add compile-time check for this signature
				var parameters = configurationMethod.GetParameters();
				if (parameters.Length != 1 || parameters[0].ParameterType != typeof(IServiceBuilder)) continue;

				try
				{
					configurationMethod.Invoke(null, new object[] { builder });
				}
				catch (Exception ex)
				{
					BeamableLogger.LogError("Configuration method failed. " + ex.Message + " {stacktrace}",
						ex.StackTrace);
					BeamableLogger.LogException(ex);
					throw;
				}
			}


			// inject services we want to configure *AFTER* the user-level. 
			//  these services are ones that we do not want the user to be able to override. 
			collection.AddSingleton(startupContext.standardBeamTelemetryAttributes);

			foreach (var serviceConfiguration in configurator.ServiceConfigurations)
			{
				serviceConfiguration(collection);
			}
			return collection;
		}
		catch (Exception ex)
		{
			BeamableLogger.LogError("Registering services failed. " + ex.Message);
			BeamableLogger.LogException(ex);
			throw;
		}

		ContentService CreateNewContentService(MicroserviceRequester requester, SocketRequesterContext socket,
			IContentResolver contentResolver, ReflectionCache reflectionCache)
		{
			return attribute.DisableAllBeamableEvents
				? new UnreliableContentService(requester, socket, contentResolver, reflectionCache)
				: new ContentService(requester, socket, contentResolver, reflectionCache);
		}

		UserDataCache<Dictionary<string, string>> StatsCacheFactory(string name, long ttlms,
			UserDataCache<Dictionary<string, string>>.CacheResolver resolver, IDependencyProvider provider)
		{
			return new EphemeralUserDataCache<Dictionary<string, string>>(name, resolver);
		}

		UserDataCache<RankEntry> LeaderboardRankEntryFactory(string name, long ttlms,
			UserDataCache<RankEntry>.CacheResolver resolver, IDependencyProvider provider)
		{
			return new EphemeralUserDataCache<RankEntry>(name, resolver);
		}

		IBeamableServices ExtractSdks(IServiceProvider provider)
		{
			var services = new BeamableServices
			{
				Analytics = provider.GetRequiredService<IMicroserviceAnalyticsService>(),
				Auth = provider.GetRequiredService<IMicroserviceAuthApi>(),
				Stats = provider.GetRequiredService<IMicroserviceStatsApi>(),
				Content = provider.GetRequiredService<IMicroserviceContentApi>(),
				Inventory = provider.GetRequiredService<IMicroserviceInventoryApi>(),
				Leaderboards = provider.GetRequiredService<IMicroserviceLeaderboardsApi>(),
				Announcements = provider.GetRequiredService<IMicroserviceAnnouncementsApi>(),
				Calendars = provider.GetRequiredService<IMicroserviceCalendarsApi>(),
				Events = provider.GetRequiredService<IMicroserviceEventsApi>(),
				Groups = provider.GetRequiredService<IMicroserviceGroupsApi>(),
				Mail = provider.GetRequiredService<IMicroserviceMailApi>(),
				Notifications = provider.GetRequiredService<IMicroserviceNotificationsApi>(),
				Social = provider.GetRequiredService<IMicroserviceSocialApi>(),
				Tournament = provider.GetRequiredService<IMicroserviceTournamentApi>(),
				TrialData = provider.GetRequiredService<IMicroserviceCloudDataApi>(),
				RealmConfig = provider.GetRequiredService<IMicroserviceRealmConfigService>(),
				Commerce = provider.GetRequiredService<IMicroserviceCommerceApi>(),
				Chat = provider.GetRequiredService<IMicroserviceChatApi>(),
				Payments = provider.GetRequiredService<IMicroservicePaymentsApi>(),
				Push = provider.GetRequiredService<IMicroservicePushApi>(),
				Scheduler = provider.GetRequiredService<BeamScheduler>()
			};
			return services;
		}
	}

	public static void InitializeServices(IServiceProvider provider)
	{
		// we need to init the mongo serialization service
		var mongo = provider.GetService<MongoSerializationService>();
		mongo.Init();
	}

	public static Task ConfigureDiscovery(StartupContext startupContext)
	{
		var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";
		if (inDocker)
		{
			return Task.CompletedTask;
		}

		var msg = new ServiceDiscoveryEntry
		{
			processId = Environment.ProcessId,
			cid = startupContext.args.CustomerID,
			pid = startupContext.args.ProjectName,
			prefix = startupContext.args.NamePrefix,
			serviceName = startupContext.attributes.MicroserviceName,
			healthPort = startupContext.args.HealthPort,
			serviceType = "service",
			startedByAccountId = startupContext.args.AccountId
		};
		var msgJson = JsonConvert.SerializeObject(msg, UnitySerializationSettings.Instance);
		var msgBytes = Encoding.UTF8.GetBytes(msgJson);
		var broadcastSocket = new UdpClient();
		broadcastSocket.Connect(new IPEndPoint(IPAddress.Broadcast, Constants.Features.Services.DISCOVERY_PORT));
		return Task.Run(function: async () =>
		{
			try
			{
				do
				{
					await broadcastSocket.SendAsync(msgBytes, msgBytes.Length);
					await Task.Delay(Constants.Features.Services.DISCOVERY_BROADCAST_PERIOD_MS);
				} while (true);
			}
			catch (Exception e)
			{
				startupContext.logger.LogError(e, e.Message);
			}
		});
	}

	public static void ConfigureRequiredProcessIdWatcher(StartupContext startupContext)
	{
		var requireProcessId = startupContext.args.RequireProcessId;
		if (requireProcessId <= 0) return;

		var _ = Task.Run(async () =>
		{
			try
			{
				startupContext.logger.ZLogDebug(
					$"Running process-watcher loop for required process id=[{requireProcessId}]");
				var processExists = true;
				do
				{
					await Task.Delay(TimeSpan.FromSeconds(1));
					try
					{
						var p = Process.GetProcessById(requireProcessId);
						if (p.HasExited)
						{
							processExists = false;
						}
					}
					catch
					{
						processExists = false;
					}


				} while (processExists);

				// terminate. 
				startupContext.logger.LogInformation("Quitting because required process no longer exists");
				Environment.Exit(0);
			}
			catch (Exception ex)
			{
				startupContext.logger.ZLogError(
					$"Error while watching for required process id. type=[{ex.GetType().Name}] message=[{ex.Message}]");
			}
		});

	}

	public static async Task GetLocalEnvironment(StartupContext ctx)
	{
		var serviceName = ctx.attributes.MicroserviceName;
		
		BeamCliInvocation invocation = null;
#pragma warning disable CS0618 // Type or member is obsolete
		if (ctx.localEnvArgs == null)
#pragma warning restore CS0618 // Type or member is obsolete
		{
			invocation = new BeamCliInvocation
			{
				command = "project generate-env",
				args = new List<BeamCliPart>
				{
					new BeamCliPart(serviceName),
					new BeamCliPart("."),
					new BeamCliPart("--auto-deploy"),
					new BeamCliPart("--quiet"),
					new BeamCliPart("--logs", "v"),
					new BeamCliPart("--pretty"),
					new BeamCliPart("--no-log-file"),
					new BeamCliPart("--remove-all-except-pid", Process.GetCurrentProcess().Id.ToString()),
				}
			};
		}
		else
		{
			invocation = new BeamCliInvocation
			{
				command = "project generate-env",
				args = new List<BeamCliPart>
				{
					new BeamCliPart(serviceName),
#pragma warning disable CS0618 // Type or member is obsolete
					// this is jank, but the usage of that field in the past was to treat it as a giant arg string.
					new BeamCliPart(ctx.localEnvArgs),
#pragma warning restore CS0618 // Type or member is obsolete
					new BeamCliPart("--quiet"),
					new BeamCliPart("--logs", "v"),
					new BeamCliPart("--pretty"),
					new BeamCliPart("--no-log-file"),
					new BeamCliPart("--remove-all-except-pid", Process.GetCurrentProcess().Id.ToString()),
				}
			};
		}

		ctx.generateLocalEnvInvocationModifier?.Invoke(invocation);

		var argString = invocation.ToCommandString();
		using var process = new Process();

		var dotnetPath = Environment.GetEnvironmentVariable(Constants.EnvironmentVariables.BEAM_DOTNET_PATH);
		var beamProgram = GetBeamProgram();

		string arguments =
			$"{beamProgram} {argString}";
		string fileName = !string.IsNullOrEmpty(dotnetPath) ? dotnetPath : "dotnet";

		process.StartInfo.FileName = fileName;
		process.StartInfo.Arguments = arguments;
		process.StartInfo.RedirectStandardOutput = true;
		process.StartInfo.RedirectStandardError = true;
		process.StartInfo.CreateNoWindow = true;
		process.StartInfo.UseShellExecute = false;
		process.EnableRaisingEvents = true;

		var result = "";
		var sublogs = "";
		process.ErrorDataReceived += (sender, args) =>
		{
			ctx.logger.ZLogTrace($"Generate env process (error): [{args.Data}]");
			if (!string.IsNullOrEmpty(args.Data)) sublogs += args.Data;
		};

		process.OutputDataReceived += (sender, args) =>
		{
			ctx.logger.ZLogTrace($"Generate env process (log): [{args.Data}]");
			if (!string.IsNullOrEmpty(args.Data)) result += args.Data;
		};


		string path = Environment.GetEnvironmentVariable(Constants.EnvironmentVariables.BEAM_DOTNET_MSBUILD_PATH,
			EnvironmentVariableTarget.Process);
		if (!string.IsNullOrEmpty(path))
		{
			process.StartInfo.EnvironmentVariables[Constants.EnvironmentVariables.BEAM_DOTNET_MSBUILD_PATH] = path;
		}

		if (!string.IsNullOrEmpty(dotnetPath))
		{
			process.StartInfo.EnvironmentVariables[Constants.EnvironmentVariables.BEAM_DOTNET_PATH] = dotnetPath;
		}

		ctx.logger.ZLogInformation($"Running command {fileName} {arguments}");
		process.Start();
		process.BeginOutputReadLine();
		process.BeginErrorReadLine();

		var exitSignal = new Promise();
		process.Exited += (sender, args) => { exitSignal.CompleteSuccess(); };

		await process.WaitForExitAsync();
		// Might be necessary due to stupid .NET thing that causes the Out/Err callbacks to trigger a bit after the process closes.
		await exitSignal;
		await Task.Delay(100);


		if (process.ExitCode != 0)
		{
			ctx.logger.ZLogError($"generate-env output:\n{sublogs}");
			throw new Exception($"Failed to generate-env message=[{result}] sub-logs=[{sublogs}]");
		}

		ctx.logger.ZLogInformation($"environment:\n{result}");

		var parsedOutput = JsonConvert.DeserializeObject<ReportDataPoint<GenerateEnvFileOutput>>(result);
		if (parsedOutput.type != "stream")
		{
			// the output type needs to be "stream" (the default data output channel name). 
			//  if the type isn't "stream", it is likely doing to be "error", but even if it isn't, 
			//  it isn't the expected value.
			throw new Exception($"Failed to parse generate-env output. raw=[{result}]");
		}

		// apply the environment data to the local process.
		var envData = parsedOutput.data;
		foreach (var envVar in envData.envVars)
		{
			Environment.SetEnvironmentVariable(envVar.name, envVar.value);
		}
	}


	public static async Task<string> ConfigureCid(IMicroserviceArgs args)
	{
		if (args.SkipAliasResolve) return args.CustomerID;

		// it is possible that the user passed in an alias instead a cid for the env var, we should fix that...
		if (AliasHelper.IsCid(args.CustomerID)) return args.CustomerID;

		// if here, we can assume the string is an alias... 
		var aliasService = new AliasService(new MicroserviceHttpRequester(args, new HttpClient()));
		var res = await aliasService.Resolve(args.CustomerID);
		return res.Cid.Value;
	}

	public static async Task ConfigureUsageService(StartupContext ctx)
	{
		var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";

		if (!inDocker)
		{
			ctx.ecsService = new LocalUsageService();
		}
		else
		{
			if (string.IsNullOrEmpty(ctx.args.MetadataUrl))
			{
				ctx.ecsService = new DockerService();
			}
			else
			{
				ctx.ecsService = new EcsService(new HttpClient());
			}
		}

		await ctx.ecsService.Init();
	}

	/// <summary>
	/// Get the local execution path of the beam CLI.
	/// If there is a Library/BeamableEditor/BeamCLI/(version)/beam file, then
	/// that will be used.
	/// However, if that file does not exist, then a global "beam" will be used.
	/// </summary>
	/// <returns></returns>
	public static string GetBeamProgram()
	{
		string beamPathOverride = Environment.GetEnvironmentVariable(Constants.EnvironmentVariables.BEAM_PATH);
		if (!string.IsNullOrEmpty(beamPathOverride))
		{
			return beamPathOverride;
		}

		return "tool run beam"; // use global
	}

	/// <summary>
	/// Ascend local folders until a .beamable folder is found.
	/// </summary>
	/// <param name="beamableFolderPath"></param>
	/// <returns></returns>
	public static bool TryFindBeamableFolder(out string beamableFolderPath)
	{
		beamableFolderPath = null;
		var curr = Directory.GetCurrentDirectory();
		var searchingForParent = true;

		do
		{
			var directories = Directory.GetDirectories(curr);
			foreach (var dir in directories)
			{
				var pathName = Path.GetFileName(dir);
				if (pathName != ".beamable") continue;

				beamableFolderPath = Path.GetFullPath(curr);
				return true;
			}

			var parent = Directory.GetParent(curr);
			if (!(parent?.Exists ?? false))
			{
				searchingForParent = false;
			}
			else
			{
				curr = parent.FullName;
			}
		} while (searchingForParent);

		return false;
	}

	public static void ConfigureTelemetry(StartupContext ctx)
	{
		var metricProvider = Sdk.CreateMeterProviderBuilder()
				.AddMeter(Constants.Features.Otel.METER_SERVICE_NAME)
				.AddMeter("MongoDB.Driver.Core.Extensions.DiagnosticSources")
				.AddProcessInstrumentation()
				.AddRuntimeInstrumentation()
				.SetResourceBuilder(ctx.resourceProvider)
				// We are using the OtlpExporter for metrics because it already retries sending data after a while, which doesn't happen for traces and logs
				.AddOtlpExporter((option, reader) =>
				{
					if (!string.IsNullOrEmpty(ctx.args.OtelExporterOtlpEndpoint) &&
					    !string.IsNullOrEmpty(ctx.args.OtelExporterOtlpProtocol))
					{
						option.Protocol = (OtlpExportProtocol)Enum.Parse(typeof(OtlpExportProtocol),
							ctx.args.OtelExporterOtlpProtocol);
						option.Endpoint = new Uri($"{ctx.args.OtelExporterOtlpEndpoint}/v1/metrics");
					}
					else if (ctx.args.OtelExporterStandardEnabled)
					{
						option.Protocol = OtlpExportProtocol.HttpProtobuf;
						option.Endpoint = new Uri($"{ctx.otlpEndpoint}/v1/metrics");
					}

					reader.TemporalityPreference = MetricReaderTemporalityPreference.Delta;
				})
				.Build()
			;

		// TODO: keep references to providers so that we can force flush them at the shutdown
		var traceBuilder = Sdk.CreateTracerProviderBuilder()
			.SetResourceBuilder(ctx.resourceProvider)
			.AddSource(Constants.Features.Otel.METER_SERVICE_NAME)
			.AddSource("MongoDB.Driver.Core.Extensions.DiagnosticSources")
			.SetSampler<TraceSampler>();

		if (ctx.args.OtelExporterStandardEnabled)
		{
			traceBuilder = traceBuilder.AddMicroserviceExporter(option =>
			{
				if (!string.IsNullOrEmpty(ctx.args.OtelExporterOtlpEndpoint) &&
				    !string.IsNullOrEmpty(ctx.args.OtelExporterOtlpProtocol))
				{
					option.Protocol =
						(OtlpExportProtocol)Enum.Parse(typeof(OtlpExportProtocol), ctx.args.OtelExporterOtlpProtocol);
					option.OtlpEndpoint = ctx.args.OtelExporterOtlpEndpoint;
				}
				else if (ctx.args.OtelExporterStandardEnabled)
				{
					option.Protocol = OtlpExportProtocol.HttpProtobuf;
					option.OtlpEndpoint = ctx.otlpEndpoint;
				}

				option.ShouldRetry = ctx.args.OtelExporterShouldRetry;

				if (!string.IsNullOrEmpty(ctx.args.OtelExporterRetryMaxSize))
				{
					option.RetryQueueMaxSize = int.Parse(ctx.args.OtelExporterRetryMaxSize);
				}
			});
		}

		traceBuilder.Build();
	}

}
