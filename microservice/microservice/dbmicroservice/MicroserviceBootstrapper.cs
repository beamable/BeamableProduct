using Beamable.Api.Analytics;
using Beamable.Api.Autogenerated;
using Beamable.Api.Autogenerated.Models;
using System;
using System.Text;
using System.Threading.Tasks;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Content;
using Beamable.Common.Api.Realms;
using Beamable.Common.Api.Stats;
using Beamable.Common.BeamCli;
using Beamable.Common.BeamCli.Contracts;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Common.Reflection;
using Beamable.Common.Scheduler;
using Beamable.Common.Util;
using Beamable.Server.Api;
using Beamable.Server.Api.Analytics;
using Beamable.Server.Api.Announcements;
using Beamable.Server.Api.Calendars;
using Beamable.Server.Api.Chat;
using Beamable.Server.Api.CloudData;
using Beamable.Server.Api.Commerce;
using Beamable.Server.Api.Content;
using Beamable.Server.Api.Events;
using Beamable.Server.Api.Groups;
using Beamable.Server.Api.Inventory;
using Beamable.Server.Api.Leaderboards;
using Beamable.Server.Api.Mail;
using Beamable.Server.Api.Notifications;
using Beamable.Server.Api.Payments;
using Beamable.Server.Api.Push;
using Beamable.Server.Api.RealmConfig;
using Beamable.Server.Api.Scheduler;
using Beamable.Server.Api.Social;
using Beamable.Server.Api.Stats;
using Beamable.Server.Api.Tournament;
using Beamable.Server.Api.Usage;
using Beamable.Server.Common;
using Beamable.Server.Content;
using Beamable.Server.Ecs;
using Core.Server.Common;
using microservice;
using microservice.dbmicroservice;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Serilog;
using Serilog.Core;
using Serilog.Events;
using Serilog.Formatting.Display;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Reflection;
using Beamable.Tooling.Common;
using Beamable.Tooling.Common.OpenAPI;
using microservice.Common;
using Microsoft.OpenApi;
using Microsoft.OpenApi.Extensions;
using Constants = Beamable.Common.Constants;
using Debug = UnityEngine.Debug;
using RankEntry = Beamable.Common.Api.Leaderboards.RankEntry;

namespace Beamable.Server
{
    public static class MicroserviceBootstrapper
    {
	    private const int MSG_SIZE_LIMIT = 1000;
	    
	    

	    public static LoggingLevelSwitch LogLevel;
	    public static ReflectionCache ReflectionCache;
	    public static ContentService ContentService;
	    public static List<BeamableMicroService> Instances = new List<BeamableMicroService>();

	    public static IUsageApi EcsService;

	    private static DebugLogSink _sink;
	    private static Task _localDiscoveryBroadcast;

	    private static DebugLogSink ConfigureLogging(IMicroserviceArgs args, MicroserviceAttribute attr)
        {
            var logLevel = args.LogLevel;
			var disableLogTruncate = (Environment.GetEnvironmentVariable("DISABLE_LOG_TRUNCATE")?.ToLowerInvariant() ?? "") == "true";

			LogUtil.TryParseLogLevel(logLevel, out var envLogLevel);

            var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";
            
            
            // The LoggingLevelSwitch _could_ be controlled at runtime, if we ever wanted to do that.
            LogLevel = new LoggingLevelSwitch { MinimumLevel = envLogLevel };

            // https://github.com/serilog/serilog/wiki/Configuration-Basics
            var logConfig = new LoggerConfiguration()
	            .MinimumLevel.ControlledBy(LogLevel)
	            .Enrich.FromLogContext()
	            .Destructure.ByTransforming<MicroserviceRequestContext>(ctx => new
	            {
		            cid = ctx.Cid,
		            pid = ctx.Pid,
		            path = ctx.Path,
		            status = ctx.Status,
		            id = ctx.Id,
		            isEvent = ctx.IsEvent,
		            userId = ctx.UserId,
		            scopes = ctx.Scopes
	            });

            if (!disableLogTruncate)
            {
	            logConfig = logConfig
		            .Enrich.With(new LogMsgSizeEnricher(args.LogTruncateLimit))
		            .Destructure.ToMaximumCollectionCount(args.LogMaxCollectionSize)
		            .Destructure.ToMaximumDepth(args.LogMaxDepth)
		            .Destructure.ToMaximumStringLength(args.LogDestructureMaxLength);
            }

            var logger = logConfig;

            DebugLogSink debugLogSink = null;
            if (!inDocker)
            {
	            debugLogSink = new DebugLogSink(new MicroserviceLogFormatter());
	            logConfig = logConfig.WriteTo.Sink(debugLogSink);
            }
            
            switch (args.LogOutputType)
            {
	            case LogOutputType.DEFAULT when !inDocker:
	            case LogOutputType.UNSTRUCTURED:
		            logger = logConfig.WriteTo.Console(
			            new MessageTemplateTextFormatter(
				            "{Timestamp:HH:mm:ss.fff} [{Level:u4}] {Message:lj}{NewLine}{Exception}"));
		            break;
	            case LogOutputType.DEFAULT: // when inDocker: // logically, think of this as having inDocker==true, but technically because the earlier case checks for !inDocker, its redundant.
	            case LogOutputType.STRUCTURED:
		            logger = logConfig.WriteTo.Console(new MicroserviceLogFormatter());
		            break;
	            case LogOutputType.FILE:
		            logger = logConfig.WriteTo.File(args.LogOutputPath ?? "./service.log");
		            break;
	            
	            case LogOutputType.STRUCTURED_AND_FILE:
		            logger = logConfig
			            .WriteTo.Console(new MicroserviceLogFormatter())
			            .WriteTo.File(args.LogOutputPath ?? "./service.log");
		            break;
				default:
					logger = logConfig.WriteTo.Console(new MicroserviceLogFormatter());
					break;
            }
            
            
            Log.Logger = logger
               .CreateLogger();

            // use newtonsoft for JsonUtility
            JsonUtilityConverter.Init();

            BeamableLogProvider.Provider = new BeamableSerilogProvider();
            Debug.Instance = new MicroserviceDebug();
            BeamableSerilogProvider.LogContext.Value = Log.Logger;

            return debugLogSink;
        }

        public static void ConfigureUnhandledError()
        {
            PromiseBase.SetPotentialUncaughtErrorHandler((promise, exception) =>
            {
	            async Task DelayedCheck()
	            {
		            await Task.Delay(1);;
		            if (promise?.HadAnyErrbacks ?? true) return;

		            BeamableLogger.LogError("Uncaught promise error. {promiseType} {message} {stack}", promise.GetType(), exception.Message, exception.StackTrace);
		            throw exception;
	            }

	            _ = Task.Run(DelayedCheck);
            });
        }

        public static void ConfigureUncaughtExceptions()
        {
	        AppDomain.CurrentDomain.UnhandledException += (sender, args) =>
	        {
		        Console.Error.WriteLine($"Uncaught exception error!!! {args.ExceptionObject.GetType().Name}");
		        if (args.ExceptionObject is Exception ex)
		        {
			        Console.Error.WriteLine($"{ex.Message} -- {ex.StackTrace}");
		        }
		        
				Log.Fatal($"Unhandled exception. type=[{args.ExceptionObject?.GetType()?.Name}]");
	        };
        }

        public static ReflectionCache ConfigureReflectionCache()
        {

	        { 
		        // unless the referenced assemblies are explicitly loaded, 
		        //  it is likely that content types will be missed when. 
		        //  dotnet has not _loaded_ those assemblies yet, so the 
		        //  reflection cache sweep will miss them. 
		        var referencedAssemblies = Assembly.GetEntryAssembly().GetReferencedAssemblies();
		        foreach (var asm in referencedAssemblies)
		        {
			        Assembly.Load(asm);
		        }
	        }

	        var reflectionCache = new ReflectionCache();
	        var contentTypeReflectionCache = new ContentTypeReflectionCache();
	        var mongoIndexesReflectionCache = new MongoIndexesReflectionCache();
	        
	        reflectionCache.RegisterTypeProvider(contentTypeReflectionCache);
	        reflectionCache.RegisterReflectionSystem(contentTypeReflectionCache);
	        reflectionCache.RegisterTypeProvider(mongoIndexesReflectionCache);
	        reflectionCache.RegisterReflectionSystem(mongoIndexesReflectionCache);

	        var relevantAssemblyNames = AppDomain.CurrentDomain.GetAssemblies().Where(asm => !asm.GetName().Name.StartsWith("System.") &&
			        !asm.GetName().Name.StartsWith("nunit.") &&
			        !asm.GetName().Name.StartsWith("JetBrains.") &&
			        !asm.GetName().Name.StartsWith("Microsoft.") &&
			        !asm.GetName().Name.StartsWith("Serilog."))
		        .Select(asm => asm.GetName().Name)
		        .ToList();
	        Log.Debug($"Generating Reflection Cache over Assemblies => {string.Join('\n', relevantAssemblyNames)}");
	        reflectionCache.GenerateReflectionCache(relevantAssemblyNames);

	        return reflectionCache;
        }

        public static IDependencyBuilder ConfigureServices<T>(IMicroserviceArgs envArgs) where T : Microservice
        {
	        Log.Debug(Constants.Features.Services.Logs.REGISTERING_STANDARD_SERVICES);
	        var attribute = typeof(T).GetCustomAttribute<MicroserviceAttribute>();
	        
	        try
	        {
		        var collection = new DependencyBuilder();
		        collection
			        .AddScoped<T>()
			        .AddSingleton(attribute)
			        .AddSingleton<IBeamSchedulerContext, SchedulerContext>()
			        .AddSingleton<BeamScheduler>()
			        .AddSingleton<IUsageApi>(EcsService)
			        .AddScoped<IDependencyProvider>(provider => new MicrosoftServiceProviderWrapper(provider))
			        .AddScoped<IRealmInfo>(provider => provider.GetService<IMicroserviceArgs>())
			        .AddScoped<IBeamableRequester>(p => p.GetService<MicroserviceRequester>())
			        .AddScoped<IRequester>(p => p.GetService<MicroserviceRequester>())
			        .AddScoped<IHttpRequester, MicroserviceHttpRequester>(() =>
			        {
				        HttpClientHandler handler = new HttpClientHandler()
				        {
					        AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
				        };
				        return new MicroserviceHttpRequester(envArgs, new HttpClient(handler));
			        })
			        .AddSingleton<IMicroserviceArgs>(envArgs)
			        .AddSingleton<SocketRequesterContext>(_ =>
			        {
				        return Instances[0].SocketContext;
			        })
			        .AddScoped(provider =>
				        new MicroserviceRequester(provider.GetService<IMicroserviceArgs>(), provider.GetService<RequestContext>(), provider.GetService<SocketRequesterContext>(), true))
			        .AddScoped<IUserContext>(provider => provider.GetService<RequestContext>())
			        .AddScoped<IMicroserviceAuthApi, ServerAuthApi>()
			        .AddScoped<IMicroserviceStatsApi, MicroserviceStatsApi>()
			        .AddScoped<IStatsApi, MicroserviceStatsApi>()
			        .AddSingleton(new RequestContext(envArgs.CustomerID, envArgs.ProjectName))
			        .AddSingleton<ContentService>(p => CreateNewContentService(
				        p.GetService<MicroserviceRequester>(),
				        p.GetService<SocketRequesterContext>(),
				        p.GetService<IContentResolver>(),
				        p.GetService<ReflectionCache>()
			        ))
			        .AddSingleton<ISignedRequesterConfig, DefaultSignedRequesterConfig>(() => new DefaultSignedRequesterConfig
			        {
				        Host = envArgs.Host
					        .Replace("ws://", "http://")
					        .Replace("wss://", "https://")
					        .Replace("/socket/", "")
					        .Replace("/socket", ""),
				        RealmSecretGenerator = () => Promise<string>.Successful(envArgs.Secret)
			        })
			        .AddScoped(p => new HttpSignedRequester(p.GetService<ISignedRequesterConfig>(),
				        p.GetService<IRealmInfo>(), p.GetService<RequestContext>()))
			        .AddScoped<ISignedRequester>(p => p.GetService<HttpSignedRequester>())
			        .AddSingleton<IMicroserviceContentApi>(p => p.GetService<ContentService>())
			        .AddSingleton<IContentApi>(p => p.GetService<ContentService>())
			        .AddSingleton<IContentResolver, DefaultContentResolver>()
			        .AddSingleton<IConnectionProvider, EasyWebSocketProvider>()
			        .AddSingleton<IAliasService, AliasService>()
			        .AddScoped<IMicroserviceInventoryApi, MicroserviceInventoryApi>()
			        .AddScoped<IMicroserviceGroupsApi, MicroserviceGroupsApi>()
			        .AddScoped<IMicroserviceAnalyticsService, MicroserviceAnalyticsService>(p => new MicroserviceAnalyticsService(p.GetService<RequestContext>(), p.GetService<ISignedRequester>()))
			        .AddScoped<IMicroserviceTournamentApi, MicroserviceTournamentApi>()
			        .AddScoped<IMicroserviceLeaderboardsApi, MicroserviceLeaderboardApi>()
			        .AddScoped<IMicroserviceAnnouncementsApi, MicroserviceAnnouncementsApi>()
			        .AddScoped<IMicroserviceCalendarsApi, MicroserviceCalendarsApi>()
			        .AddScoped<IMicroserviceEventsApi, MicroserviceEventsApi>()
			        .AddScoped<IMicroserviceMailApi, MicroserviceMailApi>()
			        .AddScoped<IMicroserviceNotificationsApi, MicroserviceNotificationApi>()
			        .AddScoped<IMicroserviceSocialApi, MicroserviceSocialApi>()
			        .AddScoped<IMicroserviceCloudDataApi, MicroserviceCloudDataApi>()
			        .AddSingleton<IMicroserviceRealmConfigService>(p => p.GetService<RealmConfigService>())
			        .AddSingleton<IRealmConfigService>(p => p.GetService<RealmConfigService>())
			        .AddSingleton<RealmConfigService>()
			        .AddScoped<IMicroserviceCommerceApi, MicroserviceCommerceApi>()
			        .AddScoped<IMicroservicePaymentsApi, MicroservicePaymentsApi>()
			        .AddScoped<IMicroservicePushApi, MicroservicePushApi>()
			        .AddSingleton<IStorageObjectConnectionProvider, StorageObjectConnectionProvider>()
			        .AddSingleton<MongoSerializationService>()
			        .AddSingleton<IMongoSerializationService>(p => p.GetService<MongoSerializationService>())
			        .AddScoped<IMicroserviceChatApi, MicroserviceChatApi>()
			        .AddSingleton(ReflectionCache)

			        .AddScoped<UserDataCache<Dictionary<string, string>>.FactoryFunction>(provider =>
				        StatsCacheFactory)
			        .AddScoped<UserDataCache<RankEntry>.FactoryFunction>(provider => LeaderboardRankEntryFactory)
			        .AddScoped<IBeamableServices>(ExtractSdks)
			        ;
		        OpenApiRegistration.RegisterOpenApis(collection);
		        
		        Log.Debug(Constants.Features.Services.Logs.REGISTERING_CUSTOM_SERVICES);
		        var builder = new DefaultServiceBuilder(collection);

		        // Gets Service Configuration Methods
		        var configurationMethods = typeof(T)
			        .GetMethods(BindingFlags.Static | BindingFlags.Public)
			        .Where(method => method.GetCustomAttribute<ConfigureServicesAttribute>() != null)
			        .Select(method =>
			        {
				        var attr = method.GetCustomAttribute<ConfigureServicesAttribute>();
				        return (method, attr);
			        })
			        .ToList();

		        // Sorts them by an user-defined order. By default (and tie-breaking), is sorted in file declaration order.
		        configurationMethods.Sort(delegate((MethodInfo method, ConfigureServicesAttribute attr) t1,
			        (MethodInfo method, ConfigureServicesAttribute attr) t2)
		        {
			        var (_, attr1) = t1;
			        var (_, attr2) = t2;
			        return attr1.ExecutionOrder.CompareTo(attr2.ExecutionOrder);
		        });

		        // Invokes each Service Configuration Method --- skips any that do not match the void(IServiceBuilder) signature.
		        foreach (var (configurationMethod, _) in configurationMethods)
		        {
			        // TODO: Add compile-time check for this signature
			        var parameters = configurationMethod.GetParameters();
			        if (parameters.Length != 1 || parameters[0].ParameterType != typeof(IServiceBuilder)) continue;

			        try
			        {
				        configurationMethod.Invoke(null, new object[] { builder });
			        }
			        catch (Exception ex)
			        {
				        BeamableLogger.LogError("Configuration method failed. " + ex.Message + " {stacktrace}",
					        ex.StackTrace);
				        BeamableLogger.LogException(ex);
				        throw;
			        }
		        }
		        return collection;
	        }
	        catch (Exception ex)
	        {
		        BeamableLogger.LogError("Registering services failed. " + ex.Message);
		        BeamableLogger.LogException(ex);
		        throw;
	        }

	        ContentService CreateNewContentService(MicroserviceRequester requester, SocketRequesterContext socket, IContentResolver contentResolver, ReflectionCache reflectionCache)
	        {
		        return attribute.DisableAllBeamableEvents
			        ? new UnreliableContentService(requester, socket, contentResolver, reflectionCache)
			        : new ContentService(requester, socket, contentResolver, reflectionCache);
	        }
	        
	        UserDataCache<Dictionary<string, string>> StatsCacheFactory(string name, long ttlms, UserDataCache<Dictionary<string, string>>.CacheResolver resolver, IDependencyProvider provider)
	        {
		        return new EphemeralUserDataCache<Dictionary<string, string>>(name, resolver);
	        }
	        
	        UserDataCache<RankEntry> LeaderboardRankEntryFactory(string name, long ttlms, UserDataCache<RankEntry>.CacheResolver resolver, IDependencyProvider provider)
	        {
		        return new EphemeralUserDataCache<RankEntry>(name, resolver);
	        }
	        
	        IBeamableServices ExtractSdks(IServiceProvider provider)
	        {
		        var services = new BeamableServices
		        {
			        Analytics = provider.GetRequiredService<IMicroserviceAnalyticsService>(),
			        Auth = provider.GetRequiredService<IMicroserviceAuthApi>(),
			        Stats = provider.GetRequiredService<IMicroserviceStatsApi>(),
			        Content = provider.GetRequiredService<IMicroserviceContentApi>(),
			        Inventory = provider.GetRequiredService<IMicroserviceInventoryApi>(),
			        Leaderboards = provider.GetRequiredService<IMicroserviceLeaderboardsApi>(),
			        Announcements = provider.GetRequiredService<IMicroserviceAnnouncementsApi>(),
			        Calendars = provider.GetRequiredService<IMicroserviceCalendarsApi>(),
			        Events = provider.GetRequiredService<IMicroserviceEventsApi>(),
			        Groups = provider.GetRequiredService<IMicroserviceGroupsApi>(),
			        Mail = provider.GetRequiredService<IMicroserviceMailApi>(),
			        Notifications = provider.GetRequiredService<IMicroserviceNotificationsApi>(),
			        Social = provider.GetRequiredService<IMicroserviceSocialApi>(),
			        Tournament = provider.GetRequiredService<IMicroserviceTournamentApi>(),
			        TrialData = provider.GetRequiredService<IMicroserviceCloudDataApi>(),
			        RealmConfig= provider.GetRequiredService<IMicroserviceRealmConfigService>(),
			        Commerce = provider.GetRequiredService<IMicroserviceCommerceApi>(),
			        Chat = provider.GetRequiredService<IMicroserviceChatApi>(),
			        Payments = provider.GetRequiredService<IMicroservicePaymentsApi>(),
			        Push = provider.GetRequiredService<IMicroservicePushApi>(),
			        Scheduler = provider.GetRequiredService<BeamScheduler>()
		        };
		        return services;
	        }
        }

        public static void InitializeServices(IServiceProvider provider)
        {
	        // we need to init the mongo serialization service
	        var mongo = provider.GetService<MongoSerializationService>();
	        mongo.Init();
        }

        public static Task ConfigureDiscovery(IMicroserviceArgs args, MicroserviceAttribute attribute)
        {
	        var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";
	        if (inDocker)
	        {
		        return Task.CompletedTask;
	        }
	        
	        var msg = new ServiceDiscoveryEntry
	        {
		        processId = Environment.ProcessId,
		        cid = args.CustomerID,
		        pid = args.ProjectName,
		        prefix = args.NamePrefix,
		        serviceName = attribute.MicroserviceName,
		        healthPort = args.HealthPort,
		        serviceType = "service",
		        startedByAccountId = args.AccountId
	        };
	        var msgJson = JsonConvert.SerializeObject(msg, UnitySerializationSettings.Instance);
	        var msgBytes = Encoding.UTF8.GetBytes(msgJson);
	        var broadcastSocket = new UdpClient();
	        broadcastSocket.Connect(new IPEndPoint(IPAddress.Broadcast, Constants.Features.Services.DISCOVERY_PORT));
	        return Task.Run(function: async () =>
	        {
		        try
		        {
			        do
			        {
				        await broadcastSocket.SendAsync(msgBytes, msgBytes.Length);
				        await Task.Delay(Constants.Features.Services.DISCOVERY_BROADCAST_PERIOD_MS);
			        } while (true);
		        }
		        catch (Exception e)
		        {
			        Log.Error(e, e.Message);
		        }
	        });
        }

        public static void ConfigureRequiredProcessIdWatcher(IMicroserviceArgs args)
        {
	        var requireProcessId = args.RequireProcessId;
	        if (requireProcessId <= 0) return;

	        var _ = Task.Run(async () =>
	        {
		        try
		        {
					Log.Debug($"Running process-watcher loop for required process id=[{requireProcessId}]");
					var processExists = true;
					do
					{
						await Task.Delay(TimeSpan.FromSeconds(1));
						try
						{
							var p = Process.GetProcessById(requireProcessId);
							if (p.HasExited)
							{
								processExists = false;
							}
						}
						catch
						{
							processExists = false;
						}
						
						
					} while (processExists);
					
					// terminate. 
					Log.Information("Quitting because required process no longer exists");
					Environment.Exit(0);
		        }
		        catch (Exception ex)
		        {
			        Log.Error($"Error while watching for required process id. type=[{ex.GetType().Name}] message=[{ex.Message}]");
		        }
	        });
	        
        }

        public static async Task<string> ConfigureCid(IMicroserviceArgs args)
        {
	        // it is possible that the user passed in an alias instead a cid for the env var, we should fix that...
	        if (AliasHelper.IsCid(args.CustomerID)) return args.CustomerID;
	        
	        // if here, we can assume the string is an alias... 
	        var aliasService = new AliasService(new MicroserviceHttpRequester(args, new HttpClient()));
	        var res = await aliasService.Resolve(args.CustomerID);
	        return res.Cid.Value;
        }

        public static async Task ConfigureUsageService(IMicroserviceArgs args)
        {
	        var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";

	        if (!inDocker)
	        {
		        EcsService = new LocalUsageService();
	        }
	        else
	        {
		        if (string.IsNullOrEmpty(args.MetadataUrl))
		        {
			        EcsService = new DockerService();
		        }
		        else
		        {
			        EcsService = new EcsService(new HttpClient());
		        }
	        }

	        await EcsService.Init();
        }
        
        /// <summary>
        /// Get the local execution path of the beam CLI.
        /// If there is a Library/BeamableEditor/BeamCLI/(version)/beam file, then
        /// that will be used.
        /// However, if that file does not exist, then a global "beam" will be used.
        /// </summary>
        /// <returns></returns>
        public static string GetBeamProgram()
        {
	        string beamPathOverride = Environment.GetEnvironmentVariable(Constants.EnvironmentVariables.BEAM_PATH);
	        if (!string.IsNullOrEmpty(beamPathOverride))
	        {
		        return beamPathOverride;
	        }

	        return "tool run beam"; // use global
        }

        /// <summary>
        /// Ascend local folders until a .beamable folder is found.
        /// </summary>
        /// <param name="beamableFolderPath"></param>
        /// <returns></returns>
        public static bool TryFindBeamableFolder(out string beamableFolderPath)
        {
	        beamableFolderPath = null;
	        var curr = Directory.GetCurrentDirectory();
	        var searchingForParent = true;

	        do
	        {
		        var directories = Directory.GetDirectories(curr);
		        foreach (var dir in directories)
		        {
			        var pathName = Path.GetFileName(dir);
			        if (pathName != ".beamable") continue;

			        beamableFolderPath = Path.GetFullPath(curr);
			        return true;
		        }

		        var parent = Directory.GetParent(curr);
		        if (!(parent?.Exists ?? false))
		        {
			        searchingForParent = false;
		        }
		        else
		        {
			        curr = parent.FullName;
		        }
	        } while (searchingForParent);

	        return false;
        }

        
        /// <summary>
        /// This method can be called before the start of the microservice to inject some CLI information.
        /// This is only used to execute a microservice through the IDE.
        /// </summary>
        /// <param name="customArgs">Optional string with args to be used instead of the default ones.</param>
        /// <typeparam name="TMicroservice">The type of the microservice calling this method.</typeparam>
        /// <exception cref="Exception">Exception raised in case the generate-env command fails.</exception>
        public static async Task Prepare<TMicroservice>(string customArgs = null) where TMicroservice : Microservice
        {
	        Type microserviceType = typeof(TMicroservice);
	        
	        var attribute = microserviceType.GetCustomAttribute<MicroserviceAttribute>();
	        
	        var commandLineArgs = Environment.GetCommandLineArgs();
	        
	        // If argument --generate-oapi exist we are going to generate the OAPI specifications for this MS instead of preparing to start.
	        if (commandLineArgs.Contains("--generate-oapi"))
	        {
		        await GenerateOpenApiSpecification(microserviceType, attribute);
		        return;
	        }
	        
	        var envArgs = new EnvironmentArgs();

	        _sink = ConfigureLogging(envArgs, attribute);
	        Log.Information($"Starting Prepare");

	        var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";
	        if (inDocker) return;

	        ConfigureRequiredProcessIdWatcher(envArgs);

	        var serviceName = attribute.MicroserviceName;
	        
	        customArgs ??= ".";
			
	        using var process = new Process();

	        var dotnetPath = Environment.GetEnvironmentVariable(Constants.EnvironmentVariables.BEAM_DOTNET_PATH);
	        var beamProgram = GetBeamProgram();

	        string arguments = $"{beamProgram} project generate-env {serviceName} {customArgs} --logs v --pretty --no-log-file --remove-all-except-pid {Process.GetCurrentProcess().Id}";
	        string fileName = !string.IsNullOrEmpty(dotnetPath) ? dotnetPath : "dotnet";
	        
	        process.StartInfo.FileName = fileName;
	        process.StartInfo.Arguments = arguments;
	        process.StartInfo.RedirectStandardOutput = true;
	        process.StartInfo.RedirectStandardError = true;
	        process.StartInfo.CreateNoWindow = true;
	        process.StartInfo.UseShellExecute = false;
	        process.EnableRaisingEvents = true;
	        
	        var result = "";
	        var sublogs = "";
	        //TODO: These events are still not working for some reason
	        process.ErrorDataReceived += (sender, args) =>
	        {
				Log.Verbose($"Generate env process (error): [{args.Data}]");
				if(!string.IsNullOrEmpty(args.Data)) sublogs += args.Data;
	        };

	        process.OutputDataReceived += (sender, args) =>
	        {
		        Log.Verbose($"Generate env process (log): [{args.Data}]");
		        if(!string.IsNullOrEmpty(args.Data)) result += args.Data;
	        };


	        string path = Environment.GetEnvironmentVariable(Constants.EnvironmentVariables.BEAM_DOTNET_MSBUILD_PATH, EnvironmentVariableTarget.Process);
	        if (!string.IsNullOrEmpty(path))
	        {
		        process.StartInfo.EnvironmentVariables[Constants.EnvironmentVariables.BEAM_DOTNET_MSBUILD_PATH] = path;
	        }

	        if (!string.IsNullOrEmpty(dotnetPath))
	        {
		        process.StartInfo.EnvironmentVariables[Constants.EnvironmentVariables.BEAM_DOTNET_PATH] = dotnetPath;
	        }
	        Log.Information($"Running command {fileName} {arguments}");
	        process.Start();
	        process.BeginOutputReadLine();
	        process.BeginErrorReadLine();

	        var exitSignal = new Promise();
	        process.Exited += (sender, args) =>
	        {
		        exitSignal.CompleteSuccess();
	        };
	        
	        await process.WaitForExitAsync();
	        // Might be necessary due to stupid .NET thing that causes the Out/Err callbacks to trigger a bit after the process closes.
	        await exitSignal;
	        await Task.Delay(100);

	     
	        if (process.ExitCode != 0)
	        {
		        Log.Error($"generate-env output:\n{sublogs}");
		        throw new Exception($"Failed to generate-env message=[{result}] sub-logs=[{sublogs}]");
	        }
	        Log.Information($"environment:\n{result}");
	        
	        var parsedOutput = JsonConvert.DeserializeObject<ReportDataPoint<GenerateEnvFileOutput>>(result);
	        if (parsedOutput.type != "stream")
	        {
		        // the output type needs to be "stream" (the default data output channel name). 
		        //  if the type isn't "stream", it is likely doing to be "error", but even if it isn't, 
		        //  it isn't the expected value.
		        throw new Exception($"Failed to parse generate-env output. raw=[{result}]");
	        }

	        // apply the environment data to the local process.
	        var envData = parsedOutput.data;
	        foreach (var envVar in envData.envVars)
	        {
		        Environment.SetEnvironmentVariable(envVar.name, envVar.value);
	        }
        }

        private static async Task GenerateOpenApiSpecification(Type microserviceType, MicroserviceAttribute attribute)
        {
	        var generator = new ServiceDocGenerator();
		        
	        var extraSchemas = ServiceDocGenerator.LoadDotnetDeclaredSchemasFromTypes(microserviceType.Assembly.GetExportedTypes(), out List<Type> _);
		        
	        var doc = generator.Generate(microserviceType, attribute, new AdminRoutes
	        {
		        MicroserviceAttribute = attribute,
		        MicroserviceType = microserviceType
	        }, false, extraSchemas.Select(t => t.type).ToArray());
				
	        var outputString = doc.Serialize(OpenApiSpecVersion.OpenApi3_0, OpenApiFormat.Json);
		       
	        var beamableFolderPath = Environment.GetEnvironmentVariable("OPEN_API_OUTPUT_PATH") 
	                                 ?? throw new InvalidOperationException("OPEN_API_OUTPUT_PATH environment variable not set");
	        
	        Console.WriteLine($"GENERATE OPEN API >> Beam Folder Path: {beamableFolderPath}");
	        
	        string directoryPath = Path.GetFullPath(beamableFolderPath);
	        if (!Directory.Exists(directoryPath))
	        {
		        Directory.CreateDirectory(directoryPath);
	        }
	        
	        Console.WriteLine($"GENERATE OPEN API >> Path: {directoryPath}");

	        
	        await File.WriteAllTextAsync(Path.Combine(directoryPath, Constants.OPEN_API_FILE_NAME), outputString);
        }

        public static async Task Start<TMicroService>() where TMicroService : Microservice
        {
	        var commandLineArgs = Environment.GetCommandLineArgs();
	        // If argument --generate-oapi exist we instead generated the OAPI specifications for it, so we can skip it.
	        if (commandLineArgs.Contains("--generate-oapi"))
	        {
		        return;
	        }


	        BeamableSerilogProvider.LogContext.Value = Log.Logger;
	        var attribute = typeof(TMicroService).GetCustomAttribute<MicroserviceAttribute>();
	        var envArgs = new EnvironmentArgs();

	        ConfigureUncaughtExceptions();
	        ConfigureUnhandledError();
	        _localDiscoveryBroadcast = ConfigureDiscovery(envArgs, attribute);
	        await ConfigureUsageService(envArgs);
	        ReflectionCache = ConfigureReflectionCache();
	        
	        // configure the root service scope, and then build the root service provider.
	        var serviceBuilder = ConfigureServices<TMicroService>(envArgs);
	        var rootServiceScope = serviceBuilder.Build(new BuildOptions
	        {
		        allowHydration = false
	        });
	        InitializeServices(rootServiceScope);

	        var resolvedCid = await ConfigureCid(envArgs);
	        var args = envArgs.Copy(conf =>
	        {
		        conf.ServiceScope = rootServiceScope;
		        conf.CustomerID = resolvedCid;
	        });

	        for (var i = 0; i < args.BeamInstanceCount; i++)
            {
	            var isFirstInstance = i == 0;
	            var beamableService = new BeamableMicroService();
				Instances.Add(beamableService);
				
				var instanceArgs = args.Copy(conf =>
				{
					// only the first instance needs to run, if anything should run at all.
					conf.DisableCustomInitializationHooks |= !isFirstInstance;
				});
				
	            if (isFirstInstance)
	            {
		            var localDebug = new ContainerDiagnosticService(instanceArgs, beamableService, _sink);
		            var runningDebugTask = localDebug.Run();
	            }
	            
	            //In case that SdkVersionExecution is null or empty, we are executing it locally with dotnet and
	            //therefore getting dependencies through nuget, so not required to check versions mismatch.
	            if (!string.IsNullOrEmpty(args.SdkVersionExecution) && !string.Equals(args.SdkVersionExecution, args.SdkVersionBaseBuild))
	            {
		            Log.Fatal(
			            "Version mismatch. Image built with {buildVersion}, but is executing with {executionVersion}. This is a fatal mistake.",
			            args.SdkVersionBaseBuild, args.SdkVersionExecution);
		            throw new Exception(
			            $"Version mismatch. Image built with {args.SdkVersionBaseBuild}, but is executing with {args.SdkVersionExecution}. This is a fatal mistake.");
	            }

	            try
	            {
		            await beamableService.Start<TMicroService>(instanceArgs);
		            if (isFirstInstance && (attribute?.EnableEagerContentLoading ?? false))
		            {
			            await rootServiceScope.GetService<ContentService>().initializedPromise;
		            }
	            }
	            catch (Exception ex)
	            {
		            var message = new StringBuilder(1024 * 10);

		            if (ex is not BeamableMicroserviceException beamEx)
			            message.AppendLine(
				            $"[BeamErrorCode=BMS{BeamableMicroserviceException.kBMS_UNHANDLED_EXCEPTION_ERROR_CODE}]" +
				            $" Unhandled Exception Found! Please notify Beamable of your use case that led to this.");
		            else
			            message.AppendLine($"[BeamErrorCode=BMS{beamEx.ErrorCode}] " +
			                               $"Beamable Exception Found! If the message is unclear, please contact Beamable with your feedback.");

		            message.AppendLine("Exception Info:");
		            message.AppendLine($"Name={ex.GetType().Name}, Message={ex.Message}");
		            message.AppendLine("Stack Trace:");
		            message.AppendLine(ex.StackTrace);
		            Log.Fatal(message.ToString());
		            throw;
	            }

	            if (args.WatchToken)
		            HotReloadMetadataUpdateHandler.ServicesToRebuild.Add(beamableService);

	            var _ = beamableService.RunForever();
            }

            await Task.Delay(-1);
        }
    }

    internal class LogMsgSizeEnricher : ILogEventEnricher
    {
	    private readonly int _width;
	    
	    public LogMsgSizeEnricher(int width)
	    {
		    _width = width;
	    }

	    public void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory)
	    {
		    foreach (var singleProp in logEvent.Properties)
		    {
			    var stringifiedPropValue = singleProp.Value?.ToString();

			    if (stringifiedPropValue != null && stringifiedPropValue.Length > _width)
			    {
				    stringifiedPropValue = stringifiedPropValue.Substring(0, _width) + "...";
				    logEvent.AddOrUpdateProperty(propertyFactory.CreateProperty(singleProp.Key, stringifiedPropValue));
			    }
		    }

	    }
    }
}
