using System;
using System.Threading.Tasks;
using Beamable.Common.Api;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Versioning;
using Microsoft.Extensions.Logging;
using System.Threading;

namespace Beamable.Server
{
	public class SingleUseUserContext : IUserContext
	{
		public long UserId { get; set; }
	}

    public static partial class MicroserviceBootstrapper
    {
	    public static AsyncLocal<LogLevel> ContextLogLevel = new();


        private static BeamServiceConfigBuilder _preparedBuilder;
        
        /// <summary>
        /// This method can be called before the start of the microservice to inject some CLI information.
        /// This is only used to execute a microservice through the IDE.
        /// </summary>
        /// <param name="customArgs">Optional string with args to be used instead of the default ones.</param>
        /// <typeparam name="TMicroservice">The type of the microservice calling this method.</typeparam>
        /// <exception cref="Exception">Exception raised in case the generate-env command fails.</exception>
        public static Task Prepare<TMicroservice>(string customArgs = null) where TMicroservice : Microservice
        {
	        _preparedBuilder = BeamServer.Create()
		        .IncludeRoutes<TMicroservice>(
			        // enable backward compat, 
			        //  old microservices never had route prefixes or client prefixes, 
			        //  so best to leave them blank. 
			        routePrefix: "", 
			        clientPrefix: "")
		        .OverrideConfig(conf =>
		        {
			        var attrs = typeof(TMicroservice).GetCustomAttribute<MicroserviceAttribute>();
			        if (attrs != null)
			        {
				        conf.Attributes.DisableAllBeamableEvents = attrs.DisableAllBeamableEvents;
				        conf.Attributes.EnableEagerContentLoading = attrs.EnableEagerContentLoading;
				        conf.Attributes.CustomAutoGeneratedClientPath = attrs.CustomAutoGeneratedClientPath;
#pragma warning disable CS0618 // Type or member is obsolete
				        conf.Attributes.UseLegacySerialization = attrs.UseLegacySerialization;
#pragma warning restore CS0618 // Type or member is obsolete
			        }
			        conf.LocalEnvCustomArgs = customArgs;
		        });
	        return Task.CompletedTask;
        }

        /// <summary>
        /// When you run `dotnet run`, the working directory is from where you ran `dotnet run` from.
        /// When you run from Docker or Rider, the working directory is where the built dll is.
        /// This is confusing, and this function will attempt to map to the Docker behaviour.
        /// </summary>
        /// <param name="attr"></param>
        public static void AdjustWorkingDirectory<TMicroservice>() where TMicroservice : Microservice
        {
	        Type microserviceType = typeof(TMicroservice);
	        var attribute = microserviceType.GetCustomAttribute<MicroserviceAttribute>();
	        var dllName = attribute.MicroserviceName + ".dll";
	        if (File.Exists(dllName)) return; // hooray, we are in the right folder already.
	        
	        var assembly = Assembly.GetExecutingAssembly();
	        var frameworkAttr = assembly
		        .GetCustomAttributes(typeof(TargetFrameworkAttribute), false)
		        .OfType<TargetFrameworkAttribute>()
		        .FirstOrDefault();

	        var frameworkFolder = frameworkAttr.FrameworkDisplayName.ToLowerInvariant().Replace(" ", "").Substring(1);
	        var likelyFolder = Path.Combine("bin", "Debug", frameworkFolder);

	        var likelyDllPath = Path.Combine(likelyFolder, dllName);
	        if (File.Exists(likelyDllPath))
	        {
		        // ah, this should be the working directory.
		        Environment.CurrentDirectory = likelyFolder;
	        }
        }

        public static void ForceUseRemoteDependencies<TMicroservice>() where TMicroservice : Microservice
        {
	        Type microserviceType = typeof(TMicroservice);
	        var attribute = microserviceType.GetCustomAttribute<MicroserviceAttribute>();
	        var serviceName = attribute.MicroserviceName;

	        var depsNames = Environment.GetEnvironmentVariable($"BEAM_DEPS_{serviceName}");

	        if (!string.IsNullOrEmpty(depsNames))
	        {
		        var deps = depsNames.Split(",");

		        foreach (string dep in deps)
		        {
			        Environment.SetEnvironmentVariable($"STORAGE_CONNSTR_{dep}", "");
		        }
	        }
        }
        
        public static async Task Start<TMicroService>() where TMicroService : Microservice
        {
	        if (_preparedBuilder == null)
	        {
		        throw new InvalidOperationException("You must call " + nameof(Prepare) + " first.");
	        }
	        await _preparedBuilder.RunForever();
        }

    }
}
