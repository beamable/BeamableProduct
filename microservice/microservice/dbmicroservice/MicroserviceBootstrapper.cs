using Beamable.Api.Autogenerated;
using System;
using System.Text;
using System.Threading.Tasks;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Content;
using Beamable.Common.Api.Realms;
using Beamable.Common.Api.Stats;
using Beamable.Common.BeamCli;
using Beamable.Common.BeamCli.Contracts;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Common.Reflection;
using Beamable.Common.Scheduler;
using Beamable.Server.Api;
using Beamable.Server.Api.Analytics;
using Beamable.Server.Api.Announcements;
using Beamable.Server.Api.Calendars;
using Beamable.Server.Api.Chat;
using Beamable.Server.Api.CloudData;
using Beamable.Server.Api.Commerce;
using Beamable.Server.Api.Content;
using Beamable.Server.Api.Events;
using Beamable.Server.Api.Groups;
using Beamable.Server.Api.Inventory;
using Beamable.Server.Api.Leaderboards;
using Beamable.Server.Api.Mail;
using Beamable.Server.Api.Notifications;
using Beamable.Server.Api.Payments;
using Beamable.Server.Api.Push;
using Beamable.Server.Api.RealmConfig;
using Beamable.Server.Api.Scheduler;
using Beamable.Server.Api.Social;
using Beamable.Server.Api.Stats;
using Beamable.Server.Api.Tournament;
using Beamable.Server.Api.Usage;
using Beamable.Server.Common;
using Beamable.Server.Content;
using Beamable.Server.Ecs;
using microservice;
using microservice.dbmicroservice;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Reflection;
using Beamable.Common.Util;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Exporter;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using ZLogger;
using Beamable.Tooling.Common;
using Constants = Beamable.Common.Constants;
using Otel = Beamable.Common.Constants.Features.Otel;
using Debug = UnityEngine.Debug;
using RankEntry = Beamable.Common.Api.Leaderboards.RankEntry;

namespace Beamable.Server
{
    public static class MicroserviceBootstrapper
    {
	    private const int MSG_SIZE_LIMIT = 1000;

	    public static ReflectionCache ReflectionCache;
	    public static ContentService ContentService;
	    public static List<BeamableMicroService> Instances = new List<BeamableMicroService>();

	    public static IUsageApi EcsService;

	    // private static DebugLogSink _sink;
	    private static Task _localDiscoveryBroadcast;
	    public static LogLevel LogLevel;

	    private static void ConfigureZLogging<TMicroservice>(IMicroserviceArgs args, bool includeOtel)
	    {
		    var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";
		    if (!LogUtil.TryParseSystemLogLevel(args.LogLevel, out LogLevel))
		    {
			    LogLevel = LogLevel.Warning;
		    }

		    _loggerFactory = LoggerFactory.Create(builder =>
		    {
			    // TODO: handle per-route / config options
			    
			    // all logs are valid, but may not pass the filter. 
			    builder.SetMinimumLevel(LogLevel.Trace);
			    
			    builder.AddFilter(level => level >= LogLevel);
			    if (!inDocker)
			    {
				    var debugLogProcessor = _debugLogProcessor = new DebugLogProcessor();
				    builder
					    .AddZLoggerLogProcessor(debugLogProcessor);
			    }

			    if (includeOtel)
			    {
				    builder.AddOpenTelemetry(logging =>
				    {
					    // https://signoz.io/blog/opentelemetry-dotnet-logs/
					    logging.IncludeScopes = true;
					    logging
						    .SetResourceBuilder(_resourceBuilder)
						    .AddOtlpExporter();

				    });
			    }
			    
			    switch (args.LogOutputType)
			    {
				    case LogOutputType.DEFAULT when !inDocker:
				    case LogOutputType.UNSTRUCTURED:
					    builder.AddZLoggerConsole(opts =>
					    {
						    opts.UsePlainTextFormatter();
					    });
					    
					    break;
				    
				    case LogOutputType.FILE:
					    builder.AddZLoggerFile(args.LogOutputPath ?? "./service.log");
					    break;
	            
				    case LogOutputType.STRUCTURED_AND_FILE:
					    builder.AddZLoggerConsole(opts =>
					    {
						    opts.UseJsonFormatter();
					    });
					    builder.AddZLoggerFile(args.LogOutputPath ?? "./service.log");

					    break;
				    case LogOutputType.DEFAULT: // when inDocker: // logically, think of this as having inDocker==true, but technically because the earlier case checks for !inDocker, its redundant.
				    case LogOutputType.STRUCTURED:
				    default:
					    builder.AddZLoggerConsole(opts =>
					    {
						    opts.UseJsonFormatter();
					    });
					    break;
			    }

		    });

		    
		    // use newtonsoft for JsonUtility
		    JsonUtilityConverter.Init();

		    BeamableLogProvider.Provider = new BeamableZLoggerProvider();
		    Debug.Instance = new MicroserviceDebug();
		    _logger = BeamableZLoggerProvider.LogContext.Value = _loggerFactory.CreateLogger<TMicroservice>();
	    }

        public static void ConfigureUnhandledError()
        {
            PromiseBase.SetPotentialUncaughtErrorHandler((promise, exception) =>
            {
	            async Task DelayedCheck()
	            {
		            await Task.Delay(1);;
		            if (promise?.HadAnyErrbacks ?? true) return;

		            BeamableLogger.LogError("Uncaught promise error. {promiseType} {message} {stack}", promise.GetType(), exception.Message, exception.StackTrace);
		            throw exception;
	            }

	            _ = Task.Run(DelayedCheck);
            });
        }

        public static void ConfigureUncaughtExceptions()
        {
	        AppDomain.CurrentDomain.UnhandledException += (sender, args) =>
	        {
		        Console.Error.WriteLine($"Uncaught exception error!!! {args.ExceptionObject.GetType().Name}");
		        if (args.ExceptionObject is Exception ex)
		        {
			        Console.Error.WriteLine($"{ex.Message} -- {ex.StackTrace}");
		        }
		        
				_logger.ZLogCritical($"Unhandled exception. type=[{args.ExceptionObject?.GetType()?.Name}]");
	        };
        }

        public static ReflectionCache ConfigureReflectionCache()
        {

	        { 
		        // unless the referenced assemblies are explicitly loaded, 
		        //  it is likely that content types will be missed when. 
		        //  dotnet has not _loaded_ those assemblies yet, so the 
		        //  reflection cache sweep will miss them. 
		        var referencedAssemblies = Assembly.GetEntryAssembly().GetReferencedAssemblies();
		        foreach (var asm in referencedAssemblies)
		        {
			        Assembly.Load(asm);
		        }
	        }

	        var reflectionCache = new ReflectionCache();
	        var contentTypeReflectionCache = new ContentTypeReflectionCache();
	        var mongoIndexesReflectionCache = new MongoIndexesReflectionCache();
	        
	        reflectionCache.RegisterTypeProvider(contentTypeReflectionCache);
	        reflectionCache.RegisterReflectionSystem(contentTypeReflectionCache);
	        reflectionCache.RegisterTypeProvider(mongoIndexesReflectionCache);
	        reflectionCache.RegisterReflectionSystem(mongoIndexesReflectionCache);

	        var relevantAssemblyNames = AppDomain.CurrentDomain.GetAssemblies().Where(asm => !asm.GetName().Name.StartsWith("System.") &&
			        !asm.GetName().Name.StartsWith("nunit.") &&
			        !asm.GetName().Name.StartsWith("JetBrains.") &&
			        !asm.GetName().Name.StartsWith("Microsoft.") &&
			        !asm.GetName().Name.StartsWith("Serilog."))
		        .Select(asm => asm.GetName().Name)
		        .ToList();
	        _logger.ZLogDebug($"Generating Reflection Cache over Assemblies => {string.Join('\n', relevantAssemblyNames)}");
	        reflectionCache.GenerateReflectionCache(relevantAssemblyNames);

	        return reflectionCache;
        }

        public static IDependencyBuilder ConfigureServices<T>(IMicroserviceArgs envArgs) where T : Microservice
        {
	        _logger.LogDebug(Constants.Features.Services.Logs.REGISTERING_STANDARD_SERVICES);
	        var attribute = typeof(T).GetCustomAttribute<MicroserviceAttribute>();
	        
	        try
	        {
		        var collection = new DependencyBuilder();
		        collection
			        .AddScoped<T>()
			        .AddSingleton(attribute)
			        .AddSingleton<IActivityProvider>(_activityProvider)
			        .AddSingleton<ILoggerFactory>(_loggerFactory)
			        .AddSingleton<IBeamSchedulerContext, SchedulerContext>()
			        .AddSingleton<BeamScheduler>()
			        .AddSingleton<IUsageApi>(EcsService)
			        .AddScoped<IDependencyProvider>(provider => new MicrosoftServiceProviderWrapper(provider))
			        .AddScoped<IRealmInfo>(provider => provider.GetService<IMicroserviceArgs>())
			        .AddScoped<IBeamableRequester>(p => p.GetService<MicroserviceRequester>())
			        .AddScoped<IRequester>(p => p.GetService<MicroserviceRequester>())
			        .AddScoped<IHttpRequester, MicroserviceHttpRequester>(() =>
			        {
				        HttpClientHandler handler = new HttpClientHandler()
				        {
					        AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
				        };
				        return new MicroserviceHttpRequester(envArgs, new HttpClient(handler));
			        })
			        .AddSingleton<IMicroserviceArgs>(envArgs)
			        .AddSingleton<SocketRequesterContext>(_ =>
			        {
				        return Instances[0].SocketContext;
			        })
			        .AddScoped(provider =>
				        new MicroserviceRequester(
					        provider.GetService<IMicroserviceArgs>(), 
					        provider.GetService<RequestContext>(), 
					        provider.GetService<SocketRequesterContext>(), 
					        true,
					        provider.GetService<IActivityProvider>()))
			        .AddScoped<IUserContext>(provider => provider.GetService<RequestContext>())
			        .AddScoped<IMicroserviceAuthApi, ServerAuthApi>()
			        .AddScoped<IMicroserviceStatsApi, MicroserviceStatsApi>()
			        .AddScoped<IStatsApi, MicroserviceStatsApi>()
			        .AddSingleton(new RequestContext(envArgs.CustomerID, envArgs.ProjectName))
			        .AddSingleton<ContentService>(p => CreateNewContentService(
				        p.GetService<MicroserviceRequester>(),
				        p.GetService<SocketRequesterContext>(),
				        p.GetService<IContentResolver>(),
				        p.GetService<ReflectionCache>()
			        ))
			        .AddSingleton<ISignedRequesterConfig, DefaultSignedRequesterConfig>(() => new DefaultSignedRequesterConfig
			        {
				        Host = envArgs.Host
					        .Replace("ws://", "http://")
					        .Replace("wss://", "https://")
					        .Replace("/socket/", "")
					        .Replace("/socket", ""),
				        RealmSecretGenerator = () => Promise<string>.Successful(envArgs.Secret)
			        })
			        .AddScoped(p => new HttpSignedRequester(p.GetService<ISignedRequesterConfig>(),
				        p.GetService<IRealmInfo>(), p.GetService<RequestContext>()))
			        .AddScoped<ISignedRequester>(p => p.GetService<HttpSignedRequester>())
			        .AddSingleton<IMicroserviceContentApi>(p => p.GetService<ContentService>())
			        .AddSingleton<IContentApi>(p => p.GetService<ContentService>())
			        .AddSingleton<IContentResolver, DefaultContentResolver>()
			        .AddSingleton<IConnectionProvider, EasyWebSocketProvider>()
			        .AddSingleton<IAliasService, AliasService>()
			        .AddScoped<IMicroserviceInventoryApi, MicroserviceInventoryApi>()
			        .AddScoped<IMicroserviceGroupsApi, MicroserviceGroupsApi>()
			        .AddScoped<IMicroserviceAnalyticsService, MicroserviceAnalyticsService>(p => new MicroserviceAnalyticsService(p.GetService<RequestContext>(), p.GetService<ISignedRequester>()))
			        .AddScoped<IMicroserviceTournamentApi, MicroserviceTournamentApi>()
			        .AddScoped<IMicroserviceLeaderboardsApi, MicroserviceLeaderboardApi>()
			        .AddScoped<IMicroserviceAnnouncementsApi, MicroserviceAnnouncementsApi>()
			        .AddScoped<IMicroserviceCalendarsApi, MicroserviceCalendarsApi>()
			        .AddScoped<IMicroserviceEventsApi, MicroserviceEventsApi>()
			        .AddScoped<IMicroserviceMailApi, MicroserviceMailApi>()
			        .AddScoped<IMicroserviceNotificationsApi, MicroserviceNotificationApi>()
			        .AddScoped<IMicroserviceSocialApi, MicroserviceSocialApi>()
			        .AddScoped<IMicroserviceCloudDataApi, MicroserviceCloudDataApi>()
			        .AddSingleton<IMicroserviceRealmConfigService>(p => p.GetService<RealmConfigService>())
			        .AddSingleton<IRealmConfigService>(p => p.GetService<RealmConfigService>())
			        .AddSingleton<RealmConfigService>()
			        .AddScoped<IMicroserviceCommerceApi, MicroserviceCommerceApi>()
			        .AddScoped<IMicroservicePaymentsApi, MicroservicePaymentsApi>()
			        .AddScoped<IMicroservicePushApi, MicroservicePushApi>()
			        .AddSingleton<IStorageObjectConnectionProvider, StorageObjectConnectionProvider>()
			        .AddSingleton<MongoSerializationService>()
			        .AddSingleton<IMongoSerializationService>(p => p.GetService<MongoSerializationService>())
			        .AddScoped<IMicroserviceChatApi, MicroserviceChatApi>()
			        .AddSingleton(ReflectionCache)

			        .AddScoped<UserDataCache<Dictionary<string, string>>.FactoryFunction>(provider =>
				        StatsCacheFactory)
			        .AddScoped<UserDataCache<RankEntry>.FactoryFunction>(provider => LeaderboardRankEntryFactory)
			        .AddScoped<IBeamableServices>(ExtractSdks)
			        
			        // allow the DI system to get a list of all telemetry attribute providers...
			        //  _INCLUDING_ the standard Beamable one, which should be registered _LAST_
			        .AddSingleton<SingletonDependencyList<ITelemetryAttributeProvider>>()
			        ;
		        OpenApiRegistration.RegisterOpenApis(collection);
		        
		        _logger.LogDebug(Constants.Features.Services.Logs.REGISTERING_CUSTOM_SERVICES);
		        var builder = new DefaultServiceBuilder(collection);

		        // Gets Service Configuration Methods
		        var configurationMethods = typeof(T)
			        .GetMethods(BindingFlags.Static | BindingFlags.Public)
			        .Where(method => method.GetCustomAttribute<ConfigureServicesAttribute>() != null)
			        .Select(method =>
			        {
				        var attr = method.GetCustomAttribute<ConfigureServicesAttribute>();
				        return (method, attr);
			        })
			        .ToList();

		        // Sorts them by an user-defined order. By default (and tie-breaking), is sorted in file declaration order.
		        configurationMethods.Sort(delegate((MethodInfo method, ConfigureServicesAttribute attr) t1,
			        (MethodInfo method, ConfigureServicesAttribute attr) t2)
		        {
			        var (_, attr1) = t1;
			        var (_, attr2) = t2;
			        return attr1.ExecutionOrder.CompareTo(attr2.ExecutionOrder);
		        });

		        // Invokes each Service Configuration Method --- skips any that do not match the void(IServiceBuilder) signature.
		        foreach (var (configurationMethod, _) in configurationMethods)
		        {
			        // TODO: Add compile-time check for this signature
			        var parameters = configurationMethod.GetParameters();
			        if (parameters.Length != 1 || parameters[0].ParameterType != typeof(IServiceBuilder)) continue;

			        try
			        {
				        configurationMethod.Invoke(null, new object[] { builder });
			        }
			        catch (Exception ex)
			        {
				        BeamableLogger.LogError("Configuration method failed. " + ex.Message + " {stacktrace}",
					        ex.StackTrace);
				        BeamableLogger.LogException(ex);
				        throw;
			        }
		        }
		        
		        
		        // inject services we want to configure *AFTER* the user-level. 
		        //  these services are ones that we do not want the user to be able to override. 
		        collection.AddSingleton(_standardBeamTelemetryAttributes);

		        
		        return collection;
	        }
	        catch (Exception ex)
	        {
		        BeamableLogger.LogError("Registering services failed. " + ex.Message);
		        BeamableLogger.LogException(ex);
		        throw;
	        }

	        ContentService CreateNewContentService(MicroserviceRequester requester, SocketRequesterContext socket, IContentResolver contentResolver, ReflectionCache reflectionCache)
	        {
		        return attribute.DisableAllBeamableEvents
			        ? new UnreliableContentService(requester, socket, contentResolver, reflectionCache)
			        : new ContentService(requester, socket, contentResolver, reflectionCache);
	        }
	        
	        UserDataCache<Dictionary<string, string>> StatsCacheFactory(string name, long ttlms, UserDataCache<Dictionary<string, string>>.CacheResolver resolver, IDependencyProvider provider)
	        {
		        return new EphemeralUserDataCache<Dictionary<string, string>>(name, resolver);
	        }
	        
	        UserDataCache<RankEntry> LeaderboardRankEntryFactory(string name, long ttlms, UserDataCache<RankEntry>.CacheResolver resolver, IDependencyProvider provider)
	        {
		        return new EphemeralUserDataCache<RankEntry>(name, resolver);
	        }
	        
	        IBeamableServices ExtractSdks(IServiceProvider provider)
	        {
		        var services = new BeamableServices
		        {
			        Analytics = provider.GetRequiredService<IMicroserviceAnalyticsService>(),
			        Auth = provider.GetRequiredService<IMicroserviceAuthApi>(),
			        Stats = provider.GetRequiredService<IMicroserviceStatsApi>(),
			        Content = provider.GetRequiredService<IMicroserviceContentApi>(),
			        Inventory = provider.GetRequiredService<IMicroserviceInventoryApi>(),
			        Leaderboards = provider.GetRequiredService<IMicroserviceLeaderboardsApi>(),
			        Announcements = provider.GetRequiredService<IMicroserviceAnnouncementsApi>(),
			        Calendars = provider.GetRequiredService<IMicroserviceCalendarsApi>(),
			        Events = provider.GetRequiredService<IMicroserviceEventsApi>(),
			        Groups = provider.GetRequiredService<IMicroserviceGroupsApi>(),
			        Mail = provider.GetRequiredService<IMicroserviceMailApi>(),
			        Notifications = provider.GetRequiredService<IMicroserviceNotificationsApi>(),
			        Social = provider.GetRequiredService<IMicroserviceSocialApi>(),
			        Tournament = provider.GetRequiredService<IMicroserviceTournamentApi>(),
			        TrialData = provider.GetRequiredService<IMicroserviceCloudDataApi>(),
			        RealmConfig= provider.GetRequiredService<IMicroserviceRealmConfigService>(),
			        Commerce = provider.GetRequiredService<IMicroserviceCommerceApi>(),
			        Chat = provider.GetRequiredService<IMicroserviceChatApi>(),
			        Payments = provider.GetRequiredService<IMicroservicePaymentsApi>(),
			        Push = provider.GetRequiredService<IMicroservicePushApi>(),
			        Scheduler = provider.GetRequiredService<BeamScheduler>()
		        };
		        return services;
	        }
        }

        public static void InitializeServices(IServiceProvider provider)
        {
	        // we need to init the mongo serialization service
	        var mongo = provider.GetService<MongoSerializationService>();
	        mongo.Init();
        }

        public static Task ConfigureDiscovery(IMicroserviceArgs args, MicroserviceAttribute attribute)
        {
	        var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";
	        if (inDocker)
	        {
		        return Task.CompletedTask;
	        }
	        
	        var msg = new ServiceDiscoveryEntry
	        {
		        processId = Environment.ProcessId,
		        cid = args.CustomerID,
		        pid = args.ProjectName,
		        prefix = args.NamePrefix,
		        serviceName = attribute.MicroserviceName,
		        healthPort = args.HealthPort,
		        serviceType = "service",
		        startedByAccountId = args.AccountId
	        };
	        var msgJson = JsonConvert.SerializeObject(msg, UnitySerializationSettings.Instance);
	        var msgBytes = Encoding.UTF8.GetBytes(msgJson);
	        var broadcastSocket = new UdpClient();
	        broadcastSocket.Connect(new IPEndPoint(IPAddress.Broadcast, Constants.Features.Services.DISCOVERY_PORT));
	        return Task.Run(function: async () =>
	        {
		        try
		        {
			        do
			        {
				        await broadcastSocket.SendAsync(msgBytes, msgBytes.Length);
				        await Task.Delay(Constants.Features.Services.DISCOVERY_BROADCAST_PERIOD_MS);
			        } while (true);
		        }
		        catch (Exception e)
		        {
			        _logger.LogError(e, e.Message);
		        }
	        });
        }

        public static void ConfigureRequiredProcessIdWatcher(IMicroserviceArgs args)
        {
	        var requireProcessId = args.RequireProcessId;
	        if (requireProcessId <= 0) return;

	        var _ = Task.Run(async () =>
	        {
		        try
		        {
					_logger.ZLogDebug($"Running process-watcher loop for required process id=[{requireProcessId}]");
					var processExists = true;
					do
					{
						await Task.Delay(TimeSpan.FromSeconds(1));
						try
						{
							var p = Process.GetProcessById(requireProcessId);
							if (p.HasExited)
							{
								processExists = false;
							}
						}
						catch
						{
							processExists = false;
						}
						
						
					} while (processExists);
					
					// terminate. 
					_logger.LogInformation("Quitting because required process no longer exists");
					Environment.Exit(0);
		        }
		        catch (Exception ex)
		        {
			        _logger.ZLogError($"Error while watching for required process id. type=[{ex.GetType().Name}] message=[{ex.Message}]");
		        }
	        });
	        
        }

        public static async Task<string> ConfigureCid(IMicroserviceArgs args)
        {
	        // it is possible that the user passed in an alias instead a cid for the env var, we should fix that...
	        if (AliasHelper.IsCid(args.CustomerID)) return args.CustomerID;
	        
	        // if here, we can assume the string is an alias... 
	        var aliasService = new AliasService(new MicroserviceHttpRequester(args, new HttpClient()));
	        var res = await aliasService.Resolve(args.CustomerID);
	        return res.Cid.Value;
        }

        public static async Task ConfigureUsageService(IMicroserviceArgs args)
        {
	        var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";

	        if (!inDocker)
	        {
		        EcsService = new LocalUsageService();
	        }
	        else
	        {
		        if (string.IsNullOrEmpty(args.MetadataUrl))
		        {
			        EcsService = new DockerService();
		        }
		        else
		        {
			        EcsService = new EcsService(new HttpClient());
		        }
	        }

	        await EcsService.Init();
        }
        
        /// <summary>
        /// Get the local execution path of the beam CLI.
        /// If there is a Library/BeamableEditor/BeamCLI/(version)/beam file, then
        /// that will be used.
        /// However, if that file does not exist, then a global "beam" will be used.
        /// </summary>
        /// <returns></returns>
        public static string GetBeamProgram()
        {
	        string beamPathOverride = Environment.GetEnvironmentVariable(Constants.EnvironmentVariables.BEAM_PATH);
	        if (!string.IsNullOrEmpty(beamPathOverride))
	        {
		        return beamPathOverride;
	        }

	        return "tool run beam"; // use global
        }

        /// <summary>
        /// Ascend local folders until a .beamable folder is found.
        /// </summary>
        /// <param name="beamableFolderPath"></param>
        /// <returns></returns>
        public static bool TryFindBeamableFolder(out string beamableFolderPath)
        {
	        beamableFolderPath = null;
	        var curr = Directory.GetCurrentDirectory();
	        var searchingForParent = true;

	        do
	        {
		        var directories = Directory.GetDirectories(curr);
		        foreach (var dir in directories)
		        {
			        var pathName = Path.GetFileName(dir);
			        if (pathName != ".beamable") continue;

			        beamableFolderPath = Path.GetFullPath(curr);
			        return true;
		        }

		        var parent = Directory.GetParent(curr);
		        if (!(parent?.Exists ?? false))
		        {
			        searchingForParent = false;
		        }
		        else
		        {
			        curr = parent.FullName;
		        }
	        } while (searchingForParent);

	        return false;
        }

        private static IMicroserviceArgs _args;
        private static IActivityProvider _activityProvider;
        private static ResourceBuilder _resourceBuilder;
        private static ILoggerFactory _loggerFactory;
        private static DebugLogProcessor _debugLogProcessor;
        public static ILogger _logger;
        private static readonly BeamStandardTelemetryAttributeProvider _standardBeamTelemetryAttributes = new BeamStandardTelemetryAttributeProvider();

        public static void ConfigureTelemetry(IMicroserviceArgs args, MicroserviceAttribute attribute)
        {
	        var metricProvider = Sdk.CreateMeterProviderBuilder()
			        .AddMeter(Otel.METER_NAME)
			        .AddMeter("MongoDB.Driver.Core.Extensions.DiagnosticSources")
			        .AddProcessInstrumentation()
			        .AddRuntimeInstrumentation()
			        .SetResourceBuilder(_resourceBuilder)
			        .AddOtlpExporter((c) =>
			        {
				        c.ExportProcessorType = ExportProcessorType.Simple;
				        c.Protocol = OtlpExportProtocol.Grpc;
			        })
			        .Build()
		        ;

			// TODO: keep references to providers so that we can force flush them at the shutdown
	        var traceProvider = Sdk.CreateTracerProviderBuilder()
			        .SetResourceBuilder(_resourceBuilder)
			        .AddSource(Otel.METER_NAME)
			        .AddSource("MongoDB.Driver.Core.Extensions.DiagnosticSources")
			        .SetSampler<TraceSampler>()
			        .AddOtlpExporter((c) =>
			        {
				        c.ExportProcessorType = ExportProcessorType.Simple;
				        c.Protocol = OtlpExportProtocol.Grpc;
			        })
			        .Build()
		        ;
        }

        
        /// <summary>
        /// This method can be called before the start of the microservice to inject some CLI information.
        /// This is only used to execute a microservice through the IDE.
        /// </summary>
        /// <param name="customArgs">Optional string with args to be used instead of the default ones.</param>
        /// <typeparam name="TMicroservice">The type of the microservice calling this method.</typeparam>
        /// <exception cref="Exception">Exception raised in case the generate-env command fails.</exception>
        public static async Task Prepare<TMicroservice>(string customArgs = null) where TMicroservice : Microservice
        {

	        var cliArgs = Environment.GetCommandLineArgs();
	        if (cliArgs.Contains("--generate-client-please"))
	        {
		        // do something else
		        Environment.Exit(0);
	        }
	        
	        var envArgs = _args = new EnvironmentArgs();
	        var attribute = typeof(TMicroservice).GetCustomAttribute<MicroserviceAttribute>();
	        
	        ConfigureZLogging<TMicroservice>(envArgs, includeOtel: false);

	        _logger.LogInformation($"Starting Prepare");

	        var inDocker = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true";
	        if (inDocker) return;

	        ConfigureRequiredProcessIdWatcher(envArgs);

	        var serviceName = attribute.MicroserviceName;
	        
	        customArgs ??= ". --auto-deploy";
			
	        using var process = new Process();

	        var dotnetPath = Environment.GetEnvironmentVariable(Constants.EnvironmentVariables.BEAM_DOTNET_PATH);
	        var beamProgram = GetBeamProgram();

	        string arguments = $"{beamProgram} project generate-env {serviceName} {customArgs} --logs v --pretty --no-log-file --remove-all-except-pid {Process.GetCurrentProcess().Id}";
	        string fileName = !string.IsNullOrEmpty(dotnetPath) ? dotnetPath : "dotnet";
	        
	        process.StartInfo.FileName = fileName;
	        process.StartInfo.Arguments = arguments;
	        process.StartInfo.RedirectStandardOutput = true;
	        process.StartInfo.RedirectStandardError = true;
	        process.StartInfo.CreateNoWindow = true;
	        process.StartInfo.UseShellExecute = false;
	        process.EnableRaisingEvents = true;
	        
	        var result = "";
	        var sublogs = "";
	        //TODO: These events are still not working for some reason
	        process.ErrorDataReceived += (sender, args) =>
	        {
				_logger.ZLogTrace($"Generate env process (error): [{args.Data}]");
				if(!string.IsNullOrEmpty(args.Data)) sublogs += args.Data;
	        };

	        process.OutputDataReceived += (sender, args) =>
	        {
		        _logger.ZLogTrace($"Generate env process (log): [{args.Data}]");
		        if(!string.IsNullOrEmpty(args.Data)) result += args.Data;
	        };


	        string path = Environment.GetEnvironmentVariable(Constants.EnvironmentVariables.BEAM_DOTNET_MSBUILD_PATH, EnvironmentVariableTarget.Process);
	        if (!string.IsNullOrEmpty(path))
	        {
		        process.StartInfo.EnvironmentVariables[Constants.EnvironmentVariables.BEAM_DOTNET_MSBUILD_PATH] = path;
	        }

	        if (!string.IsNullOrEmpty(dotnetPath))
	        {
		        process.StartInfo.EnvironmentVariables[Constants.EnvironmentVariables.BEAM_DOTNET_PATH] = dotnetPath;
	        }
	        _logger.ZLogInformation($"Running command {fileName} {arguments}");
	        process.Start();
	        process.BeginOutputReadLine();
	        process.BeginErrorReadLine();

	        var exitSignal = new Promise();
	        process.Exited += (sender, args) =>
	        {
		        exitSignal.CompleteSuccess();
	        };
	        
	        await process.WaitForExitAsync();
	        // Might be necessary due to stupid .NET thing that causes the Out/Err callbacks to trigger a bit after the process closes.
	        await exitSignal;
	        await Task.Delay(100);

	     
	        if (process.ExitCode != 0)
	        {
		        _logger.ZLogError($"generate-env output:\n{sublogs}");
		        throw new Exception($"Failed to generate-env message=[{result}] sub-logs=[{sublogs}]");
	        }
	        _logger.ZLogInformation($"environment:\n{result}");
	        
	        var parsedOutput = JsonConvert.DeserializeObject<ReportDataPoint<GenerateEnvFileOutput>>(result);
	        if (parsedOutput.type != "stream")
	        {
		        // the output type needs to be "stream" (the default data output channel name). 
		        //  if the type isn't "stream", it is likely doing to be "error", but even if it isn't, 
		        //  it isn't the expected value.
		        throw new Exception($"Failed to parse generate-env output. raw=[{result}]");
	        }

	        // apply the environment data to the local process.
	        var envData = parsedOutput.data;
	        foreach (var envVar in envData.envVars)
	        {
		        Environment.SetEnvironmentVariable(envVar.name, envVar.value);
	        }

	        envArgs = _args = new EnvironmentArgs();
	        //var resolvedCid = await ConfigureCid(envArgs);
	        //_args.SetResolvedCid(resolvedCid);


	        var activityProvider = new DefaultActivityProvider(envArgs, attribute);
	        _activityProvider = activityProvider;
	        
	        var ctx = new DefaultAttributeContext
	        {
		        Attributes = new TelemetryAttributeCollection(),
		        Args = envArgs
	        };
	        // TODO: allow customer to override the attributes

	        // run the standard provider *AFTER* the user level stuff, so that
	        //  standard beamable attributes overwrite conflicting user attributes.
	        //  Ex: It is not valid for a user to override what "cid" does. 
	        _standardBeamTelemetryAttributes.CreateDefaultAttributes(ctx);

	        _resourceBuilder = ResourceBuilder.CreateEmpty()
		        .AddService(activityProvider.ServiceName, activityProvider.ServiceNamespace,
			        autoGenerateServiceInstanceId: false,
			        serviceInstanceId: activityProvider.ServiceId)
		        .AddAttributes(ctx.Attributes.ToDictionary());
	        
	        

	        ConfigureZLogging<TMicroservice>(envArgs, includeOtel: true);
        }

        public static async Task Start<TMicroService>() where TMicroService : Microservice
        {
	        BeamableZLoggerProvider.LogContext.Value = _logger;
	        var attribute = typeof(TMicroService).GetCustomAttribute<MicroserviceAttribute>();
	        var envArgs = new EnvironmentArgs();

	        ConfigureTelemetry(envArgs, attribute);

	        ConfigureUncaughtExceptions();
	        ConfigureUnhandledError();
	        _localDiscoveryBroadcast = ConfigureDiscovery(envArgs, attribute);
	        await ConfigureUsageService(envArgs);
	        ReflectionCache = ConfigureReflectionCache();
	        
	        // configure the root service scope, and then build the root service provider.
	        var serviceBuilder = ConfigureServices<TMicroService>(envArgs);
	        var rootServiceScope = serviceBuilder.Build(new BuildOptions
	        {
		        allowHydration = false
	        });
	        InitializeServices(rootServiceScope);

	        var resolvedCid = await ConfigureCid(envArgs);
	        var args = envArgs.Copy(conf =>
	        {
		        conf.ServiceScope = rootServiceScope;
		        conf.CustomerID = resolvedCid;
	        });

	        for (var i = 0; i < args.BeamInstanceCount; i++)
            {
	            var isFirstInstance = i == 0;
	            var beamableService = new BeamableMicroService();
				Instances.Add(beamableService);
				
				var instanceArgs = args.Copy(conf =>
				{
					// only the first instance needs to run, if anything should run at all.
					conf.DisableCustomInitializationHooks |= !isFirstInstance;
				});
				
	            if (isFirstInstance)
	            {
		            var localDebug = new ContainerDiagnosticService(instanceArgs, beamableService, _debugLogProcessor);
		            var runningDebugTask = localDebug.Run();
	            }
	            
	            //In case that SdkVersionExecution is null or empty, we are executing it locally with dotnet and
	            //therefore getting dependencies through nuget, so not required to check versions mismatch.
	            if (!string.IsNullOrEmpty(args.SdkVersionExecution) && !string.Equals(args.SdkVersionExecution, args.SdkVersionBaseBuild))
	            {
		            _logger.ZLogCritical(
			            $"Version mismatch. Image built with {args.SdkVersionBaseBuild}, but is executing with {args.SdkVersionExecution}. This is a fatal mistake.");
		            throw new Exception(
			            $"Version mismatch. Image built with {args.SdkVersionBaseBuild}, but is executing with {args.SdkVersionExecution}. This is a fatal mistake.");
	            }

	            try
	            {
		            await beamableService.Start<TMicroService>(instanceArgs);
		            if (isFirstInstance && (attribute?.EnableEagerContentLoading ?? false))
		            {
			            await rootServiceScope.GetService<ContentService>().initializedPromise;
		            }
	            }
	            catch (Exception ex)
	            {
		            var message = new StringBuilder(1024 * 10);

		            if (ex is not BeamableMicroserviceException beamEx)
			            message.AppendLine(
				            $"[BeamErrorCode=BMS{BeamableMicroserviceException.kBMS_UNHANDLED_EXCEPTION_ERROR_CODE}]" +
				            $" Unhandled Exception Found! Please notify Beamable of your use case that led to this.");
		            else
			            message.AppendLine($"[BeamErrorCode=BMS{beamEx.ErrorCode}] " +
			                               $"Beamable Exception Found! If the message is unclear, please contact Beamable with your feedback.");

		            message.AppendLine("Exception Info:");
		            message.AppendLine($"Name={ex.GetType().Name}, Message={ex.Message}");
		            message.AppendLine("Stack Trace:");
		            message.AppendLine(ex.StackTrace);
		            _logger.LogCritical(message.ToString());
		            throw;
	            }

	            if (args.WatchToken)
		            HotReloadMetadataUpdateHandler.ServicesToRebuild.Add(beamableService);

	            var _ = beamableService.RunForever();
            }

            await Task.Delay(-1);
        }
    }
}
