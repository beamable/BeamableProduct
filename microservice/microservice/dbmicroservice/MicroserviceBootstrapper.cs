using Beamable.Api.Autogenerated;
using Beamable.Api.Autogenerated.Beamootel;
using System;
using System.Text;
using System.Threading.Tasks;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Content;
using Beamable.Common.Api.Realms;
using Beamable.Common.Api.Stats;
using Beamable.Common.BeamCli;
using Beamable.Common.BeamCli.Contracts;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Common.Reflection;
using Beamable.Common.Scheduler;
using Beamable.Server.Api;
using Beamable.Server.Api.Analytics;
using Beamable.Server.Api.Announcements;
using Beamable.Server.Api.Calendars;
using Beamable.Server.Api.Chat;
using Beamable.Server.Api.CloudData;
using Beamable.Server.Api.Commerce;
using Beamable.Server.Api.Content;
using Beamable.Server.Api.Events;
using Beamable.Server.Api.Groups;
using Beamable.Server.Api.Inventory;
using Beamable.Server.Api.Leaderboards;
using Beamable.Server.Api.Mail;
using Beamable.Server.Api.Notifications;
using Beamable.Server.Api.Payments;
using Beamable.Server.Api.Push;
using Beamable.Server.Api.RealmConfig;
using Beamable.Server.Api.Scheduler;
using Beamable.Server.Api.Social;
using Beamable.Server.Api.Stats;
using Beamable.Server.Api.Tournament;
using Beamable.Server.Api.Usage;
using Beamable.Server.Common;
using Beamable.Server.Content;
using Beamable.Server.Ecs;
using microservice;
using microservice.dbmicroservice;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.Versioning;
using System.Text.Json;
using Beamable.Common.Util;
using beamable.microservice.otel.exporter;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Exporter;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using System.Threading;
using beamable.tooling.common;
using ZLogger;
using Beamable.Tooling.Common;
using Beamable.Tooling.Common.OpenAPI;
using microservice.Common;
using Microsoft.OpenApi;
using Microsoft.OpenApi.Extensions;
using ZLogger.Formatters;
using Constants = Beamable.Common.Constants;
using Otel = Beamable.Common.Constants.Features.Otel;
using Debug = UnityEngine.Debug;
using RankEntry = Beamable.Common.Api.Leaderboards.RankEntry;

namespace Beamable.Server
{
	public class SingleUseUserContext : IUserContext
	{
		public long UserId { get; set; }
	}

    public static partial class MicroserviceBootstrapper
    {
	    public static LogLevel LogLevel;


        private static BeamServiceConfigBuilder _preparedBuilder;
        
        /// <summary>
        /// This method can be called before the start of the microservice to inject some CLI information.
        /// This is only used to execute a microservice through the IDE.
        /// </summary>
        /// <param name="customArgs">Optional string with args to be used instead of the default ones.</param>
        /// <typeparam name="TMicroservice">The type of the microservice calling this method.</typeparam>
        /// <exception cref="Exception">Exception raised in case the generate-env command fails.</exception>
        public static Task Prepare<TMicroservice>(string customArgs = null) where TMicroservice : Microservice
        {
	        _preparedBuilder = BeamServer.Create()
		        .IncludeRoutes<TMicroservice>(
			        // enable backward compat, 
			        //  old microservices never had route prefixes or client prefixes, 
			        //  so best to leave them blank. 
			        routePrefix: "", 
			        clientPrefix: "")
		        .OverrideConfig(conf =>
		        {
			        var attrs = typeof(TMicroservice).GetCustomAttribute<MicroserviceAttribute>();
			        if (attrs != null)
			        {
				        conf.Attributes.DisableAllBeamableEvents = attrs.DisableAllBeamableEvents;
				        conf.Attributes.EnableEagerContentLoading = attrs.EnableEagerContentLoading;
				        conf.Attributes.CustomAutoGeneratedClientPath = attrs.CustomAutoGeneratedClientPath;
#pragma warning disable CS0618 // Type or member is obsolete
				        conf.Attributes.UseLegacySerialization = attrs.UseLegacySerialization;
#pragma warning restore CS0618 // Type or member is obsolete
			        }
			        conf.LocalEnvCustomArgs = customArgs;
		        });
	        return Task.CompletedTask;
        }

        /// <summary>
        /// When you run `dotnet run`, the working directory is from where you ran `dotnet run` from.
        /// When you run from Docker or Rider, the working directory is where the built dll is.
        /// This is confusing, and this function will attempt to map to the Docker behaviour.
        /// </summary>
        /// <param name="attr"></param>
        public static void AdjustWorkingDirectory<TMicroservice>() where TMicroservice : Microservice
        {
	        Type microserviceType = typeof(TMicroservice);
	        var attribute = microserviceType.GetCustomAttribute<MicroserviceAttribute>();
	        var dllName = attribute.MicroserviceName + ".dll";
	        if (File.Exists(dllName)) return; // hooray, we are in the right folder already.
	        
	        var assembly = Assembly.GetExecutingAssembly();
	        var frameworkAttr = assembly
		        .GetCustomAttributes(typeof(TargetFrameworkAttribute), false)
		        .OfType<TargetFrameworkAttribute>()
		        .FirstOrDefault();

	        var frameworkFolder = frameworkAttr.FrameworkDisplayName.ToLowerInvariant().Replace(" ", "").Substring(1);
	        var likelyFolder = Path.Combine("bin", "Debug", frameworkFolder);

	        var likelyDllPath = Path.Combine(likelyFolder, dllName);
	        if (File.Exists(likelyDllPath))
	        {
		        // ah, this should be the working directory.
		        Environment.CurrentDirectory = likelyFolder;
	        }
        }

        public static void ForceUseRemoteDependencies<TMicroservice>() where TMicroservice : Microservice
        {
	        Type microserviceType = typeof(TMicroservice);
	        var attribute = microserviceType.GetCustomAttribute<MicroserviceAttribute>();
	        var serviceName = attribute.MicroserviceName;

	        var depsNames = Environment.GetEnvironmentVariable($"BEAM_DEPS_{serviceName}");

	        if (!string.IsNullOrEmpty(depsNames))
	        {
		        var deps = depsNames.Split(",");

		        foreach (string dep in deps)
		        {
			        Environment.SetEnvironmentVariable($"STORAGE_CONNSTR_{dep}", "");
		        }
	        }
        }
        
        public static async Task Start<TMicroService>() where TMicroService : Microservice
        {
	        if (_preparedBuilder == null)
	        {
		        throw new InvalidOperationException("You must call " + nameof(Prepare) + " first.");
	        }
	        await _preparedBuilder.RunForever();
        }

    }
}
