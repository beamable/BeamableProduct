using Beamable.Common.Content;
using Beamable.Server;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;

namespace Beamable.Microservice.SourceGen.Analyzers;


/// <summary>
/// This class is responsible for Analyzing the C#MS code and reporting Diagnostics for it
/// The diagnostics generated by this class will appear on both IDE Execution and during build time.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class ServicesAnalyzer : DiagnosticAnalyzer
{
	private bool _checkAssemblyReferences;
	private string _beamId;

	private const string VALIDATE_CALLABLE_TYPES_PROPERTY_NAME = "build_property.beamvalidatecallabletypesexistinsharedlibraries";
	private const string BEAM_ID_PROPERTY_NAME = "build_property.beamid";
	private static readonly string LibraryGeneratedPath = Path.Combine("Library", "BeamableEditor", "GeneratedProjects");

	public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics =>
		ImmutableArray.Create(Diagnostics.BeamVerboseDescriptor, Diagnostics.BeamExceptionDescriptor,
			Diagnostics.Srv.InvalidAsyncVoidCallableMethod, Diagnostics.Srv.MultipleMicroserviceClassesDetected,
			Diagnostics.Srv.MissingMicroserviceId, Diagnostics.Srv.NonPartialMicroserviceClassDetected,
			Diagnostics.Srv.NoMicroserviceClassesDetected, Diagnostics.Srv.CallableTypeInsideMicroserviceScope,
			Diagnostics.Srv.CallableMethodTypeIsNested, Diagnostics.Srv.ClassBeamGenerateSchemaAttributeIsNested,
			Diagnostics.Srv.MicroserviceIdInvalidFromCsProj, Diagnostics.Srv.StaticFieldFoundInMicroservice,
			Diagnostics.Srv.MissingSerializableAttributeOnType, Diagnostics.Srv.PropertiesFoundInSerializableTypes,
			Diagnostics.Srv.NullableFieldsInSerializableTypes, Diagnostics.Srv.FieldIsContentObjectSubtype,
			Diagnostics.Srv.TypeInBeamGeneratedIsMissingBeamGeneratedAttribute);
	
	public override void Initialize(AnalysisContext context)
	{
		context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
		context.RegisterSyntaxNodeAction(AnalyzeCallableMethods, SyntaxKind.MethodDeclaration);
		context.RegisterSyntaxNodeAction(AnalyzeFields, SyntaxKind.FieldDeclaration);
		context.RegisterSymbolAction(ValidateBeamGenerateSchemaAttr, SymbolKind.NamedType);
		context.RegisterCompilationStartAction(OnCompilationStart);
		context.EnableConcurrentExecution();
	}

	
	private void ValidateBeamGenerateSchemaAttr(SymbolAnalysisContext context)
	{
		try
		{
			var namedSymbol = (INamedTypeSymbol)context.Symbol;
			var attributes = namedSymbol.GetAttributes();
			if (attributes.Any(att => att.AttributeClass is { Name: nameof(BeamGenerateSchemaAttribute) }))
			{
				var syntaxRef =
					namedSymbol.DeclaringSyntaxReferences.FirstOrDefault(reference =>
						reference.GetSyntax() is ClassDeclarationSyntax);

				if (syntaxRef?.GetSyntax() is ClassDeclarationSyntax classDeclaration)
				{
					var location = Diagnostics.GetValidLocation(classDeclaration.Identifier.GetLocation(), context.Compilation);
					ValidateNestedType(context.Compilation, context.ReportDiagnostic, location, namedSymbol);

					ValidateSerializableAttributeOnSymbol(context.Compilation, context.ReportDiagnostic, namedSymbol,
						location);
					ValidateMembersInSymbol(context.Compilation, context.ReportDiagnostic, namedSymbol, true, location);
				}
			}
		}
		catch (Exception e)
		{
			context.ReportDiagnostic(Diagnostics.GetException(e, null, context.Compilation));
			throw;
		}
	}
	
	private void OnCompilationStart(CompilationStartAnalysisContext context)
	{
		var microserviceInfos = new ConcurrentBag<MicroserviceInfo>();
		context.RegisterSymbolAction(symbolContext =>
		{
			try
			{
				MicroserviceInfo? validateMicroservice = ValidateMicroservice(symbolContext);
				if (validateMicroservice.HasValue)
				{
					microserviceInfos.Add(validateMicroservice.Value);
				}
			}
			catch (Exception e)
			{
				symbolContext.ReportDiagnostic(Diagnostics.GetException(e, null, context.Compilation));
				throw;
			}
		}, SymbolKind.NamedType);

		var analyzerConfigOptions = context.Options.AnalyzerConfigOptionsProvider.GlobalOptions;
		var compilationReferences = context.Compilation.References.ToList();

		CheckValidateCallableTypeProperty(analyzerConfigOptions, compilationReferences);
		CacheBeamIdProperty(analyzerConfigOptions);

		context.RegisterSyntaxNodeAction(ValidateMethodReturnAndParametersType, SyntaxKind.MethodDeclaration);
		
		context.RegisterCompilationEndAction(analysisContext =>
		{
			// Diagnostics generated after the compilation end do not appear as red squiggle in the code
			// This happens because the SyntaxTree is already done, and it cannot be changed anymore with 
			// diagnostics warning/suggestions/errors
			if (microserviceInfos.Count == 0)
			{
				var err = Diagnostic.Create(Diagnostics.Srv.NoMicroserviceClassesDetected, null);
				analysisContext.ReportDiagnostic(err);
			}
			
			// Check if there is more than one microservice in the cs proj.
			// This needs to run at the end of the compilation to ensure that all microservices classes were be detected
			// The Distinct is used to we ignore multiple partial classes of the same name
			// Then we get the first one by order so we keep the diagnostic always on the same class 
			if (microserviceInfos.Select(item => item.Name).Distinct().Count() > 1)
			{
				MicroserviceInfo microserviceInfo = microserviceInfos.OrderBy(item => item.Name).First();
				string otherMicroservices = string.Join(", ", microserviceInfos
					.Where(item => item.Name != microserviceInfo.Name)
					.Select(info => info.Name).ToList());
				
				var diag = Diagnostic.Create(
					Diagnostics.Srv.MultipleMicroserviceClassesDetected,
					microserviceInfo.MicroserviceClassLocation,
					otherMicroservices
				);
		
				analysisContext.ReportDiagnostic(diag);
			}
		});
	}

	private void CacheBeamIdProperty(AnalyzerConfigOptions analyzerConfigOptions)
	{
		bool hasBeamIdProperty = analyzerConfigOptions.TryGetValue(BEAM_ID_PROPERTY_NAME, out string beamId) &&
		                         !string.IsNullOrEmpty(beamId);
		_beamId = hasBeamIdProperty ? beamId : null;
	}

	private void CheckValidateCallableTypeProperty(AnalyzerConfigOptions analyzerConfigOptions,
		List<MetadataReference> compilationReferences)
	{
		bool hasValidateProperty =
			analyzerConfigOptions.TryGetValue(VALIDATE_CALLABLE_TYPES_PROPERTY_NAME, out string value) &&
			!string.IsNullOrEmpty(value);

		bool hasAutoGeneratedReference = compilationReferences.Any(item =>
			item is PortableExecutableReference { FilePath: not null } reference &&
			reference.FilePath.Contains(LibraryGeneratedPath));


		_checkAssemblyReferences = (!hasValidateProperty && hasAutoGeneratedReference) ||
		                           (hasValidateProperty &&
		                            string.Equals(value, "true", StringComparison.OrdinalIgnoreCase));
	}

	private MicroserviceInfo? ValidateMicroservice(SymbolAnalysisContext symbolContext)
	{
		var namedSymbol = (INamedTypeSymbol)symbolContext.Symbol;

		if (namedSymbol.TypeKind != TypeKind.Class || namedSymbol.BaseType is not { Name: nameof(Server.Microservice) })
		{
			return null;
		}
			
		var classDeclarationSyntaxes = namedSymbol.DeclaringSyntaxReferences.Where(reference => reference.GetSyntax() is ClassDeclarationSyntax)
			.Select(reference => reference.GetSyntax() as ClassDeclarationSyntax).ToList();
		var location = classDeclarationSyntaxes.FirstOrDefault()?.Identifier.GetLocation();
			
		ImmutableArray<AttributeData> attributes = namedSymbol.GetAttributes();
		if (!attributes.Any(att => att.AttributeClass is { Name: nameof(MicroserviceAttribute) }))
		{
			var missingIdDiagnostic = Diagnostic.Create(Diagnostics.Srv.MissingMicroserviceId, location);
			symbolContext.ReportDiagnostic(missingIdDiagnostic);
		}
		else
		{
			var attribute = attributes.FirstOrDefault(att => att.AttributeClass is { Name: nameof(MicroserviceAttribute) });
			var attributeParameter = attribute.ConstructorArguments.FirstOrDefault();
			if (attributeParameter.Value is string value && !string.IsNullOrEmpty(_beamId) && value != _beamId)
			{
				var properties = new Dictionary<string, string> { { Diagnostics.Srv.PROP_BEAM_ID, _beamId } }
					.ToImmutableDictionary();
				
				var invalidMicroserviceBeamId = Diagnostic.Create(Diagnostics.Srv.MicroserviceIdInvalidFromCsProj,
					location, properties: properties,value, _beamId);
				symbolContext.ReportDiagnostic(invalidMicroserviceBeamId);
			}
		}

		if (!classDeclarationSyntaxes.Any(syntax =>
			    syntax.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.PartialKeyword))))
		{
			var err = Diagnostic.Create(Diagnostics.Srv.NonPartialMicroserviceClassDetected, location);
			symbolContext.ReportDiagnostic(err);
		}

		return new MicroserviceInfo(namedSymbol);
	}

	private static void AnalyzeCallableMethods(SyntaxNodeAnalysisContext context)
	{
		try
		{
			var method = (MethodDeclarationSyntax)context.Node;
			IMethodSymbol methodSymbol = context.SemanticModel.GetDeclaredSymbol(method);

			if (methodSymbol == null || !methodSymbol.GetAttributes().Any(IsCallableAttribute))
			{
				return;
			}

			if (IsAsyncVoid(methodSymbol))
			{
				var diagnostic = Diagnostic.Create(Diagnostics.Srv.InvalidAsyncVoidCallableMethod,
					method.ReturnType.GetLocation(), methodSymbol.Name);
				context.ReportDiagnostic(diagnostic);
			}
		}
		catch (Exception e)
		{
			context.ReportDiagnostic(Diagnostics.GetException(e, null, context.Compilation));
			throw;
		}
	}
	
	private void AnalyzeFields(SyntaxNodeAnalysisContext context)
	{
		try
		{
			var field = (FieldDeclarationSyntax)context.Node;
		
			var classDeclaration = field.FirstAncestorOrSelf<ClassDeclarationSyntax>();
			if (classDeclaration?.BaseList == null ||
			    !classDeclaration.BaseList.Types.Any(item => item.ToString().Contains(nameof(Server.Microservice))))
			{
				return;
			}

			if (!field.Modifiers.Any(SyntaxKind.StaticKeyword) ||
			    field.Modifiers.Any(SyntaxKind.ReadOnlyKeyword))
			{
				return;
			}
		
		
			SyntaxToken identifier = field.Declaration.Variables.First().Identifier;
			string fieldName = identifier.ToString();

			var props = new Dictionary<string, string> { { Diagnostics.Srv.PROP_FIELD_NAME, fieldName } }
				.ToImmutableDictionary();
		
			var diagnostic = Diagnostic.Create(Diagnostics.Srv.StaticFieldFoundInMicroservice,
				identifier.GetLocation(), properties: props, fieldName);
			context.ReportDiagnostic(diagnostic);
		}
		catch (Exception e)
		{
			context.ReportDiagnostic(Diagnostics.GetException(e, null, context.Compilation));
			throw;
		}

	}


	private static bool IsAsyncVoid(IMethodSymbol methodSymbol)
	{
		if (!methodSymbol.IsAsync)
			return false;

		if (methodSymbol.ReturnType.SpecialType != SpecialType.System_Void)
			return false;

		return true;
	}

	private void ValidateMethodReturnAndParametersType(SyntaxNodeAnalysisContext context)
	{
		var method = (MethodDeclarationSyntax)context.Node;
		IMethodSymbol methodSymbol = context.SemanticModel.GetDeclaredSymbol(method);
		
		if (methodSymbol == null || !methodSymbol.GetAttributes().Any(IsCallableAttribute))
		{
			return;
		}
		
		ValidateReturnType(context, methodSymbol, method);
		ValidateParameters(context, methodSymbol);
	}

	private bool IsPrimitiveBuiltInOrBeamableType(ITypeSymbol symbol)
	{
		if(symbol == null)
			return false;
		
		// When handling arrays, we need to validate the elementType instead
		if (symbol is IArrayTypeSymbol arrayTypeSymbol)
		{
			return IsPrimitiveBuiltInOrBeamableType(arrayTypeSymbol.ElementType);
		}

		var primitiveSpecialTypes = new[] {
			SpecialType.System_Byte, 
			SpecialType.System_SByte, 
			SpecialType.System_Int16, 
			SpecialType.System_UInt16,
			SpecialType.System_Int32,
			SpecialType.System_UInt32,
			SpecialType.System_Int64,
			SpecialType.System_UInt64,
			SpecialType.System_Single,
			SpecialType.System_Double,
			SpecialType.System_Char,
			SpecialType.System_Boolean,
			SpecialType.System_String,
			SpecialType.System_DateTime,
			SpecialType.System_Void,
			SpecialType.System_IAsyncResult,
		};

		
		if(primitiveSpecialTypes.Contains(symbol.SpecialType))
			return true;
		
		var specialHandlingTypes = new[]
		{
			"Beamable.Common.Content.Optional", 
			"Beamable.Common.Content.ContentRef",
			"Beamable.Common.Content.ContentLink",
			"Beamable.Common.PromiseBase",
			"System.Threading.Tasks.Task",
			"System.Guid",
			"System.Collections.Generic.List"
		};

		// CSharpErrorMessageFormat... add comment
		List<string> allTypes = new List<string> { symbol.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat) };
		var lastSymbol = symbol;
		while (lastSymbol.BaseType != null)
		{
			lastSymbol = lastSymbol.BaseType;
			allTypes.Add(lastSymbol.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat));
		}
		
		return specialHandlingTypes.Any(beamType => allTypes.Any(symbolType => symbolType.StartsWith(beamType)));

	}

	private void ValidateReturnType(SyntaxNodeAnalysisContext context, IMethodSymbol methodSymbol,
		MethodDeclarationSyntax method)
	{
		try
		{
			var methodAssembly = methodSymbol.ContainingAssembly;
			Location returnLocation = Diagnostics.GetValidLocation(method.ReturnType.GetLocation(), context.Compilation);
			if (_checkAssemblyReferences)
			{
				ValidateTypeAssembly(context, returnLocation, methodSymbol.ReturnType, methodAssembly,
					methodSymbol.Name);
			}
			ValidateNestedType(context.Compilation, context.ReportDiagnostic, returnLocation, methodSymbol.ReturnType, methodSymbol.Name);

			ValidateSerializableAttributeOnSymbol(context.Compilation, context.ReportDiagnostic,
				methodSymbol.ReturnType, returnLocation);
			ValidateMembersInSymbol(context.Compilation, context.ReportDiagnostic, methodSymbol.ReturnType,
				fallbackLocation: returnLocation);
		}
		catch (Exception e)
		{
			context.ReportDiagnostic(Diagnostics.GetException(e, null, context.Compilation));
			throw;
		}
	}

	private void ValidateParameters(SyntaxNodeAnalysisContext context, IMethodSymbol methodSymbol)
	{
		try
		{
			var methodAssembly = methodSymbol.ContainingAssembly;

			foreach (var parameterSymbol in methodSymbol.Parameters)
			{

				Location parameterLocation = Diagnostics.GetValidLocation(parameterSymbol.Locations.FirstOrDefault(), context.Compilation);

				context.ReportDiagnostic(Diagnostics.GetVerbose(
					$"ValidateParameters | Parameter {parameterSymbol.Name} location: {parameterLocation.GetLineSpan()}",
					parameterLocation, context.Compilation));
				if (_checkAssemblyReferences)
				{
					ValidateTypeAssembly(context, parameterLocation, parameterSymbol.Type,
						methodAssembly,
						methodSymbol.Name);
				}

				ValidateNestedType(context.Compilation, context.ReportDiagnostic, parameterLocation, parameterSymbol.Type,
					methodSymbol.Name);

				ValidateSerializableAttributeOnSymbol(context.Compilation, context.ReportDiagnostic,
					parameterSymbol.Type, parameterLocation);
				ValidateMembersInSymbol(context.Compilation, context.ReportDiagnostic, parameterSymbol.Type,
					fallbackLocation: parameterLocation);

			}
		}
		catch (Exception e)
		{
			context.ReportDiagnostic(Diagnostics.GetException(e, null, context.Compilation));
			throw;
		}
	}

	private void ValidateNestedType(Compilation compilation, Action<Diagnostic> reportDiagnostic, Location diagnosticLocation, ITypeSymbol typeSymbol, string methodName = null)
	{
		try
		{
			if(typeSymbol.ContainingType == null)
				return;
			var descriptor = string.IsNullOrEmpty(methodName)
				? Diagnostics.Srv.ClassBeamGenerateSchemaAttributeIsNested
				: Diagnostics.Srv.CallableMethodTypeIsNested;
			var diagnostic = Diagnostic.Create(descriptor,
				diagnosticLocation, typeSymbol.Name, methodName);
			reportDiagnostic(diagnostic);
		}
		catch (Exception e)
		{
			reportDiagnostic(Diagnostics.GetException(e, null, compilation));
			throw;
		}
	}


	private void ValidateTypeAssembly(SyntaxNodeAnalysisContext context, Location location, ITypeSymbol typeSymbol, IAssemblySymbol methodAssemblySymbol, string methodName)
	{
		try
		{
			// If it is a Generic Type, we need to check inner types to see if them are in the same Assembly
			if (typeSymbol is INamedTypeSymbol { IsGenericType: true } namedTypeSymbol)
			{
				foreach (ITypeSymbol typeMember in namedTypeSymbol.TypeArguments)
				{
					ValidateTypeAssembly(context, location, typeMember, methodAssemblySymbol, methodName);
				}
			}

			if (typeSymbol.ContainingAssembly == null)
			{
				context.ReportDiagnostic(Diagnostics.GetVerbose($"ValidateTypeAssembly | type: {typeSymbol.Name} have a null assembly", location, context.Compilation));
				return;
			}

			if ( methodAssemblySymbol.Identity == typeSymbol.ContainingAssembly.Identity)
			{
				// This means that the return type is declared inside the microservice scope
				var diagnostic = Diagnostic.Create(Diagnostics.Srv.CallableTypeInsideMicroserviceScope,
					location, methodName, typeSymbol.Name);
				context.ReportDiagnostic(diagnostic);
			}
		}
		catch (Exception e)
		{
			context.ReportDiagnostic(Diagnostics.GetException(e, null, context.Compilation));
			throw;
		}
	}

	private void ValidateSerializableAttributeOnSymbol(Compilation compilation, Action<Diagnostic> reportDiagnostic,
		ITypeSymbol typeSymbol, Location fallbackLocation = null)
	{
		Location location = Diagnostics.GetValidLocation(typeSymbol.Locations.FirstOrDefault(), compilation, fallbackLocation);
		reportDiagnostic.Invoke(Diagnostics.GetVerbose(
			$"SerializableValidate | Symbol {typeSymbol.Name} location: {location.GetLineSpan()}", location, compilation));
		if (typeSymbol is INamedTypeSymbol { IsGenericType: true } namedTypeSymbol)
		{
			reportDiagnostic.Invoke(Diagnostics.GetVerbose(
				$"SerializableValidate | {typeSymbol.Name} is a GenericType, validating each generic type", location, compilation));
			foreach (ITypeSymbol typeMember in namedTypeSymbol.TypeArguments)
			{
				ValidateSerializableAttributeOnSymbol(compilation, reportDiagnostic, typeMember, fallbackLocation);
			}
		}


		// We don't need to check for Primitive, Built-in and Beamable Types
		if (IsPrimitiveBuiltInOrBeamableType(typeSymbol) ||
		    typeSymbol.SpecialType is SpecialType.System_Nullable_T ||
		    typeSymbol.NullableAnnotation is NullableAnnotation.Annotated)
		{
			reportDiagnostic.Invoke(Diagnostics.GetVerbose(
				$"SerializableValidate | {typeSymbol.Name} is a Primitive, Bult-in, or Nullable Type, skipping Serializable validation", location, compilation));
			return;
		}

		reportDiagnostic.Invoke(Diagnostics.GetVerbose(
			$"SerializableValidate | {typeSymbol.Name} is not a Primitive, Bult-in, or Nullable Type", location, compilation));

		var attributes = string.Join(" | ", typeSymbol.GetAttributes().Select(a =>
				$"Name: {a.AttributeClass?.Name ?? string.Empty}, " +
				$"MetadataName: {a.AttributeClass?.MetadataName ?? string.Empty}, " +
				$"ClassToDisplayString: {a.AttributeClass?.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat) ?? string.Empty}, " +
				$"NamespaceName: {a.AttributeClass?.ContainingNamespace.Name ?? string.Empty}, " +
				$"NamespaceToDisplay: {a.AttributeClass?.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat) ?? string.Empty}, "+
				$"AssemblyToDisplay: {a.AttributeClass?.ContainingAssembly?.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat) ?? string.Empty}")
			.ToList());

		reportDiagnostic.Invoke(Diagnostics.GetVerbose(
			$"SerializableValidate | {typeSymbol.Name} has the following attributes: {attributes}", location, compilation));
		
		bool isSerializable = typeSymbol is INamedTypeSymbol { IsSerializable: true };
		reportDiagnostic.Invoke(Diagnostics.GetVerbose($"SerializableValidate | IsTypeSerializable: {isSerializable}",  location, compilation));

		if (isSerializable)
		{
			reportDiagnostic.Invoke(Diagnostics.GetVerbose(
				$"SerializableValidate | {typeSymbol.Name} has SerializableAttribute", location, compilation));
			return;
		}

		reportDiagnostic.Invoke(Diagnostics.GetVerbose(
			$"SerializableValidate | {typeSymbol.Name} hasn't SerializableAttribute", location, compilation));

		// Try to get type location, if not found because it is out of scope, try to get the fallback.
		// If none fallback is passed, use Location.None so we don't throw any Exception.
		var diagnostic = Diagnostic.Create(Diagnostics.Srv.MissingSerializableAttributeOnType,
			location, typeSymbol.Name);
		reportDiagnostic.Invoke(diagnostic);
	}

	/// <summary>
	/// 
	/// </summary>
	/// <param name="compilation"></param>
	/// <param name="reportDiagnostic"></param>
	/// <param name="typeSymbol"></param>
	/// <param name="checkBeamGenAttr"></param>
	/// <param name="fallbackLocation"></param>
	private void ValidateMembersInSymbol(Compilation compilation, Action<Diagnostic> reportDiagnostic,
		ITypeSymbol typeSymbol, bool checkBeamGenAttr = false, Location fallbackLocation = null)
	{
		// Recursively checks all generic types
		if (typeSymbol is INamedTypeSymbol { IsGenericType: true } namedTypeSymbol)
		{
			
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} is a GenericType, validating each generic type", fallbackLocation, compilation));
			
			foreach (ITypeSymbol typeMember in namedTypeSymbol.TypeArguments)
			{
				ValidateMembersInSymbol(compilation, reportDiagnostic, typeMember, checkBeamGenAttr, fallbackLocation);
			}
		}
		
		// We don't need to check for Primitive, Built-in and Beamable Types
		// add case of nullable
		if (IsPrimitiveBuiltInOrBeamableType(typeSymbol) || 
		    typeSymbol.SpecialType == SpecialType.System_Nullable_T ||
		    typeSymbol.NullableAnnotation == NullableAnnotation.Annotated)
		{
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name}  is a Primitive, Bult-in, or Nullable Type, skipping Serializable validation", fallbackLocation, compilation));
			return;
		}
		
		reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name}  is not a Primitive, Bult-in, or Nullable Type, skipping Serializable validation", fallbackLocation, compilation));

		// We only need to validate Members for Classes and Structs
		if (typeSymbol.TypeKind is not (TypeKind.Class or TypeKind.Struct))
		{
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name}  is not a Class or Struct, we can skip member validation for it", fallbackLocation, compilation));
			return;
		}

		foreach (ISymbol member in typeSymbol.GetMembers())
		{
			if (member is IPropertySymbol propertySymbol)
			{
				// if it is Property, we warn the customer that it will not be detected for client code gen
				Location propertyLocation = Diagnostics.GetValidLocation(propertySymbol.Locations.FirstOrDefault(), compilation, fallbackLocation);
				
				reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | Property {propertySymbol.Name} location: {propertyLocation.GetLineSpan()}", propertyLocation, compilation));
				
				reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} - Member {member.Name} is a property", propertyLocation, compilation));
				var diagnostic = Diagnostic.Create(Diagnostics.Srv.PropertiesFoundInSerializableTypes, propertyLocation, propertySymbol.Name);
				reportDiagnostic.Invoke(diagnostic);
				continue;
			}

			if (member is not IFieldSymbol fieldSymbol)
			{
				reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} - Member {member.Name} is not a Field, skipping it", fallbackLocation, compilation));
				continue;
			}
			
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} - Member {member.Name} is a Field", fallbackLocation, compilation));
			
			// Validate if Field is subtype from ContentObject
			Location fieldLocation = Diagnostics.GetValidLocation(fieldSymbol.Locations.FirstOrDefault(), compilation, fallbackLocation);
			
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} - Field {fieldSymbol.Name} location: {fieldLocation.GetLineSpan().ToString()}", fieldLocation, compilation));
			
			if (fieldSymbol.Type.BaseType?.Name == nameof(ContentObject) &&
			    fieldSymbol.Type.Name != nameof(ContentObject))
			{
				
				reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} - Field {fieldSymbol.Name} is a ContentObject Subtype", fieldLocation, compilation));
				
				var diagnostic = Diagnostic.Create(Diagnostics.Srv.FieldIsContentObjectSubtype,  fieldLocation, fieldSymbol.Name);
				reportDiagnostic.Invoke(diagnostic);
			}
			
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} - Field {fieldSymbol.Name} is not a ContentObject Subtype", fieldLocation, compilation));

			// Validate if Field is nullable, code gen do not support it
			if (fieldSymbol.NullableAnnotation == NullableAnnotation.Annotated ||
			    fieldSymbol.Type.SpecialType == SpecialType.System_Nullable_T)
			{
				
				reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} - Field {fieldSymbol.Name} is Nullable", fieldLocation, compilation));
				
				var diagnostic = Diagnostic.Create(Diagnostics.Srv.NullableFieldsInSerializableTypes, fieldLocation, fieldSymbol.Name);
				reportDiagnostic.Invoke(diagnostic);
			}
			
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} - Member {fieldSymbol.Name} is not Nullable", fieldLocation, compilation));
			
			//Validate if field type is also serializable
			ValidateSerializableAttributeOnSymbol(compilation, reportDiagnostic, fieldSymbol.Type, fallbackLocation);

			if (!checkBeamGenAttr)
			{
				reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | No need to Check BeamGenAttribute on {typeSymbol.Name} Member {fieldSymbol} Finishing Validation", fallbackLocation, compilation));
				continue;
			}

			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | Need to Check BeamGenAttribute on {typeSymbol.Name} Member {fieldSymbol} Finishing Validation", fallbackLocation, compilation));


			// Validate if type contains attribute as well
			ImmutableArray<AttributeData> attributes = fieldSymbol.Type.GetAttributes();
			bool hasBeamGenerateAttr = attributes.Any(att => att.AttributeClass is
				{ Name: nameof(BeamGenerateSchemaAttribute) });
			bool isPrimitiveOrBeamableType = IsPrimitiveBuiltInOrBeamableType(fieldSymbol.Type);
			
			var stringAttributes = string.Join(" | ", typeSymbol.GetAttributes().Select(a =>
					$"{a.AttributeClass?.Name ?? string.Empty}, " +
					$"{a.AttributeClass?.MetadataName ?? string.Empty}, " +
					$"{a.AttributeClass?.ToDisplayString() ?? string.Empty}, " +
					$"{a.AttributeClass?.ContainingNamespace.Name ?? string.Empty}" +
					$"{a.AttributeClass?.ContainingNamespace.ToDisplayString() ?? string.Empty}")
				.ToList());
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} Member {fieldSymbol} has the following Attributes: {stringAttributes}", fallbackLocation, compilation));
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} Member {fieldSymbol} Is Beam or Primitive Type: {isPrimitiveOrBeamableType}", fallbackLocation, compilation));
			reportDiagnostic.Invoke(Diagnostics.GetVerbose($"ValidateMembers | {typeSymbol.Name} Member {fieldSymbol} Has BeamGenAttributes: {hasBeamGenerateAttr}", fallbackLocation, compilation));
			
			if(hasBeamGenerateAttr || isPrimitiveOrBeamableType)
				continue;
			
			Location typeLocation = fieldSymbol.Type.Locations.FirstOrDefault() ?? fieldLocation;
			var missingAttrDiagnostic = Diagnostic.Create(Diagnostics.Srv.TypeInBeamGeneratedIsMissingBeamGeneratedAttribute, typeLocation, fieldSymbol.Type.Name);
			reportDiagnostic.Invoke(missingAttrDiagnostic);
			
		}
	}

	/// <summary>
	/// Checks if the Attributes is <see cref="CallableAttribute"/> or an attribute that inherits it.
	/// <para>
	/// It will not detect attributes subtypes of subtypes. Example: A attribute that inherits <see cref="ClientCallableAttribute"/>
	/// </para>
	/// </summary>
	/// <param name="data">AttributeData to check if it is a Callable</param>
	/// <returns></returns>
	private static bool IsCallableAttribute(AttributeData data)
	{
		INamedTypeSymbol attributeClass = data.AttributeClass;
		if (attributeClass == null) return false;
		string callableAttributeName = nameof(CallableAttribute);
		if (attributeClass.Name == callableAttributeName)
		{
			return true;
		}

		return attributeClass.BaseType?.Name == callableAttributeName;
	}
	
}
