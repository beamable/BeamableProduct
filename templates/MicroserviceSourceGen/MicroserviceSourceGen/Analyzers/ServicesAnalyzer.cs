using Beamable.Server;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;

namespace Beamable.Microservice.SourceGen.Analyzers;


/// <summary>
/// This class is responsible for Analyzing the C#MS code and reporting Diagnostics for it
/// The diagnostics generated by this class will appear on both IDE Execution and during build time.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class ServicesAnalyzer : DiagnosticAnalyzer
{
	private bool _checkAssemblyReferences;
	private string _beamId;

	private const string VALIDATE_CALLABLE_TYPES_PROPERTY_NAME = "build_property.beamvalidatecallabletypesexistinsharedlibraries";
	private const string BEAM_ID_PROPERTY_NAME = "build_property.beamid";
	private static readonly string LibraryGeneratedPath = Path.Combine("Library", "BeamableEditor", "GeneratedProjects");
	
	public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics =>
		ImmutableArray.Create(Diagnostics.Srv.InvalidAsyncVoidCallableMethod,
			Diagnostics.Srv.MultipleMicroserviceClassesDetected, Diagnostics.Srv.MissingMicroserviceId,
			Diagnostics.Srv.NonPartialMicroserviceClassDetected, Diagnostics.Srv.NoMicroserviceClassesDetected,
			Diagnostics.Srv.CallableTypeInsideMicroserviceScope, Diagnostics.Srv.CallableMethodTypeIsNested,
			Diagnostics.Srv.ClassBeamGenerateSchemaAttributeIsNested, Diagnostics.Srv.MicroserviceIdInvalidFromCsProj,
			Diagnostics.Srv.StaticFieldFoundInMicroservice);
	
	public override void Initialize(AnalysisContext context)
	{
		context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
		context.RegisterSyntaxNodeAction(AnalyzeCallableMethods, SyntaxKind.MethodDeclaration);
		context.RegisterSyntaxNodeAction(AnalyzeFields, SyntaxKind.FieldDeclaration);
		context.RegisterSymbolAction(AnalyzeNestedTypes, SymbolKind.NamedType);
		context.RegisterCompilationStartAction(OnCompilationStart);
		context.EnableConcurrentExecution();
	}

	
	private void AnalyzeNestedTypes(SymbolAnalysisContext context)
	{
		var namedSymbol = (INamedTypeSymbol)context.Symbol;
		var attributes = namedSymbol.GetAttributes();
		if (attributes.Any(att => att.AttributeClass is { Name: nameof(BeamGenerateSchemaAttribute) }))
		{
			var classDeclaration = namedSymbol.DeclaringSyntaxReferences.FirstOrDefault(reference => reference.GetSyntax() is ClassDeclarationSyntax).GetSyntax() as ClassDeclarationSyntax;
			var location = classDeclaration.Identifier.GetLocation();
			ValidateNestedType(context.ReportDiagnostic, location, namedSymbol);
		}
	}

	
	private void OnCompilationStart(CompilationStartAnalysisContext context)
	{
		var microserviceInfos = new List<MicroserviceInfo>();
		context.RegisterSymbolAction(symbolContext =>
		{
			ValidateMicroservice(symbolContext, microserviceInfos);
		}, SymbolKind.NamedType);

		var analyzerConfigOptions = context.Options.AnalyzerConfigOptionsProvider.GlobalOptions;
		var compilationReferences = context.Compilation.References.ToList();

		CheckValidateCallableTypeProperty(analyzerConfigOptions, compilationReferences);
		CacheBeamIdProperty(analyzerConfigOptions, compilationReferences);

		context.RegisterSyntaxNodeAction(ValidateMethodReturnAndParametersType, SyntaxKind.MethodDeclaration);
		


		context.RegisterCompilationEndAction(analysisContext =>
		{
			// Diagnostics generated after the compilation end do not appear as red squiggle in the code
			// This happens because the SyntaxTree is already done, and it cannot be changed anymore with 
			// diagnostics warning/suggestions/errors
			if (microserviceInfos.Count == 0)
			{
				var err = Diagnostic.Create(Diagnostics.Srv.NoMicroserviceClassesDetected, null);
				analysisContext.ReportDiagnostic(err);
			}
		});
	}

	private void CacheBeamIdProperty(AnalyzerConfigOptions analyzerConfigOptions, List<MetadataReference> compilationReferences)
	{
		bool hasBeamIdProperty = analyzerConfigOptions.TryGetValue(BEAM_ID_PROPERTY_NAME, out string beamId) &&
		                         !string.IsNullOrEmpty(beamId);
		_beamId = hasBeamIdProperty ? beamId : null;
	}

	private void CheckValidateCallableTypeProperty(AnalyzerConfigOptions analyzerConfigOptions,
		List<MetadataReference> compilationReferences)
	{
		bool hasValidateProperty =
			analyzerConfigOptions.TryGetValue(VALIDATE_CALLABLE_TYPES_PROPERTY_NAME, out string value) &&
			!string.IsNullOrEmpty(value);

		bool hasAutoGeneratedReference = compilationReferences.Any(item =>
			item is PortableExecutableReference { FilePath: not null } reference &&
			reference.FilePath.Contains(LibraryGeneratedPath));


		_checkAssemblyReferences = (!hasValidateProperty && hasAutoGeneratedReference) ||
		                           (hasValidateProperty &&
		                            string.Equals(value, "true", StringComparison.OrdinalIgnoreCase));
	}

	private void ValidateMicroservice(SymbolAnalysisContext symbolContext, List<MicroserviceInfo> microserviceInfos)
	{
		var namedSymbol = (INamedTypeSymbol)symbolContext.Symbol;

		if (namedSymbol.TypeKind != TypeKind.Class || namedSymbol.BaseType is not { Name: nameof(Server.Microservice) })
		{
			return;
		}
			
		var classDeclarationSyntaxes = namedSymbol.DeclaringSyntaxReferences.Where(reference => reference.GetSyntax() is ClassDeclarationSyntax)
			.Select(reference => reference.GetSyntax() as ClassDeclarationSyntax).ToList();
		var location = classDeclarationSyntaxes.FirstOrDefault()?.Identifier.GetLocation();
			
		ImmutableArray<AttributeData> attributes = namedSymbol.GetAttributes();
		if (!attributes.Any(att => att.AttributeClass is { Name: nameof(MicroserviceAttribute) }))
		{
			var missingIdDiagnostic = Diagnostic.Create(Diagnostics.Srv.MissingMicroserviceId, location);
			symbolContext.ReportDiagnostic(missingIdDiagnostic);
		}
		else
		{
			var attribute = attributes.FirstOrDefault(att => att.AttributeClass is { Name: nameof(MicroserviceAttribute) });
			var attributeParameter = attribute.ConstructorArguments.FirstOrDefault();
			if (attributeParameter.Value is string value && !string.IsNullOrEmpty(_beamId) && value != _beamId)
			{
				var properties = new Dictionary<string, string> { { Diagnostics.Srv.PROP_BEAM_ID, _beamId } }
					.ToImmutableDictionary();
				
				var invalidMicroserviceBeamId = Diagnostic.Create(Diagnostics.Srv.MicroserviceIdInvalidFromCsProj,
					location, properties: properties,value, _beamId);
				symbolContext.ReportDiagnostic(invalidMicroserviceBeamId);
			}
		}

		if (!classDeclarationSyntaxes.Any(syntax =>
			    syntax.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.PartialKeyword))))
		{
			var err = Diagnostic.Create(Diagnostics.Srv.NonPartialMicroserviceClassDetected, location);
			symbolContext.ReportDiagnostic(err);
		}

		if (!microserviceInfos.Any(i => i.Name.Equals(namedSymbol.Name)))
		{
			microserviceInfos.Add(new MicroserviceInfo(namedSymbol));
		}

		if (microserviceInfos.Count(info => info.Name != namedSymbol.Name) >= 1)
		{
			var otherMicroservices = string.Join(", ",microserviceInfos.Select(info => info.Name).ToList());
			var diag = Diagnostic.Create(
				Diagnostics.Srv.MultipleMicroserviceClassesDetected,
				location,
				otherMicroservices
			);
		
			symbolContext.ReportDiagnostic(diag);
		}
	}

	private static void AnalyzeCallableMethods(SyntaxNodeAnalysisContext context)
	{
		var method = (MethodDeclarationSyntax)context.Node;
		IMethodSymbol methodSymbol = context.SemanticModel.GetDeclaredSymbol(method);

		if (methodSymbol == null || !methodSymbol.GetAttributes().Any(IsCallableAttribute))
		{
			return;
		}

		if (IsAsyncVoid(methodSymbol))
		{
			var diagnostic = Diagnostic.Create(Diagnostics.Srv.InvalidAsyncVoidCallableMethod,
				method.ReturnType.GetLocation(), methodSymbol.Name);
			context.ReportDiagnostic(diagnostic);
		}
	}
	
	private void AnalyzeFields(SyntaxNodeAnalysisContext context)
	{
		var field = (FieldDeclarationSyntax)context.Node;
		
		
		var classDeclaration = field.FirstAncestorOrSelf<ClassDeclarationSyntax>();
		if (classDeclaration?.BaseList == null ||
		    !classDeclaration.BaseList.Types.Any(item => item.ToString().Contains(nameof(Server.Microservice))))
		{
			return;
		}

		if (!field.Modifiers.Any(SyntaxKind.StaticKeyword) ||
		    field.Modifiers.Any(SyntaxKind.ReadOnlyKeyword))
		{
			return;
		}
		
		
		SyntaxToken identifier = field.Declaration.Variables.First().Identifier;
		string fieldName = identifier.ToString();

		var props = new Dictionary<string, string> { { Diagnostics.Srv.PROP_FIELD_NAME, fieldName } }
			.ToImmutableDictionary();
		
		var diagnostic = Diagnostic.Create(Diagnostics.Srv.StaticFieldFoundInMicroservice,
			identifier.GetLocation(), properties: props, fieldName);
		context.ReportDiagnostic(diagnostic);

	}


	private static bool IsAsyncVoid(IMethodSymbol methodSymbol)
	{
		if (!methodSymbol.IsAsync)
			return false;

		if (methodSymbol.ReturnType.SpecialType != SpecialType.System_Void)
			return false;

		return true;
	}

	private void ValidateMethodReturnAndParametersType(SyntaxNodeAnalysisContext context)
	{
		var method = (MethodDeclarationSyntax)context.Node;
		IMethodSymbol methodSymbol = context.SemanticModel.GetDeclaredSymbol(method);
		
		if(methodSymbol == null)
			return;
		
		ValidateReturnType(context, methodSymbol, method);
		ValidateParameters(context, methodSymbol);
	}

	private void ValidateReturnType(SyntaxNodeAnalysisContext context, IMethodSymbol methodSymbol,
		MethodDeclarationSyntax method)
	{
		if (methodSymbol.ReturnType.TypeKind is not (TypeKind.Class or TypeKind.Struct or TypeKind.Interface))
		{
			return;
		}
		
		var methodAssembly = methodSymbol.ContainingAssembly;
		if (_checkAssemblyReferences)
		{
			ValidateTypeAssembly(context, method.ReturnType.GetLocation(), methodSymbol.ReturnType, methodAssembly,
				methodSymbol.Name);
		}

		ValidateNestedType(context.ReportDiagnostic, method.ReturnType.GetLocation(), methodSymbol.ReturnType, methodSymbol.Name);
	}

	private void ValidateParameters(SyntaxNodeAnalysisContext context, IMethodSymbol methodSymbol)
	{
		var parametersToCheck = methodSymbol.Parameters
			.Where(parameter => parameter.Type.TypeKind is TypeKind.Class or TypeKind.Struct or TypeKind.Interface);
		var methodAssembly = methodSymbol.ContainingAssembly;
		
		foreach (var parameterSymbol in parametersToCheck)
		{
			if (_checkAssemblyReferences)
			{
				ValidateTypeAssembly(context, parameterSymbol.Locations.FirstOrDefault(), parameterSymbol.Type,
					methodAssembly,
					methodSymbol.Name);
			}

			ValidateNestedType(context.ReportDiagnostic, parameterSymbol.Locations.FirstOrDefault(), parameterSymbol.Type, methodSymbol.Name);
		}

	}

	private void ValidateNestedType(Action<Diagnostic> reportDiagnostic, Location diagnosticLocation, ITypeSymbol typeSymbol, string methodName = null)
	{
		if(typeSymbol.ContainingType == null)
			return;
		var descriptor = string.IsNullOrEmpty(methodName)
			? Diagnostics.Srv.ClassBeamGenerateSchemaAttributeIsNested
			: Diagnostics.Srv.CallableMethodTypeIsNested;
		var diagnostic = Diagnostic.Create(descriptor,
			diagnosticLocation, typeSymbol.Name, methodName);
		reportDiagnostic(diagnostic);
	}


	private void ValidateTypeAssembly(SyntaxNodeAnalysisContext context, Location location, ITypeSymbol typeSymbol, IAssemblySymbol methodAssemblySymbol, string methodName)
	{
		// If it is a Generic Type, we need to check inner types to see if them are in the same Assembly
		if (typeSymbol is INamedTypeSymbol { IsGenericType: true } namedTypeSymbol)
		{
			foreach (ITypeSymbol typeMember in namedTypeSymbol.TypeArguments)
			{
				ValidateTypeAssembly(context, location, typeMember, methodAssemblySymbol, methodName);
			}
		}
		var returnAssemblySymbol = typeSymbol.ContainingAssembly;
		if (methodAssemblySymbol.Identity == returnAssemblySymbol.Identity)
		{
			// This means that the return type is declared inside the microservice scope
			var diagnostic = Diagnostic.Create(Diagnostics.Srv.CallableTypeInsideMicroserviceScope,
				location, methodName, typeSymbol.Name);
			context.ReportDiagnostic(diagnostic);
		}
	}

	/// <summary>
	/// Checks if the Attributes is <see cref="CallableAttribute"/> or an attribute that inherits it.
	/// <para>
	/// It will not detect attributes subtypes of subtypes. Example: A attribute that inherits <see cref="ClientCallableAttribute"/>
	/// </para>
	/// </summary>
	/// <param name="data">AttributeData to check if it is a Callable</param>
	/// <returns></returns>
	private static bool IsCallableAttribute(AttributeData data)
	{
		INamedTypeSymbol attributeClass = data.AttributeClass;
		if (attributeClass == null) return false;
		string callableAttributeName = nameof(CallableAttribute);
		if (attributeClass.Name == callableAttributeName)
		{
			return true;
		}

		return attributeClass.BaseType?.Name == callableAttributeName;
	}
	
}
