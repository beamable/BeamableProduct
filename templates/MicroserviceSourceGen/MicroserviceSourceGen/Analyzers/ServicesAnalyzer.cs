using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.OpenApi.Extensions;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.Json;

namespace Beamable.Server;


/// <summary>
/// This class is responsible for Analyzing the C#MS code and reporting Diagnostics for it
/// The diagnostics generated by this class will appear on both IDE Execution and during build time.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class ServicesAnalyzer : DiagnosticAnalyzer
{
	public const string FEDERATION_ATTRIBUTE_NAME = "FederationId";
	
	private MicroserviceFederationsConfig _sourceGenConfig;

	public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(
		Diagnostics.Srv.InvalidAsyncVoidCallableMethod, Diagnostics.Fed.FederationIdMissingAttribute,
		Diagnostics.Fed.ConfiguredFederationMissingFromCode, Diagnostics.Fed.DeclaredFederationInvalidFederationId,
		Diagnostics.Fed.DeclaredFederationMissingFromSourceGenConfig, Diagnostics.Fed.FederationIdMustBeDefault,
		Diagnostics.Fed.FederationCodeGeneratedProperly, Diagnostics.Fed.FederationConfigFileNotFound,
		Diagnostics.Fed.ErrorParsingFederationConfigFile, Diagnostics.Fed.FederationIdInvalidConfigFile);
	
	public override void Initialize(AnalysisContext context)
	{
		context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
		context.EnableConcurrentExecution();
		context.RegisterSyntaxNodeAction(AnalyzeForAsyncVoidMethod, SyntaxKind.MethodDeclaration);
		context.RegisterCompilationStartAction(InitializeCompilation);
	}
	
	private void InitializeCompilation(CompilationStartAnalysisContext context)
	{
		var configFile = context.Options
			.AdditionalFiles
			.FirstOrDefault(f => Path.GetFileName(f.Path) == MicroserviceFederationsConfig.CONFIG_FILE_NAME);
		if (configFile != null)
		{
			var text = configFile.GetText(context.CancellationToken);
			if (text == null)
			{
				var noFileFoundFederation = Diagnostic.Create(Diagnostics.Fed.FederationConfigFileNotFound, Location.None);
				context.RegisterCompilationEndAction(endContext => endContext.ReportDiagnostic(noFileFoundFederation));
				return;
			}
			try
			{
				_sourceGenConfig = JsonSerializer.Deserialize<MicroserviceFederationsConfig>(
					text.ToString(),
					new JsonSerializerOptions { IncludeFields = true });
				
				context.RegisterSymbolAction(AnalyzeForInvalidFederations, SymbolKind.NamedType);
			}
			catch (Exception ex)
			{
				var diag = Diagnostic.Create(Diagnostics.Fed.ErrorParsingFederationConfigFile, Location.None, ex.Message);
				context.RegisterCompilationEndAction(endContext => endContext.ReportDiagnostic(diag));
			}
		}
		else
		{
			var noFileFoundFederation = Diagnostic.Create(Diagnostics.Fed.FederationConfigFileNotFound, Location.None);
			context.RegisterCompilationEndAction(endContext => endContext.ReportDiagnostic(noFileFoundFederation));
		}
	}

	private void AnalyzeForInvalidFederations(SymbolAnalysisContext context)
	{
		var classSymbol = (INamedTypeSymbol)context.Symbol;
		if (classSymbol.BaseType?.Name != nameof(Microservice))
		{
			return;
		}
		List<BeamableSourceGenerator.FederationInfo> federations = GetFederationInterfaces(classSymbol);
		if (ValidateFederations(context.ReportDiagnostic, classSymbol.Name, classSymbol.Locations[0], federations,
			    _sourceGenConfig))
		{
			var federationCodeGenSuccess = Diagnostic.Create(Diagnostics.Fed.FederationCodeGeneratedProperly, Location.None);
			context.ReportDiagnostic(federationCodeGenSuccess);
		}
	}


	public static List<BeamableSourceGenerator.FederationInfo> GetFederationInterfaces(INamedTypeSymbol classSymbol)
	{
		List<BeamableSourceGenerator.FederationInfo> federations = new();
		foreach (INamedTypeSymbol symbol in classSymbol.Interfaces)
		{
			if (!symbol.Interfaces.Any(it => it.Name == nameof(IFederation)))
			{
				continue;
			}

			string federationInterfaceName = symbol.Name;

			// Find the first type arg of the federation interface that implements IFederationId
			ITypeSymbol federationIdType = symbol.TypeArguments.First(t => t.Interfaces.Any(typeArgInterface =>
				typeArgInterface.Name is nameof(IFederationId) or nameof(IThirdPartyCloudIdentity)));
			string className = federationIdType.Name;

			AttributeData fedAttribute = federationIdType
				.GetAttributes()
				.FirstOrDefault(a => a?.AttributeClass?.Name == nameof(FederationIdAttribute));

			TypedConstant? fedValue = fedAttribute?.ConstructorArguments.FirstOrDefault();
			string id = fedValue?.Value?.ToString();

			federations.Add(new BeamableSourceGenerator.FederationInfo(
				id!,
				className,
				new FederationInstanceConfig() { Interface = federationInterfaceName },
				federationIdType.Locations[0]
			));
		}

		return federations;
	}

	private static void AnalyzeForAsyncVoidMethod(SyntaxNodeAnalysisContext context)
	{
		var method = (MethodDeclarationSyntax)context.Node;
		IMethodSymbol symbol = context.SemanticModel.GetDeclaredSymbol(method);

		if (symbol != null && IsMethodCallableAsyncVoid(symbol))
		{
			var diagnostic = Diagnostic.Create(Diagnostics.Srv.InvalidAsyncVoidCallableMethod, method.ReturnType.GetLocation(), symbol.Name);
			context.ReportDiagnostic(diagnostic);
		}
	}

	private static bool IsMethodCallableAsyncVoid(IMethodSymbol methodSymbol)
	{
		if (!methodSymbol.IsAsync)
			return false;
		
		if (!methodSymbol.GetAttributes().Any(IsCallableAttribute))
			return false;

		if (methodSymbol.ReturnType.SpecialType != SpecialType.System_Void)
			return false;

		return true;
	}

	private static bool ValidateFederations(Action<Diagnostic> reportDiagnostic, string microserviceName,
		Location microserviceLocation, List<BeamableSourceGenerator.FederationInfo> federationInfos,
		MicroserviceFederationsConfig federationConfig)
	{
		bool isValid = true;
		var federations = federationConfig.Federations;

		Dictionary<string, (string Id, string Interface)> flatConfig = federations
			.SelectMany(kvp => kvp.Value.Select(f => (kvp.Key, f.Interface)))
			.ToDictionary(x => $"{x.Key}/{x.Interface}");

		var flatCode = federationInfos.Where(f => f.Id != null).ToDictionary(x => $"{x.Id}/{x.Federation.Interface}");

		foreach (var fed in federationInfos)
		{
			if (fed.Id == null)
			{
				var error = Diagnostic.Create(Diagnostics.Fed.FederationIdMissingAttribute, fed.Location);
				reportDiagnostic(error);
				isValid = false;
			}
			else if (fed.Federation.Interface == FederationType.IFederatedPlayerInit.GetDisplayName())
			{
				// Only one IFederatedPlayerInit federation can exit and its ID must be "default". 
				if (fed.Id != "default")
				{
					var error = Diagnostic.Create(Diagnostics.Fed.FederationIdMustBeDefault, fed.Location, fed.Id);
					reportDiagnostic(error);
					isValid = false;
				}
			}
			else if (!ValidateFederationId(fed.Id))
			{
				var error = Diagnostic.Create(Diagnostics.Fed.DeclaredFederationInvalidFederationId,
					fed.Location, microserviceName, fed.Id);
				reportDiagnostic(error);
				isValid = false;
			}
		}

		var configsThatDoNotExistInCode = flatConfig.Keys.Except(flatCode.Keys).ToList();
		var configsThatDoNotExistInSource = flatCode.Where(item => !flatConfig.Keys.Contains(item.Key));

		foreach (var configKey in configsThatDoNotExistInCode)
		{
			var (fedId, fedInterface) = flatConfig[configKey];
			if (!ValidateFederationId(fedId))
			{
				var invalidFedId = Diagnostic.Create(Diagnostics.Fed.FederationIdInvalidConfigFile, microserviceLocation, fedId);
				reportDiagnostic(invalidFedId);
				continue;
			}

			isValid = false;
			var error = Diagnostic.Create(
				Diagnostics.Fed.ConfiguredFederationMissingFromCode,
				microserviceLocation,
				microserviceName,
				fedId,
				fedInterface);
			reportDiagnostic(error);
		}

		foreach (var codeFedInfo in configsThatDoNotExistInSource)
		{
			string codeKey = codeFedInfo.Key;
			var federationInfo = flatCode[codeKey];
			isValid = false;
			var error = Diagnostic.Create(
				Diagnostics.Fed.DeclaredFederationMissingFromSourceGenConfig,
				codeFedInfo.Value.Location,
				microserviceName,
				federationInfo.Id,
				federationInfo.Federation.Interface);
			reportDiagnostic(error);
		}

		return isValid;
	}
	
	
	/// <summary>
	/// <para>
	///  First digit can't be a number
	///  It can only contain Alphanumeric or "_" chars
	/// </para>
	/// </summary>
	/// <param name="id">The federation id that will be validated</param>
	/// <returns></returns>
	public static bool ValidateFederationId(string id)
	{
		if (string.IsNullOrEmpty(id)) return false;
		var isValid = true;
		for (int charIdx = 0; charIdx < id.Length; charIdx++)
		{
			var currChar = id[charIdx];
			if (charIdx == 0)
			{
				isValid &= char.IsLetter(currChar);
			}
			else
			{
				isValid &= char.IsLetterOrDigit(currChar) || currChar.Equals('_');
			}
		}

		return isValid;
	}


	/// <summary>
	/// Checks if the Attributes is <see cref="CallableAttribute"/> or an attribute that inherits it.
	/// <para>
	/// It will not detect attributes subtypes of subtypes. Example: A attribute that inherits <see cref="ClientCallableAttribute"/>
	/// </para>
	/// </summary>
	/// <param name="data">AttributeData to check if it is a Callable</param>
	/// <returns></returns>
	private static bool IsCallableAttribute(AttributeData data)
	{
		INamedTypeSymbol attributeClass = data.AttributeClass;
		if (attributeClass == null) return false;
		string callableAttributeName = nameof(CallableAttribute);
		if (attributeClass.Name == callableAttributeName)
		{
			return true;
		}

		return attributeClass.BaseType?.Name == callableAttributeName;
	}
	
}
