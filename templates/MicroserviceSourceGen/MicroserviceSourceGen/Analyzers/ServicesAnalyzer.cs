using Beamable.Server;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace Beamable.Microservice.SourceGen.Analyzers;


/// <summary>
/// This class is responsible for Analyzing the C#MS code and reporting Diagnostics for it
/// The diagnostics generated by this class will appear on both IDE Execution and during build time.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class ServicesAnalyzer : DiagnosticAnalyzer
{
	public const string FEDERATION_ATTRIBUTE_NAME = "FederationId";
	public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics =>
		ImmutableArray.Create(Diagnostics.Srv.InvalidAsyncVoidCallableMethod,
			Diagnostics.Srv.MultipleMicroserviceClassesDetected, Diagnostics.Srv.MissingMicroserviceId,
			Diagnostics.Srv.NonPartialMicroserviceClassDetected, Diagnostics.Srv.NoMicroserviceClassesDetected);
	
	public override void Initialize(AnalysisContext context)
	{
		context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
		context.RegisterSyntaxNodeAction(AnalyzeForAsyncVoidMethod, SyntaxKind.MethodDeclaration);
		context.RegisterCompilationStartAction(ValidateMicroserviceClasses);
		
	}
	
	private void ValidateMicroserviceClasses(CompilationStartAnalysisContext context)
	{
		var microserviceInfos = new List<MicroserviceInfo>();
		context.RegisterSymbolAction(symbolContext =>
		{
			var namedSymbol = (INamedTypeSymbol)symbolContext.Symbol;

			if (namedSymbol.TypeKind != TypeKind.Class || namedSymbol.BaseType is not { Name: nameof(Server.Microservice) })
			{
				return;
			}
			microserviceInfos.Add(new MicroserviceInfo(namedSymbol));
			
		}, SymbolKind.NamedType);
		
		context.RegisterCompilationEndAction(analysisContext =>
		{
			var mergedInfos = new List<MicroserviceInfo>();
			foreach (MicroserviceInfo microserviceInfo in microserviceInfos)
			{
				if (!mergedInfos.Any(i => i.Name.Equals(microserviceInfo.Name)))
				{
					if (microserviceInfo.MicroserviceAttributeLocation != null)
					{
						mergedInfos.Add(microserviceInfo);
					}
				}
			}
			
			if (microserviceInfos.Count > 0 && mergedInfos.Count == 0)
			{
				var missingIdDiagnostic = Diagnostic.Create(Diagnostics.Srv.MissingMicroserviceId, microserviceInfos[0].MicroserviceClassLocation);
				analysisContext.ReportDiagnostic(missingIdDiagnostic);
				return;
			}
			
			ValidateMicroserviceDeclaration(analysisContext, mergedInfos.ToImmutableArray());
		});
	}

	private static void ValidateMicroserviceDeclaration(CompilationAnalysisContext context, ImmutableArray<MicroserviceInfo> infos)
	{
		if (infos.Length == 0)
		{
			var err = Diagnostic.Create(Diagnostics.Srv.NoMicroserviceClassesDetected, null);
			context.ReportDiagnostic(err);
			return;
		}

		var info = infos[0];
		if (infos.Length > 1)
		{
			var classNames = string.Join(", ", infos.Select(intoItem => intoItem.Name));
			var extraLocations = infos.Select(intoItem => intoItem.MicroserviceClassLocation);
			var error = Diagnostic.Create(Diagnostics.Srv.MultipleMicroserviceClassesDetected, info.MicroserviceClassLocation, extraLocations, classNames);
			context.ReportDiagnostic(error);
			return;
		}
		
		if (!info.IsPartial)
		{
			var err = Diagnostic.Create(Diagnostics.Srv.NonPartialMicroserviceClassDetected, info.MicroserviceClassLocation);
			context.ReportDiagnostic(err);
		}
	}
	
	private static void AnalyzeForAsyncVoidMethod(SyntaxNodeAnalysisContext context)
	{
		var method = (MethodDeclarationSyntax)context.Node;
		IMethodSymbol symbol = context.SemanticModel.GetDeclaredSymbol(method);

		if (symbol != null && IsMethodCallableAsyncVoid(symbol))
		{
			var diagnostic = Diagnostic.Create(Diagnostics.Srv.InvalidAsyncVoidCallableMethod, method.ReturnType.GetLocation(), symbol.Name);
			context.ReportDiagnostic(diagnostic);
		}
	}

	private static bool IsMethodCallableAsyncVoid(IMethodSymbol methodSymbol)
	{
		if (!methodSymbol.IsAsync)
			return false;
		
		if (!methodSymbol.GetAttributes().Any(IsCallableAttribute))
			return false;

		if (methodSymbol.ReturnType.SpecialType != SpecialType.System_Void)
			return false;

		return true;
	}

	/// <summary>
	/// Checks if the Attributes is <see cref="CallableAttribute"/> or an attribute that inherits it.
	/// <para>
	/// It will not detect attributes subtypes of subtypes. Example: A attribute that inherits <see cref="ClientCallableAttribute"/>
	/// </para>
	/// </summary>
	/// <param name="data">AttributeData to check if it is a Callable</param>
	/// <returns></returns>
	private static bool IsCallableAttribute(AttributeData data)
	{
		INamedTypeSymbol attributeClass = data.AttributeClass;
		if (attributeClass == null) return false;
		string callableAttributeName = nameof(CallableAttribute);
		if (attributeClass.Name == callableAttributeName)
		{
			return true;
		}

		return attributeClass.BaseType?.Name == callableAttributeName;
	}
	
}
