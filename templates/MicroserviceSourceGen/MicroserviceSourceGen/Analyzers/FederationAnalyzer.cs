using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Server;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.OpenApi.Extensions;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.Json;

namespace Beamable.Microservice.SourceGen.Analyzers;


/// <summary>
/// This class is responsible for Analyzing the C#MS code and reporting Diagnostics for it
/// The diagnostics generated by this class will appear on both IDE Execution and during build time.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class FederationAnalyzer : DiagnosticAnalyzer
{
	
	
	private MicroserviceFederationsConfig _sourceGenConfig;

	public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(
		Diagnostics.Fed.FederationIdMissingAttribute,
		Diagnostics.Fed.ConfiguredFederationMissingFromCode, Diagnostics.Fed.DeclaredFederationInvalidFederationId,
		Diagnostics.Fed.DeclaredFederationMissingFromSourceGenConfig, Diagnostics.Fed.FederationIdMustBeDefault,
		Diagnostics.Fed.FederationCodeGeneratedProperly, Diagnostics.Fed.FederationIdInvalidConfigFile,
		Diagnostics.Cfg.NoSourceGenConfigFound, Diagnostics.Cfg.FailedToDeserializeSourceGenConfig,
		Diagnostics.Cfg.MultipleSourceGenConfigsFound);
	
	public override void Initialize(AnalysisContext context)
	{
		context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
		context.EnableConcurrentExecution();
		context.RegisterCompilationStartAction(InitializeCompilation);
	}

	private void InitializeCompilation(CompilationStartAnalysisContext context)
	{
		var configFiles = context.Options.AdditionalFiles.Where(item =>
			Path.GetFileName(item.Path) == MicroserviceFederationsConfig.CONFIG_FILE_NAME).ToList();

		if (configFiles.Count > 1)
		{
			string fileNames = string.Join(", ",configFiles.Select(item => item.Path));
			var multipleFiles = Diagnostic.Create(Diagnostics.Cfg.MultipleSourceGenConfigsFound, Location.None, fileNames);
			context.RegisterCompilationEndAction(endContext => endContext.ReportDiagnostic(multipleFiles));
		} else if (configFiles.Count == 0)
		{
			var noFileFoundFederation = Diagnostic.Create(Diagnostics.Cfg.NoSourceGenConfigFound, Location.None);
			context.RegisterCompilationEndAction(endContext => endContext.ReportDiagnostic(noFileFoundFederation));
			return;
		}

		var configFile = configFiles.FirstOrDefault();
		var text = configFile!.GetText(context.CancellationToken);
		if (text == null)
		{
			var noFileFoundFederation = Diagnostic.Create(Diagnostics.Cfg.NoSourceGenConfigFound, Location.None);
			context.RegisterCompilationEndAction(endContext => endContext.ReportDiagnostic(noFileFoundFederation));
			return;
		}

		try
		{
			_sourceGenConfig = JsonSerializer.Deserialize<MicroserviceFederationsConfig>(
				text.ToString(),
				new JsonSerializerOptions { IncludeFields = true });

			context.RegisterSymbolAction(AnalyzeForInvalidFederations, SymbolKind.NamedType);
		}
		catch (Exception ex)
		{
			var diag = Diagnostic.Create(Diagnostics.Cfg.FailedToDeserializeSourceGenConfig, Location.None, ex.Message);
			context.RegisterCompilationEndAction(endContext => endContext.ReportDiagnostic(diag));
		}

	}

	private void AnalyzeForInvalidFederations(SymbolAnalysisContext context)
	{
		var classSymbol = (INamedTypeSymbol)context.Symbol;
		if (classSymbol.BaseType?.Name != nameof(Server.Microservice))
		{
			return;
		}
		List<FederationInfo> federations = GetFederationInterfaces(classSymbol);
		if (ValidateFederations(context.ReportDiagnostic, classSymbol.Name, classSymbol.Locations[0], federations,
			    _sourceGenConfig))
		{
			var federationCodeGenSuccess = Diagnostic.Create(Diagnostics.Fed.FederationCodeGeneratedProperly, Location.None);
			context.ReportDiagnostic(federationCodeGenSuccess);
		}
	}


	public static List<FederationInfo> GetFederationInterfaces(INamedTypeSymbol classSymbol)
	{
		List<FederationInfo> federations = new();
		foreach (INamedTypeSymbol symbol in classSymbol.Interfaces)
		{
			if (!symbol.Interfaces.Any(it => it.Name == nameof(IFederation)))
			{
				continue;
			}

			string federationInterfaceName = symbol.Name;

			// Find the first type arg of the federation interface that implements IFederationId
			ITypeSymbol federationIdType = symbol.TypeArguments.First(t => t.Interfaces.Any(typeArgInterface =>
				typeArgInterface.Name is nameof(IFederationId) or nameof(IThirdPartyCloudIdentity)));
			string className = federationIdType.Name;

			AttributeData fedAttribute = federationIdType
				.GetAttributes()
				.FirstOrDefault(a => a?.AttributeClass?.Name == nameof(FederationIdAttribute));

			TypedConstant? fedValue = fedAttribute?.ConstructorArguments.FirstOrDefault();
			string id = fedValue?.Value?.ToString();

			federations.Add(new FederationInfo(
				id!,
				className,
				new FederationInstanceConfig() { Interface = federationInterfaceName },
				federationIdType.Locations[0]
			));
		}

		return federations;
	}

	private static bool ValidateFederations(Action<Diagnostic> reportDiagnostic, string microserviceName,
		Location microserviceLocation, List<FederationInfo> federationInfos,
		MicroserviceFederationsConfig federationConfig)
	{
		bool isValid = true;
		var federations = federationConfig.Federations;

		Dictionary<string, (string Id, string Interface)> flatConfig = federations
			.SelectMany(kvp => kvp.Value.Select(f => (kvp.Key, f.Interface)))
			.ToDictionary(x => $"{x.Key}/{x.Interface}");

		var flatCode = federationInfos.Where(f => f.Id != null).ToDictionary(x => $"{x.Id}/{x.Federation.Interface}");

		foreach (var fed in federationInfos)
		{
			if (fed.Id == null)
			{
				var error = Diagnostic.Create(Diagnostics.Fed.FederationIdMissingAttribute, fed.Location);
				reportDiagnostic(error);
				isValid = false;
			}
			else if (fed.Federation.Interface == FederationType.IFederatedPlayerInit.GetDisplayName())
			{
				// Only one IFederatedPlayerInit federation can exit and its ID must be "default". 
				if (fed.Id != "default")
				{
					var error = Diagnostic.Create(Diagnostics.Fed.FederationIdMustBeDefault, fed.Location, fed.Id);
					reportDiagnostic(error);
					isValid = false;
				}
			}
			else if (!ValidateFederationId(fed.Id))
			{
				var error = Diagnostic.Create(Diagnostics.Fed.DeclaredFederationInvalidFederationId,
					fed.Location, microserviceName, fed.Id);
				reportDiagnostic(error);
				isValid = false;
			}
		}

		var configsThatDoNotExistInCode = flatConfig.Keys.Except(flatCode.Keys).ToList();
		var configsThatDoNotExistInSource = flatCode.Where(item => !flatConfig.Keys.Contains(item.Key));

		foreach (var configKey in configsThatDoNotExistInCode)
		{
			var (fedId, fedInterface) = flatConfig[configKey];
			var properties = ImmutableDictionary<string, string>.Empty
				.Add(Diagnostics.Fed.PROP_FEDERATION_ID, fedId)
				.Add(Diagnostics.Fed.PROP_FEDERATION_INTERFACE, fedInterface)
				.Add(Diagnostics.Fed.PROP_MICROSERVICE_NAME, microserviceName);
			
			
			if (!ValidateFederationId(fedId))
			{
				var invalidFedId = Diagnostic.Create(Diagnostics.Fed.FederationIdInvalidConfigFile, microserviceLocation, properties, fedId);
				reportDiagnostic(invalidFedId);
				continue;
			}

			isValid = false;
			var error = Diagnostic.Create(
				Diagnostics.Fed.ConfiguredFederationMissingFromCode,
				microserviceLocation,
				properties,
				microserviceName,
				fedId,
				fedInterface);
			reportDiagnostic(error);
		}

		foreach (var codeFedInfo in configsThatDoNotExistInSource)
		{
			string codeKey = codeFedInfo.Key;
			var federationInfo = flatCode[codeKey];
			
			var properties = ImmutableDictionary<string, string>.Empty
				.Add(Diagnostics.Fed.PROP_FEDERATION_ID, federationInfo.Id)
				.Add(Diagnostics.Fed.PROP_FEDERATION_INTERFACE, federationInfo.Federation.Interface)
				.Add(Diagnostics.Fed.PROP_MICROSERVICE_NAME, microserviceName)
				.Add(Diagnostics.Fed.PROP_FEDERATION_CLASS_NAME, federationInfo.ClassName);
			
			isValid = false;
			var error = Diagnostic.Create(
				Diagnostics.Fed.DeclaredFederationMissingFromSourceGenConfig,
				codeFedInfo.Value.Location,
				properties,
				microserviceName,
				federationInfo.Id,
				federationInfo.Federation.Interface);
			reportDiagnostic(error);
		}

		return isValid;
	}
	
	
	/// <summary>
	/// <para>
	///  First digit can't be a number
	///  It can only contain Alphanumeric or "_" chars
	/// </para>
	/// </summary>
	/// <param name="id">The federation id that will be validated</param>
	/// <returns></returns>
	public static bool ValidateFederationId(string id)
	{
		if (string.IsNullOrEmpty(id)) return false;
		var isValid = true;
		for (int charIdx = 0; charIdx < id.Length; charIdx++)
		{
			var currChar = id[charIdx];
			if (charIdx == 0)
			{
				isValid &= char.IsLetter(currChar);
			}
			else
			{
				isValid &= char.IsLetterOrDigit(currChar) || currChar.Equals('_');
			}
		}

		return isValid;
	}
	
}
