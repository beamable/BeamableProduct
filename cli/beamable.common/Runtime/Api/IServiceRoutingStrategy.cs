using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Beamable.Common.Api
{
	public interface IServiceRoutingStrategy
	{
		/// <summary>
		/// Resolve the routingKey for a given service name.
		/// This routingKey is used for targeted Microservice calls.
		/// </summary>
		/// <param name="serviceName"></param>
		/// <returns></returns>
		Promise<string> GetPrefix(string serviceName);

		/// <summary>
		/// Resolve the routingKey to be used for all requests, even
		/// those not directly going to a Microservice.
		/// Due to out-of-band federation, it is possible that a request
		/// can be sent to a regular Beamable Managed service, but still cause a federation event
		/// to occur. 
		/// </summary>
		/// <returns></returns>
		Promise<string> GetGlobalPrefix();

		/// <summary>
		/// All services must have a routing key in the format,
		/// name:key
		/// and multiple keys can be separated with commas. 
		/// </summary>
		/// <returns></returns>
		Promise<Dictionary<string, string>> GetServiceMap();
	}

	public static class ServiceRoutingStrategyExtensions
	{
		/// <summary>
		/// Uses the <see cref="IServiceRoutingStrategy.GetServiceMap"/> method to produce a
		/// well formatted string for the routing key header value.
		/// </summary>
		/// <param name="strategy"></param>
		/// <returns></returns>
		public static async Promise<string> GetRoutingHeaderValue(this IServiceRoutingStrategy strategy)
		{
			var map = await strategy.GetServiceMap();
			var value = string.Join(",", map.Select(kvp => $"{kvp.Key}:{kvp.Value}"));
			return value;
		}

		public static string GetDefaultRoutingKeyForMachine()
		{
			return Environment.MachineName
				.Replace(":", "_")
				.Replace(",", "_")
				.ToLowerInvariant();
		}
	}
	
	
	public class DefaultServiceRoutingStrategy : IServiceRoutingStrategy
	{
		private IBeamoApi _beamo;

		public Promise<MicroserviceRegistrations[]> registrationPromise;

		public DefaultServiceRoutingStrategy(IBeamoApi beamo)
		{
			_beamo = beamo;
			var _ = Refresh();
		}

		public async Promise Refresh()
		{
			registrationPromise = new Promise<MicroserviceRegistrations[]>();
			var res = await _beamo.PostMicroserviceRegistrations(new MicroserviceRegistrationsQuery(), includeAuthHeader: true);
			registrationPromise.CompleteSuccess(res.registrations);
		}

		/// <summary>
		/// The routing key should be the machine name of the host.
		/// The routing keys do not allow : and , characters, because those
		/// characters are used as delimiters 
		/// </summary>
		public static string DefaultRoutingKey => ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine();
		
		public async Promise<string> GetPrefix(string serviceName)
		{
			serviceName = serviceName.ToLowerInvariant();
			var filterString = $".{serviceName}.";
			
			var registrations = await registrationPromise;
			
			// filter the total set of realm running services for the ones that match our given service
			var validRegistrations = new List<MicroserviceRegistrations>();
			foreach (var reg in registrations)
			{
				// serviceName is in format cid.pid.servicename.basic
				if (reg.serviceName.Contains(filterString))
				{
					validRegistrations.Add(reg);
				}
			}
			
			// select one of the valid registrations based on the routingKey
			var hasLocal = false;
			var hasDeployed = false;
			foreach (var reg in validRegistrations)
			{
				if (reg.routingKey?.TryGet(out var routingKey) ?? false)
				{
					if (string.Equals(routingKey, DefaultRoutingKey))
					{
						hasLocal = true;
					}
				} else if ((!reg.routingKey?.HasValue) ?? true)
				{
					hasDeployed = true;
				}
			}

			if (hasLocal)
			{
				// use the local service
				return DefaultRoutingKey; 
			} else if (hasDeployed)
			{
				// use the remote service
				return null;
			}

			// this will break, so we can log a warning...
			BeamableLogger.LogWarning($"No microservice is running locally or remotely for the given service name=[{serviceName}]. Subsequent requests will fail.");
			return null; 
		}

		public async Promise<string> GetGlobalPrefix()
		{
			var registrations = await registrationPromise;
			foreach (var reg in registrations)
			{
				if (reg.routingKey?.TryGet(out var routingKey) ?? false)
				{
					if (string.Equals(routingKey, DefaultRoutingKey))
					{
						// if there are ANY local services running, we should federate to them automatically.
						return DefaultRoutingKey;
					}
				} 
			}

			// otherwise, assume that the federation exists in the remote deployed service. 
			return null;
		}

		public async Promise<Dictionary<string, string>> GetServiceMap()
		{
			var registrations = await registrationPromise;

			var results = new Dictionary<string, string>();

			// extract all services that have a matching routing key
			foreach (var reg in registrations)
			{
				if (reg.routingKey?.TryGet(out var routingKey) ?? false)
				{
					if (string.Equals(routingKey, DefaultRoutingKey))
					{
						// extract the service name, which is in the format cid.pid.name.basic, 
						var serviceName = reg.serviceName.Split('.')[2];
						results[serviceName] = routingKey;
					}
				} 
			}

			return results;
		}
	}
}
