using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Spew;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;

namespace Beamable.Common.Api
{
	public interface IServiceRoutingStrategy
	{
		/// <summary>
		/// All services must have a routing key in the format,
		/// name:key
		/// and multiple keys can be separated with commas. 
		/// </summary>
		/// <returns></returns>
		Promise<Dictionary<string, string>> GetServiceMap();
	}

	public static class ServiceRoutingStrategyExtensions
	{
		/// <summary>
		/// Uses the <see cref="IServiceRoutingStrategy.GetServiceMap"/> method to produce a
		/// well formatted string for the routing key header value.
		/// </summary>
		/// <param name="strategy"></param>
		/// <returns></returns>
		public static async Promise<string> GetRoutingHeaderValue(this IServiceRoutingStrategy strategy)
		{
			var map = await strategy.GetServiceMap();
			var value = string.Join(",", map.Select(kvp => $"{kvp.Key}:{kvp.Value}"));
			return value;
		}

		public static string GetDefaultRoutingKeyForMachine()
		{
			var devices = NetworkInterface.GetAllNetworkInterfaces().ToList();

			byte[] macBytes = null;
			
			// if we don't sort the list, then different conditions may change the routingKey order.
			devices.Sort((a, b) => String.Compare(a.Id, b.Id, StringComparison.Ordinal));
			for (var i = 0; i < devices.Count; i++)
			{
				var device = devices[i];
				
				var addrBytes = device.GetPhysicalAddress().GetAddressBytes();
				if (addrBytes.Length == 0) continue;

				macBytes = device.GetPhysicalAddress().GetAddressBytes();
				break;
			}
			
			if (macBytes == null)
				throw new InvalidOperationException(
					"cannot get routingKey for a machine with no active network addresses");
			
			// hash the macAddr to avoid leaking pii
			using var md5 = System.Security.Cryptography.MD5.Create();
			md5.TransformFinalBlock(macBytes, 0, macBytes.Length);
			var macAddr = BitConverter.ToString(md5.Hash).Replace("-", "").ToLowerInvariant();;
			
			return (Environment.MachineName + "_" + macAddr)
				.Replace(":", "_")
				.Replace(",", "_")
				.ToLowerInvariant();
		}

		public static string GetRoutingKeyMap(IEnumerable<string> servicesNames)
		{
			string routingKey = GetDefaultRoutingKeyForMachine();
			return string.Join(",", servicesNames.Select(n => $"{n}:{routingKey}"));
		}
	}
	
	
	public class DefaultServiceRoutingStrategy : IServiceRoutingStrategy
	{
		private IBeamoApi _beamo;

		public DefaultServiceRoutingStrategy(IBeamoApi beamo)
		{
			_beamo = beamo;
		}

		/// <summary>
		/// The routing key should be the machine name of the host.
		/// The routing keys do not allow : and , characters, because those
		/// characters are used as delimiters 
		/// </summary>
		public static string DefaultRoutingKey => ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine();
		
		public async Promise<Dictionary<string, string>> GetServiceMap()
		{
			var res = await _beamo.PostMicroserviceRegistrations(new MicroserviceRegistrationsQuery(), includeAuthHeader: true);

			var results = new Dictionary<string, string>();

			// extract all services that have a matching routing key
			foreach (var reg in res.registrations)
			{
				if (reg.routingKey != null && reg.routingKey.TryGet(out string routingKey))
				{
					if (string.Equals(routingKey, DefaultRoutingKey))
					{
						// extract the service name, which is in the format cid.pid.name.basic,
						var serviceName = reg.serviceName.Split('.')[2];
						results[serviceName] = DefaultRoutingKey;
					}
				}
			}

			return results;
		}
	}
}
