
using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Announcements;
using Beamable.Api.Autogenerated.Auth;
using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Beamootel;
using Beamable.Api.Autogenerated.Calendars;
using Beamable.Api.Autogenerated.Cloudsaving;
using Beamable.Api.Autogenerated.Commerce;
using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.EventPlayers;
using Beamable.Api.Autogenerated.Events;
using Beamable.Api.Autogenerated.Groups;
using Beamable.Api.Autogenerated.GroupUsers;
using Beamable.Api.Autogenerated.Inventory;
using Beamable.Api.Autogenerated.Leaderboards;
using Beamable.Api.Autogenerated.Lobby;
using Beamable.Api.Autogenerated.Mail;
using Beamable.Api.Autogenerated.Mailbox;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Notification;
using Beamable.Api.Autogenerated.Party;
using Beamable.Api.Autogenerated.Payments;
using Beamable.Api.Autogenerated.Player;
using Beamable.Api.Autogenerated.Presence;
using Beamable.Api.Autogenerated.Push;
using Beamable.Api.Autogenerated.Realms;
using Beamable.Api.Autogenerated.Scheduler;
using Beamable.Api.Autogenerated.Session;
using Beamable.Api.Autogenerated.Social;
using Beamable.Api.Autogenerated.Stats;
using Beamable.Api.Autogenerated.Tournaments;
using Beamable.Api.Autogenerated.Trials;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Serialization;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Beamable.Api.Autogenerated
{
	public class OpenApiRegistration
	{
		public static void RegisterOpenApis(IDependencyBuilder builder)
		{
			// ApiSchedulerJobNextExecutionsGetSchedulerResponse
			// content requires special CSV parsing, and this allows us to inject an override.
			// builder.AddSingleton<ICustomSerializer<ClientManifestResponse>, ClientManifestCsvResponseSerializer>();
			builder.AddSingleton<ICustomSerializer<ApiSchedulerJobsGetSchedulerResponse>, ArrayResponseSerializer<ApiSchedulerJobsGetSchedulerResponse, JobDefinition>>();
			builder.AddSingleton<ICustomSerializer<ApiSchedulerJobActivityGetSchedulerResponse>, ArrayResponseSerializer<ApiSchedulerJobActivityGetSchedulerResponse, JobActivity>>();
			builder.AddSingleton<ICustomSerializer<ApiSchedulerJobNextExecutionsGetSchedulerResponse>, ArrayDateTimeResponseSerializer<ApiSchedulerJobNextExecutionsGetSchedulerResponse>>();
			builder.AddSingleton<ICustomSerializer<CloudStorage>, CloudStorageSerializer>();
			builder.AddOrOverrideScoped<IAccountsApi, AccountsApi>();
			builder.AddOrOverrideScoped<IContentApi, ContentApi>();
			builder.AddOrOverrideScoped<IAnnouncementsApi, AnnouncementsApi>();
			builder.AddOrOverrideScoped<IAuthApi, AuthApi>();
			builder.AddOrOverrideScoped<IBeamoApi, BeamoApi>();
			builder.AddOrOverrideScoped<ICalendarsApi, CalendarsApi>();
			builder.AddOrOverrideScoped<ICloudsavingApi, CloudsavingApi>();
			builder.AddOrOverrideScoped<ICommerceApi, CommerceApi>();
			builder.AddOrOverrideScoped<IEventPlayersApi, EventPlayersApi>();
			builder.AddOrOverrideScoped<IEventsApi, EventsApi>();
			builder.AddOrOverrideScoped<IGroupsApi, GroupsApi>();
			builder.AddOrOverrideScoped<IGroupUsersApi, GroupUsersApi>();
			builder.AddOrOverrideScoped<IInventoryApi, InventoryApi>();
			builder.AddOrOverrideScoped<ILeaderboardsApi, LeaderboardsApi>();
			builder.AddOrOverrideScoped<IMailApi, MailApi>();
			builder.AddOrOverrideScoped<INotificationApi, NotificationApi>();
			builder.AddOrOverrideScoped<IPaymentsApi, PaymentsApi>();
			builder.AddOrOverrideScoped<IPushApi, PushApi>();
			builder.AddOrOverrideScoped<IRealmsApi, RealmsApi>();
			builder.AddOrOverrideScoped<ISocialApi, SocialApi>();
			builder.AddOrOverrideScoped<IStatsApi, StatsApi>();
			builder.AddOrOverrideScoped<ITournamentsApi, TournamentsApi>();
			builder.AddOrOverrideScoped<ISessionApi, SessionApi>();
			builder.AddOrOverrideScoped<ITrialsApi, TrialsApi>();

			// proto-actor based services
			builder.AddOrOverrideScoped<IBeamAuthApi, BeamAuthApi>();
			builder.AddOrOverrideScoped<IBeamLobbyApi, BeamLobbyApi>();
			builder.AddOrOverrideScoped<IBeamMailboxApi, BeamMailboxApi>();
			builder.AddOrOverrideScoped<IBeamPartyApi, BeamPartyApi>();
			builder.AddOrOverrideScoped<IBeamPlayerApi, BeamPlayerApi>();
			builder.AddOrOverrideScoped<IBeamPresenceApi, BeamPresenceApi>();
			builder.AddOrOverrideScoped<IBeamSchedulerApi, BeamSchedulerApi>();
			builder.AddOrOverrideScoped<IBeamBeamoApi, BeamBeamoApi>();
			builder.AddOrOverrideScoped<IBeamBeamootelApi, BeamBeamootelApi>();
		}
	}

	static class OpenApiRegistrationExtensions
	{
		public static void AddOrOverrideScoped<TInterface, TImpl>(this IDependencyBuilder builder) where TImpl : TInterface
		{
			if (builder.Has<TInterface>())
			{
				builder.Remove<TInterface>();
			}
			if (builder.Has<TImpl>())
			{
				builder.Remove<TImpl>();
			}

			builder.AddScoped<TImpl>();
			builder.AddScoped<TInterface>(p => p.GetService<TImpl>());
		}
	}

	public interface ICustomSerializer<T>
	{
		T Deserialize(string data);
	}

	public class CloudStorageSerializer : ICustomSerializer<CloudStorage>
	{
		public CloudStorage Deserialize(string data)
		{
			var storage = new CloudStorage();
			var wrapper = JsonSerializable.FromJson<CloudStorageWrapper>(data);
			storage.reference = wrapper.reference;
			return storage;
		}

		public class CloudStorageWrapper : CloudStorage
		{
			public override void Serialize(JsonSerializable.IStreamSerializer s)
			{
				base.Serialize(s);
				if ((s.HasKey("ref")
					 || ((reference != default(OptionalString))
						 && reference.HasValue)))
				{
					s.Serialize("ref", ref reference.Value);
					reference.HasValue = true;
				}
			}
		}
	}

	public class ArrayDateTimeResponseSerializer<T> : ICustomSerializer<T>
		where T : List<DateTime>, new()
	{
		public T Deserialize(string data)
		{
			const string jsonPrefix = "{\"" + nameof(SneakyArrayWrapper.data) + "\":";
			const string jsonSuffix = "}";
			var json = jsonPrefix + data + jsonSuffix;
			var wrapper = JsonSerializable.FromJson<SneakyArrayWrapper>(json);
			var res = new T();
			res.AddRange(wrapper.data.Select(d =>
			{
				if (DateTime.TryParse(d, out DateTime dateTime))
				{
					return dateTime;
				}

				throw new FormatException("Could not handle parsing input as date, input: " + d);
			}).ToList());
			return res;
		}


		[Serializable]
		class SneakyArrayWrapper : JsonSerializable.ISerializable
		{
			public string[] data;
			public void Serialize(JsonSerializable.IStreamSerializer s)
			{
				s.SerializeArray(nameof(data), ref data);
			}
		}
	}

	public class ArrayResponseSerializer<T, TElement> : ICustomSerializer<T>
		where T : List<TElement>, new()
	{
		private List<JsonSerializable.ISerializableFactory> _serializationFactories =
			new List<JsonSerializable.ISerializableFactory>();
		public ArrayResponseSerializer()
		{
			_serializationFactories.Add(new IOneOf_HttpCallOrPublishMessageOrServiceCallFactory());
			_serializationFactories.Add(new IOneOf_CronTriggerOrExactTriggerFactory());
			_serializationFactories.Add(new IOneOf_ContentOrTextOrBinaryFactory());
		}

		public T Deserialize(string data)
		{
			const string jsonPrefix = "{\"" + nameof(SneakyArrayWrapper.data) + "\":";
			const string jsonSuffix = "}";
			var json = jsonPrefix + data + jsonSuffix;
			var wrapper = JsonSerializable.FromJson<SneakyArrayWrapper>(json, _serializationFactories);
			var res = new T();
			res.AddRange(wrapper.data);
			return res;
		}


		[Serializable]
		class SneakyArrayWrapper : JsonSerializable.ISerializable
		{
			public TElement[] data;
			public void Serialize(JsonSerializable.IStreamSerializer s)
			{
				s.SerializeArray(nameof(data), ref data);
			}
		}
	}

	public class ClientManifestCsvResponseSerializer : ICustomSerializer<ClientManifestResponse>
	{
		public ClientManifestResponse Deserialize(string data)
	 	{
	 		var scanner = new CsvManifestScanner(data);
	 		var manifest = scanner.Parse();

	 		var response = new ClientManifestResponse();
	 		response.items = new Models.ClientContentInfo[manifest.entries.Count];
	 		for (var i = 0; i < response.items.Length; i++)
	 		{
	 			response.items[i] = new Models.ClientContentInfo
	 			{
	 				contentId = manifest.entries[i].contentId,
	 				tags = manifest.entries[i].tags,
	 				type = ContentType.Content,
	 				uri = manifest.entries[i].uri,
	 				version = manifest.entries[i].version,
	 			};
	 		}
	 		return response;
	 	}
	}
}
