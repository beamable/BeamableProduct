using Beamable.Api.Autogenerated.Realms;
using Beamable.Common.Api;
using Beamable.Common.Pooling;
using Beamable.Serialization.SmallerJSON;
using Beamable.Server;
using Newtonsoft.Json;
using System.Net.WebSockets;
using System.Security.Cryptography;
using System.Text;

namespace cli.Utils;

public class WebsocketUtil
{
	#region Server Events Handling

	public struct ServerNotificationMessage
	{
		public int id;
		public string path;
		public object body;
	}

	/// <summary>
	/// The handle itself encapsulates the <see cref="ClientWebSocket"/> through multiple connection attempts.
	/// When the gateway API closes the socket externally, then the socket instance needs to be rebuilt.
	/// This class wraps up the function that creates and authenticates the socket. 
	/// </summary>
	public class WebsocketConnectionHandle
	{
		private Func<Task<ClientWebSocket>> _connector;

		private Task<ClientWebSocket> _socket;

		public Task<ClientWebSocket> Socket
		{
			get
			{
				if (_socket == null)
				{
					_socket = _connector();
				}

				return _socket;
			}
		}

		public WebsocketConnectionHandle(Func<Task<ClientWebSocket>> connector)
		{
			_connector = connector;
			var _ = Socket; // kick off connection immediately. 
		}

		public void ResetSocket()
		{
			_socket = null;
		}
	}

	/// <summary>
	/// Use this if a command wants to configure a websocket to listen to a particular set of server events.
	/// Then, use the resulting <see cref="WebsocketConnectionHandle"/> with <see cref="RunServerNotificationListenLoop"/> to keep listening for events.
	/// </summary>
	public static WebsocketConnectionHandle ConfigureWebSocketForServerNotifications(CommandArgs args, string[] events, CancellationToken cancellationToken)
	{
		var connector = new Func<Task<ClientWebSocket>>(async () =>
		{
			var socketAddress = GetSocketUrl(args.AppContext.Host);
			var accessToken = args.AppContext.Token.Token;
			var cid = args.AppContext.Cid;
			var pid = args.AppContext.Pid;
			return await ConfigureWebSocketForServerNotifications(cid, pid, socketAddress, accessToken, events, cancellationToken);
		});
		return new WebsocketConnectionHandle(connector);
	}

	/// <summary>
	/// Takes a <see cref="ClientWebSocket"/> configured via <see cref="ConfigureWebSocketForServerNotifications"/> and keeps listening for events while the connection is open.
	/// </summary>
	public static async Task<ClientWebSocket> RunServerNotificationListenLoop(WebsocketConnectionHandle handle, Action<ServerNotificationMessage> onNotification, CancellationToken cancellationToken,
		bool nackCallbackExceptions = false)
	{
		var ws = await handle.Socket;
		do
		{
			try
			{
				var message = await ReadMessage(ws, cancellationToken);
				var messageObj = JsonConvert.DeserializeObject<ServerNotificationMessage>(message);

				using var stringBuilder = StringBuilderPool.StaticPool.Spawn();
				var dict = new ArrayDict { ["id"] = messageObj.id, ["status"] = 200, };

				var ack = Json.Serialize(dict, stringBuilder.Builder);
				if (nackCallbackExceptions)
				{
					try
					{
						onNotification?.Invoke(messageObj);
					}
					catch (Exception e)
					{
						onNotification?.Invoke(messageObj);
						dict["status"] = 500;
						var nack = Json.Serialize(dict, stringBuilder.Builder);
						await SendMessageAsync(ws, nack, cancellationToken);
						Log.Error(e,
							"Error invoking Notification callback... You should not see this as a Beamable customer. If you do, please tell us");
						throw;
					}

					// Ack that we successfully processed the message
					await SendMessageAsync(ws, ack, cancellationToken);
				}
				else
				{
					onNotification?.Invoke(messageObj);
					await SendMessageAsync(ws, ack, cancellationToken);
				}


				if (cancellationToken.IsCancellationRequested)
					break;
			}
			catch (OperationCanceledException)
			{
				Log.Debug($"{nameof(RunServerNotificationListenLoop)} was cancelled");
			}
			catch (WebSocketException ex) when (ex.Message.Contains("remote party closed the WebSocket connection without completing the close handshake"))
			{
				handle.ResetSocket();
				Log.Debug("websocket connection was closed by Beamable host. Reconnecting... ");
				ws = await handle.Socket;
			}
		} while (ws.State == WebSocketState.Open);

		return ws;
	}

	private static async Task<ClientWebSocket> ConfigureWebSocketForServerNotifications(string cid, string pid, string socketAddress, 
		string accessToken, 
		string[] events, CancellationToken cancellationToken)
	{
		Log.Debug($"Connecting to {socketAddress} / token={accessToken}");
		var ws = new ClientWebSocket();

		await ws.ConnectAsync(new Uri(socketAddress), cancellationToken);
		await AuthenticateWithToken(ws, accessToken, cid, pid, cancellationToken);
		await RegisterForEvents(ws, cancellationToken, events);

		return ws;
	}


	private static async Task RegisterForEvents(ClientWebSocket ws, CancellationToken cancelToken, string[] eventList)
	{
		object reqObject;
		if (eventList.Length == 0)
		{
			reqObject = new { id = 3, method = "post", path = "gateway/provider", body = new { type = "event", } };
		}
		else
		{
			reqObject = new { id = 3, method = "post", path = "gateway/provider", body = new { type = "event", evtWhitelist = eventList } };
		}

		var reqJson = JsonConvert.SerializeObject(reqObject);
		Log.Debug($"Registering for events - {reqJson}");

		await SendMessageAsync(ws, reqJson, cancelToken);
		var resultJson = await ReadMessage(ws, cancelToken);
		Log.Debug($"Received {resultJson}");

		var registerResult = JsonConvert.DeserializeObject<AuthResult>(resultJson);
		if (registerResult.status != 200)
		{
			throw new CliException($"Could not register with Beamable status=[{registerResult.status}]");
		}
	}

	#endregion

	#region Connection Targets

	private static async Task<string> GetRealmSecret(CommandArgs args)
	{
		var api = args.DependencyProvider.GetService<IRealmsApi>();
		try
		{
			var customer = await api.GetAdminCustomer();
			var project = customer.customer.projects.FirstOrDefault(p => p.name == args.AppContext.Pid);
			if (project == null) throw new CliException("Invalid PID");
			return project.secret;
		}
		catch (RequesterException ex)
		{
			if (ex.RequestError.status == 403)
			{
				throw new CliException($"Missing permission to access the realm secret for the realm {args.AppContext.Pid}. ");
			}

			throw;
		}
	}

	private static string GetSocketUrl(string apiUrl)
	{
		string url = apiUrl
			.Replace("localhost", "host.docker.internal")
			.Replace("http://", "ws://")
			.Replace("https://", "wss://");
		return $"{url}/socket";
	}

	#endregion


	#region Server Websocket Authentication

	public struct NonceResult
	{
		public Dictionary<string, string> body;
	}

	public struct AuthResult
	{
		// {
		// 	"id" : 2,
		// 	"status" : 400,
		// 	"body" : {
		// 		"status" : 400,
		// 		"service" : "gateway",
		// 		"error" : "TBD",
		// 		"message" : ""
		// 	}
		// }

		public int id;
		public int status;
		public AuthResultBody body;

		public struct AuthResultBody
		{
			public int status;
			public string service;
			public string message;
			public string error;
		}
	}

	
	private static async Task AuthenticateWithToken(ClientWebSocket ws, string accessToken, string cid, string pid, CancellationToken cancellationToken)
	{
		var authRequest = JsonConvert.SerializeObject(new { id = 2, method = "post", path = "gateway/auth", body = new
		{
			cid, 
			pid, 
			token = accessToken,
		} });
		await SendMessageAsync(ws, authRequest, cancellationToken);
		Log.Debug($"Sending auth request {authRequest}");

		var authResponse = await ReadMessage(ws, cancellationToken);
		Log.Debug($"Received auth response {authResponse}");

		var authResult = JsonConvert.DeserializeObject<AuthResult>(authResponse);
		if (authResult.status != 200)
		{
			throw new CliException($"Could not authenticate with Beamable status=[{authResult.status}] service=[{authResult.body.service}] message=[{authResult.body.message}] error=[{authResult.body.error}]");
		}
	}


	[Obsolete("this is here for documentation purposes; if you wanted to connect with a realm secret, this is how. ")]
	private static async Task Authenticate(ClientWebSocket ws, string secret, string cid, string pid, CancellationToken cancellationToken)
	{
		string CalculateSignature(string text)
		{
			MD5 md5 = MD5.Create();
			byte[] data = Encoding.UTF8.GetBytes(text);
			byte[] hash = md5.ComputeHash(data);
			return Convert.ToBase64String(hash);
		}

		Log.Debug($"Authorizing WS connection at ThreadID = {Thread.CurrentThread.ManagedThreadId}");
		var nonceRequest = JsonConvert.SerializeObject(new { id = 1, method = "get", path = "gateway/nonce", });
		Log.Debug($"Sending nonce {nonceRequest}");
		await SendMessageAsync(ws, nonceRequest, cancellationToken);
		var nonceResponse = await ReadMessage(ws, cancellationToken);
		Log.Debug($"Received challenge {nonceResponse}");
		var nonceObj = JsonConvert.DeserializeObject<NonceResult>(nonceResponse);
		var nonce = nonceObj.body["nonce"];
		var sig = CalculateSignature(secret + nonce);
		var authRequest = JsonConvert.SerializeObject(new { id = 2, method = "post", path = "gateway/auth", body = new
		{
			cid, 
			pid, 
			signature = sig,
		} });
		await SendMessageAsync(ws, authRequest, cancellationToken);
		Log.Debug($"Sending auth request {authRequest}");

		var authResponse = await ReadMessage(ws, cancellationToken);
		Log.Debug($"Received auth response {authResponse}");

		var authResult = JsonConvert.DeserializeObject<AuthResult>(authResponse);
		if (authResult.status != 200)
		{
			throw new CliException($"Could not authenticate with Beamable status=[{authResult.status}] service=[{authResult.body.service}] message=[{authResult.body.message}] error=[{authResult.body.error}]");
		}
	}

	#endregion


	private const int SEND_CHUNK_SIZE = 1024;

	public static async Task<string> ReadMessage(ClientWebSocket ws, CancellationToken cancelToken)
	{
		using var stream = new MemoryStream();
		WebSocketReceiveResult result = null;
		do
		{
			var read = new ArraySegment<byte>(new byte[4096]);
			result = await ws.ReceiveAsync(read, cancelToken);
			await stream.WriteAsync(read.Array, read.Offset, result.Count, cancelToken);
		} while (!result.EndOfMessage);

		stream.Seek(0, SeekOrigin.Begin);

		switch (result.MessageType)
		{
			case WebSocketMessageType.Text:
				var reader = new StreamReader(stream, Encoding.UTF8);
				var content = await reader.ReadToEndAsync();
				return content;
		}

		throw new NotImplementedException();
	}

	public static async Task SendMessageAsync(ClientWebSocket ws, string message, CancellationToken cancelToken)
	{
		if (ws.State != WebSocketState.Open)
		{
			throw new CliException($"Connection is not open. state=[{ws.State}]");
		}

		var messageBuffer = Encoding.UTF8.GetBytes(message);
		var messagesCount = (int)Math.Ceiling((double)messageBuffer.Length / SEND_CHUNK_SIZE);

		for (var i = 0; i < messagesCount; i++)
		{
			var offset = (SEND_CHUNK_SIZE * i);
			var count = SEND_CHUNK_SIZE;
			var lastMessage = ((i + 1) == messagesCount);

			if ((count * (i + 1)) > messageBuffer.Length)
			{
				count = messageBuffer.Length - offset;
			}

			await ws.SendAsync(new ArraySegment<byte>(messageBuffer, offset, count), WebSocketMessageType.Text,
				lastMessage, cancelToken);
		}
	}
}
