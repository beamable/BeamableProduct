using Beamable.Api.Autogenerated.Realms;
using Newtonsoft.Json;
using Serilog;
using System.Net.WebSockets;
using System.Text;

namespace cli.Utils;

public class WebsocketUtil
{
	#region Server Events Handling

	public struct ServerNotificationMessage
	{
		public string path;
		public object body;
	}

	/// <summary>
	/// Use this if a command wants to configure a websocket to listen to a particular set of server events.
	/// Then, use the resulting <see cref="ClientWebSocket"/> with <see cref="RunServerNotificationListenLoop"/> to keep listening for events.
	/// </summary>
	public static async Task<ClientWebSocket> ConfigureWebSocketForServerNotifications(CommandArgs args, string[] events, CancellationToken cancellationToken)
	{
		var socketAddress = GetSocketUrl(args.AppContext.Host);
		var realmSecret = await GetRealmSecret(args);
		var cid = args.AppContext.Cid;
		var pid = args.AppContext.Pid;
		return await ConfigureWebSocketForServerNotifications(cid, pid, socketAddress, realmSecret, events, cancellationToken);
	}

	/// <summary>
	/// Takes a <see cref="ClientWebSocket"/> configured via <see cref="ConfigureWebSocketForServerNotifications"/> and keeps listening for events while the connection is open.
	/// </summary>
	public static async Task<ClientWebSocket> RunServerNotificationListenLoop(ClientWebSocket ws, Action<ServerNotificationMessage> onNotification, CancellationToken cancellationToken)
	{
		do
		{
			var message = await WebsocketUtil.ReadMessage(ws, cancellationToken);
			var messageObj = JsonConvert.DeserializeObject<ServerNotificationMessage>(message);

			onNotification?.Invoke(messageObj);
		} while (ws.State == WebSocketState.Open);

		return ws;
	}

	private static async Task<ClientWebSocket> ConfigureWebSocketForServerNotifications(string cid, string pid, string socketAddress, string realmSecret, string[] events, CancellationToken cancellationToken)
	{
		Log.Debug($"Connecting to {socketAddress} / {realmSecret}");
		var ws = new ClientWebSocket();
		cancellationToken = new CancellationToken();
		await ws.ConnectAsync(new Uri(socketAddress), cancellationToken);

		await Authenticate(ws, realmSecret, cid, pid, cancellationToken);
		await RegisterForEvents(ws, cancellationToken, events);
		return ws;
	}


	private static async Task RegisterForEvents(ClientWebSocket ws, CancellationToken cancelToken, string[] eventList)
	{
		object reqObject;
		if (eventList.Length == 0)
		{
			reqObject = new { id = 3, method = "post", path = "gateway/provider", body = new { type = "event", } };
		}
		else
		{
			reqObject = new
			{
				id = 3,
				method = "post",
				path = "gateway/provider",
				body = new
				{
					type = "event",
					evtWhitelist = eventList
					//new string[] { "content.manifest", "realm-config.refresh" }
				}
			};
		}

		var reqJson = JsonConvert.SerializeObject(reqObject);
		Log.Debug($"Registering for events - {reqJson}");

		await WebsocketUtil.SendMessageAsync(ws, reqJson, cancelToken);
		var resultJson = await WebsocketUtil.ReadMessage(ws, cancelToken);
		Log.Debug($"Received {resultJson}");

		var registerResult = JsonConvert.DeserializeObject<AuthResult>(resultJson);
		if (registerResult.status != 200)
		{
			throw new CliException($"Could not register with Beamable status=[{registerResult.status}]");
		}
	}

	#endregion

	#region Connection Targets

	private static async Task<string> GetRealmSecret(CommandArgs args)
	{
		var api = args.DependencyProvider.GetService<IRealmsApi>();
		var customer = await api.GetCustomer();
		var project = customer.customer.projects.FirstOrDefault(p => p.pid == args.AppContext.Pid);
		if (project == null) throw new CliException("Invalid PID");
		return project.secret.Value;
	}

	private static string GetSocketUrl(string apiUrl)
	{
		string url = apiUrl
			.Replace("localhost", "host.docker.internal")
			.Replace("http://", "ws://")
			.Replace("https://", "wss://");
		return $"{url}/socket";
	}

	#endregion


	#region Server Websocket Authentication

	public struct NonceResult
	{
		public Dictionary<string, string> body;
	}

	public struct AuthResult
	{
		public int status;
	}

	private static async Task Authenticate(ClientWebSocket ws, string secret, string cid, string pid, CancellationToken cancellationToken)
	{
		string CalculateSignature(string text)
		{
			System.Security.Cryptography.MD5 md5 = System.Security.Cryptography.MD5.Create();
			byte[] data = Encoding.UTF8.GetBytes(text);
			byte[] hash = md5.ComputeHash(data);
			return Convert.ToBase64String(hash);
		}

		Log.Debug($"Authorizing WS connection at ThreadID = {Thread.CurrentThread.ManagedThreadId}");
		var nonceRequest = JsonConvert.SerializeObject(new { id = 1, method = "get", path = "gateway/nonce", });
		Log.Debug($"Sending nonce {nonceRequest}");
		await WebsocketUtil.SendMessageAsync(ws, nonceRequest, cancellationToken);
		var nonceResponse = await WebsocketUtil.ReadMessage(ws, cancellationToken);
		Log.Debug($"Received challenge {nonceResponse}");
		var nonceObj = JsonConvert.DeserializeObject<NonceResult>(nonceResponse);
		var nonce = nonceObj.body["nonce"];
		var sig = CalculateSignature(secret + nonce);
		var authRequest = JsonConvert.SerializeObject(new { id = 2, method = "post", path = "gateway/auth", body = new { cid, pid, signature = sig } });
		await WebsocketUtil.SendMessageAsync(ws, authRequest, cancellationToken);
		Log.Debug($"Sending auth request {authRequest}");

		var authResponse = await WebsocketUtil.ReadMessage(ws, cancellationToken);
		Log.Debug($"Received auth response {authResponse}");

		var authResult = JsonConvert.DeserializeObject<AuthResult>(authResponse);
		if (authResult.status != 200)
		{
			throw new CliException($"Could not authenticate with Beamable status=[{authResult.status}]");
		}
	}

	#endregion


	private const int SEND_CHUNK_SIZE = 1024;

	public static async Task<string> ReadMessage(ClientWebSocket ws, CancellationToken cancelToken)
	{
		using var stream = new MemoryStream();
		WebSocketReceiveResult result = null;
		do
		{
			var read = new ArraySegment<byte>(new byte[4096]);
			result = await ws.ReceiveAsync(read, cancelToken);
			await stream.WriteAsync(read.Array, read.Offset, result.Count, cancelToken);
		} while (!result.EndOfMessage);

		stream.Seek(0, SeekOrigin.Begin);

		switch (result.MessageType)
		{
			case WebSocketMessageType.Text:
				var reader = new StreamReader(stream, Encoding.UTF8);
				var content = await reader.ReadToEndAsync();
				return content;
		}

		throw new NotImplementedException();
	}

	public static async Task SendMessageAsync(ClientWebSocket ws, string message, CancellationToken cancelToken)
	{
		if (ws.State != WebSocketState.Open)
		{
			throw new CliException($"Connection is not open. state=[{ws.State}]");
		}

		var messageBuffer = Encoding.UTF8.GetBytes(message);
		var messagesCount = (int)Math.Ceiling((double)messageBuffer.Length / SEND_CHUNK_SIZE);

		for (var i = 0; i < messagesCount; i++)
		{
			var offset = (SEND_CHUNK_SIZE * i);
			var count = SEND_CHUNK_SIZE;
			var lastMessage = ((i + 1) == messagesCount);

			if ((count * (i + 1)) > messageBuffer.Length)
			{
				count = messageBuffer.Length - offset;
			}

			await ws.SendAsync(new ArraySegment<byte>(messageBuffer, offset, count), WebSocketMessageType.Text,
				lastMessage, cancelToken);
		}
	}
}
