using Beamable.Api.Autogenerated;
using Beamable.Api.Autogenerated.Beamootel;
using Beamable.Common;
using Beamable.Server;
using Beamable.Common.Api;
using Beamable.Common.Api.Auth;
using Beamable.Common.Api.Notifications;
using Beamable.Common.Api.Realms;
using Beamable.Common.BeamCli;
using Beamable.Common.Dependencies;
using Beamable.Common.Semantics;
using Beamable.Common.Util;
using beamable.otel.exporter;
using cli.CliServerCommand;
using cli.Commands.Project;
using cli.Commands.Project.Deps;
using cli.Commands.Project.StorageData;
using cli.Content;
using cli.Content.Tag;
using cli.DeploymentCommands;
using cli.DockerCommands;
using cli.Docs;
using cli.Dotnet;
using cli.FederationCommands;
using cli.Notifications;
using cli.Options;
using cli.PlayerCommands;
using cli.Portal;
using cli.Services;
using cli.Services.HttpServer;
using cli.TempCommands;
using cli.TokenCommands;
using cli.UnityCommands;
using cli.Unreal;
using cli.UnrealCommands;
using cli.Utils;
using cli.Version;
using CliWrap;
using Errata;
using Microsoft.Build.Locator;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using System.CommandLine;
using System.CommandLine.Binding;
using System.CommandLine.Builder;
using System.CommandLine.Help;
using System.CommandLine.Invocation;
using System.CommandLine.IO;
using System.CommandLine.Parsing;
using System.Diagnostics;
using System.Reflection;
using Beamable.Server.Common;
using Beamable.Tooling.Common;
using cli.CheckCommands;
using cli.Commands.OtelCommands.Grafana;
using cli.Commands.Project.Logs;
using cli.Services.Web;
using cli.DeveloperUserCommands;
using cli.OtelCommands;
using cli.OtelCommands.Grafana;
using cli.Services.DeveloperUserManager;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Exporter;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using Spectre.Console;
using ZLogger;
using Command = System.CommandLine.Command;
using Otel = Beamable.Common.Constants.Features.Otel;

namespace cli;

public class App
{
	public static ILogger GlobalLogger;
	public static ILoggerFactory GlobalLoggerFactory;
	public BeamLogSwitch LogSwitch { get; set; } = new BeamLogSwitch
	{
		Level = LogLevel.Information
	};

	public static MeterProvider MeterProvider;

	public IDependencyBuilder Commands { get; set; }
	public IDependencyProviderScope CommandProvider { get; set; }

	private Action<IDependencyBuilder> _serviceConfigurator;

	private QueuedLogger _queuedLogger;

	public App()
	{
		//This is necessary, so we can use MSBuild to read different projects and get their properties later on
		if (MSBuildLocator.CanRegister)
		{
			string path = Environment.GetEnvironmentVariable(Beamable.Common.Constants.EnvironmentVariables.BEAM_DOTNET_MSBUILD_PATH, EnvironmentVariableTarget.Process);
			if (!string.IsNullOrEmpty(path))
			{
				MSBuildLocator.RegisterMSBuildPath(path);
			}
			else
			{
				MSBuildLocator.RegisterDefaults();
			}

		}

		Commands = new DependencyBuilder();
	}

	public bool IsBuilt => CommandProvider != null;

	private static (ILogger, ILoggerFactory) ConfigureZLogging(App app, IDependencyProvider provider, Action<ILoggingBuilder> configurator)
	{
		var appCtx = provider.GetService<IAppContext>();
		var factory = LoggerFactory.Create(builder =>
		{
			if (configurator != null)
			{
				configurator(builder);
				return;
			}
			
			builder.SetMinimumLevel(LogLevel.Trace);
			
			// forward zLogs to the spectre console
			builder.AddZLoggerLogProcessor(opts =>
			{
				opts.UseBeamFormatter(appCtx);
				return new SpectreZLoggerProcessor(appCtx.LogSwitch, opts);
			});

			if (Otel.CliTracesEnabled())
			{
				// TODO: make the log level configurable via an option
				builder.AddFilter<OpenTelemetryLoggerProvider>((logLevel) => logLevel >= LogLevel.Information);
				builder.AddOpenTelemetry(opts =>
				{
					opts.IncludeScopes = true;
					
					opts.SetResourceBuilder(provider.GetService<ResourceBuilder>());
					opts.AddFileExporter(opts =>
					{
						var configService = provider.GetService<ConfigService>();
						var configPath = configService.ConfigTempOtelLogsDirectoryPath;
						opts.ExportPath = configPath ?? ".";

						var otelConfig = configService.LoadOtelConfigFromFile();
						
						if (Enum.TryParse(otelConfig.BeamCliTelemetryLogLevel, out LogLevel logLevel))
						{
							opts.MinimalLogLevel = logLevel;
						}
						else
						{
							opts.MinimalLogLevel = LogLevel.Warning;
						}
					});
				});
			}

			// maybe write the logs to a file?
			if (appCtx.ShouldUseLogFile && appCtx.TryGetTempLogFilePath(out var logPath))
			{
				var path = Path.GetDirectoryName(logPath);
				if (Directory.Exists(path))
				{
					var existingLogFiles = Directory.GetFiles(path);
					// this is magic number... I guess its a rough estimate of a number of commands per day?
					const int MaxNumberOfLogFilesBeforeAutoClean = 250;
					if (existingLogFiles.Length > MaxNumberOfLogFilesBeforeAutoClean)
					{
						// clean up everything older than a day
						ClearTempLogFilesCommand.CleanLogs(TimeSpan.FromDays(1), existingLogFiles);
					}
				}

				
				builder.AddZLoggerFile(logPath, opts =>
				{
					opts.UseBeamFormatter(appCtx);
				});
				
				
			}
			
			if (appCtx.ShouldEmitLogs)
			{
				builder.AddZLoggerLogProcessor(new ReporterSink(provider));
			}
			
		});
		
		
		var logger = factory.CreateLogger<BeamableZLoggerProvider>();
		
		return (logger, factory);
	}
	

	/// <summary>
	/// These services are registered AFTER the basic CLI parsing has taken place.
	/// </summary>
	/// <param name="services"></param>
	private void ConfigureServices(IDependencyBuilder services)
	{
		// register services
		services.AddSingleton<BeamLogSwitch>(LogSwitch);
		services.AddSingleton<IAppContext, DefaultAppContext>();
		services.AddSingleton<IRequesterInfo>(p => p.GetService<IAppContext>());
		services.AddSingleton<IRealmInfo>(p => p.GetService<IAppContext>());
		services.AddSingleton<IRealmsApi, RealmsService>();
		services.AddSingleton<NoAuthHttpRequester>();
		services.AddSingleton<IAliasService, AliasService>(p => new AliasService(p.GetService<NoAuthHttpRequester>()));
		services.AddSingleton<IBeamableRequester>(provider => provider.GetRequiredService<CliRequester>());
		services.AddSingleton<CliRequester, CliRequester>();
		services.AddSingleton<IRequester>(p => p.GetService<CliRequester>());
		services.AddSingleton<IAuthSettings, DefaultAuthSettings>();
		services.AddSingleton<IAuthApi, AuthApi>();
		services.AddSingleton<ConfigService>();
		services.AddSingleton<BeamoService>();
		services.AddSingleton<BeamoLocalSystem>();
		services.AddSingleton<ContentService, ContentService>();
		services.AddSingleton<DeveloperUserManagerService, DeveloperUserManagerService>();
		services.AddSingleton<SwaggerService>();
		services.AddSingleton<ISwaggerStreamDownloader, SwaggerStreamDownloader>();
		services.AddSingleton<UnitySourceGenerator>();
		services.AddSingleton<UnrealSourceGenerator>();
		services.AddSingleton<WebSourceGenerator>();
		services.AddSingleton<ProjectService>();
		services.AddSingleton<SwaggerService.SourceGeneratorListProvider>();
		services.AddSingleton<UnityCliGenerator>();
		services.AddSingleton<UnrealCliGenerator>();
		services.AddTransient<DiscoveryService>();
		services.AddSingleton<DocService>();
		services.AddSingleton<CliGenerator>();
		services.AddSingleton<VersionService>();
		services.AddSingleton<IDataReporterService, DataReporterService>();
		services.AddSingleton<ServerService>();
		services.AddSingleton<AppLifecycle>();
		services.AddSingleton<IFileOpenerService, FileOpenerService>();
		services.AddSingleton<ISignedRequesterConfig, CliSignedRequesterConfig>();
		services.AddSingleton<HttpSignedRequester>();
		services.AddSingleton<IUserContext, SimpleUserContext>(_ => new SimpleUserContext(0) );
		services.AddSingleton<ProcessFileLocker>();
		

		services.AddSingleton<DefaultActivityProvider>(DefaultActivityProvider.CreateCliServiceProvider());
		services.AddSingleton<ResourceBuilder>(p =>
		{
			var activityProvider = p.GetService<DefaultActivityProvider>();
			var ctx = p.GetService<IAppContext>();


			var dict = new Dictionary<string, object>()
			{
				[Otel.ATTR_SDK_VERSION] = BeamAssemblyVersionUtil.GetVersion<App>(),
			};
			if (!string.IsNullOrEmpty(ctx.Cid))
			{
				dict[Otel.ATTR_CID] = ctx.Cid;
			}
			if (!string.IsNullOrEmpty(ctx.Pid))
			{
				dict[Otel.ATTR_PID] = ctx.Pid;
			}
			if (!string.IsNullOrEmpty(ctx.EngineCalling))
			{
				dict[Otel.ATTR_ENGINE_SOURCE] = ctx.EngineCalling;
			}
			if (!string.IsNullOrEmpty(ctx.EngineSdkVersion))
			{
				dict[Otel.ATTR_ENGINE_SDK_VERSION] = ctx.EngineSdkVersion;
			}
			if (!string.IsNullOrEmpty(ctx.EngineVersion))
			{
				dict[Otel.ATTR_ENGINE_VERSION] = ctx.EngineVersion;
			}

			dict[Otel.ATTR_SOURCE] = "cli";
				
			var resourceBuilder = ResourceBuilder.CreateEmpty()
				.AddService(activityProvider.ServiceName, activityProvider.ServiceNamespace,
					autoGenerateServiceInstanceId: false,
					serviceInstanceId: activityProvider.ServiceId)
				.AddAttributes(dict);
			
			return resourceBuilder;
		});
		services.AddSingleton<TracerProvider>(p =>
		{
			var resourceBuilder = p.GetService<ResourceBuilder>();
			if (Otel.CliTracesEnabled())
			{
				
				return Sdk.CreateTracerProviderBuilder()
					.SetSampler(new TraceIdRatioBasedSampler(0.05f)) //TODO find a better way to reduce number of traces, also get this percentage from a env var
					.SetResourceBuilder(resourceBuilder)
					.AddHttpClientInstrumentation(opts =>
					{
						opts.RecordException = true;
					})
					.AddSource(Otel.METER_CLI_NAME)
					.AddFileExporter(opt =>
					{
						var path = p.GetService<ConfigService>().ConfigTempOtelTracesDirectoryPath;
						opt.ExportPath = path ?? ".";
					})
					.Build();

			}
			return null;
		});

		services.AddSingleton<MeterProvider>(p =>
		{
			if (MeterProvider != null)
			{
				return MeterProvider;
			}

			MeterProvider = _setMeterProvider(p);

			return MeterProvider;
		});

		
		OpenApiRegistration.RegisterOpenApis(services);

		_serviceConfigurator?.Invoke(services);
	}

	private Action<IDependencyProvider> _setLogger = _ =>
	{
		// no-op
	};

	private Func<IDependencyProvider, MeterProvider> _setMeterProvider;

	private BeamActivity _activity;
	private TracerProvider _traceProvider;
	private MeterProvider _meterProvider;

	public virtual void Flush()
	{
		if (!string.IsNullOrEmpty(Environment.GetEnvironmentVariable("BEAM_SKIP_CLI_FLUSH")))
		{
			return;
		}
		
		_activity?.Stop();
		_activity?.Dispose();
		GlobalLoggerFactory?.Dispose();
		_traceProvider?.ForceFlush();
		_traceProvider?.Shutdown();
		_meterProvider?.ForceFlush();
		_meterProvider?.Shutdown();
	}

	public virtual void Configure(
		Action<IDependencyBuilder> serviceConfigurator = null,
		Action<IDependencyBuilder> commandConfigurator = null,
		Action<ILoggingBuilder> configureLogger = null,
		bool overwriteLogger = true
		)
	{
		if (IsBuilt)
			throw new InvalidOperationException("The app has already been built, and cannot be configured anymore");
		
		// The LoggingLevelSwitch _could_ be controlled at runtime, if we ever wanted to do that.
		LogSwitch = new BeamLogSwitch { Level = LogLevel.Information };



		_setMeterProvider = (provider) =>
		{
			var resourceBuilder = provider.GetService<ResourceBuilder>();

			if (Otel.CliTracesEnabled())
			{
				return Sdk.CreateMeterProviderBuilder()
					.AddProcessInstrumentation()
					.AddRuntimeInstrumentation()
					.SetResourceBuilder(resourceBuilder)
					.AddHttpClientInstrumentation()
					.AddFileExporter((opts, metricReader) =>
					{
						var path = provider.GetService<ConfigService>().ConfigTempOtelMetricsDirectoryPath;
						opts.ExportPath = path ?? ".";

						metricReader.TemporalityPreference = MetricReaderTemporalityPreference.Delta;
					})
					.Build();
			}

			return null;
		};

		if (overwriteLogger)
		{
			_setLogger = (provider) =>
			{
				(var logger, GlobalLoggerFactory) = ConfigureZLogging(this, provider, configureLogger);
				GlobalLogger = logger;
				if (_queuedLogger == BeamableZLoggerProvider.LogContext.Value)
				{
					_queuedLogger.Flush(logger);
				}
				
				BeamableZLoggerProvider.GlobalLogger = BeamableZLoggerProvider.LogContext.Value = logger;
			};
		}
		else
		{
			_setLogger = (provider) =>
			{
				var appCtx = provider.GetService<IAppContext>();
				if (appCtx.ShouldEmitLogs)
				{
					var factory = GlobalLoggerFactory = LoggerFactory.Create(builder =>
					{
						builder.SetMinimumLevel(LogLevel.Trace);
						builder.AddZLoggerLogProcessor(new ReporterSink(provider));
					});
					var logger = factory.CreateLogger<BeamableZLoggerProvider>();
					if (_queuedLogger == BeamableZLoggerProvider.LogContext.Value)
					{
						_queuedLogger.Flush(logger);
					}
					BeamableZLoggerProvider.GlobalLogger = BeamableZLoggerProvider.LogContext.Value = logger;
				}
			};
		}

		if (BeamableZLoggerProvider.LogContext.Value == null)
		{
			BeamableZLoggerProvider.GlobalLogger = BeamableZLoggerProvider.LogContext.Value = _queuedLogger = new QueuedLogger();
		}

		Commands.AddSingleton(new ArgValidator<ServiceName>(arg => new ServiceName(arg)));
		Commands.AddSingleton(new ArgValidator<PackageVersion>(arg =>
		{
			if (arg == null) return "0.0.0";
			try
			{
				return PackageVersion.FromSemanticVersionString(arg);
			}
			catch (Exception ex)
			{
				throw new Exception($"Failed to parse version. Invalid=[{arg}] Message=[{ex.Message}]");
			}
		}));

		// add global options
		Commands.AddSingleton<DryRunOption>();
		Commands.AddSingleton<SkipStandaloneValidationOption>();
		Commands.AddSingleton(PreferRemoteFederationOption.Instance);
		Commands.AddSingleton(CidOption.Instance);
		Commands.AddSingleton(EngineCallerOption.Instance);
		Commands.AddSingleton(EngineSdkVersionOption.Instance);
		Commands.AddSingleton(EngineVersionOption.Instance);
		Commands.AddSingleton(IgnoreBeamoIdsOption.Instance);
		Commands.AddSingleton<QuietOption>();
		Commands.AddSingleton(PidOption.Instance);
		Commands.AddSingleton<HostOption>();
		Commands.AddSingleton<LimitOption>();
		Commands.AddSingleton<SkipOption>();
		Commands.AddSingleton<DeployFilePathOption>();
		Commands.AddSingleton<AccessTokenOption>();
		Commands.AddSingleton<RefreshTokenOption>();
		Commands.AddSingleton(LogOption.Instance);
		Commands.AddSingleton<ShowRawOutput>();
		Commands.AddSingleton<ShowPrettyOutput>();
		Commands.AddSingleton(ExtraProjectPathOptions.Instance);
		Commands.AddSingleton(DotnetPathOption.Instance);
		Commands.AddSingleton(NoForwardingOption.Instance);
		Commands.AddSingleton(AllHelpOption.Instance);
		Commands.AddSingleton(NoLogFileOption.Instance);
		Commands.AddSingleton(UnmaskLogsOption.Instance);
		Commands.AddSingleton(DockerPathOption.Instance);
		Commands.AddSingleton(provider =>
		{
			var root = new RootCommand();
			root.AddGlobalOption(provider.GetRequiredService<DryRunOption>());
			root.AddGlobalOption(provider.GetRequiredService<CidOption>());
			root.AddGlobalOption(provider.GetRequiredService<EngineCallerOption>());
			root.AddGlobalOption(provider.GetRequiredService<EngineSdkVersionOption>());
			root.AddGlobalOption(provider.GetRequiredService<EngineVersionOption>());
			root.AddGlobalOption(provider.GetRequiredService<PidOption>());
			root.AddGlobalOption(provider.GetRequiredService<QuietOption>());
			root.AddGlobalOption(provider.GetRequiredService<HostOption>());
			root.AddGlobalOption(provider.GetRequiredService<AccessTokenOption>());
			root.AddGlobalOption(provider.GetRequiredService<RefreshTokenOption>());
			root.AddGlobalOption(provider.GetRequiredService<LogOption>());
			root.AddGlobalOption(provider.GetRequiredService<NoForwardingOption>());
			root.AddGlobalOption(IgnoreBeamoIdsOption.Instance);
			root.AddGlobalOption(PreferRemoteFederationOption.Instance);
			root.AddGlobalOption(AllHelpOption.Instance);;
			root.AddGlobalOption(UnmaskLogsOption.Instance);
			root.AddGlobalOption(NoLogFileOption.Instance);
			root.AddGlobalOption(DockerPathOption.Instance);
			root.AddGlobalOption(EmitLogsOption.Instance);
			root.AddGlobalOption(ExtraProjectPathOptions.Instance);
			root.AddGlobalOption(provider.GetRequiredService<ShowRawOutput>());
			root.AddGlobalOption(provider.GetRequiredService<ShowPrettyOutput>());
			root.AddGlobalOption(provider.GetRequiredService<SkipStandaloneValidationOption>());
			root.AddGlobalOption(provider.GetRequiredService<DotnetPathOption>());
			root.Description = "A CLI for interacting with the Beamable Cloud.";
			return root;
		});


		// add commands
		Commands.AddRootCommand<CliInterfaceGeneratorCommand, CliInterfaceGeneratorCommandArgs>();
		Commands.AddRootCommand<ServerGroupCommand>();
		Commands.AddSubCommand<ServeCliCommand, ServeCliCommandArgs, ServerGroupCommand>();
		Commands.AddSubCommand<RequestCliCommand, RequestCliCommandArgs, ServerGroupCommand>();
		Commands.AddSubCommand<ServerPsCommand, ServerPsCommandArgs, ServerGroupCommand>();
		Commands.AddSubCommand<ServerKillCommand, ServerKillCommandArgs, ServerGroupCommand>();
		Commands.AddRootCommand<InitCommand, InitCommandArgs>();
		
		Commands.AddRootCommand<CheckCommandCommandGroup>();
		Commands.AddSubCommand<CreateChecksCommand, CreateChecksCommandArgs, CheckCommandCommandGroup>();

		Commands.AddRootCommand<OtelCommand>();
		Commands.AddSubCommandWithHandler<GetClickhouseCredentials, GetClickhouseCredentialsArgs, OtelCommand>();
		Commands.AddSubCommandWithHandler<PushTelemetryCommand, PushTelemetryCommandArgs, OtelCommand>();
		Commands.AddSubCommandWithHandler<PruneTelemetryCommand, PruneTelemetryCommandArgs, OtelCommand>();
		Commands.AddSubCommandWithHandler<ReportTelemetryCommand, ReportTelemetryCommandArgs, OtelCommand>();
		Commands.AddSubCommandWithHandler<FetchTelemetryLogsCommand, FetchTelemetryLogsCommandArgs, OtelCommand>();
		Commands.AddSubCommandWithHandler<SetBeamOtelConfigCommand, SetBeamOtelConfigCommandArgs, OtelCommand>();
		Commands.AddSubCommandWithHandler<GetBeamOtelConfigCommand, GetBeamOtelConfigCommandArgs, OtelCommand>();

		Commands.AddSubCommandWithHandler<CollectorCommand, CollectorCommandArgs, OtelCommand>();
		Commands.AddSubCommandWithHandler<StartCollectorCommand, StartCollectorCommandArgs, CollectorCommand>();
		Commands.AddSubCommandWithHandler<StopCollectorCommand, StopCollectorCommandArgs, CollectorCommand>();

		Commands.AddSubCommandWithHandler<CollectorStatusCommand, CollectorStatusCommandArgs, CollectorCommand>();
		Commands.AddSubCommandWithHandler<DownloadCollectorCommand, DownloadCollectorCommandArgs, CollectorCommand>();
		
		Commands.AddRootCommand<GrafanaCommand>();
		Commands.AddSubCommand<StartGrafanaCommand, StartGrafanaCommandArgs, GrafanaCommand>();
		Commands.AddSubCommand<CheckGrafanaCommand, CheckGrafanaCommandArgs, GrafanaCommand>();
		Commands.AddSubCommand<StopGrafanaCommand, StopGrafanaCommandArgs, GrafanaCommand>();


		Commands.AddRootCommand<ProjectCommand>();

		Commands.AddSubCommand<OpenSolutionCommand, OpenSolutionCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<StorageGroupCommand, CommandGroupArgs, ProjectCommand>();
		Commands.AddSubCommand<SnapshotStorageObjectCommand, SnapshotStorageObjectCommandArgs, StorageGroupCommand>();
		Commands.AddSubCommand<RestoreStorageObjectCommand, RestoreStorageObjectCommandArgs, StorageGroupCommand>();
		Commands.AddSubCommand<EraseStorageObjectCommand, EraseStorageObjectCommandArgs, StorageGroupCommand>();

		Commands.AddSubCommand<GetRemoteLogsCommand, GetRemoteLogsCommandArgs, ProjectCommand>();
		
		Commands.AddSubCommand<ProjectNewCommand, CommandGroupArgs, ProjectCommand>();
		Commands.AddSubCommand<GenerateOApiCommand, GenerateOApiCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<RunProjectCommand, RunProjectCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<DeleteProjectCommand, DeleteProjectCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<StopProjectCommand, StopProjectCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<BuildProjectCommand, BuildProjectCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<BuildSolutionCommand, BuildSolutionCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<NewMicroserviceCommand, NewMicroserviceArgs, ProjectNewCommand>();
		Commands.AddSubCommand<NewCommonLibraryCommand, CreateCommonLibraryArgs, ProjectNewCommand>();
		Commands.AddSubCommand<ProjectDependencies, ProjectDependenciesArgs, ProjectCommand>();
		Commands.AddSubCommand<SetEnabledCommand, SetEnabledCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<SetDisableCommand, SetEnabledCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<SaveProjectPathsCommand, SaveProjectPathsCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<RegenerateSolutionFilesCommand, RegenerateSolutionFilesCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<GroupCommand,CommandGroupArgs, ProjectCommand>();
		Commands.AddSubCommand<GroupAddCommand, UpdateGroupArgs, GroupCommand>();
		Commands.AddSubCommand<GroupRemoveCommand, UpdateGroupArgs, GroupCommand>();
		Commands.AddSubCommand<ListCommand, ListCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<NewStorageCommand, NewStorageCommandArgs, ProjectNewCommand>();
		Commands.AddSubCommand<NewPortalExtensionCommand, NewPortalExtensionCommandArgs, ProjectNewCommand>();
		Commands.AddSubCommand<GenerateEnvFileCommand, GenerateEnvFileCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<GenerateIgnoreFileCommand, GenerateIgnoreFileCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<GenerateClientFileCommand, GenerateClientFileCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<GeneratePropertiesFileCommand, GeneratePropertiesFileCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<OpenSwaggerCommand, OpenSwaggerCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<ReadProjectSettingsCommand, ReadProjectSettingsCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<WriteProjectSettingsCommand, WriteProjectSettingsCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<TailLogsCommand, TailLogsCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<OpenMongoExpressCommand, OpenMongoExpressCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<AddUnityClientOutputCommand, AddProjectClientOutputCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<AddUnrealClientOutputCommand, UnrealAddProjectClientOutputCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<UpdateUnityBeamPackageCommand, UpdateUnityBeamPackageCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<ShareCodeCommand, ShareCodeCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<CheckStatusCommand, CheckStatusCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<ShowRemoteManifestCommand, ShowRemoteManifestCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<GenerateClientOapiCommand, GenerateClientOapiCommandArgs, ProjectCommand>();

		Commands.AddSubCommand<ProjectGenerateCommand, CommandGroupArgs, ProjectCommand>();
		Commands.AddSubCommand<GenerateWebClientCommand, GenerateWebClientCommandArgs, ProjectGenerateCommand>();

		Commands.AddRootCommand<AccountMeCommand, AccountMeCommandArgs>();
		Commands.AddRootCommand<GenerateDocsCommand, GenerateDocsCommandArgs>();
		Commands.AddRootCommand<GenerateMkDocsCommand, GenerateMkDocsCommandArgs>();
		
		// FEDERATION COMMANDS
		Commands.AddRootCommand<FederationCommand>();
		Commands.AddSubCommand<ListFederationsCommand, ListServicesCommandArgs, FederationCommand>();
		Commands.AddSubCommand<DisableFederationCommand, DisableFederationCommandArgs, FederationCommand>();
		Commands.AddSubCommand<EnableFederationCommand, DisableFederationCommandArgs, FederationCommand>();
		Commands.AddSubCommand<GetLocalRoutingKeyCommand, GetLocalRoutingKeyCommandArgs, FederationCommand>();
		
		// FEDERATION LOCAL SETTING COMMANDS
		Commands.AddSubCommand<FederationLocalSettingsCommand, CommandGroupArgs, FederationCommand>();
		Commands.AddSubCommand<FederationLocalSettingsCommand.Get, CommandGroupArgs, FederationLocalSettingsCommand>();
		Commands.AddSubCommand<FederationLocalSettingsCommand.Set, CommandGroupArgs, FederationLocalSettingsCommand>();
		Commands.AddSubCommand<GetLocalSettingsIFederatedGameServerCommand, GetLocalSettingsIFederatedGameServerCommandArgs, FederationLocalSettingsCommand.Get>();
		Commands.AddSubCommand<SetLocalSettingsIFederatedGameServerCommand, SetLocalSettingsIFederatedGameServerCommandArgs, FederationLocalSettingsCommand.Set>();
		
		
		Commands.AddRootCommand<TokenCommandGroup>();
		Commands.AddSubCommand<GetTokenDetailsCommand, GetTokenDetailsCommandArgs, TokenCommandGroup>();
		Commands.AddSubCommand<GetTokenListCommand, GetTokenListCommandArgs, TokenCommandGroup>();
		Commands.AddSubCommand<GetTokenViaRefreshCommand, GetTokenViaRefreshCommandArgs, TokenCommandGroup>();
		Commands.AddSubCommand<GetTokenForGuestCommand, GetTokenForGuestCommandArgs, TokenCommandGroup>();

		Commands.AddRootCommand<TempCommandGroup>();
		Commands.AddSubCommand<TempClearCommandGroup, TempClearArgs, TempCommandGroup>();
		Commands.AddSubCommandWithHandler<ClearTempLogFilesCommand, ClearTempLogFilesCommandArgs, TempClearCommandGroup>();
		
		Commands.AddRootCommand<PlayerCommand, PlayerCommandArgs>();
		
		Commands.AddRootCommand<PortalCommand, PortalCommandArgs>();
		Commands.AddSubCommandWithHandler<PortalOpenCurrentAccountCommand, PortalOpenCurrentAccountCommandArgs, PortalCommand>();
		Commands.AddSubCommandWithHandler<PortalExtensionCommand, PortalExtensionCommandArgs, PortalCommand>();
		Commands
			.AddSubCommandWithHandler<PortalExtensionCheckCommand, PortalExtensionCheckCommandArgs,
				PortalExtensionCommand>();
		Commands
			.AddSubCommandWithHandler<PortalExtensionRunCommand, PortalExtensionRunCommandArgs,
				PortalExtensionCommand>();
		Commands
			.AddSubCommandWithHandler<PortalExtensionAddDependencyCommand, PortalExtensionAddDependencyCommandArgs,
				PortalExtensionCommand>();

		Commands.AddRootCommand<ConfigCommand, ConfigCommandArgs>();
		Commands.AddSubCommandWithHandler<ConfigRoutesCommand, ConfigRoutesCommandArgs, ConfigCommand>();
		Commands.AddSubCommandWithHandler<ConfigSetCommand, ConfigSetCommandArgs, ConfigCommand>();
		Commands.AddSubCommandWithHandler<ConfigGetSecret, ConfigGetSecretArgs, ConfigCommand>();
		Commands.AddSubCommandWithHandler<RealmConfigCommand, RealmConfigCommandArgs, ConfigCommand>();
		Commands.AddSubCommandWithHandler<RealmConfigSetCommand, RealmConfigSetCommandArgs, RealmConfigCommand>();
		Commands.AddSubCommandWithHandler<RealmConfigRemoveCommand, RealmConfigRemoveCommandArgs, RealmConfigCommand>();
		Commands.AddRootCommand<LoginCommand, LoginCommandArgs>();
		Commands.AddRootCommand<LogoutCommand, LogoutCommandArgs>();
		Commands.AddRootCommand<OpenAPICommand>();
		Commands.AddSubCommand<GenerateSdkCommand, GenerateSdkCommandArgs, OpenAPICommand>();
		Commands.AddSubCommand<DownloadOpenAPICommand, DownloadOpenAPICommandArgs, OpenAPICommand>();
		Commands.AddSubCommandWithHandler<DepsCommand, DepsCommandArgs, ProjectCommand>();
		Commands.AddSubCommandWithHandler<ListDepsCommand, ListDepsCommandArgs, DepsCommand>();
		Commands.AddSubCommandWithHandler<AddDepsCommand, AddDepsCommandArgs, DepsCommand>();
		Commands.AddSubCommandWithHandler<RemoveDepsCommand, RemoveDepsCommandArgs, DepsCommand>();

		Commands.AddRootCommand<NotificationBaseCommand>();
		Commands.AddSubCommand<NotificationServerCommand, NotificationServerCommandArgs, NotificationBaseCommand>();
		Commands.AddSubCommand<NotificationPlayerCommand, NotificationPlayerCommandArgs, NotificationBaseCommand>();

		Commands.AddRootCommand<ProfilingCommand>();
		Commands.AddSubCommand<CheckCountersCommand, CheckCountersCommandArgs, ProfilingCommand>();
		Commands.AddSubCommand<CheckNBomberCommand, CheckNBomberCommandArgs, ProfilingCommand>();
		Commands.AddSubCommand<RunNBomberCommand, RunNBomberCommandArgs, ProfilingCommand>();

		// unity commands
		Commands.AddRootCommand<UnityGroupCommand>();
		Commands.AddSubCommand<RestoreProjectCommand, RestoreProjectCommandArgs, UnityGroupCommand>();
		Commands.AddSubCommand<CopyProjectSrcToUnityCommand, CopyProjectSrcToUnityCommandArgs, UnityGroupCommand>();
		Commands.AddSubCommand<GetUnityVersionInfoCommand, GetUnityVersionInfoCommandArgs, UnityGroupCommand>();
		Commands.AddSubCommand<ReleaseSharedUnityCodeCommand, ReleaseSharedUnityCodeCommandArgs, UnityGroupCommand>();
		Commands.AddSubCommand<DownloadNugetDepToUnityCommand, DownloadNugetDepToUnityCommandArgs, UnityGroupCommand>();
		Commands.AddSubCommand<DownloadAllNugetDepsToUnityCommand, DownloadAllNugetDepsToUnityCommandArgs,
				UnityGroupCommand>();
		Commands.AddSubCommand<UpdateServiceAssemblyReferencesCommand, UpdateServiceAssemblyReferencesCommandArgs,
			UnityGroupCommand>();
		Commands.AddSubCommand<UpdateServiceDllsReferenceCommand, UpdateServiceDllsReferenceCommandArgs,
			UnityGroupCommand>();
		Commands.AddSubCommand<ShowManifestCommand, ShowManifestCommandArgs, UnityGroupCommand>();
		
		// unreal commands
		Commands.AddRootCommand<UnrealGroupCommand>();
		Commands.AddSubCommand<InitUnrealSDKCommand, InitUnrealSDKCommandArgs, UnrealGroupCommand>();
		Commands.AddSubCommand<SelectUnrealSampleCommand, SelectUnrealSampleCommandArgs, UnrealGroupCommand>();
		
		// version commands
		Commands.AddRootCommand<VersionCommand, VersionCommandArgs>();
		Commands.AddSubCommandWithHandler<VersionListCommand, VersionListCommandArgs, VersionCommand>();
		Commands.AddSubCommandWithHandler<VersionInstallCommand, VersionInstallCommandArgs, VersionCommand>();
		Commands.AddSubCommandWithHandler<ConstructVersionCommand, ConstructVersionCommandArgs, VersionCommand>();
		// org commands
		Commands.AddRootCommand<OrganizationCommand>();
		Commands.AddSubCommand<RegisterCommand, RegisterCommandArgs, OrganizationCommand>();
		Commands.AddSubCommand<RealmListCommand, RealmsListCommandArgs, OrganizationCommand>();
		Commands.AddSubCommand<GameListCommand, GameListCommandArgs, OrganizationCommand>();
		
		// beamo commands
		Commands.AddRootCommand<ServicesCommand>();

		Commands.AddSubCommand<DockerGroupCommand, CommandGroupArgs, ServicesCommand>();
		Commands.AddSubCommand<DockerStatusCommand, DockerStatusCommandArgs, DockerGroupCommand>();
		Commands.AddSubCommand<StartDockerCommand, StartDockerCommandArgs, DockerGroupCommand>();
		
		Commands.AddSubCommand<ServicesManifestsCommand, ServicesManifestsArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesListCommand, ServicesListCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesDeployCommand, ServicesDeployCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesRunCommand, ServicesRunCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesResetCommand, CommandGroupArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesResetImageCommand, ServicesResetImageCommandArgs, ServicesResetCommand>();
		Commands.AddSubCommand<ServicesResetContainerCommand, ServicesResetContainerCommandArgs, ServicesResetCommand>();
		Commands.AddSubCommand<ServicesStopCommand, ServicesStopCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesTemplatesCommand, ServicesTemplatesCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesRegistryCommand, ServicesRegistryCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesUploadApiCommand, ServicesUploadApiCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesLogsUrlCommand, ServicesLogsUrlCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesMetricsUrlCommand, ServicesMetricsUrlCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesPromoteCommand, ServicesPromoteCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesGetConnectionStringCommand, ServicesGetConnectionStringCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesGenerateLocalManifestCommand, ServicesGenerateLocalManifestCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesBuildCommand, ServicesBuildCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesUpdateDockerfileCommand, ServicesUpdateDockerfileCommandArgs, ServicesCommand>();
		// content commands

		Commands.AddRootCommand<DeploymentCommand>();
		
		Commands.AddSubCommandWithHandler<CheckRegistryCommand, CheckRegistryCommandArgs, DeploymentCommand>();
		Commands.AddSubCommandWithHandler<GetDeploymentCommand, GetDeploymentCommandArgs, DeploymentCommand>();
		Commands.AddSubCommandWithHandler<ListDeploymentsCommand, ListDeploymentsCommandArgs, DeploymentCommand>();
		Commands.AddSubCommandWithHandler<ShowCurrentBeamoStatusCommand, ShowCurrentBeamoStatusCommandArgs, DeploymentCommand>();
		Commands.AddSubCommandWithHandler<PlanDeploymentCommand, PlanDeploymentCommandArgs, DeploymentCommand>();
		Commands.AddSubCommandWithHandler<ReleaseDeploymentCommand, ReleaseDeploymentCommandArgs, DeploymentCommand>();
		
		Commands.AddRootCommand<ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentPsCommand, ContentPsCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentStatusCommand, ContentStatusCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentOpenCommand, ContentOpenCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentReplaceCommand, ContentReplaceCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentSaveCommand, ContentSaveCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentPublishCommand, ContentPublishCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentSyncCommand, ContentSyncCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentResolveConflictCommand, ContentResolveConflictCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentListManifestsCommand, ContentListManifestsCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentCreateLocalManifestCommand, ContentCreateLocalManifestCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentArchiveManifestCommand, ContentArchiveManifestCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentSnapshotCommand, ContentSnapshotCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentRestoreCommand, ContentRestoreCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentSnapshotListCommand, ContentSnapshotListCommandArgs, ContentCommand>();
		
		Commands.AddSubCommandWithHandler<ContentTagCommand, ContentTagCommandArgs, ContentCommand>();
		
		Commands.AddSubCommandWithHandler<ContentTagSetCommand, ContentTagSetCommandArgs, ContentTagCommand>();
		Commands.AddSubCommandWithHandler<ContentTagAddCommand, ContentTagAddCommandArgs, ContentTagCommand>();
		Commands.AddSubCommandWithHandler<ContentTagRemoveCommand, ContentTagRemoveCommandArgs, ContentTagCommand>();
		
		// Developer User Management 
		Commands.AddRootCommand<DeveloperUserManagerCommand>();

		Commands.AddSubCommandWithHandler<DeveloperUserCreateCommand, DeveloperUserCreateArgs, DeveloperUserManagerCommand>();
		Commands.AddSubCommandWithHandler<DeveloperUserCreateBatchCommand, DeveloperUserCreateBatchArgs, DeveloperUserManagerCommand>();
		Commands.AddSubCommandWithHandler<DeveloperUserSaveCommand, DeveloperUserSaveArgs, DeveloperUserManagerCommand>();
		Commands.AddSubCommandWithHandler<DeveloperUserCopyStateCommand, DeveloperUserCopyStateArgs, DeveloperUserManagerCommand>();
		Commands.AddSubCommandWithHandler<DeveloperUserPsCommand, DeveloperUserPsArgs, DeveloperUserManagerCommand>();
		Commands.AddSubCommandWithHandler<DeveloperUserUpdateInfoCommand, DeveloperUserUpdateInfoArgs, DeveloperUserManagerCommand>();
		Commands.AddSubCommandWithHandler<DeveloperUserRemoveCommand, DeveloperUserRemoveArgs, DeveloperUserManagerCommand>();
		Commands.AddSubCommandWithHandler<DeveloperUserCleanCapturedUsersBufferCommand, DeveloperUserCleanCapturedUsersBufferArgs, DeveloperUserManagerCommand>();

		commandConfigurator?.Invoke(Commands);

		// customize
		_serviceConfigurator = serviceConfigurator;
	}

	public List<Command> InstantiateAllCommands()
	{
		// automatically create all commands
		var commandList = new List<Command>();
		var commandFactoryServices = CommandProvider.SingletonServices.Where(t =>
			t.Interface.IsGenericType && t.Interface.GetGenericTypeDefinition() == typeof(ICommandFactory<>)).ToList();
		foreach (var factoryDescriptor in commandFactoryServices)
		{
			CommandProvider.GetService(factoryDescriptor.Interface);
			var commandType = factoryDescriptor.Interface.GetGenericArguments()[0];
			var command = (Command)CommandProvider.GetService(commandType);

			commandList.Add(command);
		}

		return commandList;
	}

	public virtual void Build()
	{
		if (IsBuilt)
			throw new InvalidOperationException("The app has already been built, and cannot be built again");
		
		BeamableLogProvider.Provider = new BeamableZLoggerProvider();
		var logBuffer = new ZLoggerBufferedProcessor();
		{ // construct some fake log setup so that we can log before the actual logs are initilaized. 
			var factory = LoggerFactory.Create(builder => { builder.AddZLoggerLogProcessor(logBuffer); });
			var logger = factory.CreateLogger<App>();
			BeamableZLoggerProvider.GlobalLogger = BeamableZLoggerProvider.LogContext.Value = logger;
		}
		Commands.AddSingleton(logBuffer);
		
		CommandProvider = Commands.Build();

		var sw = new Stopwatch();
		sw.Start();
		var _ = InstantiateAllCommands();
		sw.Stop();
		Log.Verbose("BUILD ALL COMMANDS TOOK : " + sw.ElapsedMilliseconds);

		// sort the commands
		var root = CommandProvider.GetService<RootCommand>();
		SortCommands(root);
	}

	void SortCommands(Command root)
	{
		var subCommandField = typeof(Command).GetField("_subcommands", BindingFlags.Instance | BindingFlags.NonPublic);
		if (subCommandField == null) return;
		var subCommands = (List<Command>)subCommandField.GetValue(root);
		if (subCommands == null) return;
		subCommands.Sort((a, b) =>
		{
			if (a is not IAppCommand aCommand)
			{
				return 0;
			}

			if (b is not IAppCommand bCommand)
			{
				return 0;
			}

			// all internal commands go at the end
			if (aCommand.IsForInternalUse != bCommand.IsForInternalUse)
			{
				return bCommand.IsForInternalUse ? -1 : 1;
			}

			// and all commands are sorted by their order
			if (bCommand.Order != aCommand.Order)
			{
				return bCommand.Order.CompareTo(aCommand.Order);
			}

			// or alphabet order
			return String.Compare(a.Name, b.Name, StringComparison.Ordinal);

		});

		foreach (var subCommand in subCommands)
		{
			SortCommands(subCommand);
		}
	}

	public static IEnumerable<HelpSectionDelegate> GetHelpLayout()
	{
		yield return HelpBuilder.Default.SynopsisSection();
		yield return HelpBuilder.Default.CommandUsageSection();
		yield return HelpBuilder.Default.CommandArgumentsSection();
		yield return HelpBuilder.Default.OptionsSection();
		// Instead of using HelpBuilder.Default.SubcommandsSection();
		//  we inject our own subCommandSection.
		yield return (ctx) => new BeamHelpBuilder(ctx).WriteSubcommands(ctx);
		yield return HelpBuilder.Default.AdditionalArgumentsSection();
	}

	class ZLoggerBufferedProcessor : IAsyncLogProcessor
	{
		public List<IZLoggerEntry> logs = new List<IZLoggerEntry>();
		public List<IZLoggerEntry> logsGotWhileDisabled = new List<IZLoggerEntry>();
		public bool isDisabled;
		public ValueTask DisposeAsync()
		{
			return ValueTask.CompletedTask;
		}

		public void Post(IZLoggerEntry log)
		{
			if (isDisabled)
			{
				logsGotWhileDisabled.Add(log);
				return; 
			}
			logs.Add(log);
		}
	}
	
	protected virtual Parser GetProgram()
	{
		var root = CommandProvider.GetRequiredService<RootCommand>();

		var helpBuilder = new HelpBuilder(LocalizationResources.Instance, 100);
		_activity = null;
		_traceProvider = null;
		_meterProvider = null;
		
		helpBuilder.CustomizeLayout(c =>
		{
			
			var defaultLayout = GetHelpLayout().ToList();
			defaultLayout.Add(PrintOutputHelp);
			defaultLayout.Add(ctx =>
			{
				if (!ConfigService.IsRedirected)
				{
					// return; // nothing to say if we aren't being redirected...
				}

				var options = ctx.Command.Options;
				
				if (ctx.Command is IHaveRedirectionConcernMessage concernedCommand)
				{
					
					ctx.Output.WriteLine("Redirection Warning:");
					concernedCommand.WriteValidationMessage(ctx.Command, ctx.Output);
				}

				
			});
			var executingVersion = BeamAssemblyVersionUtil.GetVersion<App>();

			defaultLayout.Insert(0, (ctx) =>
			{
				if (ctx.Command is not IAppCommand appCommand)
				{
					return;
				}

				if (appCommand.IsForInternalUse)
				{
					ctx.Output.WriteLine("Internal Use Warning!!!");
					ctx.Output.WriteLine("  This command was designed to be used as an internal command for the Beamable team. ");
					ctx.Output.WriteLine("  You may use the command, but please understand the command was not specifically ");
					ctx.Output.WriteLine("  designed to be used outside of the Beamable team. The command structure may change ");
					ctx.Output.WriteLine("  in the future. Happy spelunking!");
				}
			});
			
			defaultLayout.Insert(0, (ctx) =>
			{
				ctx.Output.WriteLine("CLI Version: " + executingVersion);
			});

			if (!ConfigService.TryToFindBeamableFolder(".", out var guessPath))
			{
				return defaultLayout;
			}
			if (!ConfigService.TryGetProjectBeamableCLIVersion(guessPath, out var localVersion))
			{
				return defaultLayout;
			}

			if (executingVersion != localVersion)
			{
				var noForward = c.ParseResult.GetValueForOption(NoForwardingOption.Instance);
				if (noForward)
				{
					defaultLayout.Insert(0, ctx =>
					{
						ctx.Output.WriteLine($"Version Warning!");
						ctx.Output.WriteLine($"  A local project was detected at path=[{guessPath}].");
						ctx.Output.WriteLine($"  The local project is using local-version=[{localVersion}], ");
						ctx.Output.WriteLine($"  but this CLI is showing --help for execution-version=[{executingVersion}]. ");
						ctx.Output.WriteLine("");
						ctx.Output.WriteLine("  To see the --help information for the local version, use ");
						ctx.Output.WriteLine("  `dotnet beam --help`  ");
						ctx.Output.WriteLine("");
						ctx.Output.WriteLine("  By default, all commands will be redirected to the local version, unless ");
						ctx.Output.WriteLine($"  the {NoForwardingOption.OPTION_FLAG} flag is set.");

					});
					return defaultLayout;
				}

				return new List<HelpSectionDelegate>
				{
					ctx =>
					{
						ctx.Output.WriteLine($"execution-version=[{executingVersion}]");
						ctx.Output.WriteLine($"local-version=[{localVersion}]");
						ctx.Output.WriteLine($"Showing redirected help.");
					},
					ProxyHelp
				};
			}

			return defaultLayout;
		});

		var commandLineBuilder = new CommandLineBuilder(root);
		
		
		// this middleware pre-handles the --all-help option.
		commandLineBuilder.AddMiddleware((ctx, next) =>
		{
			var isAllHelp = ctx.ParseResult.GetValueForOption(AllHelpOption.Instance);
			if (isAllHelp)
			{
				PrintHelp(ctx);
				return Task.CompletedTask;
			}
			return next(ctx);
		}, MiddlewareOrder.Configuration);
		
		// this middleware is responsible for catching parse errors and putting them on the data-out raw channel
		commandLineBuilder.AddMiddleware((ctx, next) =>
		{
			if (ctx.ParseResult.Errors.Count == 0)
			{
				// no parse errors, so this middleware has nothing to do.
				return next(ctx);
			}

			var provider = ServiceProviderServiceExtensions.GetService<AppServices>(ctx.BindingContext);
			var appContext = ServiceProviderServiceExtensions.GetService<IAppContext>(provider);
			var reporter = ServiceProviderServiceExtensions.GetService<IDataReporterService>(provider);
			var isPiping = appContext.UsePipeOutput || appContext.ShowRawOutput;
			
			if (!isPiping)
			{
				// we aren't using raw output, so this middleware has nothing to do.
				return next(ctx);
			}

			var ex = new Exception(string.Join(",", ctx.ParseResult.Errors));
			ctx.ExitCode = 1;
			reporter.Exception(ex, ctx.ExitCode, ctx.BindingContext.ParseResult.Diagram());
			// don't call the next task, because we have "handled" the error by posting it to the error channel
			return Task.CompletedTask;
			
		}, MiddlewareOrder.ErrorReporting);
		
		
		commandLineBuilder.AddMiddleware(async (ctx, next) =>
		{
			var sw = new Stopwatch();
			sw.Start();
			// create a scope for the execution of the command
			var provider = CommandProvider.Fork(services =>
			{
				// add in the services that need to rely on the CLI parsing having completed
				services.AddSingleton(ctx);
				services.AddSingleton(ctx.BindingContext);
				services.AddSingleton(helpBuilder);
				services.AddSingleton<BeamActivity>(p => p.GetService<DefaultActivityProvider>().Create("invocation"));
				ConfigureServices(services);
			});
			// TODO: I guess we need this maybe
			_ = provider.GetService<IAppContext>();
			
			// First thing we have to do is ensure we have our paths to our Config directories loaded.
			provider.GetService<ConfigService>().SetWorkingDir();

			{ // if the application is force-quit, then we should cancel our life-cycle to give commands a chance to clean up
				Console.CancelKeyPress += (sender, eventArgs) =>
				{
					
					// prevent the application from shutting down immediately after a CTRL+C appears, 
					eventArgs.Cancel = true;
					Log.Global.LogDebug("Starting graceful shutdown...");
					
					// give the CLI stuff a chance to shutdown gracefully
					var lifecycle = provider.GetService<AppLifecycle>();
					lifecycle.Cancel();

					// and schedule a hard exit in some short amount of time later
					Task.Run(async () =>
					{
						const int GRACEFUL_SHUTDOWN_MILLISECOND_LIMIT = 250;
						await Task.Delay(GRACEFUL_SHUTDOWN_MILLISECOND_LIMIT);
						Log.Global.LogDebug("Done waiting for graceful shutdown...");
						Environment.Exit(0);
					});
				};
			}

			Log.Verbose("command prep (make provider) took " + sw.ElapsedMilliseconds);

			// we can take advantage of a feature of the CLI tool to use their slightly jank DI system to inject our DI system. DI in DI.
			ctx.BindingContext.AddService(_ => new AppServices { duck = provider });
			var appContext = provider.GetRequiredService<IAppContext>();
			await appContext.Apply(ctx.BindingContext);
			
			// update log information before dependency injection is sealed.
			{
				_setLogger(provider);
				var proc = CommandProvider.GetService<ZLoggerBufferedProcessor>();
				proc.isDisabled = true;
				foreach (var log in proc.logs)
				{
					BeamableZLoggerProvider.LogContext.Value.Log(log.LogInfo.LogLevel, log.ToString());
				}

				proc.isDisabled = false;
				foreach (var log in proc.logsGotWhileDisabled)
				{
					BeamableZLoggerProvider.LogContext.Value.LogWarning("The following log was received while the internal logger was switching.");
					BeamableZLoggerProvider.LogContext.Value.Log(log.LogInfo.LogLevel, log.ToString());
				}
			}

			//in case otel is enabled, check if otel data stored in files is too large
			if (Otel.CliTracesEnabled())
			{
				bool quiet = ctx.BindingContext.ParseResult.GetValueForOption(provider.GetRequiredService<QuietOption>());
				
				var configService = provider.GetService<ConfigService>();
				var otelDirectory = configService.ConfigTempOtelDirectoryPath;
		
				// Check if the .beamable folder exists
				string beamableDirectory = Path.Combine(configService.BeamableWorkspace, ".beamable");
				
				bool shouldTryToCreateFolders = Directory.Exists(beamableDirectory);
				
				// If the user didn't have the otel config in the files
				shouldTryToCreateFolders &= !OtelUtils.HasOtelConfig(configService);

				// If it is quiet or autosetup we should create the otel settings as true anyway
				if (shouldTryToCreateFolders)
				{
					// default value
					bool shouldContinue = true;
					
					// If we have the auto setup telemetry env var setup we get the value to accept/reject
					if (Otel.CliAutoSetupTelemetryEnabled())
					{
						shouldContinue = Otel.CliAutoSetupTelemetryAccept();
					}else if (Otel.CliRunningOnDockerContainer()) // If it is running on a docker and wasn't overrided by the Otel.CliAutoSetupTelemetryEnabled() shouldn't use the telemetry
					{
						shouldContinue = false;
					}
					else if(!quiet)// if we don't have the auto setup set we will check if we should auto accept or show the prompt
					{
						shouldContinue = AnsiConsole.Prompt(
							new ConfirmationPrompt($"To help us improve your experience, weâ€™d like to collect usage data using OpenTelemetry.\nThis data includes general usage and error reports\n\nDo you allow us to collect this telemetry data?")
								.ShowChoices());
					}

					OtelUtils.SetAllowOtelConfig(shouldContinue, configService);
				}
				
				bool hasOtelConfig = Directory.Exists(beamableDirectory) && OtelUtils.HasOtelConfig(configService);
				
				// If it is running silent we should create the folder for the user.
				// or If all otel folders wasn't created and otel was allowed
				// we create all the folders for otel
				if (hasOtelConfig && !OtelUtils.HasAllOtelFolders(configService) && OtelUtils.GetAllowOtelConfig(configService))
				{
					OtelUtils.CreateOtelFolders(configService);
				}
				
				// If the it's not allowed to use telemetry we enforce the deletion of the folders
				// The folders existence is basically what defines the usage of telemetry
				if (hasOtelConfig && !OtelUtils.GetAllowOtelConfig(configService))
				{
					OtelUtils.DeleteOtelFolders(configService);
				}
				
				if (Directory.Exists(otelDirectory))
				{
					var dirResult = DirectoryUtils.CalculateDirectorySize(otelDirectory);

					var maxSize = configService.LoadOtelConfigFromFile().BeamCliTelemetryMaxSize;

					if (dirResult.Size >= maxSize)
					{
						Log.Information($"The size of your open telemetry data stored in files has exceeded the limit of 50mb, please consider running [dotnet beam otel push] in order to flush your local data to a remote database," +
						            $" or instead you can run [dotnet beam otel prune] to do cleanup of older data");
						Log.Information($"You currently have {DirectoryUtils.FormatBytes(dirResult.Size)} in used space for the amount of {dirResult.FileCount} files.");
					}
				}
			}
			
			Log.Verbose("command prep (make logs) took " + sw.ElapsedMilliseconds);
			// resolve the root trace, must be done app context is applied with cli bindings 
			_traceProvider = provider.GetService<TracerProvider>();
			_meterProvider = provider.GetService<MeterProvider>();
			
			_activity = provider.GetService<BeamActivity>();
			try
			{

				Log.Verbose("command prep (app context) took " + sw.ElapsedMilliseconds);

				// Check if we need to forward this command --- we only forward if the executing version of the CLI is different than the one locally installed on the project.
				// As long as the versions are the same, running the local one or the global one changes nothing in behaviour.
				var runningVersion = appContext.ExecutingVersion;
				var localVersion = appContext.LocalProjectVersion;
				var isCalledFromInsideBeamableProject = localVersion != null;
				Log.Verbose(
					$"Checking for command redirect. is-local=[{isCalledFromInsideBeamableProject}] running-version=[{runningVersion}] project-version=[{localVersion}]");

				var isMisalignedVersion = runningVersion != localVersion;
				var areVersionsBothLocal = (runningVersion?.StartsWith("0.0.123") ?? false) &&
				                           (localVersion?.StartsWith("0.0.123") ?? false);
				var needsProxy = isMisalignedVersion && !areVersionsBothLocal;
				if (isCalledFromInsideBeamableProject && needsProxy)
				{
					var preventRedirect = ctx.ParseResult.GetValueForOption(provider.GetService<NoForwardingOption>());
					if (!preventRedirect)
					{
						await ProxyCommand(ctx, provider, runningVersion, localVersion);
						return;
					}
				}

				Log.Verbose("command prep (past proxy) took " + sw.ElapsedMilliseconds);


				var skip = ctx.ParseResult.CommandResult.Command is ISkipManifest;
				if (skip)
				{
					Log.Debug(
						$"skipping manifest initialization because command=[{ctx.ParseResult.CommandResult.Command.GetType().Name}] is a {nameof(ISkipManifest)}");
				}
				else
				{
					try
					{
						var beamoSystem = provider.GetService<BeamoLocalSystem>();
						beamoSystem.InitManifest(useManifestCache: true).Wait();
					}
					catch (AggregateException aggregateException)
					{
						foreach (var ex in aggregateException.InnerExceptions)
						{
							Log.Error(ex.GetType().Name + " -- " + ex.Message + "\n" + ex.StackTrace);
						}

						throw;
					}


					{
						// generate the route-map if we need to
						if (!appContext.PreferRemoteFederation)
						{
							var federations = ListFederationsCommand.GetLocalFederations(appContext.Cid, appContext.Pid,
								provider.GetService<BeamoLocalSystem>().BeamoManifest);
							var routeMap = string.Join(",",
								federations.services.Select(s => $"micro_{s.beamoName}:{s.routingKey}"));
							if (provider.CanBuildService<CliRequester>())
							{
								var requester = provider.GetService<CliRequester>();
								Log.Debug($"Setting routing header=[{routeMap}]");
								requester.GlobalHeaders[Beamable.Common.Constants.Requester.HEADER_ROUTINGKEY] =
									routeMap;
							}
						}
					}

				}



				Log.Verbose("command prep took " + sw.ElapsedMilliseconds);
				await next(ctx);
				_activity.SetStatus(ActivityStatusCode.Ok);
				sw.Stop();
				Log.Verbose("command execution took " + sw.ElapsedMilliseconds);
			}
			finally
			{
			
			}
		}, MiddlewareOrder.Configuration);
		commandLineBuilder.UseDefaults();
		commandLineBuilder.UseSuggestDirective();
		commandLineBuilder.UseTypoCorrections();
		commandLineBuilder.UseHelpBuilder(_ => helpBuilder);
		
		commandLineBuilder.UseExceptionHandler((ex, context) =>
		{
			_activity?.SetException(ex);
			switch (ex)
			{
				case RequesterException requesterException:
					Console.Error.WriteLine($"[[{requesterException.Uri}]]request error with response code: {requesterException.Status} and message: {requesterException.RequestError.message}");
					break;
				case CliException cliException:
					if (cliException.ReportOnStdOut)
					{
						// Create a new report
						var report = new Report(
							new BeamResourceRepository(
								typeof(Program).Assembly));
						if (cliException.Reports != null)
						{
							foreach (var error in cliException.Reports)
								report.AddDiagnostic(error);
						}
						else
						{
							// if there are no custom reports for the exception, default to the message.
							report.AddDiagnostic(new Diagnostic(cliException.Message));
						}

						report.Render(AnsiConsole.Console);
						Console.Error.WriteLine(string.Empty);
					}
					else
					{
						Console.Error.WriteLine(cliException.Message);
					}
					Environment.ExitCode = context.ExitCode = cliException.NonZeroOrOneExitCode;
					
					break;
				default:
					Environment.ExitCode = context.ExitCode = 1;
					Console.Error.WriteLine(ex.Message);
					Console.Error.WriteLine(ex.StackTrace);
					break;
			}

			var provider = ServiceProviderServiceExtensions.GetService<AppServices>(context.BindingContext);
			var appContext = ServiceProviderServiceExtensions.GetService<IAppContext>(provider);
			if (appContext.UsePipeOutput || appContext.ShowRawOutput)
			{
				var reporter = ServiceProviderServiceExtensions.GetService<IDataReporterService>(provider);
				reporter.Exception(ex, context.ExitCode, context.BindingContext.ParseResult.Diagram());
			}
			

			if (appContext.ShouldUseLogFile)
			{
				if (!appContext.TryGetTempLogFilePath(out var logFile))
				{
					Log.Warning("Could not write logs because no .beamable project exists to host the log file. Please re-run the command with '--logs v', or, create a .beamable folder using 'beam init' and then re-run the command.");
				}
				else
				{
					Log.Error(ex.ToString());
					Console.Error.WriteLine("\nLogs at\n  " + Path.GetFullPath(logFile));
				}
			}
		});
		
		
		return commandLineBuilder.Build();
	}

	private void ProxyHelp(HelpContext helpContext)
	{
		var dotnetPath = helpContext.ParseResult.GetValueForOption(DotnetPathOption.Instance) ?? "dotnet"; // TODO: use IAppContext to get env var or option based dotnet path
		var argumentsToForward= string.Join(" ", new []{"beam"}.Concat(Environment.GetCommandLineArgs()[1..]));
		
		var stdOut = PipeTarget.ToDelegate(line => helpContext.Output.WriteLine(line));
		var stdErr = PipeTarget.ToStream(Console.OpenStandardError());
		
		var proxy = CliExtensions
				.GetDotnetCommand(dotnetPath, argumentsToForward)
				.WithValidation(CommandResultValidation.None)// it is okay if the sub command fails, hopefully it logs a useful error.
				.WithEnvironmentVariables(new Dictionary<string, string>
				{
					[ConfigService.ENV_VAR_BEAM_CLI_IS_REDIRECTED_COMMAND] = "1"
				})
				.WithStandardOutputPipe(stdOut)
				.WithStandardErrorPipe(stdErr)
			;
		var task = proxy.ExecuteAsync();
		task.Task.Wait();
	}

	private async Task ProxyCommand(InvocationContext context, IDependencyProviderScope provider, PackageVersion executingVersion, PackageVersion projectVersion)
	{
		// get the version of dotnet available (which may not always be the global dotnet installation) 
		var dotnetPath = context.ParseResult.GetValueForOption(provider.GetService<DotnetPathOption>()); // TODO: use IAppContext to get env var or option based dotnet path
		var isPretty = context.ParseResult.GetValueForOption(provider.GetService<ShowPrettyOutput>());
		var appContext = provider.GetService<IAppContext>();
		var shouldRedirect = (appContext.UsePipeOutput || appContext.ShowRawOutput);
			
		var argumentsToForward= string.Join(" ", new []{"beam", "--pretty"}.Concat(Environment.GetCommandLineArgs()[1..]));

		var warningMessage =
			$"You tried using a Beamable CLI version=[{executingVersion}] which is different than the one configured in this project=[{projectVersion}]. We are forwarding the command ({argumentsToForward}) to the version the project is using via dotnet=[{dotnetPath}]. Instead of relying on this forwarding, please 'dotnet beam' from inside the project directory.";
		if (shouldRedirect)
		{
			Console.Error.WriteLine(warningMessage);
		}
		else
		{
			Log.Warning(warningMessage);
		}

		var stdOut = PipeTarget.ToStream(Console.OpenStandardOutput());
		var stdErr = PipeTarget.ToStream(Console.OpenStandardError());
		var proxy = CliExtensions
			.GetDotnetCommand(dotnetPath, argumentsToForward)
			.WithValidation(CommandResultValidation.None)// it is okay if the sub command fails, hopefully it logs a useful error.
			.WithEnvironmentVariables(new Dictionary<string, string>
			{
				[ConfigService.ENV_VAR_BEAM_CLI_IS_REDIRECTED_COMMAND] = "1"
			})
			// TODO: ideally, support somehow std-in commands
			// .WithStandardInputPipe(PipeSource.FromStream(Console.OpenStandardInput()))
			
			;
		if (shouldRedirect) // the sub process _should_ be redirecting, 
		{
			// so take the data, and forward it
			proxy = proxy.WithStandardOutputPipe(stdOut); 

			// and if we are supposed to be showing logs, those appear on stderr
			if (isPretty)
			{
				proxy = proxy.WithStandardErrorPipe(stdErr);
			}
		}
		else
		{
			// data _shouldn't_ sent, but it will be _anyway_. 
			// so we can cheat it back and take the stderr (logs) and show them on stdOut. 
			//   Note: stdout from the proxied process IS the data channel, but we
			//         don't need it, so it is lost.
			proxy = proxy.WithStandardErrorPipe(stdOut);
		}
		
		var forwardedResult = await proxy.ExecuteAsync();
		context.ExitCode = forwardedResult.ExitCode;
	}
	
	static void PrintHelp(InvocationContext context)
	{
		var output = context.Console.Out.CreateTextWriter();
		var helpContext = new HelpContext(context.HelpBuilder,
			context.ParseResult.CommandResult.Command,
			output,
			context.ParseResult);

		context.HelpBuilder.Write(helpContext);
	}

	static void PrintOutputHelp(HelpContext context)
	{
		
		switch (context.Command)
		{
			// case ISingleResult singleResult:
			// 	var resultType = singleResult.ResultType;
			// 	context.Output.WriteLine("");
			// 	context.Output.WriteLine("Raw Output:");
			// 	if (singleResult.IsSingleReturn)
			// 	{
			// 		context.Output.WriteLine($"  Returns a single {resultType.Name} object, which may resemble the following...");
			// 	}
			// 	else
			// 	{
			// 		context.Output.WriteLine($"  Returns a stream of {resultType.Name} objects, which each may resemble the following...");
			// 	}
			//
			// 	var data = new ReportDataPoint { data = singleResult.CreateEmptyInstance(), type = "stream", ts = DateTimeOffset.Now.ToUnixTimeMilliseconds() };
			// 	var json = JsonConvert.SerializeObject(data, Formatting.Indented);
			// 	context.Output.WriteLine("  " + json.ReplaceLineEndings("\n  "));
			// 	break;
			default:
				// we need to explicitly check for interface implementations... 
				var genType = typeof(IResultSteam<,>);
				var commandType = context.Command.GetType();
				var allInterfaces = commandType.GetInterfaces();
				var resultStreamTypeArgs = new List<Type[]>();
				ISingleResult single = null;
				if (context.Command is ISingleResult result)
				{
					single = result;
				}
				
				foreach (var subInterface in allInterfaces)
				{
					if (!subInterface.IsGenericType) continue;
					if (subInterface.GetGenericTypeDefinition() != genType) continue;

					var genArgs = subInterface.GetGenericArguments();
					resultStreamTypeArgs.Add(genArgs);

				}

				if (resultStreamTypeArgs.Count == 0) break;

				// okay, there is an undocumented result stream.

				context.Output.WriteLine("Raw Output:");
				foreach (var resultStream in resultStreamTypeArgs)
				{
					var channelType = resultStream[0];
					var dataType = resultStream[1];

					var channelInstance = (IResultChannel)Activator.CreateInstance(channelType);

					var isSingle = single != null && dataType == single.ResultType;
					object dataInstance = isSingle ? single.CreateEmptyInstance() : Activator.CreateInstance(dataType);

					context.Output.WriteLine($"  Returns a {(isSingle ? "stream of" : "single message of")} {dataType.Name} object on the {channelInstance!.ChannelName} stream, which each may resemble the following...");
					var resultStreamData = new ReportDataPoint { data = dataInstance, type = channelInstance.ChannelName, ts = DateTimeOffset.Now.ToUnixTimeMilliseconds() };
					var resultStreamJson = JsonConvert.SerializeObject(resultStreamData, Formatting.Indented);
					context.Output.WriteLine("  " + resultStreamJson.ReplaceLineEndings("\n  "));
					context.Output.WriteLine("  ");
				}

				break;
		}
	}

	public virtual int Run(string[] args)
	{
		var prog = GetProgram();
		return prog.Invoke(args);
	}

	public virtual Task<int> RunAsync(string[] args)
	{
		var prog = GetProgram();
		return prog.InvokeAsync(args);
	}

	public virtual Task<int> RunWithSingleString(string commandLine, bool useCustomSplitter)
	{
		var sw = new Stopwatch();
		sw.Start();
		var prog = GetProgram();
		sw.Stop();
		Log.Verbose("prepared virtual program instance in " + sw.ElapsedMilliseconds);

		// TODO: Do dotnet beam server serve --no-custom-splitter-that-fixes-ms-dumb-stuff
		if(useCustomSplitter)
		{
			var args = ServerCLIStringSplitter.Instance.Split(commandLine).ToArray();
			Log.Verbose("parsed split args " + string.Join(" ", args));
			return prog.InvokeAsync(args);
		}
		return prog.InvokeAsync(commandLine);
	}
	
	/// <summary>
    /// Splits a string based on whitespace and quotation marks
    /// </summary>
    public class ServerCLIStringSplitter
    {
        /// <summary>
        /// A single instance of <see cref="ServerCLIStringSplitter"/>
        /// </summary>
        public static readonly ServerCLIStringSplitter Instance = new();

        private ServerCLIStringSplitter()
        {
        }

        private enum Boundary
        {
            TokenStart,
            WordEnd,
            QuoteStart,
            QuoteEnd
        }

        /// <summary>
        /// Splits a string into a sequence of strings based on whitespace and quotation marks.
        /// </summary>
        /// <param name="commandLine">A command line input string.</param>
        /// <returns>A sequence of strings.</returns>
        public IEnumerable<string> Split(string commandLine)
        {
            var memory = commandLine.AsMemory();

            var startTokenIndex = 0;

            var pos = 0;

            var seeking = Boundary.TokenStart;
            var seekingQuote = Boundary.QuoteStart;

            while (pos < memory.Length)
            {
                var c = memory.Span[pos];

                if (char.IsWhiteSpace(c))
                {
                    if (seekingQuote == Boundary.QuoteStart)
                    {
                        switch (seeking)
                        {
                            case Boundary.WordEnd:
                                yield return CurrentToken();
                                startTokenIndex = pos;
                                seeking = Boundary.TokenStart;
                                break;

                            case Boundary.TokenStart:
                                startTokenIndex = pos;
                                break;
                        }
                    }
                }
                // If we see an escape marking, skip the following character.
                else if (c == '\\')
                {
	                pos++;
                }
                else if (c == '\"')
                {
                    if (seeking == Boundary.TokenStart)
                    {
                        switch (seekingQuote)
                        {
                            case Boundary.QuoteEnd:
                                yield return CurrentToken();
                                startTokenIndex = pos;
                                seekingQuote = Boundary.QuoteStart;
                                break;

                            case Boundary.QuoteStart:
                                startTokenIndex = pos + 1;
                                seekingQuote = Boundary.QuoteEnd;
                                break;
                        }
                    }
                    else
                    {
                        switch (seekingQuote)
                        {
                            case Boundary.QuoteEnd:
                                seekingQuote = Boundary.QuoteStart;
                                break;

                            case Boundary.QuoteStart:
                                seekingQuote = Boundary.QuoteEnd;
                                break;
                        }
                    }
                }
                else if (seeking == Boundary.TokenStart && seekingQuote == Boundary.QuoteStart)
                {
                    seeking = Boundary.WordEnd;
                    startTokenIndex = pos;
                }

                pos++;

                if (IsAtEndOfInput())
                {
                    switch (seeking)
                    {
                        case Boundary.TokenStart:
                            break;
                        default:
                            yield return CurrentToken();
                            break;
                    }
                }
            }

            string CurrentToken()
            {
                return memory.Slice(startTokenIndex, IndexOfEndOfToken()).ToString();
            }

            int IndexOfEndOfToken() => pos - startTokenIndex;

            bool IsAtEndOfInput() => pos == memory.Length;
        }
    }
}
