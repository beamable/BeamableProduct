using Beamable.Api.Autogenerated;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Auth;
using Beamable.Common.Api.Realms;
using Beamable.Common.Dependencies;
using Beamable.Common.Semantics;
using cli.Commands.Project;
using cli.Content;
using cli.Content.Tag;
using cli.Docs;
using cli.Dotnet;
using cli.Services;
using cli.Services.Content;
using cli.Unreal;
using cli.Version;
using Microsoft.Extensions.DependencyInjection;
using Serilog;
using Serilog.Core;
using Serilog.Events;
using Serilog.Sinks.Spectre;
using Serilog.Sinks.SpectreConsole;
using Spectre.Console;
using System.CommandLine;
using System.CommandLine.Builder;
using System.CommandLine.Invocation;
using System.CommandLine.Parsing;

namespace cli;

public class App
{
	public static LoggingLevelSwitch LogLevel { get; set; }

	public IDependencyBuilder Commands { get; set; }
	public IDependencyProviderScope CommandProvider { get; set; }

	private Action<IDependencyBuilder> _serviceConfigurator;

	public App()
	{
		Commands = new DependencyBuilder();
	}

	public bool IsBuilt => CommandProvider != null;

	private static void ConfigureLogging(Func<LoggerConfiguration, ILogger> configureLogger = null)
	{
		// The LoggingLevelSwitch _could_ be controlled at runtime, if we ever wanted to do that.
		LogLevel = new LoggingLevelSwitch { MinimumLevel = LogEventLevel.Information };

		// https://github.com/serilog/serilog/wiki/Configuration-Basics
		// configureLogger ??= config => config.WriteTo.Console()
		configureLogger ??= config =>
			config.WriteTo.Console(outputTemplate: "{Timestamp:HH:mm:ss} [{Level:u4}] {Message:l}{NewLine}{Exception}")
				.MinimumLevel.ControlledBy(LogLevel)
				.CreateLogger();
		Log.Logger = configureLogger(new LoggerConfiguration());

		BeamableLogProvider.Provider = new CliSerilogProvider();
		CliSerilogProvider.LogContext.Value = Log.Logger;
	}

	/// <summary>
	/// These services are registered AFTER the basic CLI parsing has taken place.
	/// </summary>
	/// <param name="services"></param>
	private void ConfigureServices(IDependencyBuilder services)
	{
		// register services
		services.AddSingleton<IAppContext, DefaultAppContext>();
		services.AddSingleton<IRealmsApi, RealmsService>();
		services.AddSingleton<IAliasService, AliasService>();
		services.AddSingleton<IBeamableRequester>(provider => provider.GetRequiredService<CliRequester>());
		services.AddSingleton<CliRequester, CliRequester>();
		services.AddSingleton<IRequester>(p => p.GetService<CliRequester>());
		services.AddSingleton<IAuthSettings, DefaultAuthSettings>();
		services.AddSingleton<IAuthApi, AuthApi>();
		services.AddSingleton<ConfigService>();
		services.AddSingleton<BeamoService>();
		services.AddSingleton<BeamoLocalSystem>();
		services.AddSingleton<ContentService>();
		services.AddSingleton<CliEnvironment>();
		services.AddSingleton<SwaggerService>();
		services.AddSingleton<ISwaggerStreamDownloader, SwaggerStreamDownloader>();
		services.AddSingleton<UnitySourceGenerator>();
		services.AddSingleton<UnrealSourceGenerator>();
		services.AddSingleton<ProjectService>();
		services.AddSingleton<SwaggerService.SourceGeneratorListProvider>();
		services.AddSingleton<UnityCliGenerator>();
		services.AddSingleton<UnrealCliGenerator>();
		services.AddTransient<DiscoveryService>();
		services.AddSingleton<DocService>();
		services.AddSingleton<CliGenerator>();
		services.AddSingleton<VersionService>();

		OpenApiRegistration.RegisterOpenApis(services);

		_serviceConfigurator?.Invoke(services);
	}

	public virtual void Configure(
		Action<IDependencyBuilder> serviceConfigurator = null,
		Action<IDependencyBuilder> commandConfigurator = null,
		Func<LoggerConfiguration, ILogger> configureLogger = null
		)
	{
		if (IsBuilt)
			throw new InvalidOperationException("The app has already been built, and cannot be configured anymore");

		ConfigureLogging(configureLogger);

		Commands.AddSingleton(new ArgValidator<ServiceName>(arg => new ServiceName(arg)));

		// add global options
		Commands.AddSingleton<DryRunOption>();
		Commands.AddSingleton<SkipStandaloneValidationOption>();
		Commands.AddSingleton<CidOption>();
		Commands.AddSingleton<PidOption>();
		Commands.AddSingleton<ConfigDirOption>();
		Commands.AddSingleton<HostOption>();
		Commands.AddSingleton<LimitOption>();
		Commands.AddSingleton<SkipOption>();
		Commands.AddSingleton<DeployFilePathOption>();
		Commands.AddSingleton<AccessTokenOption>();
		Commands.AddSingleton<RefreshTokenOption>();
		Commands.AddSingleton<LogOption>();
		Commands.AddSingleton<EnableReporterOption>();
		Commands.AddSingleton<DotnetPathOption>();
		Commands.AddSingleton(provider =>
		{
			var root = new RootCommand();
			root.AddGlobalOption(provider.GetRequiredService<DryRunOption>());
			root.AddGlobalOption(provider.GetRequiredService<CidOption>());
			root.AddGlobalOption(provider.GetRequiredService<PidOption>());
			root.AddGlobalOption(provider.GetRequiredService<HostOption>());
			root.AddGlobalOption(provider.GetRequiredService<RefreshTokenOption>());
			root.AddGlobalOption(provider.GetRequiredService<LogOption>());
			root.AddGlobalOption(provider.GetRequiredService<ConfigDirOption>());
			root.AddGlobalOption(provider.GetRequiredService<EnableReporterOption>());
			root.AddGlobalOption(provider.GetRequiredService<SkipStandaloneValidationOption>());
			root.AddGlobalOption(provider.GetRequiredService<DotnetPathOption>());
			root.Description = "A CLI for interacting with the Beamable Cloud.";
			return root;
		});


		// add commands
		Commands.AddRootCommand<CliInterfaceGeneratorCommand, CliInterfaceGeneratorCommandArgs>();

		Commands.AddRootCommand<InitCommand, InitCommandArgs>();
		Commands.AddRootCommand<ProjectCommand, ProjectCommandArgs>();
		Commands.AddCommand<NewSolutionCommand, NewSolutionCommandArgs, ProjectCommand>();
		Commands.AddCommand<RegenerateSolutionFilesCommand, RegenerateSolutionFilesCommandArgs, ProjectCommand>();
		Commands.AddCommand<ListCommand, ListCommandArgs, ProjectCommand>();
		Commands.AddCommand<NewStorageCommand, NewStorageCommandArgs, ProjectCommand>();
		Commands.AddCommand<GenerateEnvFileCommand, GenerateEnvFileCommandArgs, ProjectCommand>();
		Commands.AddCommand<GenerateIgnoreFileCommand, GenerateIgnoreFileCommandArgs, ProjectCommand>();
		Commands.AddCommand<GenerateClientFileCommand, GenerateClientFileCommandArgs, ProjectCommand>();
		Commands.AddCommand<OpenSwaggerCommand, OpenSwaggerCommandArgs, ProjectCommand>();
		Commands.AddCommand<TailLogsCommand, TailLogsCommandArgs, ProjectCommand>();
		Commands.AddCommand<OpenMongoExpressCommand, OpenMongoExpressCommandArgs, ProjectCommand>();
		Commands.AddCommand<AddUnityClientOutputCommand, AddProjectClientOutputCommandArgs, ProjectCommand>();
		Commands.AddCommand<AddUnrealClientOutputCommand, AddProjectClientOutputCommandArgs, ProjectCommand>();
		Commands.AddCommand<UpdateUnityBeamPackageCommand, UpdateUnityBeamPackageCommandArgs, ProjectCommand>();
		Commands.AddCommand<ProjectVersionCommand, ProjectVersionCommandArgs, ProjectCommand>();
		Commands.AddCommand<ShareCodeCommand, ShareCodeCommandArgs, ProjectCommand>();
		Commands.AddCommand<CheckStatusCommand, CheckStatusCommandArgs, ProjectCommand>();
		Commands.AddCommand<AddServiceToSolutionCommand, SolutionCommandArgs, ProjectCommand>();
		Commands.AddRootCommand<AccountMeCommand, AccountMeCommandArgs>();
		Commands.AddRootCommand<BaseRequestGetCommand, BaseRequestArgs>();
		Commands.AddRootCommand<BaseRequestPutCommand, BaseRequestArgs>();
		Commands.AddRootCommand<BaseRequestPostCommand, BaseRequestArgs>();
		Commands.AddRootCommand<BaseRequestDeleteCommand, BaseRequestArgs>();
		Commands.AddRootCommand<GenerateDocsCommand, GenerateDocsCommandArgs>();
		Commands.AddRootCommand<ConfigCommand, ConfigCommandArgs>();
		Commands.AddCommand<ConfigSetCommand, ConfigSetCommandArgs, ConfigCommand>();
		Commands.AddCommand<ConfigGetSecret, ConfigGetSecretArgs, ConfigCommand>();
		Commands.AddRootCommand<LoginCommand, LoginCommandArgs>();
		Commands.AddRootCommand<OpenAPICommand, OpenAPICommandArgs>();
		Commands.AddCommand<GenerateSdkCommand, GenerateSdkCommandArgs, OpenAPICommand>();
		Commands.AddCommand<DownloadOpenAPICommand, DownloadOpenAPICommandArgs, OpenAPICommand>();

		Commands.AddRootCommand<ProfilingCommand, ProfilingCommandArgs>();
		Commands.AddCommand<CheckCountersCommand, CheckCountersCommandArgs, ProfilingCommand>();
		Commands.AddCommand<CheckNBomberCommand, CheckNBomberCommandArgs, ProfilingCommand>();
		Commands.AddCommand<RunNBomberCommand, RunNBomberCommandArgs, ProfilingCommand>();

		// version commands
		Commands.AddRootCommand<VersionCommand, VersionCommandArgs>();
		Commands.AddCommand<VersionListCommand, VersionListCommandArgs, VersionCommand>();
		Commands.AddCommand<VersionInstallCommand, VersionInstallCommandArgs, VersionCommand>();

		// org commands
		Commands.AddRootCommand<OrganizationCommand, OrganizationCommandArgs>();
		Commands.AddCommand<RegisterCommand, RegisterCommandArgs, OrganizationCommand>();

		// beamo commands
		Commands.AddRootCommand<ServicesCommand, ServicesCommandArgs>();
		Commands.AddCommand<ServicesManifestsCommand, ServicesManifestsArgs, ServicesCommand>();
		Commands.AddCommand<ServicesListCommand, ServicesListCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesRegisterCommand, ServicesRegisterCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesModifyCommand, ServicesModifyCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesEnableCommand, ServicesEnableCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesDeployCommand, ServicesDeployCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesRunCommand, ServicesRunCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesResetCommand, ServicesResetCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesStopCommand, ServicesStopCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesTemplatesCommand, ServicesTemplatesCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesRegistryCommand, ServicesRegistryCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesUploadApiCommand, ServicesUploadApiCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesLogsUrlCommand, ServicesLogsUrlCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesMetricsUrlCommand, ServicesMetricsUrlCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesPromoteCommand, ServicesPromoteCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesGetConnectionStringCommand, ServicesGetConnectionStringCommandArgs, ServicesCommand>();
		Commands.AddCommand<ServicesSetManifestCommand, ServicesSetManifestCommandArgs, ServicesCommand>();


		// content commands
		Commands.AddRootCommand<ContentCommand, ContentCommandArgs>();
		Commands.AddCommand<ContentPullCommand, ContentPullCommandArgs, ContentCommand>();
		Commands.AddCommand<ContentStatusCommand, ContentStatusCommandArgs, ContentCommand>();
		Commands.AddCommand<ContentOpenCommand, ContentOpenCommandArgs, ContentCommand>();
		Commands.AddCommand<ContentPublishCommand, ContentPublishCommandArgs, ContentCommand>();
		Commands.AddCommand<ContentResetCommand, ContentResetCommandArgs, ContentCommand>();

		Commands.AddCommand<ContentTagCommand, ContentTagCommandArgs, ContentCommand>();
		Commands.AddCommand<ContentTagAddCommand, ContentTagAddCommandArgs, ContentTagCommand>();
		Commands.AddCommand<ContentTagRemoveCommand, ContentTagAddCommandArgs, ContentTagCommand>();

		commandConfigurator?.Invoke(Commands);

		// customize
		_serviceConfigurator = serviceConfigurator;
	}

	public virtual void Build()
	{
		if (IsBuilt)
			throw new InvalidOperationException("The app has already been built, and cannot be built again");

		CommandProvider = Commands.Build();

		// automatically create all commands
		var commandFactoryServices = CommandProvider.SingletonServices.Where(t =>
			t.Interface.IsGenericType && t.Interface.GetGenericTypeDefinition() == typeof(ICommandFactory<>)).ToList();
		foreach (var factory in commandFactoryServices)
		{
			CommandProvider.GetService(factory.Interface);
		}
	}


	protected virtual Parser GetProgram()
	{
		var root = CommandProvider.GetRequiredService<RootCommand>();

		var commandLineBuilder = new CommandLineBuilder(root);
		commandLineBuilder.AddMiddleware(consoleContext =>
		{
			// create a scope for the execution of the command
			var provider = CommandProvider.Fork(services =>
			{
				// add in the services that need to rely on the CLI parsing having completed
				services.AddSingleton(consoleContext);
				services.AddSingleton(consoleContext.BindingContext);
				ConfigureServices(services);
			});
			// we can take advantage of a feature of the CLI tool to use their slightly jank DI system to inject our DI system. DI in DI.
			consoleContext.BindingContext.AddService(_ => new AppServices { duck = provider });

			var appContext = provider.GetRequiredService<IAppContext>();
			appContext.Apply(consoleContext.BindingContext);
		}, MiddlewareOrder.Configuration);
		commandLineBuilder.UseDefaults();
		commandLineBuilder.UseSuggestDirective();
		commandLineBuilder.UseTypoCorrections();
		commandLineBuilder.UseExceptionHandler((ex, context) =>
		{
			switch (ex)
			{
				case RequesterException requesterException:
					Console.WriteLine($"[[{requesterException.Uri}]]request error with response code: {requesterException.Status} and message: {requesterException.RequestError.message}");
					break;
				case CliException cliException:
					if (cliException.ReportOnStdOut)
					{
						Console.WriteLine(cliException.Message);
					}
					else
					{
						Console.Error.WriteLine(cliException.Message);
					}
					context.ExitCode = cliException.NonZeroOrOneExitCode;
					break;
				default:
					context.ExitCode = 1;
					Console.Error.WriteLine(ex.Message);
					Console.Error.WriteLine(ex.StackTrace);
					break;
			}
		});
		return commandLineBuilder.Build();
	}

	public virtual int Run(string[] args)
	{
		var prog = GetProgram();
		return prog.Invoke(args);
	}

	public virtual Task<int> RunAsync(string[] args)
	{
		var prog = GetProgram();
		return prog.InvokeAsync(args);
	}
}
