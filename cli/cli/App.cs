using Beamable.Api.Autogenerated;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Auth;
using Beamable.Common.Api.Realms;
using Beamable.Common.BeamCli;
using Beamable.Common.Dependencies;
using Beamable.Common.Semantics;
using cli.CliServerCommand;
using cli.Commands.Project;
using cli.Commands.Project.Deps;
using cli.Content;
using cli.Content.Tag;
using cli.Docs;
using cli.Dotnet;
using cli.Notifications;
using cli.Options;
using cli.Services;
using cli.Services.Content;
using cli.Services.HttpServer;
using cli.UnityCommands;
using cli.Unreal;
using cli.UnrealCommands;
using cli.Utils;
using cli.Version;
using CliWrap;
using CommandLine.Text;
using Errata;
using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis.Sarif;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Serilog;
using Serilog.Core;
using Serilog.Enrichers.Sensitive;
using Serilog.Events;
using Spectre.Console;
using Spectre.Console.Rendering;
using System.CommandLine;
using System.CommandLine.Builder;
using System.CommandLine.Help;
using System.CommandLine.Invocation;
using System.CommandLine.IO;
using System.CommandLine.Parsing;
using System.Reflection;
using Command = System.CommandLine.Command;

namespace cli;

public class App
{
	public LoggingLevelSwitch LogLevel { get; set; }

	public IDependencyBuilder Commands { get; set; }
	public IDependencyProviderScope CommandProvider { get; set; }

	private Action<IDependencyBuilder> _serviceConfigurator;

	public App()
	{
		//This is necessary, so we can use MSBuild to read different projects and get their properties later on
		if (MSBuildLocator.CanRegister)
		{
			string path = Environment.GetEnvironmentVariable(Beamable.Common.Constants.EnvironmentVariables.BEAM_DOTNET_MSBUILD_PATH, EnvironmentVariableTarget.Process);
			if (!string.IsNullOrEmpty(path))
			{
				MSBuildLocator.RegisterMSBuildPath(path);
			}
			else
			{
				MSBuildLocator.RegisterDefaults();
			}

		}

		Commands = new DependencyBuilder();
	}

	public bool IsBuilt => CommandProvider != null;

	private static void ConfigureLogging(App app, IDependencyProvider provider, Func<LoggerConfiguration, ILogger> configureLogger = null)
	{
		var appCtx = provider.GetService<IAppContext>();
		try
		{
			if (appCtx.ShouldUseLogFile)
			{
				File.Delete(appCtx.TempLogFilePath);
			}
		}
		catch
		{
			// if we cannot delete the temp file, then the worst outcome is that we are appending new data to it.
		}

		// https://github.com/serilog/serilog/wiki/Configuration-Basics
		configureLogger ??= config =>
		{

			var baseConfig = config.MinimumLevel.Verbose();
			if (appCtx.ShouldMaskLogs)
			{
				baseConfig = baseConfig.Enrich.WithSensitiveDataMasking(options =>
				{
					options.MaskingOperators.Clear();
					options.MaskingOperators.Add(new TokenMasker());
					options.MaskValue = "***";
				});
			}

			baseConfig = baseConfig.WriteTo.Logger(subConfig =>
				subConfig
					.WriteTo.BeamAnsi("{Message:lj}{NewLine}{Exception}")
					.MinimumLevel.ControlledBy(app.LogLevel)
			);
			if (appCtx.ShouldUseLogFile)
			{
				baseConfig.WriteTo.File(appCtx.TempLogFilePath, LogEventLevel.Verbose);
			}

			return baseConfig.CreateLogger();
		};



		Log.Logger = configureLogger(new LoggerConfiguration());

		BeamableLogProvider.Provider = new CliSerilogProvider();
		CliSerilogProvider.LogContext.Value = Log.Logger;
	}

	/// <summary>
	/// These services are registered AFTER the basic CLI parsing has taken place.
	/// </summary>
	/// <param name="services"></param>
	private void ConfigureServices(IDependencyBuilder services)
	{
		// register services
		services.AddSingleton<LoggingLevelSwitch>(LogLevel);
		services.AddSingleton<IAppContext, DefaultAppContext>();
		services.AddSingleton<IRealmsApi, RealmsService>();
		services.AddSingleton<IAliasService, AliasService>();
		services.AddSingleton<IBeamableRequester>(provider => provider.GetRequiredService<CliRequester>());
		services.AddSingleton<CliRequester, CliRequester>();
		services.AddSingleton<IRequester>(p => p.GetService<CliRequester>());
		services.AddSingleton<IAuthSettings, DefaultAuthSettings>();
		services.AddSingleton<IAuthApi, AuthApi>();
		services.AddSingleton<ConfigService>();
		services.AddSingleton<BeamoService>();
		services.AddSingleton<BeamoLocalSystem>();
		services.AddSingleton<ContentService>();
		services.AddSingleton<CliEnvironment>();
		services.AddSingleton<SwaggerService>();
		services.AddSingleton<ISwaggerStreamDownloader, SwaggerStreamDownloader>();
		services.AddSingleton<UnitySourceGenerator>();
		services.AddSingleton<UnrealSourceGenerator>();
		services.AddSingleton<ProjectService>();
		services.AddSingleton<SwaggerService.SourceGeneratorListProvider>();
		services.AddSingleton<UnityCliGenerator>();
		services.AddSingleton<UnrealCliGenerator>();
		services.AddTransient<DiscoveryService>();
		services.AddSingleton<DocService>();
		services.AddSingleton<CliGenerator>();
		services.AddSingleton<VersionService>();
		services.AddSingleton<IDataReporterService, DataReporterService>();
		services.AddSingleton<ServerService>();
		services.AddSingleton<AppLifecycle>();

		OpenApiRegistration.RegisterOpenApis(services);

		_serviceConfigurator?.Invoke(services);
	}

	private Action<IDependencyProvider> setLogger = _ =>
	{
		// no-op
	};

	public virtual void Configure(
		Action<IDependencyBuilder> serviceConfigurator = null,
		Action<IDependencyBuilder> commandConfigurator = null,
		Func<LoggerConfiguration, ILogger> configureLogger = null,
		bool overwriteLogger = true
		)
	{
		if (IsBuilt)
			throw new InvalidOperationException("The app has already been built, and cannot be configured anymore");

		// The LoggingLevelSwitch _could_ be controlled at runtime, if we ever wanted to do that.
		LogLevel = new LoggingLevelSwitch { MinimumLevel = LogEventLevel.Information };

		if (overwriteLogger)
		{
			setLogger = (provider) =>
			{
				ConfigureLogging(this, provider, configureLogger);
			};
		}

		Commands.AddSingleton(new ArgValidator<ServiceName>(arg => new ServiceName(arg)));
		Commands.AddSingleton(new ArgValidator<PackageVersion>(arg =>
		{
			if (arg == null) return "0.0.0";
			try
			{
				return PackageVersion.FromSemanticVersionString(arg);
			}
			catch (Exception ex)
			{
				throw new Exception($"Failed to parse version. Invalid=[{arg}] Message=[{ex.Message}]");
			}
		}));

		// add global options
		Commands.AddSingleton<DryRunOption>();
		Commands.AddSingleton<SkipStandaloneValidationOption>();
		Commands.AddSingleton<CidOption>();
		Commands.AddSingleton<QuietOption>();
		Commands.AddSingleton<PidOption>();
		Commands.AddSingleton<ConfigDirOption>();
		Commands.AddSingleton<HostOption>();
		Commands.AddSingleton<LimitOption>();
		Commands.AddSingleton<SkipOption>();
		Commands.AddSingleton<DeployFilePathOption>();
		Commands.AddSingleton<AccessTokenOption>();
		Commands.AddSingleton<RefreshTokenOption>();
		Commands.AddSingleton<LogOption>();
		Commands.AddSingleton<ShowRawOutput>();
		Commands.AddSingleton<ShowPrettyOutput>();
		Commands.AddSingleton<DotnetPathOption>();
		Commands.AddSingleton(AllHelpOption.Instance);
		Commands.AddSingleton(NoLogFileOption.Instance);
		Commands.AddSingleton(UnmaskLogsOption.Instance);
		Commands.AddSingleton(DockerPathOption.Instance);
		Commands.AddSingleton(provider =>
		{
			var root = new RootCommand();
			root.AddGlobalOption(provider.GetRequiredService<DryRunOption>());
			root.AddGlobalOption(provider.GetRequiredService<CidOption>());
			root.AddGlobalOption(provider.GetRequiredService<PidOption>());
			root.AddGlobalOption(provider.GetRequiredService<QuietOption>());
			root.AddGlobalOption(provider.GetRequiredService<HostOption>());
			root.AddGlobalOption(provider.GetRequiredService<RefreshTokenOption>());
			root.AddGlobalOption(provider.GetRequiredService<LogOption>());
			root.AddGlobalOption(AllHelpOption.Instance); ;
			root.AddGlobalOption(UnmaskLogsOption.Instance);
			root.AddGlobalOption(NoLogFileOption.Instance);
			root.AddGlobalOption(DockerPathOption.Instance);
			root.AddGlobalOption(provider.GetRequiredService<ConfigDirOption>());
			root.AddGlobalOption(provider.GetRequiredService<ShowRawOutput>());
			root.AddGlobalOption(provider.GetRequiredService<ShowPrettyOutput>());
			root.AddGlobalOption(provider.GetRequiredService<SkipStandaloneValidationOption>());
			root.AddGlobalOption(provider.GetRequiredService<DotnetPathOption>());
			root.Description = "A CLI for interacting with the Beamable Cloud.";
			return root;
		});


		// add commands
		Commands.AddRootCommand<CliInterfaceGeneratorCommand, CliInterfaceGeneratorCommandArgs>();
		Commands.AddRootCommand<ServerGroupCommand>();
		Commands.AddSubCommand<ServeCliCommand, ServeCliCommandArgs, ServerGroupCommand>();
		Commands.AddSubCommand<RequestCliCommand, RequestCliCommandArgs, ServerGroupCommand>();
		Commands.AddRootCommand<InitCommand, InitCommandArgs>();
		Commands.AddRootCommand<ProjectCommand>();
		Commands.AddSubCommand<ProjectNewCommand, CommandGroupArgs, ProjectCommand>();
		Commands.AddSubCommand<GenerateOApiCommand, GenerateOApiCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<RunProjectCommand, RunProjectCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<StopProjectCommand, StopProjectCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<BuildProjectCommand, BuildProjectCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<NewMicroserviceCommand, NewMicroserviceArgs, ProjectNewCommand>();
		Commands.AddSubCommand<NewCommonLibraryCommand, CreateCommonLibraryArgs, ProjectNewCommand>();
		Commands.AddSubCommand<ProjectDependencies, ProjectDependenciesArgs, ProjectCommand>();
		Commands.AddSubCommand<SetEnabledCommand, SetEnabledCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<SetDisableCommand, SetEnabledCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<RegenerateSolutionFilesCommand, RegenerateSolutionFilesCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<ListCommand, ListCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<NewStorageCommand, NewStorageCommandArgs, ProjectNewCommand>();
		Commands.AddSubCommand<GenerateEnvFileCommand, GenerateEnvFileCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<GenerateIgnoreFileCommand, GenerateIgnoreFileCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<GenerateClientFileCommand, GenerateClientFileCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<GeneratePropertiesFileCommand, GeneratePropertiesFileCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<OpenSwaggerCommand, OpenSwaggerCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<TailLogsCommand, TailLogsCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<OpenMongoExpressCommand, OpenMongoExpressCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<AddUnityClientOutputCommand, AddProjectClientOutputCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<AddUnrealClientOutputCommand, UnrealAddProjectClientOutputCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<UpdateUnityBeamPackageCommand, UpdateUnityBeamPackageCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<ProjectVersionCommand, ProjectVersionCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<ShareCodeCommand, ShareCodeCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<CheckStatusCommand, CheckStatusCommandArgs, ProjectCommand>();
		Commands.AddSubCommand<ShowRemoteManifestCommand, ShowRemoteManifestCommandArgs, ProjectCommand>();
		Commands.AddRootCommand<AccountMeCommand, AccountMeCommandArgs>();
		Commands.AddRootCommand<BaseRequestGetCommand, BaseRequestArgs>();
		Commands.AddRootCommand<BaseRequestPutCommand, BaseRequestArgs>();
		Commands.AddRootCommand<BaseRequestPostCommand, BaseRequestArgs>();
		Commands.AddRootCommand<BaseRequestDeleteCommand, BaseRequestArgs>();
		Commands.AddRootCommand<GenerateDocsCommand, GenerateDocsCommandArgs>();
		Commands.AddRootCommand<ConfigCommand, ConfigCommandArgs>();
		Commands.AddSubCommandWithHandler<ConfigSetCommand, ConfigSetCommandArgs, ConfigCommand>();
		Commands.AddSubCommandWithHandler<ConfigGetSecret, ConfigGetSecretArgs, ConfigCommand>();
		Commands.AddSubCommandWithHandler<RealmConfigCommand, RealmConfigCommandArgs, ConfigCommand>();
		Commands.AddSubCommandWithHandler<RealmConfigSetCommand, RealmConfigSetCommandArgs, RealmConfigCommand>();
		Commands.AddSubCommandWithHandler<RealmConfigRemoveCommand, RealmConfigRemoveCommandArgs, RealmConfigCommand>();
		Commands.AddRootCommand<LoginCommand, LoginCommandArgs>();
		Commands.AddRootCommand<OpenAPICommand>();
		Commands.AddSubCommand<GenerateSdkCommand, GenerateSdkCommandArgs, OpenAPICommand>();
		Commands.AddSubCommand<DownloadOpenAPICommand, DownloadOpenAPICommandArgs, OpenAPICommand>();
		Commands.AddSubCommandWithHandler<DepsCommand, DepsCommandArgs, ProjectCommand>();
		Commands.AddSubCommandWithHandler<ListDepsCommand, ListDepsCommandArgs, DepsCommand>();
		Commands.AddSubCommandWithHandler<AddDepsCommand, AddDepsCommandArgs, DepsCommand>();
		Commands.AddSubCommandWithHandler<RemoveDepsCommand, RemoveDepsCommandArgs, DepsCommand>();

		Commands.AddRootCommand<NotificationBaseCommand>();
		Commands.AddSubCommand<NotificationServerCommand, NotificationServerCommandArgs, NotificationBaseCommand>();
		Commands.AddSubCommand<NotificationPlayerCommand, NotificationPlayerCommandArgs, NotificationBaseCommand>();

		Commands.AddRootCommand<ProfilingCommand>();
		Commands.AddSubCommand<CheckCountersCommand, CheckCountersCommandArgs, ProfilingCommand>();
		Commands.AddSubCommand<CheckNBomberCommand, CheckNBomberCommandArgs, ProfilingCommand>();
		Commands.AddSubCommand<RunNBomberCommand, RunNBomberCommandArgs, ProfilingCommand>();

		// unity commands
		Commands.AddRootCommand<UnityGroupCommand>();
		Commands.AddSubCommand<CopyProjectSrcToUnityCommand, CopyProjectSrcToUnityCommandArgs, UnityGroupCommand>();
		Commands.AddSubCommand<GetUnityVersionInfoCommand, GetUnityVersionInfoCommandArgs, UnityGroupCommand>();
		Commands.AddSubCommand<ReleaseSharedUnityCodeCommand, ReleaseSharedUnityCodeCommandArgs, UnityGroupCommand>();
		Commands.AddSubCommand<DownloadNugetDepToUnityCommand, DownloadNugetDepToUnityCommandArgs, UnityGroupCommand>();
		Commands.AddSubCommand<DownloadAllNugetDepsToUnityCommand, DownloadAllNugetDepsToUnityCommandArgs,
				UnityGroupCommand>();
		Commands.AddSubCommand<UpdateServiceAssemblyReferencesCommand, UpdateServiceAssemblyReferencesCommandArgs,
			UnityGroupCommand>();

		// unreal commands
		Commands.AddRootCommand<UnrealGroupCommand>();
		Commands.AddSubCommand<InitUnrealSDKCommand, InitUnrealSDKCommandArgs, UnrealGroupCommand>();

		// version commands
		Commands.AddRootCommand<VersionCommand, VersionCommandArgs>();
		Commands.AddSubCommandWithHandler<VersionListCommand, VersionListCommandArgs, VersionCommand>();
		Commands.AddSubCommandWithHandler<VersionInstallCommand, VersionInstallCommandArgs, VersionCommand>();
		Commands.AddSubCommandWithHandler<ConstructVersionCommand, ConstructVersionCommandArgs, VersionCommand>();
		// org commands
		Commands.AddRootCommand<OrganizationCommand>();
		Commands.AddSubCommand<RegisterCommand, RegisterCommandArgs, OrganizationCommand>();

		// beamo commands
		Commands.AddRootCommand<ServicesCommand>();
		Commands.AddSubCommand<ServicesManifestsCommand, ServicesManifestsArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesListCommand, ServicesListCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesDeployCommand, ServicesDeployCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesRunCommand, ServicesRunCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesResetCommand, CommandGroupArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesResetImageCommand, ServicesResetImageCommandArgs, ServicesResetCommand>();
		Commands.AddSubCommand<ServicesResetContainerCommand, ServicesResetContainerCommandArgs, ServicesResetCommand>();
		Commands.AddSubCommand<ServicesStopCommand, ServicesStopCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesTemplatesCommand, ServicesTemplatesCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesRegistryCommand, ServicesRegistryCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesUploadApiCommand, ServicesUploadApiCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesLogsUrlCommand, ServicesLogsUrlCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesMetricsUrlCommand, ServicesMetricsUrlCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesPromoteCommand, ServicesPromoteCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesGetConnectionStringCommand, ServicesGetConnectionStringCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesGenerateLocalManifestCommand, ServicesGenerateLocalManifestCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesGenerateTarballCommand, ServicesGenerateTarballCommandArgs, ServicesCommand>();
		Commands.AddSubCommand<ServicesBuildCommand, ServicesBuildCommandArgs, ServicesCommand>();
		// content commands

		Commands.AddRootCommand<ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentPullCommand, ContentPullCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentStatusCommand, ContentStatusCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentOpenCommand, ContentOpenCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentBulkEditCommand, ContentBulkEditCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentPublishCommand, ContentPublishCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentLocalManifestCommand, ContentLocalManifestCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentResetCommand, ContentResetCommandArgs, ContentCommand>();

		Commands.AddSubCommandWithHandler<ContentTagCommand, ContentTagCommandArgs, ContentCommand>();
		Commands.AddSubCommandWithHandler<ContentTagAddCommand, ContentTagAddCommandArgs, ContentTagCommand>();
		Commands.AddSubCommandWithHandler<ContentTagRemoveCommand, ContentTagAddCommandArgs, ContentTagCommand>();

		commandConfigurator?.Invoke(Commands);

		// customize
		_serviceConfigurator = serviceConfigurator;
	}

	public List<Command> InstantiateAllCommands()
	{
		// automatically create all commands
		var commandList = new List<Command>();
		var commandFactoryServices = CommandProvider.SingletonServices.Where(t =>
			t.Interface.IsGenericType && t.Interface.GetGenericTypeDefinition() == typeof(ICommandFactory<>)).ToList();
		foreach (var factoryDescriptor in commandFactoryServices)
		{
			CommandProvider.GetService(factoryDescriptor.Interface);
			var commandType = factoryDescriptor.Interface.GetGenericArguments()[0];
			var command = (Command)CommandProvider.GetService(commandType);

			commandList.Add(command);
		}

		return commandList;
	}

	public virtual void Build()
	{
		if (IsBuilt)
			throw new InvalidOperationException("The app has already been built, and cannot be built again");

		CommandProvider = Commands.Build();

		var _ = InstantiateAllCommands();

		// sort the commands
		var root = CommandProvider.GetService<RootCommand>();
		SortCommands(root);
	}

	void SortCommands(Command root)
	{
		var subCommandField = typeof(Command).GetField("_subcommands", BindingFlags.Instance | BindingFlags.NonPublic);
		if (subCommandField == null) return;
		var subCommands = (List<Command>)subCommandField.GetValue(root);
		if (subCommands == null) return;
		subCommands.Sort((a, b) =>
		{
			if (a is not IAppCommand aCommand)
			{
				return 0;
			}

			if (b is not IAppCommand bCommand)
			{
				return 0;
			}

			// all internal commands go at the end
			if (aCommand.IsForInternalUse != bCommand.IsForInternalUse)
			{
				return bCommand.IsForInternalUse ? -1 : 1;
			}

			// and all commands are sorted by their order
			if (bCommand.Order != aCommand.Order)
			{
				return bCommand.Order.CompareTo(aCommand.Order);
			}

			// or alphabet order
			return String.Compare(a.Name, b.Name, StringComparison.Ordinal);

		});

		foreach (var subCommand in subCommands)
		{
			SortCommands(subCommand);
		}
	}

	public static IEnumerable<HelpSectionDelegate> GetHelpLayout()
	{
		yield return HelpBuilder.Default.SynopsisSection();
		yield return HelpBuilder.Default.CommandUsageSection();
		yield return HelpBuilder.Default.CommandArgumentsSection();
		yield return HelpBuilder.Default.OptionsSection();
		// Instead of using HelpBuilder.Default.SubcommandsSection();
		//  we inject our own subCommandSection.
		yield return (ctx) => new BeamHelpBuilder(ctx).WriteSubcommands(ctx);
		yield return HelpBuilder.Default.AdditionalArgumentsSection();
	}

	protected virtual Parser GetProgram()
	{
		var root = CommandProvider.GetRequiredService<RootCommand>();

		var helpBuilder = new HelpBuilder(LocalizationResources.Instance, 100);

		helpBuilder.CustomizeLayout(c =>
		{
			var defaultLayout = GetHelpLayout().ToList();

			defaultLayout.Add(PrintOutputHelp);

			defaultLayout.Insert(0, (ctx) =>
			{
				if (ctx.Command is not IAppCommand appCommand)
				{
					return;
				}

				if (appCommand.IsForInternalUse)
				{
					ctx.Output.WriteLine("Internal Use Warning!!!");
					ctx.Output.WriteLine("  This command was designed to be used as an internal command for the Beamable team. ");
					ctx.Output.WriteLine("  You may use the command, but please understand the command was not specifically ");
					ctx.Output.WriteLine("  designed to be used outside of the Beamable team. The command structure may change ");
					ctx.Output.WriteLine("  in the future. Happy spelunking!");
				}

			});

			return defaultLayout;
		});

		var commandLineBuilder = new CommandLineBuilder(root);

		// this middleware pre-handles the --all-help option.
		commandLineBuilder.AddMiddleware((ctx, next) =>
		{
			var isAllHelp = ctx.ParseResult.GetValueForOption(AllHelpOption.Instance);
			if (isAllHelp)
			{
				PrintHelp(ctx);
				return Task.CompletedTask;
			}
			return next(ctx);
		}, MiddlewareOrder.Configuration);

		// this middleware is responsible for catching parse errors and putting them on the data-out raw channel
		commandLineBuilder.AddMiddleware((ctx, next) =>
		{
			if (ctx.ParseResult.Errors.Count == 0)
			{
				// no parse errors, so this middleware has nothing to do.
				return next(ctx);
			}

			var provider = ctx.BindingContext.GetService<AppServices>();
			var appContext = provider.GetService<IAppContext>();
			var reporter = provider.GetService<IDataReporterService>();
			var isPiping = appContext.UsePipeOutput || appContext.ShowRawOutput;

			if (!isPiping)
			{
				// we aren't using raw output, so this middleware has nothing to do.
				return next(ctx);
			}

			var ex = new Exception(string.Join(",", ctx.ParseResult.Errors));
			ctx.ExitCode = 1;
			reporter.Exception(ex, ctx.ExitCode, ctx.BindingContext.ParseResult.Diagram());
			// don't call the next task, because we have "handled" the error by posting it to the error channel
			return Task.CompletedTask;

		}, MiddlewareOrder.ErrorReporting);


		commandLineBuilder.AddMiddleware(async (ctx, next) =>
		{
			// create a scope for the execution of the command
			var provider = CommandProvider.Fork(services =>
			{
				// add in the services that need to rely on the CLI parsing having completed
				services.AddSingleton(ctx);
				services.AddSingleton(ctx.BindingContext);
				services.AddSingleton(helpBuilder);
				ConfigureServices(services);
			});

			// update log information before dependency injection is sealed.
			setLogger(provider);

			// we can take advantage of a feature of the CLI tool to use their slightly jank DI system to inject our DI system. DI in DI.
			ctx.BindingContext.AddService(_ => new AppServices { duck = provider });
			var appContext = provider.GetRequiredService<IAppContext>();
			appContext.Apply(ctx.BindingContext);

			// Check if we need to forward this command --- we only forward if the executing version of the CLI is different than the one locally installed on the project.
			// As long as the versions are the same, running the local one or the global one changes nothing in behaviour.
			var runningVersion = VersionService.GetNugetPackagesForExecutingCliVersion().ToString();
			var isCalledFromInsideBeamableProject = provider.GetService<ConfigService>().TryGetProjectBeamableCLIVersion(out var projectLocalVersion);
			if (isCalledFromInsideBeamableProject && runningVersion != projectLocalVersion)
			{
				// Get the args that were given to this command invocation
				var argumentsToForward = string.Join(" ", new[] { "beam" }.Concat(Environment.GetCommandLineArgs()[1..]));
				Log.Warning("You tried used a Beamable CLI version different than the one configured in this project. We are forwarding the command ({cmd}) to the version the project is using. Instead of relying on this forwarding, please 'dotnet beam' from inside the project directory.",
					argumentsToForward);
				var forwardedCommand = Cli.Wrap("dotnet");
				var forwardedResult = await forwardedCommand
					.WithArguments(argumentsToForward)
					.ExecuteAsyncAndLog();

				ctx.ExitCode = forwardedResult.ExitCode;
				return;
			}

			try
			{
				var beamoSystem = provider.GetService<BeamoLocalSystem>();
				beamoSystem.InitManifest().Wait();
			}
			catch (AggregateException aggregateException)
			{
				foreach (var ex in aggregateException.InnerExceptions)
				{
					Log.Error(ex.GetType().Name + " -- " + ex.Message + "\n" + ex.StackTrace);
				}
				throw;
			}

			await next(ctx);

		}, MiddlewareOrder.Configuration);
		commandLineBuilder.UseDefaults();
		commandLineBuilder.UseSuggestDirective();
		commandLineBuilder.UseTypoCorrections();
		commandLineBuilder.UseHelpBuilder(context => helpBuilder);
		commandLineBuilder.UseExceptionHandler((ex, context) =>
		{
			switch (ex)
			{
				case RequesterException requesterException:
					Console.Error.WriteLine($"[[{requesterException.Uri}]]request error with response code: {requesterException.Status} and message: {requesterException.RequestError.message}");
					break;
				case CliException cliException:
					if (cliException.ReportOnStdOut)
					{
						// Create a new report
						var report = new Report(
							new BeamResourceRepository(
								typeof(Program).Assembly));
						if (cliException.Reports != null)
						{
							foreach (var error in cliException.Reports)
								report.AddDiagnostic(error);
						}
						else
						{
							// if there are no custom reports for the exception, default to the message.
							report.AddDiagnostic(new Diagnostic(cliException.Message));
						}

						report.Render(AnsiConsole.Console);
						Console.Error.WriteLine(string.Empty);
					}
					else
					{
						Console.Error.WriteLine(cliException.Message);
					}
					context.ExitCode = cliException.NonZeroOrOneExitCode;
					break;
				default:
					context.ExitCode = 1;
					Console.Error.WriteLine(ex.Message);
					Console.Error.WriteLine(ex.StackTrace);
					break;
			}

			var provider = context.BindingContext.GetService<AppServices>();
			var appContext = provider.GetService<IAppContext>();
			if (appContext.UsePipeOutput || appContext.ShowRawOutput)
			{
				var reporter = provider.GetService<IDataReporterService>();

				reporter.Exception(ex, context.ExitCode, context.BindingContext.ParseResult.Diagram());
			}

			if (appContext.ShouldUseLogFile)
			{
				Log.CloseAndFlush();
				File.AppendAllText(appContext.TempLogFilePath, ex.ToString());
				Console.Error.WriteLine("\nLogs at\n  " + appContext.TempLogFilePath);
			}
		});
		return commandLineBuilder.Build();
	}

	static void PrintHelp(InvocationContext context)
	{
		var output = context.Console.Out.CreateTextWriter();
		var helpContext = new HelpContext(context.HelpBuilder,
			context.ParseResult.CommandResult.Command,
			output,
			context.ParseResult);

		context.HelpBuilder.Write(helpContext);
	}

	static void PrintOutputHelp(HelpContext context)
	{
		switch (context.Command)
		{
			case ISingleResult singleResult:
				var resultType = singleResult.ResultType;
				context.Output.WriteLine("");
				context.Output.WriteLine("Raw Output:");
				if (singleResult.IsSingleReturn)
				{
					context.Output.WriteLine($"  Returns a single {resultType.Name} object, which may resemble the following...");
				}
				else
				{
					context.Output.WriteLine($"  Returns a stream of {resultType.Name} objects, which each may resemble the following...");
				}

				var data = new ReportDataPoint { data = singleResult.CreateEmptyInstance(), type = "stream", ts = DateTimeOffset.Now.ToUnixTimeMilliseconds() };
				var json = JsonConvert.SerializeObject(data, Formatting.Indented);
				context.Output.WriteLine("  " + json.ReplaceLineEndings("\n  "));
				break;
			default:
				// we need to explicitly check for interface implementations... 
				var genType = typeof(IResultSteam<,>);
				var commandType = context.Command.GetType();
				var allInterfaces = commandType.GetInterfaces();
				var resultStreamTypeArgs = new List<Type[]>();
				foreach (var subInterface in allInterfaces)
				{
					if (!subInterface.IsGenericType) continue;
					if (subInterface.GetGenericTypeDefinition() != genType) continue;

					var genArgs = subInterface.GetGenericArguments();
					resultStreamTypeArgs.Add(genArgs);

				}

				if (resultStreamTypeArgs.Count == 0) break;

				// okay, there is an undocumented result stream.

				context.Output.WriteLine("Raw Output:");
				foreach (var resultStream in resultStreamTypeArgs)
				{
					var channelType = resultStream[0];
					var dataType = resultStream[1];

					var channelInstance = (IResultChannel)Activator.CreateInstance(channelType);

					context.Output.WriteLine($"  Returns a stream of {dataType.Name} objects on the {channelInstance.ChannelName} stream, which each may resemble the following...");
					var resultStreamData = new ReportDataPoint { data = Activator.CreateInstance(dataType), type = channelInstance.ChannelName, ts = DateTimeOffset.Now.ToUnixTimeMilliseconds() };
					var resultStreamJson = JsonConvert.SerializeObject(resultStreamData, Formatting.Indented);
					context.Output.WriteLine("  " + resultStreamJson.ReplaceLineEndings("\n  "));
					context.Output.WriteLine("  ");
				}

				break;
		}
	}

	public virtual int Run(string[] args)
	{
		var prog = GetProgram();
		return prog.Invoke(args);
	}

	public virtual Task<int> RunAsync(string[] args)
	{
		var prog = GetProgram();
		return prog.InvokeAsync(args);
	}

	public virtual Task<int> RunWithSingleString(string commandLine)
	{
		var prog = GetProgram();
		return prog.InvokeAsync(commandLine);
	}
}
