using Beamable.Common.BeamCli.Contracts;
using cli.UnityCommands;
using Newtonsoft.Json;
using Serilog;
using System.IO.Compression;

namespace cli.Services.Unity;

public static class UnityProjectUtil
{
	/// <summary>
	/// Take the src files from a dotnet project, and copy them into a target Unity project.
	/// Meta files will generated for the cs files as well.
	/// 
	/// </summary>
	/// <param name="csProjPath"></param>
	/// <param name="targetUnityPath"></param>
	/// <returns></returns>
	public static CopyProjectSrcToUnityCommandOutput CopyProject(string srcFolder, string targetUnityPath)
	{
		Log.Debug($"Copying src files from {srcFolder} to {targetUnityPath}");
		
		// TODO: at some point, this may be too much memory to hold all at once if we are copying an absolutely massive project. In that case, consider a streaming approach.
		var sourceFiles = Enumerable.ToList<GeneratedFileDescriptor>(GetAllSourceInDirectory(srcFolder)); 
		var metaFiles = UnityCliGenerator.GenerateMetaFiles(sourceFiles);
		
		foreach (var x in metaFiles)
		{
			Log.Debug("Found src: " + x.FileName);
		}
		
		// need to create meta files for the various folders, too...
		var uniqueFolders = sourceFiles.Select(x => Path.GetDirectoryName(x.FileName))
			.Distinct()
			.Where(x => !string.IsNullOrEmpty(x))
			.ToList();
		foreach (var x in uniqueFolders)
		{
			Log.Debug("Found folder: " + x);
		}
		var metaFolders = UnityCliGenerator.GenerateMetaFiles(uniqueFolders);

		WriteFilesAtDirectory(targetUnityPath, sourceFiles);
		WriteFilesAtDirectory(targetUnityPath, metaFiles);
		WriteFilesAtDirectory(targetUnityPath, metaFolders);
		
		return new CopyProjectSrcToUnityCommandOutput
		{
			filesCopied = sourceFiles.Count
		};
	}

	/// <summary>
	/// Write all files into a directory. 
	/// </summary>
	/// <param name="targetDirectory"></param>
	/// <param name="files"></param>
	private static void WriteFilesAtDirectory(string targetDirectory, List<GeneratedFileDescriptor> files)
	{
		foreach (var file in files)
		{
			var fullPath = Path.Combine(targetDirectory, file.FileName);
			var dir = Path.GetDirectoryName(fullPath);
			Directory.CreateDirectory(dir);
			Log.Debug($"Writing {file.FileName} to {fullPath}");
			File.WriteAllText(fullPath, file.Content);
			
			File.SetAttributes(fullPath, FileAttributes.ReadOnly);
		}
	}

	/// <summary>
	/// Given a path to a csproj, iterate through all the .cs files in the sub directories of the csproj.
	/// This does not honor true MSBuild configurations, this is just a file directory scan.
	///
	/// The resulting paths are relative to the csProjPath's folder
	/// </summary>
	/// <param name="csProjPath"></param>
	/// <returns></returns>
	private static IEnumerable<GeneratedFileDescriptor> GetAllSourceFiles(string csProjPath)
	{
		var dir = Path.GetFullPath(Path.GetDirectoryName(csProjPath));
		return GetAllSourceInDirectory(dir);
	}
	
	private static IEnumerable<GeneratedFileDescriptor> GetAllSourceInDirectory(string dir)
	{
		var toExplore = new Queue<string>();
		toExplore.Enqueue(dir);

		while (toExplore.Count > 0)
		{
			var current = toExplore.Dequeue();

			var files = Directory.GetFiles(current, "*.cs", SearchOption.TopDirectoryOnly);
			foreach (var file in files)
			{
				// TODO: If a project requires a non cs file, then this will not copy it.
				if (!file.EndsWith(".cs")) continue;
				var path = Path.GetRelativePath(dir, file);
				var content = "// This file generated by a copy-operation from another project. \n// Edits to this file will be overwritten by the build process. \n\n" + File.ReadAllText(file);
				yield return new GeneratedFileDescriptor { FileName = path, Content = content};
			}

			var subDirs = Directory.GetDirectories(current);
			foreach (var subDir in subDirs)
			{
				var dirName = Path.GetFileName(subDir);
				if (dirName == "bin") continue;
				if (dirName == "obj") continue;
				toExplore.Enqueue(subDir);
			}
		}
	}

	/// <summary>
	/// Download a nuget package from nuget.org and copy the src files into a target unity project.
	/// This will generate meta files as well.
	/// </summary>
	/// <param name="packageId"></param>
	/// <param name="packageVersion"></param>
	/// <param name="packageSrc"></param>
	/// <param name="outputPath"></param>
	/// <exception cref="CliException"></exception>
	public static async Task DownloadPackage(string packageId, string packageVersion, string packageSrc, string outputPath)
	{
		var packageUrl = $"https://www.nuget.org/api/v2/package/{packageId}/{packageVersion}";
		var detailUrl = $"https://www.nuget.org/packages/{packageId}/{packageVersion}";
		

		using (HttpClient client = new HttpClient())
		{
			// Download the zip file as a byte array
			byte[] zipBytes = await client.GetByteArrayAsync(packageUrl);

			// Extract files in memory without saving the entire archive to disk
			using (MemoryStream memoryStream = new MemoryStream(zipBytes))
			{
				using (ZipArchive zipArchive = new ZipArchive(memoryStream))
				{
					// Iterate through each entry in the zip archive
					Log.Debug($"checking log entries for prefix=[{packageSrc}]");
					foreach (ZipArchiveEntry entry in zipArchive.Entries)
					{
						// Check if the entry is one of the files we want to save
						if (!entry.FullName.StartsWith(packageSrc))
						{
							Log.Debug($"skipping {entry.FullName}");
							continue;
						} 
						
						var relativePath = entry.FullName.Substring(packageSrc.Length);
						string filePath = Path.Combine(outputPath, relativePath);

						// Ensure the directory for the file exists
						Directory.CreateDirectory(Path.GetDirectoryName(filePath));

						// Extract the entry to a file on disk
						try
						{
							if (File.Exists(filePath)) File.Delete(filePath);

							using (Stream entryStream = entry.Open())
							using (FileStream fileStream = File.Create(filePath))
							using (StreamWriter writer = new StreamWriter(fileStream))
							{
								await writer.WriteLineAsync(
									$"// this file was copied from nuget package {packageId}@{packageVersion}\n// {detailUrl}\n");
								await writer.FlushAsync();
								await entryStream.CopyToAsync(fileStream);
							}

							Log.Debug($"Extracted and saved: {entry.FullName} to {filePath}");

							var metaDesc = UnityCliGenerator.GenerateMetaFile(filePath);
							await File.WriteAllTextAsync(metaDesc.FileName, metaDesc.Content);
							Log.Debug($"Saved meta file: {metaDesc.FileName}");

						}
						catch (Exception ex)
						{
							Log.Warning($"Failed to handle {entry.FullName}. {ex.GetType().Name} - {ex.Message}");
							throw new CliException(
								$"Failed to handle {entry.FullName}. {ex.GetType().Name} - {ex.Message}");
						}

					}

				}
			}
		}
	}

	/// <summary>
	/// Capture a collection of information about a Beamable unity project
	/// </summary>
	/// <param name="unityPath"></param>
	/// <param name="packageId"></param>
	/// <returns></returns>
	/// <exception cref="CliException"></exception>
	public static GetUnityVersionInfoCommandOutput GetUnityInfo(string unityPath, string packageId)
	{
		if (!TryGetPackageFolder(unityPath, out var packagePath, packageId))
		{
			throw new CliException("No beamable package is installed at that unity location");
		}
		if (!TryGetPackageFolder(unityPath, out var corePackagePath, "com.beamable"))
		{
			throw new CliException("No beamable package is installed at that unity location");
		}
		if (!TryGetUnityProjectNugetVersion(corePackagePath, out var versionData))
		{
			Log.Warning("Given beamable unity project does not have version file");
			versionData = new EnvironmentVersionData
			{
				nugetPackageVersion = "0.0.0"
			};
		}

		if (!TryGetUnityProjectPackageVersion(packagePath, out var packageData))
		{
			Log.Warning("Given beamable package does not have package.json file");
			packageData = new UnityProjectUtil.UnityPackage()
			{
				version = "0.0.0"
			};
		}
		
		return new GetUnityVersionInfoCommandOutput
		{
			packageFolder = packagePath,
			beamableNugetVersion = versionData.nugetPackageVersion,
			sdkVersion = packageData.version
		};
	}

	/// <summary>
	/// Identify where the package folder for the given PackageId is. It could be a local package (/Packages),
	/// or an installed package (/Library/PackageCache) folder.
	/// </summary>
	/// <param name="unityPath"></param>
	/// <param name="packagePath"></param>
	/// <param name="packageId"></param>
	/// <returns></returns>
	public static bool TryGetPackageFolder(string unityPath, out string packagePath, string packageId = "com.beamable")
	{
		packagePath = null;
		var localPackagePath = Path.Combine(unityPath, "Packages", packageId);
		if (Directory.Exists(localPackagePath))
		{
			packagePath = localPackagePath;
			return true;
		}
		
		var packageCache = Path.Combine(unityPath, "Library", "PackageCache");
		var cachedPackages = Directory.GetDirectories(packageCache);
		foreach (var cachedPackage in cachedPackages)
		{
			var cachedPackageName = Path.GetFileName(cachedPackage);
			if (cachedPackageName.StartsWith(packageId + "@"))
			{
				packagePath = cachedPackage; // Library/PackageCache/com.beamable@2.0.0
				return true;
			}
		}

		return false;
	}

	public static bool TryGetUnityProjectNugetVersion(string packagePath, out EnvironmentVersionData versionData)
	{
		versionData = null;
		var versionPath = Path.Combine(packagePath, "Runtime/Environment/Resources/versions-default.json");
		if (!File.Exists(versionPath))
		{
			return false;
		}
		var json = File.ReadAllText(versionPath);
		versionData = JsonConvert.DeserializeObject<EnvironmentVersionData>(json);
		return true;
	}

	public static bool TryGetUnityProjectPackageVersion(string packagePath, out UnityPackage data)
	{
		data = null;
		var packageJsonPath = Path.Combine(packagePath, "package.json");
		if (!File.Exists(packageJsonPath))
		{
			return false;
		}
		var json = File.ReadAllText(packageJsonPath);
		data = JsonConvert.DeserializeObject<UnityPackage>(json);
		return true;
	}

	[Serializable]
	public class UnityPackage
	{
		public string version;
	}

	public static void DeleteAllFilesWithExtensions(string folder, string[] extensions)
	{
		foreach (var ext in extensions)
		{
			var filesToDelete = Directory.GetFiles(folder, $"*{ext}", SearchOption.AllDirectories);
			foreach (var file in filesToDelete)
			{
				File.SetAttributes(file, FileAttributes.None);
				File.Delete(file);
			}
		}
	}
}
