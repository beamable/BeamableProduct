using Beamable.Api.Autogenerated;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Serialization;
using cli.Unreal;
using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Models;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using Beamable.Server;

namespace cli;

public class UnitySourceGenerator : SwaggerService.ISourceGenerator
{
	/// <summary>
	/// Given a <see cref="IGenerationContext"/> containing openAPI specifications, produce a set of <see cref="GeneratedFileDescriptor"/>
	/// that contain the C# source code for the openAPI specs
	/// </summary>
	/// <param name="context"></param>
	/// <returns></returns>
	public List<GeneratedFileDescriptor> Generate(IGenerationContext context)
	{
		var res = new List<GeneratedFileDescriptor>();

		// generate all of the models, which we cram into one single file, from all documents.
		var modelFile = UnityHelper.GenerateModel(context, out var oneOfs);
		res.Add(modelFile);

		// find the unique services...
		var serviceTypes = context.Documents.DistinctBy(document =>
		{
			UnityHelper.GetTypeNames(document, out _, out var className, out _, out _);
			return className;
		});
		foreach (var document in serviceTypes)
		{
			res.Add(UnityHelper.GenerateBaseService(document, oneOfs));
		}

		// generate all the services, which is 1:1 with the documents in the openAPI sequence
		foreach (var document in context.Documents)
		{
			res.Add(UnityHelper.GenerateService(document));
		}


		return res;
	}
}

public class SchemaTypeDeclarations
{
	public CodeTypeDeclaration EnumExtensions;
	public CodeTypeDeclaration Model;
	public CodeTypeDeclaration Optional;
	public CodeTypeDeclaration OptionalArray;
	public CodeTypeDeclaration OptionalMap;
	public CodeTypeDeclaration OptionalMapArray;
	public CodeTypeDeclaration OptionalArrayMap;
	public CodeTypeDeclaration Map;
	public CodeTypeDeclaration MapArray;
	public CodeTypeDeclaration ArrayMap;
	public IList<RequiredOneOfInterface> OneOfs;
}

public class RequiredOneOfInterface
{
	public string interfaceName;
	public IList<OpenApiSchema> childTypeSchemas;
	public CodeTypeDeclaration type;
	public CodeTypeDeclaration optionalType;
	public CodeTypeDeclaration serializationFactoryType;
}

public static class UnityHelper
{
	const string PARAM_SERIALIZER = "s";

	public const string BeamableOptionalNamespace = "Beamable.Common.Content";
	public const string BeamableSerializeNamespace = "Beamable.Serialization";
	public const string BeamableGeneratedNamespace = "Beamable.Api.Autogenerated";
	public const string BeamableDepsNamespace = "Beamable.Common.Dependencies";


	public static string BeamableGeneratedModelsNamespace => $"{BeamableGeneratedNamespace}.Models";

	public static GeneratedFileDescriptor GenerateModel(IGenerationContext context, out Dictionary<string, RequiredOneOfInterface> oneOfs)
	{
		var unit = new CodeCompileUnit();
		var root = new CodeNamespace(BeamableGeneratedModelsNamespace);
		root.Imports.Add(new CodeNamespaceImport(BeamableOptionalNamespace));
		root.Imports.Add(new CodeNamespaceImport(BeamableSerializeNamespace));
		unit.Namespaces.Add(root);

		// add all of the model types...
		var nameToTypes = new Dictionary<string, SchemaTypeDeclarations>();
		var nameToRefCount = new Dictionary<string, int>();

		oneOfs = new Dictionary<string, RequiredOneOfInterface>();
		foreach (var schema in context.OrderedSchemas)
		{
			// build all the types associated with this model...
			var types = UnityHelper.GenerateDeclarations(schema.ReferenceId, schema.Schema);
			nameToTypes.TryAdd(schema.ReferenceId, types);

			// and always add the root model type...
			root.Types.Add(types.Model);

			// always add any oneOfs...
			foreach (var oneOf in types.OneOfs)
			{
				if (!oneOfs.ContainsKey(oneOf.interfaceName))
				{
					root.Types.Add(oneOf.type);
					root.Types.Add(oneOf.optionalType);
					root.Types.Add(oneOf.serializationFactoryType);
					oneOfs.Add(oneOf.interfaceName, oneOf);
				}
			}

			// and always add the enum type if it isn't null...
			if (types.EnumExtensions != null)
			{
				root.Types.Add(types.EnumExtensions);
			}

			// make some counts about how many fields are referencing variant types
			foreach (var member in types.Model.Members)
			{
				if (member is CodeMemberField field)
				{
					if (!nameToRefCount.TryGetValue(field.Type.BaseType, out var existing))
					{
						existing = 0;
					}
					nameToRefCount[field.Type.BaseType] = existing + 1;
				}
			}
		}

		// handle oneOf interface matching...
		foreach (var (interfaceName, requiredOneOfInterface) in oneOfs)
		{
			foreach (var childSchema in requiredOneOfInterface.childTypeSchemas)
			{
				if (childSchema.Reference == null)
				{
					throw new Exception("OneOf cannot be created without a reference type");
				}

				if (!nameToTypes.TryGetValue(childSchema.Reference.Id, out var childType))
				{
					throw new Exception($"OneOf of id=[{childSchema.Reference.Id}] not found");
				}

				childType.Model.BaseTypes.Add(interfaceName);
			}
		}

		void AddTypeIfRequired(CodeTypeDeclaration countCheck, CodeTypeDeclaration decl = null)
		{
			decl ??= countCheck;
			if (countCheck != null && decl != null && nameToRefCount.TryGetValue(countCheck.Name, out _))
			{
				root.Types.Add(decl);
			}
		}

		// we only need to generate model variants that are actually referenced. For example, if there was a TunaModel, we wouldn't want to generate an OptionalMapOfTunaModel unless some code actually needed it.
		foreach (var kvp in nameToTypes)
		{
			AddTypeIfRequired(kvp.Value.Optional);
			AddTypeIfRequired(kvp.Value.OptionalArray);
			AddTypeIfRequired(kvp.Value.OptionalMap);
			AddTypeIfRequired(kvp.Value.OptionalMapArray);
			AddTypeIfRequired(kvp.Value.OptionalArrayMap);
			AddTypeIfRequired(kvp.Value.Map);
			AddTypeIfRequired(kvp.Value.OptionalMap, kvp.Value.Map);
			AddTypeIfRequired(kvp.Value.MapArray);
			AddTypeIfRequired(kvp.Value.ArrayMap);
			AddTypeIfRequired(kvp.Value.OptionalMapArray, kvp.Value.MapArray);
			AddTypeIfRequired(kvp.Value.OptionalArrayMap, kvp.Value.ArrayMap);
		}


		return new GeneratedFileDescriptor { FileName = "Models.gs.cs", Content = UnityHelper.GenerateCsharp(unit) };
	}


	public static void GeneratePartialServiceType(OpenApiDocument document, out CodeCompileUnit unit, out CodeTypeDeclaration type, out CodeTypeDeclaration interfaceType)
	{
		unit = new CodeCompileUnit();
		GetTypeNames(document, out var title, out var className, out _, out _);

		var namespaceName = SanitizeClassName(title);
		// if (title == "Beamable")
		// {
		// 	namespaceName = "Api";
		// }
		var root = new CodeNamespace($"{BeamableGeneratedNamespace}.{namespaceName}");
		root.Imports.Add(new CodeNamespaceImport(BeamableGeneratedModelsNamespace));
		root.Imports.Add(new CodeNamespaceImport(BeamableOptionalNamespace));
		root.Imports.Add(new CodeNamespaceImport("Beamable.Common"));
		root.Imports.Add(new CodeNamespaceImport("IBeamableRequester = Beamable.Common.Api.IBeamableRequester"));
		root.Imports.Add(new CodeNamespaceImport("Method = Beamable.Common.Api.Method"));
		root.Imports.Add(new CodeNamespaceImport(BeamableDepsNamespace));
		unit.Namespaces.Add(root);

		type = new CodeTypeDeclaration($"{className}") { IsPartial = true };
		interfaceType = new CodeTypeDeclaration($"I{className}") { IsInterface = true, IsPartial = true };

		type.BaseTypes.Add(new CodeTypeReference(interfaceType.Name));

		root.Types.Add(interfaceType);
		root.Types.Add(type);
	}

	public static GeneratedFileDescriptor GenerateBaseService(OpenApiDocument document, Dictionary<string, RequiredOneOfInterface> oneOfs)
	{
		GeneratePartialServiceType(document, out var unit, out var type, out _);
		GetTypeNames(document, out _, out _, out var fileName, out _);

		var requesterField = new CodeMemberField(nameof(IBeamableRequester), "_requester")
		{
			Attributes = MemberAttributes.Private
		};
		type.Members.Add(requesterField);
		var providerVariableName = "_provider";
		var providerField = new CodeMemberField(nameof(IDependencyProvider), providerVariableName)
		{
			Attributes = MemberAttributes.Private
		};
		type.Members.Add(providerField);

		var factoryVariableName = "_serializationFactories";
		var factoryField = new CodeMemberField(new CodeTypeReference(typeof(List<>))
		{
			TypeArguments = { new CodeTypeReference(typeof(JsonSerializable.ISerializableFactory)) }
		}, factoryVariableName);
		type.Members.Add(factoryField);

		var cons = new CodeConstructor { Attributes = MemberAttributes.Public };
		var referenceFactories = new CodeVariableReferenceExpression(factoryVariableName);
		var referenceProvider = new CodeVariableReferenceExpression(providerVariableName);
		cons.Parameters.Add(new CodeParameterDeclarationExpression(nameof(IBeamableRequester), "requester"));
		cons.Parameters.Add(new CodeParameterDeclarationExpression(nameof(IDependencyProvider), "provider")
		{
			CustomAttributes = new CodeAttributeDeclarationCollection(new CodeAttributeDeclaration[]
			{
				new CodeAttributeDeclaration(new CodeTypeReference(typeof(DefaultParameterValueAttribute)), new CodeAttributeArgument(new CodeDefaultValueExpression(new CodeTypeReference(typeof(IDependencyProvider))))),
				new CodeAttributeDeclaration(new CodeTypeReference(typeof(OptionalAttribute)))
			})
		});
		cons.Statements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "_requester"), new CodeArgumentReferenceExpression("requester")));
		cons.Statements.Add(new CodeAssignStatement(referenceProvider, new CodeArgumentReferenceExpression("provider")));
		cons.Statements.Add(new CodeAssignStatement(referenceFactories, new CodeObjectCreateExpression(factoryField.Type)));

		foreach (var oneOf in oneOfs) // TODO: wait, we don't need to do this for services that don't reference the oneOf
		{
			var createInstanceExpr = new CodeObjectCreateExpression(new CodeTypeReference(oneOf.Value.serializationFactoryType.Name));
			cons.Statements.Add(new CodeMethodInvokeExpression(referenceFactories, nameof(List<int>.Add),
				createInstanceExpr));
		}

		type.Members.Add(cons);


		var serializationMethod = new CodeMemberMethod { Name = "Serialize", Attributes = MemberAttributes.Private };

		var serializeGenericType = new CodeTypeParameter("T");
		serializeGenericType.Constraints.Add(typeof(JsonSerializable.ISerializable));
		serializeGenericType.HasConstructorConstraint = true;
		serializationMethod.TypeParameters.Add(serializeGenericType);
		serializationMethod.Parameters.Add(new CodeParameterDeclarationExpression(typeof(string), "json"));
		serializationMethod.ReturnType = new CodeTypeReference("T");


		var customSerializerType =
			new CodeTypeReference(nameof(ICustomSerializer<int>), serializationMethod.ReturnType);
		var overrideSerailizationBlock = new CodeConditionStatement(
			condition: new CodeMethodInvokeExpression(method: new CodeMethodReferenceExpression(referenceProvider,
				nameof(IDependencyProvider.CanBuildService), customSerializerType)));
		overrideSerailizationBlock.TrueStatements.Add(
			new CodeVariableDeclarationStatement(customSerializerType, "serializer",
				new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(referenceProvider,
					nameof(IDependencyProvider.GetService), customSerializerType))));
		overrideSerailizationBlock.TrueStatements.Add(new CodeMethodReturnStatement(new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(
			targetObject: new CodeVariableReferenceExpression("serializer"), methodName: nameof(ICustomSerializer<int>.Deserialize))
		)
		{
			Parameters = { new CodeVariableReferenceExpression("json") }
		}));

		// create an expression that answers the question, "is the optional _itself_ not null?"
		var valueIsNotNullExpr = new CodeBinaryOperatorExpression(referenceProvider,
			CodeBinaryOperatorType.IdentityInequality,
			new CodeDefaultValueExpression(new CodeTypeReference(typeof(IDependencyProvider))));

		var nonNullBlock = new CodeConditionStatement(valueIsNotNullExpr, overrideSerailizationBlock);

		serializationMethod.Statements.Add(nonNullBlock);
		serializationMethod.Statements.Add(
			new CodeMethodReturnStatement(
				new CodeMethodInvokeExpression(
					new CodeMethodReferenceExpression(
						targetObject: new CodeTypeReferenceExpression(typeof(JsonSerializable)),
						methodName: nameof(JsonSerializable.FromJson))
					{
						TypeArguments = { new CodeTypeReference(serializeGenericType) }
					}
				)
				{ Parameters = { new CodeVariableReferenceExpression("json"), referenceFactories } }
			));

		// where T : ISerializable, new()
		type.Members.Add(serializationMethod);
		return new GeneratedFileDescriptor
		{
			FileName = $"{fileName}Common.gs.cs",
			Content = GenerateCsharp(unit)
		};
	}

	public static GeneratedFileDescriptor GenerateService(OpenApiDocument document)
	{
		GetTypeNames(document, out _, out _, out var fileName, out var methodSuffix);
		GeneratePartialServiceType(document, out var unit, out var type, out var interfaceType);

		foreach (var path in document.Paths)
		{
			// TODO: pull this into a helper method
			var skipsLeft = document.Info.Title.Contains("object") ? 4 : 3;
			var index = 0;
			for (var i = 0; i < path.Key.Length; i++)
			{
				if (path.Key[i] == '/')
				{
					skipsLeft--;
				}

				if (skipsLeft == 0)
				{
					index = i + 1;
					break;
				}
			}
			var methodName = path.Key.Substring(index);

			methodName = SwaggerService.FormatPathNameAsMethodName(methodName);
			if (methodName.Length > 1)
			{
				methodName = char.ToUpper(methodName[0]) + methodName.Substring(1);
			}

			methodName = SanitizeFieldName(methodName);

			foreach (var operation in path.Value.Operations)
			{

				var method = GenerateApiMethod(methodSuffix, path.Key, operation, methodName);
				if (method != null)
				{
					interfaceType.Members.Add(method);
					type.Members.Add(method);
				}
			}
		}


		return new GeneratedFileDescriptor
		{
			FileName = $"{fileName}.gs.cs",
			Content = GenerateCsharp(unit)
		};
	}

	static CodeMemberMethod GenerateApiMethod(string methodPrefix, string pathName, KeyValuePair<OperationType, OpenApiOperation> operation,
		string methodName)
	{
		const string varUrl = "gsUrl"; // gs stands for generated-source
		const string varQuery = "gsQuery";
		const string varQueries = "gsQueries";
		const string varReq = "gsReq";
		const string paramIncludeAuth = "includeAuthHeader";

		var httpMethod = Method.GET;

		var requesterReference = new CodeVariableReferenceExpression("_requester");

		switch (operation.Key)
		{
			case OperationType.Get:
				httpMethod = Method.GET;
				break;
			case OperationType.Delete:
				httpMethod = Method.DELETE;
				break;
			case OperationType.Post:
				httpMethod = Method.POST;
				break;
			case OperationType.Put:
				httpMethod = Method.PUT;
				break;
		}

		// TODO: if not 200, check for the first 20x
		OpenApiResponse response = null;
		for (var i = 200; i < 230; i++)
		{
			if (operation.Value.Responses.TryGetValue(i.ToString(), out response))
			{
				break;
			}
		}

		if (response == null)
		{
			Log.Warning($"Cannot generate a method for path=[{pathName}] because there is no valid 20x response ");
			return null; 
		}

		// bool isCsv = false;
		// TODO: support application/csv for content
		if (!response.Content.TryGetValue("application/json", out var mediaResponse))
		{
			// isCsv = true;
			if (!response.Content.TryGetValue("text/csv", out mediaResponse))
			{
				return null;
			}
		}

		var operationName = methodPrefix + operation.Key + methodName;
		var returnType = new CodeTypeReference(nameof(Promise));
		var responseType = new CodeTypeReference(mediaResponse.Schema.Reference.Id);

		// string csvOrder = null;
		// string csvPKey = null;
		// if (isCsv)
		// {
		// 	// ASSUMPTION!!!! Anytime we are reading CSV from open-api, the SPEC IS WRONG, and includes an intermediary type that we should ignore.
		// 	var subType =
		// 		mediaResponse.Schema.Reference.HostDocument.Components.Schemas[mediaResponse.Schema.Reference.Id].Properties.FirstOrDefault();
		// 	var realReference = subType.Value.Items.Reference.Id;
		// 	var realType = mediaResponse.Schema.Reference.HostDocument.Components.Schemas[realReference];
		// 	
		// 	if (!realType.Extensions.TryGetValue("x-beamable-csv-order", out var order) || !(order is OpenApiString orderStr))
		// 	{
		// 		throw new Exception("CSV message must contain an order extension");
		// 	}
		// 	if (!realType.Extensions.TryGetValue("x-beamable-primary-key", out var pkey)|| !(pkey is OpenApiString pkeyStr))
		// 	{
		// 		throw new Exception("CSV message must contain a pkey extension");
		// 	}
		//
		// 	csvOrder = orderStr.Value;
		// 	csvPKey = pkeyStr.Value;
		// 	responseType = new CodeTypeReference(realReference);
		// }

		returnType.TypeArguments.Add(responseType);

		var method = new CodeMemberMethod
		{
			Name = operationName,
			Attributes = MemberAttributes.Public,
			ReturnType = returnType
		};

		var methodComments = new List<string>();

		var uri = pathName;
		bool hasReqBody = false;

		// TODO: we only support one security schema at the moment...

		var authHeaderRequired = false;
		if (operation.Value.Security.Count == 1)
		{
			authHeaderRequired = operation.Value.Security[0].Any(kvp => kvp.Key.Reference.Id == "user");
		}
		
		/// Summary description
		methodComments.Add("<summary>");
		if (!string.IsNullOrWhiteSpace(operation.Value.Summary))
		{
			methodComments.Add(operation.Value.Summary);
			methodComments.Add(string.Empty);
		}
		methodComments.Add($"{httpMethod} call to `{uri}` endpoint.");
		methodComments.Add("</summary>");

		var requiredParams = new List<CodeParameterDeclarationExpression>();
		var optionalParams = new List<CodeParameterDeclarationExpression>();

		var parameters = operation.Value.Parameters.ToList();
		parameters.Sort((a, b) => string.Compare(a.Name, b.Name, StringComparison.Ordinal));

		foreach (var param in parameters)
		{
			var genSchema = new GenSchema(param.Schema);

			methodComments.Add($"<param name=\"{param.Name}\">{param.Description }</param>");

			if (param.Name == "objectId")
			{
				if (param.Extensions.TryGetValue("x-beamable-object-id", out var ext) && ext is OpenApiObject obj)
				{
					if (obj.TryGetValue("type", out var customType) && customType is OpenApiString typeStr)
					{
						var customSchema = new OpenApiSchema { Type = typeStr.Value };
						if (obj.TryGetValue("format", out var customFormat) && customFormat is OpenApiString formatStr)
						{
							customSchema.Format = formatStr.Value;
						}

						genSchema = new GenSchema(customSchema);
					}
				}
			}

			if (param.Required)
			{

				requiredParams.Add(new CodeParameterDeclarationExpression
				{
					Name = param.Name,
					Type = genSchema.GetTypeReference()
				});
			}
			else
			{
				optionalParams.Add(new CodeParameterDeclarationExpression
				{
					// the optional parameter should default to null
					Name = param.Name,
					Type = genSchema.GetOptionalTypeReferenceGeneric(),
					CustomAttributes = new CodeAttributeDeclarationCollection(new CodeAttributeDeclaration[]
					{
						new CodeAttributeDeclaration(new CodeTypeReference(typeof(DefaultParameterValueAttribute)), new CodeAttributeArgument(new CodePrimitiveExpression(null))),
						new CodeAttributeDeclaration(new CodeTypeReference(typeof(OptionalAttribute)))
					})
				});
			}
		}
		method.Parameters.AddRange(requiredParams.ToArray());

		if (operation.Value.RequestBody?.Content?.TryGetValue("application/json", out var requestMediaType) ?? false)
		{
			hasReqBody = true;
			methodComments.Add($"<param name=\"{varReq}\">The <see cref=\"{requestMediaType.Schema.Reference.Id}\"/> instance to use for the request</param>");
			method.Parameters.Add(new CodeParameterDeclarationExpression
			{
				Name = varReq,
				Type = new CodeTypeReference(requestMediaType.Schema.Reference.Id)
			});
		}

		// optional parameters go last...
		method.Parameters.AddRange(optionalParams.ToArray());

		// the auth should always be the last parameter.
		if (!authHeaderRequired)
		{
			methodComments.Add($"<param name=\"{paramIncludeAuth}\">By default, every request will include an authorization header so that the request acts on behalf of the current user. When the {paramIncludeAuth} argument is false, the request will not include the authorization header for the current user.</param>");
			method.Parameters.Add(new CodeParameterDeclarationExpression
			{
				// the auth header parameter should default to true.
				Name = paramIncludeAuth,
				Type = new CodeTypeReference(typeof(bool)),
				CustomAttributes = new CodeAttributeDeclarationCollection(new CodeAttributeDeclaration[]
				{
					new CodeAttributeDeclaration(new CodeTypeReference(typeof(DefaultParameterValueAttribute)), new CodeAttributeArgument(new CodePrimitiveExpression(true))),
					new CodeAttributeDeclaration(new CodeTypeReference(typeof(OptionalAttribute)))
				})
			});
		}


		// url construction
		method.Statements.Add(new CodeVariableDeclarationStatement(typeof(string), varUrl,
			new CodePrimitiveExpression(uri)));

		var queryStringRef = new CodeVariableReferenceExpression(varQuery);

		var queryArgs = new List<string>();
		var queryStatements = new List<CodeStatement>();

		var queryListAssign = new CodeVariableDeclarationStatement(typeof(List<string>), varQueries,
			new CodeObjectCreateExpression(typeof(List<string>)));

		var queryListRef = new CodeVariableReferenceExpression(varQueries);

		foreach (var param in operation.Value.Parameters)
		{
			var paramRef = new CodeVariableReferenceExpression(param.Name);
			switch (param.In)
			{
				case ParameterLocation.Path:
					var paramToStr = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(param.Name),
						nameof(object.ToString));
					var pathEscaped = new CodeMethodInvokeExpression(requesterReference,
						nameof(IBeamableRequester.EscapeURL), paramToStr);
					var replace = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(varUrl),
						nameof(string.Replace), new CodePrimitiveExpression($"{{{param.Name}}}"),
						pathEscaped);

					method.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(varUrl),
						replace));
					break;
				case ParameterLocation.Query:

					if (param.Required)
					{
						var toStringExpr =
							new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(param.Name),
								nameof(object.ToString));
						var escaped = new CodeMethodInvokeExpression(requesterReference,
							nameof(IBeamableRequester.EscapeURL), toStringExpr);
						var expr = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof(string)),
							nameof(string.Concat), new CodePrimitiveExpression($"{param.Name}="),
							escaped);
						var methodInvoke = new CodeMethodInvokeExpression(queryListRef,
							nameof(List<string>.Add), expr);
						queryStatements.Add(new CodeExpressionStatement(methodInvoke));

					}
					else
					{
						// create an expression that answers the question, "does the optional field have a value?"
						var hasValueExpr = new CodeFieldReferenceExpression(paramRef, nameof(Optional.HasValue));

						// create an expression that answers the question, "is the optional _itself_ not null?"
						var valueIsNotNullExpr = new CodeBinaryOperatorExpression(paramRef,
							CodeBinaryOperatorType.IdentityInequality,
							new CodeDefaultValueExpression(new GenSchema(param.Schema).GetOptionalTypeReference()));

						// create an expression that translates
						var shouldSerializeExpr = new CodeBinaryOperatorExpression(valueIsNotNullExpr,
							CodeBinaryOperatorType.BooleanAnd, hasValueExpr);

						var valueExpr =
							new CodeFieldReferenceExpression(new CodeVariableReferenceExpression(param.Name),
								nameof(Optional<int>.Value));
						var toStringExpr =
							new CodeMethodInvokeExpression(valueExpr,
								nameof(object.ToString));

						var expr = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof(string)),
							nameof(string.Concat), new CodePrimitiveExpression($"{param.Name}="),
							toStringExpr);

						var methodInvoke = new CodeMethodInvokeExpression(queryListRef,
							nameof(List<string>.Add), expr);

						// create the if-statement that uses the expression...
						var conditionStatement =
							new CodeConditionStatement(shouldSerializeExpr,

								// and set set the optional to have a value
								new CodeExpressionStatement(methodInvoke)
							);

						queryStatements.Add(conditionStatement);
						// need to check if the param has a value or not...
					}

					queryArgs.Add(param.Name); // these are variables in the method
					break;
			}
		}

		if (queryArgs.Count > 0)
		{
			method.Statements.Add(new CodeVariableDeclarationStatement(typeof(string), varQuery,
				new CodePrimitiveExpression("?")));

			method.Statements.Add(queryListAssign);
			method.Statements.AddRange(queryStatements.ToArray());
			var joinExpr = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof(string)),
				nameof(string.Join), new CodePrimitiveExpression("&"), queryListRef);

			var joinAssignment = new CodeAssignStatement(queryStringRef,
				new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof(string)),
					nameof(string.Concat), queryStringRef,
					joinExpr));

			var queryListRefIfStatement = new CodeConditionStatement(
				new CodeBinaryOperatorExpression(new CodePropertyReferenceExpression(
					queryListRef, "Count"), CodeBinaryOperatorType.GreaterThan, new CodePrimitiveExpression(0)));

			queryListRefIfStatement.TrueStatements.Add(joinAssignment);
			queryListRefIfStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(varUrl),
				new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof(string)), nameof(string.Concat),
					new CodeVariableReferenceExpression(varUrl), new CodeVariableReferenceExpression(varQuery))));

			method.Statements.Add(queryListRefIfStatement);
		}


		// make the request itself.
		var requestCommand = new CodeMethodInvokeExpression(requesterReference,
			nameof(IBeamableRequester.Request));
		requestCommand.Method.TypeArguments.Add(responseType);

		// we always need a Method parameter...
		requestCommand.Parameters.Add(new CodeTypeReferenceExpression("Method." + httpMethod));

		// we then need a url
		requestCommand.Parameters.Add(new CodeVariableReferenceExpression(varUrl));

		// we always need a request body
		if (hasReqBody)
		{
			// either use the reference to the given model,
			requestCommand.Parameters.Add(new CodeMethodInvokeExpression(
				new CodeTypeReferenceExpression(typeof(JsonSerializable)),
				nameof(JsonSerializable.ToJson), new CodeVariableReferenceExpression(varReq)));
		}
		else
		{
			// or pass in null
			requestCommand.Parameters.Add(new CodeDefaultValueExpression(new CodeTypeReference(typeof(object))));
		}

		// pass in the auth header
		if (authHeaderRequired)
		{
			requestCommand.Parameters.Add(new CodePrimitiveExpression(true));
		}
		else
		{
			requestCommand.Parameters.Add(
				new CodeArgumentReferenceExpression(
					paramIncludeAuth)); // TODO: maybe not every method should have this open exposed?
		}

		// var parserArg = new CodeDelegateInvokeExpression() // COMEBACKHERE

		// always use a custom parser based on the response type so that we can use the serialization stuff
		requestCommand.Parameters.Add(new CodeMethodReferenceExpression(
					new CodeThisReferenceExpression(), "Serialize")
		{ TypeArguments = { responseType } });


		// return the result
		var returnCommand = new CodeMethodReturnStatement(requestCommand);
		methodComments.Add($"<returns>A promise containing the <see cref=\"{responseType.BaseType}\"/></returns>");
		method.Comments.AddRange(methodComments.Select(str => new CodeCommentStatement(str, true)).ToArray());
		method.Statements.Add(new CodeCommentStatement("make the request and return the result"));
		method.Statements.Add(returnCommand);

		return method;
	}

	public static void GetTypeNames(OpenApiDocument document, out string title, out string className, out string fileName, out string methodCustomization)
	{
		var words = document.Info.Title.Split(' ');
		// remove "basic" and "object" words...
		const string basicService = "Basic";
		const string objectService = "Object";
		const string apiService = "Actor";

		fileName = "";
		title = "";
		className = "";
		methodCustomization = "";
		for (var j = 0; j < words.Length; j++)
		{
			var casedWord = "";
			var word = words[j];
			for (var i = 0; i < word.Length; i++)
			{
				var letter = i == 0
					? char.ToUpper(word[i])
					: char.ToLower(word[i]);
				casedWord += letter;
			}

			if (j == 0)
			{
				title = casedWord;
			}

			switch (casedWord)
			{
				case basicService:
					fileName += casedWord;
					break;
				case apiService: // in the API naming case, we'll keep "Beam<SERVICE>" conventions
					className = $"Beam{className}";
					fileName = $"Beam{fileName}";
					break;
				case objectService:
					methodCustomization = "Object";
					fileName += casedWord;
					break;
				default:
					className += casedWord;
					fileName += casedWord;
					break;
			}
		}

		className = className.Replace("Playerpresence", "PlayerPresence");
		className += "Api";
		className = SanitizeClassName(className);

	}


	/// <summary>
	/// Generate all of the various model variants for the given schema.
	/// </summary>
	/// <param name="name">The name of the schema</param>
	/// <param name="schema">the openAPI schema itself</param>
	/// <returns>a <see cref="SchemaTypeDeclarations"/> that contains type decls </returns>
	public static SchemaTypeDeclarations GenerateDeclarations(string name, OpenApiSchema schema)
	{
		GenerateModelDecl(name, schema, out var model, out var oneOfs);
		return new SchemaTypeDeclarations
		{
			EnumExtensions = GenerateEnumExtensions(name, schema),
			Model = model,
			Optional = GenerateOptionalDecl(name, schema),
			OptionalArray = GenerateOptionalArrayDecl(name, schema),
			OptionalMap = GenerateOptionalMapDecl(name, schema),
			OptionalMapArray = GenerateOptionalMapArrayDecl(name, schema),
			MapArray = GenerateMapArrayDecl(name, schema),
			ArrayMap = GenerateArrayMapDecl(name, schema),
			OptionalArrayMap = GenerateOptionalArrayMapDecl(name, schema),
			Map = GenerateMapDecl(name, schema),
			OneOfs = oneOfs
		};
	}

	/// <summary>
	/// The Optional-Map captures a type like
	/// <code>
	/// public OptionalMapOfInt doop;
	/// </code>
	///
	/// which internally is an <code>
	/// Optional{MapOf{Int}}
	/// </code>
	///
	/// </summary>
	/// <param name="name"></param>
	/// <param name="schema"></param>
	/// <returns></returns>
	public static CodeTypeDeclaration GenerateOptionalMapDecl(string name, OpenApiSchema schema)
	{
		switch (schema.Type, schema.Format)
		{
			case ("array", _):
			case ("object", _):
				var className = SanitizeClassName(name);
				var optionalClassName = $"OptionalMapOf{className}";

				var type = new CodeTypeDeclaration();
				type.CustomAttributes.Add(
					new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.SerializableAttribute))));

				type.Name = optionalClassName;
				var baseType = new CodeTypeReference(typeof(Optional<>));
				baseType.TypeArguments.Add(new CodeTypeReference($"MapOf{className}"));
				type.BaseTypes.Add(baseType);
				return type;
		}

		return null;
	}

	public static CodeTypeDeclaration GenerateMapDecl(string name, OpenApiSchema schema)
	{
		switch (schema.Type, schema.Format)
		{
			case ("array", _):
			case ("object", _):
				var className = SanitizeClassName(name);
				var optionalClassName = $"MapOf{className}";

				var type = new CodeTypeDeclaration();
				type.CustomAttributes.Add(
					new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.SerializableAttribute))));

				type.Name = optionalClassName;
				var baseType = new CodeTypeReference(typeof(SerializableDictionaryStringToSomething<>));
				var genericType = new CodeTypeReference(className);
				baseType.TypeArguments.Add(genericType);
				type.BaseTypes.Add(baseType);
				return type;
		}

		return null;
	}

	/// <summary>
	/// The Optional-Map-Array captures a type like
	/// <code>
	/// public OptionalMapOfIntArray doop;
	/// </code>
	///
	/// which internally is an <code>
	/// Optional{MapOf{Int[]}}
	/// </code>
	///
	/// </summary>
	/// <param name="name"></param>
	/// <param name="schema"></param>
	/// <returns></returns>
	public static CodeTypeDeclaration GenerateOptionalMapArrayDecl(string name, OpenApiSchema schema)
	{
		switch (schema.Type, schema.Format)
		{
			case ("array", _):
			case ("object", _):
				var className = SanitizeClassName(name);
				var optionalClassName = $"OptionalMapOfArrayOf{className}";
				var type = new CodeTypeDeclaration();
				type.CustomAttributes.Add(
					new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.SerializableAttribute))));

				type.Name = optionalClassName;
				var baseType = new CodeTypeReference(typeof(Optional<>));
				baseType.TypeArguments.Add(new CodeTypeReference($"MapOfArrayOf{className}"));
				type.BaseTypes.Add(baseType);
				return type;
		}
		return null;
	}


	public static CodeTypeDeclaration GenerateOptionalArrayMapDecl(string name, OpenApiSchema schema)
	{
		switch (schema.Type, schema.Format)
		{
			case ("array", _):
			case ("object", _):
				var className = SanitizeClassName(name);
				var optionalClassName = $"OptionalArrayOfMapOf{className}";
				var type = new CodeTypeDeclaration();
				type.CustomAttributes.Add(
					new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.SerializableAttribute))));

				type.Name = optionalClassName;
				var baseType = new CodeTypeReference(typeof(Optional<>));
				baseType.TypeArguments.Add(new CodeTypeReference($"ArrayOfMapOf{className}"));
				type.BaseTypes.Add(baseType);

				return type;
		}
		return null;
	}

	public static CodeTypeDeclaration GenerateMapArrayDecl(string name, OpenApiSchema schema)
	{
		switch (schema.Type, schema.Format)
		{
			case ("array", _):
			case ("object", _):
				var className = SanitizeClassName(name);
				var optionalClassName = $"MapOfArrayOf{className}";
				var type = new CodeTypeDeclaration();
				type.CustomAttributes.Add(
					new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.SerializableAttribute))));

				type.Name = optionalClassName;
				var baseType = new CodeTypeReference(typeof(SerializableDictionaryStringToSomething<>));
				var genericType = new CodeTypeReference(className);
				genericType.ArrayRank = 1;
				baseType.TypeArguments.Add(genericType);

				type.BaseTypes.Add(baseType);
				return type;
		}
		return null;
	}


	public static CodeTypeDeclaration GenerateArrayMapDecl(string name, OpenApiSchema schema)
	{
		switch (schema.Type, schema.Format)
		{
			case ("array", _):
			case ("object", _):
				var className = SanitizeClassName(name);
				var optionalClassName = $"ArrayOfMapOf{className}";
				var type = new CodeTypeDeclaration();
				type.CustomAttributes.Add(
					new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.SerializableAttribute))));

				type.Name = optionalClassName;

				var baseType = new CodeTypeReference(typeof(List<>));
				var mapType = new CodeTypeReference(typeof(SerializableDictionaryStringToSomething<>));
				var genericType = new CodeTypeReference(className);
				mapType.ArrayRank = 1;
				mapType.TypeArguments.Add(genericType);
				baseType.TypeArguments.Add(mapType);

				type.BaseTypes.Add(baseType);
				return type;
		}
		return null;
	}

	/// <summary>
	/// The Optional-Array captures a type like
	/// <code>
	/// public OptionalIntArray doop;
	/// </code>
	///
	/// which internally is an <code>
	/// OptionalArray{Int}
	/// </code>
	///
	/// </summary>
	/// <param name="name"></param>
	/// <param name="schema"></param>
	/// <returns></returns>
	public static CodeTypeDeclaration GenerateOptionalArrayDecl(string name, OpenApiSchema schema)
	{
		bool isEnum = schema.Enum.Count > 0;
		switch (schema.Type, schema.Format, isEnum)
		{
			case ("array", _, _):
			case ("object", _, _):
			case (_, _, true):
				var className = SanitizeClassName(name);
				var optionalClassName = $"OptionalArrayOf{className}";
				var type = new CodeTypeDeclaration();
				type.CustomAttributes.Add(
					new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.SerializableAttribute))));

				type.Name = optionalClassName;
				var baseType = new CodeTypeReference(typeof(OptionalArray<>));
				var genericType = new CodeTypeReference(className);
				baseType.TypeArguments.Add(genericType);
				type.BaseTypes.Add(baseType);

				// add a default constructor...
				var defaultCons = new CodeConstructor();
				defaultCons.Attributes = MemberAttributes.Public;
				type.Members.Add(defaultCons);

				// add a constructor that accepts a value...
				var typedCons = new CodeConstructor();
				var argType = new CodeTypeReference(className);
				argType.ArrayRank = 1;
				typedCons.Parameters.Add(new CodeParameterDeclarationExpression(argType, "value"));
				typedCons.Attributes = MemberAttributes.Public;
				typedCons.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(nameof(Optional.HasValue)),
					new CodePrimitiveExpression(true)));
				typedCons.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(nameof(Optional<int>.Value)),
					new CodeVariableReferenceExpression("value")));
				type.Members.Add(typedCons);

				return type;
		}
		return null;
	}

	public static CodeTypeDeclaration GenerateOptionalDecl(string name)
	{
		var type = new CodeTypeDeclaration($"Optional{SanitizeClassName(name)}");

		// make sure the model is serializable
		type.CustomAttributes.Add(
			new CodeAttributeDeclaration(new CodeTypeReference(typeof(SerializableAttribute))));

		var baseType = new CodeTypeReference(typeof(Optional<>));
		type.BaseTypes.Add(baseType);
		var genericType = new CodeTypeReference(SanitizeClassName(name));
		baseType.TypeArguments.Add(genericType);

		// add a default constructor...
		var defaultCons = new CodeConstructor();
		defaultCons.Attributes = MemberAttributes.Public;
		type.Members.Add(defaultCons);

		// add a constructor that accepts a value...
		var typedCons = new CodeConstructor();
		typedCons.Parameters.Add(new CodeParameterDeclarationExpression(genericType, "value"));
		typedCons.Attributes = MemberAttributes.Public;
		typedCons.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(nameof(Optional.HasValue)),
			new CodePrimitiveExpression(true)));
		typedCons.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(nameof(Optional<int>.Value)),
			new CodeVariableReferenceExpression("value")));
		type.Members.Add(typedCons);

		return type;
	}

	/// <summary>
	/// The Optional captures a type like
	/// <code>
	/// public OptionalInt doop;
	/// </code>
	///
	/// which internally is an <code>
	/// Optional{Int}
	/// </code>
	///
	/// </summary>
	/// <param name="name"></param>
	/// <param name="schema"></param>
	/// <returns></returns>
	public static CodeTypeDeclaration GenerateOptionalDecl(string name, OpenApiSchema schema)
	{
		switch (schema.Type, schema.Format)
		{
			case ("string", _) when schema.Enum?.Count > 0:
			case ("array", _):
			case ("object", _):
				return GenerateOptionalDecl(name);
		}
		// we don't need anything, because the primitive types are already included in the code base.
		return null;

	}

	public static string ConvertEnumValueToDisplay(string networkValue)
	{
		return char.ToUpper(networkValue[0]) + networkValue.Substring(1);
	}

	public static CodeTypeDeclaration GenerateEnumModelDecl(string name, OpenApiSchema schema)
	{
		var type = new CodeTypeDeclaration(SanitizeClassName(name));
		type.IsEnum = true;

		foreach (var enumValue in schema.Enum)
		{
			// only string fields are allowed...
			if (enumValue is not OpenApiString strValue)
			{
				continue;
			}

			var field = new CodeMemberField(type.Name, ConvertEnumValueToDisplay(strValue.Value));
			type.Members.Add(field);
		}

		return type;
	}

	public static CodeTypeDeclaration GenerateEnumExtensions(string name, OpenApiSchema schema)
	{
		if (schema.Enum.Count == 0) return null;

		var type = new CodeTypeDeclaration($"{SanitizeClassName(name)}Extensions");
		var enumType = new CodeTypeReference(SanitizeClassName(name));

		var toStringMethod = new CodeMemberMethod
		{
			Name = "ToEnumString",
			Attributes = MemberAttributes.Static | MemberAttributes.Public,
			ReturnType = new CodeTypeReference(typeof(string))
		};
		toStringMethod.Parameters.Add(new CodeParameterDeclarationExpression(enumType, "val"));

		var fromStringMethod = new CodeMemberMethod
		{
			Name = "FromEnumString",
			Attributes = MemberAttributes.Static | MemberAttributes.Public,
			ReturnType = enumType
		};
		fromStringMethod.Parameters.Add(new CodeParameterDeclarationExpression(typeof(string), "str"));


		foreach (var enumValue in schema.Enum)
		{
			// only string fields are allowed...
			if (enumValue is not OpenApiString strValue)
			{
				continue;
			}

			var codeEnumValue = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(enumType), ConvertEnumValueToDisplay(strValue.Value));
			var valRef = new CodeVariableReferenceExpression("val");
			var strRef = new CodeVariableReferenceExpression("str");

			var toStringIfStatement = new CodeConditionStatement(
				new CodeBinaryOperatorExpression(codeEnumValue, CodeBinaryOperatorType.ValueEquality, valRef));
			toStringIfStatement.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(strValue.Value)));

			var fromStringIfStatement = new CodeConditionStatement(
				new CodeBinaryOperatorExpression(new CodePrimitiveExpression(strValue.Value),
					CodeBinaryOperatorType.ValueEquality, strRef));
			fromStringIfStatement.TrueStatements.Add(new CodeMethodReturnStatement(codeEnumValue));

			toStringMethod.Statements.Add(toStringIfStatement);
			fromStringMethod.Statements.Add(fromStringIfStatement);
		}

		toStringMethod.Statements.Add(new CodeThrowExceptionStatement(new CodeObjectCreateExpression(
			new CodeTypeReference(typeof(System.ArgumentException)),
			new CodePrimitiveExpression("Unknown enum value"))));

		fromStringMethod.Statements.Add(new CodeThrowExceptionStatement(new CodeObjectCreateExpression(
			new CodeTypeReference(typeof(System.ArgumentException)),
			new CodePrimitiveExpression("Unknown string value"))));


		type.Members.Add(toStringMethod);
		type.Members.Add(fromStringMethod);

		return type;
	}


	/// <inheritdoc cref="GenerateModelDecl"/>
	/// This exists for backwards test compatability.
	public static CodeTypeDeclaration GenerateModelDecl(string name, OpenApiSchema schema)
	{
		GenerateModelDecl(name, schema, out var generated, out _);
		return generated;
	}


	/// <summary>
	/// The model decl is the main type decl for an open api Schema. Its the one that actually defines
	/// all of the properties and serialization method.
	/// </summary>
	/// <param name="name"></param>
	/// <param name="schema"></param>
	/// <returns></returns>
	public static void GenerateModelDecl(string name, OpenApiSchema schema, out CodeTypeDeclaration generatedModel, out List<RequiredOneOfInterface> polymorphicFields)
	{
		polymorphicFields = new List<RequiredOneOfInterface>();
		if (schema.Enum?.Count > 0)
		{
			generatedModel = GenerateEnumModelDecl(name, schema);
			return;
		}

		var type = new CodeTypeDeclaration(SanitizeClassName(name));

		// make the type partial, so that we can extend it manually...
		type.IsPartial = true;

		// make sure the model is serializable
		type.CustomAttributes.Add(
			new CodeAttributeDeclaration(new CodeTypeReference(typeof(SerializableAttribute))));



		if (schema.Items != null)
		{
			// if the base type is a list, then add the list base class.
			if (schema.Items?.Reference?.Id != null)
			{
				type.BaseTypes.Add(new CodeTypeReference(typeof(List<>))
				{
					TypeArguments = { new CodeTypeReference(SanitizeClassName(schema.Items.Reference.Id)) }
				});
				if (schema.Properties.Count > 0)
				{
					throw new Exception(
						$"Cannot have a model type that is a list, and has properties. name=[{name}] model=[{schema.Title}] ");
				}
			}
			else
			{
				var gen = new GenSchema(schema.Items);

				var baseType = gen.GetTypeReference();
				type.BaseTypes.Add(new CodeTypeReference(typeof(List<>)) { TypeArguments = { baseType } }
				);
			}
		}

		// add the serialization interface
		type.BaseTypes.Add(new CodeTypeReference(typeof(JsonSerializable.ISerializable)));

		// add the implementation of the serialization interface as a method...
		var serializeMethod = new CodeMemberMethod();
		serializeMethod.Name = nameof(JsonSerializable.IStreamSerializer.Serialize);
		serializeMethod.Parameters.Add(
			new CodeParameterDeclarationExpression(typeof(JsonSerializable.IStreamSerializer), PARAM_SERIALIZER));
		serializeMethod.Attributes = MemberAttributes.Public;

		type.Members.Add(serializeMethod);

		var props = schema.Properties.ToList();
		props.Sort((a, b) => string.Compare(a.Key, b.Key, StringComparison.Ordinal));

		foreach (var property in props)
		{
			// construct some primitive information about this field.
			var fieldApiName = property.Key;
			var fieldSchema = property.Value;

			var isPolymorphArray = fieldSchema.Items?.OneOf?.Count > 0;
			var isPolymorphObject = fieldSchema.OneOf?.Count > 0;
			var isPolymorph = isPolymorphArray || isPolymorphObject;
			var isRequired = isPolymorph || schema.Required.Contains(fieldApiName);

			// add the field to the model type.
			var field = GenerateField(fieldApiName, fieldSchema, isRequired);
			type.Members.Add(field);

			// add the field's serialization to the serializeMethod.
			var serializationStatement = GenerateSerializationStatement(type, fieldSchema, field, fieldApiName, isRequired);
			if (serializationStatement != null)
			{
				serializeMethod.Statements.Add(serializationStatement);
			}

			// if the fieldSchema introduced an anonymous enum, we need to handle it.
			if (fieldSchema.Enum?.Count > 0 && fieldSchema.Reference == null)
			{
				var enumName = $"{type.Name}_{field.Name}";
				field.Type = new CodeTypeReference(enumName);
				var innerEnum = GenerateEnumModelDecl(enumName, fieldSchema);
				var innerExtensions = GenerateEnumExtensions(enumName, fieldSchema);

				type.Members.Add(innerEnum);
				type.Members.Add(innerExtensions);
			}

			RequiredOneOfInterface HandleOneOf(IList<OpenApiSchema> oneOf)
			{
				var interfaceName = OneOfClassName(oneOf);
				var innerInterface = new CodeTypeDeclaration(interfaceName) { IsInterface = true };
				innerInterface.BaseTypes.Add(new CodeTypeReference(typeof(JsonSerializable.ISerializable)));
				innerInterface.IsPartial = true;

				var factoryName = interfaceName + "Factory";
				var factoryType = new CodeTypeDeclaration(factoryName);

				var factoryBaseType = new CodeTypeReference(typeof(JsonSerializable.TypeLookupFactory<>));
				factoryBaseType.TypeArguments.Add(new CodeTypeReference(interfaceName));
				factoryType.BaseTypes.Add(factoryBaseType);

				var factoryConstructor = new CodeConstructor { Attributes = MemberAttributes.Public };
				factoryType.Members.Add(factoryConstructor);
				foreach (var child in oneOf)
				{
					var childClassName = SanitizeClassName(child.Reference.Id);
					var referencedSchema = schema.Reference.HostDocument.Components.Schemas[child.Reference.Id];
					if (!referencedSchema.Properties.TryGetValue("type", out var childTypeProperty))
					{
						throw new Exception("Cannot construct oneOf to types that do not have internal type field");
					}

					if (!(childTypeProperty.Default is OpenApiString openApiStr))
					{
						openApiStr = new OpenApiString(childClassName);
					}
					var statement = new CodeExpressionStatement(new CodeMethodInvokeExpression(
						method: new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), nameof(JsonSerializable.TypeLookupFactory<JsonSerializable.ISerializable>.Add))
						{
							TypeArguments = { new CodeTypeReference(childClassName) }
						},
						parameters: new CodePrimitiveExpression(openApiStr.Value)));
					factoryConstructor.Statements.Add(statement);
				}

				return new RequiredOneOfInterface
				{
					interfaceName = interfaceName,
					childTypeSchemas = oneOf,
					type = innerInterface,
					optionalType = GenerateOptionalDecl(interfaceName),
					serializationFactoryType = factoryType
				};

			}

			if (isPolymorphArray)
			{
				polymorphicFields.Add(HandleOneOf(fieldSchema.Items.OneOf));
			}

			if (isPolymorphObject)
			{
				polymorphicFields.Add(HandleOneOf(fieldSchema.OneOf));
			}
		}

		generatedModel = type;
	}

	/// <summary>
	/// Generating a field decl for a model schema
	/// </summary>
	/// <param name="fieldName"></param>
	/// <param name="schema"></param>
	/// <param name="isRequired">If false, the field type will be an Optional</param>
	/// <returns></returns>
	public static CodeMemberField GenerateField(string fieldName, OpenApiSchema schema, bool isRequired)
	{
		var fieldSchema = new GenSchema(schema);
		var field = new CodeMemberField();

		field.Name = SanitizeFieldName(fieldName);
		field.Type = isRequired ? fieldSchema.GetTypeReference() : fieldSchema.GetOptionalTypeReference();
		field.Attributes = MemberAttributes.Public;

		// the init expression is only required when its an object of some sort...
		if (!isRequired || schema.Type == "object" || schema.Reference != null)
		{
			field.InitExpression = new CodeObjectCreateExpression(field.Type);
		}

		return field;
	}

	/// <summary>
	/// The schemaName may be invalid C# for a className, so transform it into something valid
	/// </summary>
	/// <param name="schemaName"></param>
	/// <returns></returns>
	public static string SanitizeClassName(string schemaName)
	{
		var className = SanitizeFieldName(schemaName.Replace(" ", ""));
		return className; // TODO: add upercasing and all that..
	}

	public static string OneOfClassName(IList<OpenApiSchema> schemas)
	{
		var oneOfStrs = string.Join("Or", schemas.Select(x => x.Title.Capitalize()).ToList());
		return "IOneOf_" + oneOfStrs;
	}

	/// <summary>
	/// The fieldName may be invalid for C# for a fieldName, so transform it into something valid
	/// </summary>
	/// <param name="propKey"></param>
	/// <returns></returns>
	private static string SanitizeFieldName(string propKey)
	{
		string AppendKey(string str) => str + "Key";
		var protectedKeys = new HashSet<string>
		{
			// TODO: add all other C# keywords...
			"object", "event", "namespace", "do", "as", "if", "for", "fixed",
			"int", "long", "params", "string", "var", "protected", "void",
			"while", "public", "private", "class", "interface", "const"
		};

		for (var i = propKey.Length - 2; i >= 0; i--)
		{
			if (propKey[i] == '-' || propKey[i] == '/' || propKey[i] == '$')
			{
				if (i + 2 >= propKey.Length)
				{
					propKey = propKey[..i] + char.ToUpper(propKey[i + 1]);
				}
				else
				{
					propKey = propKey[..i] + char.ToUpper(propKey[i + 1]) + propKey[(i + 2)..];
				}
			}
		}

		return protectedKeys.Contains(propKey)
			? AppendKey(propKey)
			: propKey;
	}

	/// <summary>
	/// Every field in a model declr needs to have a corresponding serialization statement in the serialization method.
	/// This function will produce the code statement that correctly serializes the field.
	///
	/// If the given field is an Optional field (<see cref="isRequired"/> would be false), then
	/// the serialization logic is complicated, because we CANNOT serialize the property if it doesn't have value.
	/// This means we need to do an <i>if</i> statement.
	///
	/// But for fields that are required, then the statement is just a simple serialization.
	/// </summary>
	/// <param name="schema"></param>
	/// <param name="field"></param>
	/// <param name="apiFieldName"></param>
	/// <param name="isRequired"></param>
	/// <returns></returns>
	public static CodeStatement GenerateSerializationStatement(CodeTypeDeclaration modelType, OpenApiSchema schema, CodeMemberField field, string apiFieldName, bool isRequired)
	{
		// first, we need to figure out which serialization method to use.
		var hasMethod = GetSerializationMethodReference(modelType, field, schema, out var invokeSerializationMethod, out var extraParameters);

		// and if there is not valid serialization method, then we cannot serialize this field
		if (!hasMethod) return null;


		var varRef = new CodeSnippetExpression($"ref {field.Name}");
		var referenceField = new CodeVariableReferenceExpression(field.Name);
		var serializeName = new CodePrimitiveExpression(apiFieldName);

		List<CodeExpression> methodParams = null;

		// if the field is required, we can simply return the usage of the serialization method...
		if (isRequired)
		{
			methodParams = new List<CodeExpression> { serializeName, varRef };
			methodParams.AddRange(extraParameters);
			return new CodeExpressionStatement(new CodeMethodInvokeExpression(invokeSerializationMethod, methodParams.ToArray()));
		}
		// but otherwise, the field is an Optional, and we need to construct an if statement...

		// create an expression that answers the question, "does the optional field have a value?"
		var hasValueExpr = new CodeFieldReferenceExpression(referenceField, nameof(Optional.HasValue));

		// create an expression that answers the question, "does the json contain a key for this field?"
		var hasKeyExpr =
			new CodeMethodInvokeExpression(new CodeArgumentReferenceExpression(PARAM_SERIALIZER), nameof(JsonSerializable.IStreamSerializer.HasKey), serializeName);

		// create an expression that answers the question, "is the optional _itself_ not null?"
		var valueIsNotNullExpr = new CodeBinaryOperatorExpression(referenceField,
			CodeBinaryOperatorType.IdentityInequality,
			new CodeDefaultValueExpression(field.Type));

		// create an expression that translates roughly to
		//  (hasKeyExpr) || (valueIsNotNullExpr && hasValueExpr)
		// which in english, sounds like, "is there json to serialize, OR, is the optional non-null and valued?"
		var shouldSerializeExpr = new CodeBinaryOperatorExpression(hasKeyExpr, CodeBinaryOperatorType.BooleanOr,
			new CodeBinaryOperatorExpression(valueIsNotNullExpr, CodeBinaryOperatorType.BooleanAnd, hasValueExpr));

		methodParams = new List<CodeExpression>
		{
			serializeName,
			new CodeFieldReferenceExpression(varRef, nameof(Optional<int>.Value))
		};
		methodParams.AddRange(extraParameters);

		// create the if-statement that uses the expression...
		var conditionStatement =
			new CodeConditionStatement(shouldSerializeExpr,

				// in the positive case on the conditional, call the serialize method
				new CodeExpressionStatement(new CodeMethodInvokeExpression(invokeSerializationMethod, methodParams.ToArray())),

				// and set set the optional to have a value
				new CodeAssignStatement(new CodeFieldReferenceExpression(referenceField, nameof(Optional.HasValue)), new CodePrimitiveExpression(true)));
		return conditionStatement;

	}

	/// <summary>
	/// Given a openAPI schema, the _way_ we serialize it is different.
	/// We'll always call one of the following...
	/// <list type="numbered">
	/// <item> Serialize </item>
	/// <item> SerializeArray </item>
	/// <item> SerializeDictionary </item>
	/// </list>
	///
	/// But knowing _which_ one is tricky, and it involves checking for the type of the schema.
	/// Pretty much, if the schema is a Map type, we'd use <i>SerializeDictionary</i>, and if its an Array type, we'd use <i>SerializeArray</i>
	/// </summary>
	/// <param name="schema"></param>
	/// <returns></returns>
	private static bool GetSerializationMethodReference(CodeTypeDeclaration modelType, CodeMemberField field, OpenApiSchema schema, out CodeMethodReferenceExpression methodExpr, out List<CodeExpression> parameters)
	{
		methodExpr = null;
		parameters = new List<CodeExpression>();

		switch (schema.Type)
		{
			case "string" when schema.Enum?.Count > 0 && schema.Reference != null:
				methodExpr = new CodeMethodReferenceExpression(new CodeArgumentReferenceExpression(PARAM_SERIALIZER),
					nameof(ISerializableExtension.SerializeEnum));
				var extensionClass = new CodeTypeReferenceExpression($"{schema.Reference.Id}Extensions");
				parameters.Add(new CodeMethodReferenceExpression(extensionClass, "ToEnumString"));
				parameters.Add(new CodeMethodReferenceExpression(extensionClass, "FromEnumString"));

				return true;
			case "string" when schema.Enum?.Count > 0:
				var anonName = $"{modelType.Name}_{field.Name}";

				methodExpr = new CodeMethodReferenceExpression(new CodeArgumentReferenceExpression(PARAM_SERIALIZER),
					nameof(ISerializableExtension.SerializeEnum));
				var anonExtensionClass = new CodeTypeReferenceExpression($"{anonName}Extensions");
				parameters.Add(new CodeMethodReferenceExpression(anonExtensionClass, "ToEnumString"));
				parameters.Add(new CodeMethodReferenceExpression(anonExtensionClass, "FromEnumString"));


				return true;
			case "string" when schema.Format == "date-time":
				// use the default serialize method.
				methodExpr = new CodeMethodReferenceExpression(new CodeArgumentReferenceExpression(PARAM_SERIALIZER),
					nameof(JsonSerializable.IStreamSerializer.Serialize));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ssZ"));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ss.fZ"));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ss.ffZ"));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ss.fffZ"));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ss.ffffZ"));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ss.fffffZ"));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ss.ffffffZ"));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ss.fffffffzzz"));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ss.ffffffffzzz"));
				parameters.Add(new CodePrimitiveExpression("yyyy-MM-ddTHH:mm:ss.fffffffffzzz"));
				return true;
			case "object" when schema.Extensions.ContainsKey("x-beamable-json-object"):
				methodExpr = new CodeMethodReferenceExpression(new CodeArgumentReferenceExpression(PARAM_SERIALIZER),
					nameof(JsonSerializable.IStreamSerializer.SerializeNestedJson));
				return true;
			case "object" when schema.AdditionalPropertiesAllowed:
				var method = new CodeMethodReferenceExpression(new CodeArgumentReferenceExpression(PARAM_SERIALIZER),
					nameof(JsonSerializable.IStreamSerializer.SerializeDictionary));

				// map types will ALWAYS be string->something, so to figure out what "something" is, check the openAPI's additionalProperties...
				var elemType = new GenSchema(schema.AdditionalProperties).GetTypeReference();

				var keyType = new GenSchema(schema).GetTypeReference();
				method.TypeArguments.Add(keyType);
				method.TypeArguments.Add(elemType);

				methodExpr = method;
				return true;
			case "array" when schema.Items?.AdditionalProperties?.Reference != null:
				methodExpr = new CodeMethodReferenceExpression(new CodeArgumentReferenceExpression(PARAM_SERIALIZER),
					nameof(JsonSerializable.IStreamSerializer.SerializeList));
				return true;
			case "array":
				// use the array serialization
				methodExpr = new CodeMethodReferenceExpression(new CodeArgumentReferenceExpression(PARAM_SERIALIZER),
					nameof(JsonSerializable.IStreamSerializer.SerializeArray));
				return true;
			default:
				// we just cannot support the serialization of unspecified object types, so don't serialize.
				var isTypeEmptyOrObject = string.IsNullOrEmpty(schema.Type) || schema.Type == "object";
				var hasReference = schema.Reference != null;
				var isPolyMorph = schema.OneOf?.Count > 0;

				if (isTypeEmptyOrObject && !hasReference && !isPolyMorph) return false;

				// use the default serialize method.
				methodExpr = new CodeMethodReferenceExpression(new CodeArgumentReferenceExpression(PARAM_SERIALIZER),
					nameof(JsonSerializable.IStreamSerializer.Serialize));
				return true;
		}
	}

	public static string GenerateCsharp(CodeCompileUnit unit)
	{

		CodeDomProvider provider = CodeDomProvider.CreateProvider("CSharp");
		CodeGeneratorOptions options = new CodeGeneratorOptions { BracingStyle = "C", BlankLinesBetweenMembers = false };
		var sb = new StringBuilder();
		using var sourceWriter = new StringWriter(sb);

		provider.GenerateCodeFromCompileUnit(
			unit, sourceWriter, options);
		sourceWriter.Flush();
		var source = sb.ToString();

		// CodeDom adds some comments we don't want before the namespace declaration.
		var expectedFirstLineMinusAutoGenComments = new Regex("(namespace.*\n{)|(using.*;)");
		return source.Substring(expectedFirstLineMinusAutoGenComments.Matches(source).First().Index).Insert(0, "\n");
	}
}

public class GenCodeTypeReference : CodeTypeReference
{
	public string DisplayName { get; set; }

	public string UpperDisplayName => char.ToUpper(DisplayName[0]) + DisplayName.Substring(1);

	public GenCodeTypeReference(Type runtimeType) : base(runtimeType)
	{
		DisplayName = GetDisplayName(runtimeType);
	}

	public GenCodeTypeReference(string typeName) : base(typeName)
	{
		DisplayName = typeName;
	}

	public GenCodeTypeReference(string typeName, int arrayRank) : base(typeName, arrayRank)
	{
		DisplayName = typeName;
	}


	public GenCodeTypeReference(GenCodeTypeReference type, int arrayRank) : base(type, arrayRank)
	{
		DisplayName = "ArrayOf" + type.DisplayName.Capitalize();
	}

	private static Dictionary<Type, string> _typeToDisplayName = new Dictionary<Type, string>
	{
		[typeof(int)] = "int",
		[typeof(long)] = "long",
		[typeof(short)] = "short",
		[typeof(byte)] = "byte",
		[typeof(double)] = "double",
		[typeof(float)] = "float",
		[typeof(bool)] = "bool",
		[typeof(string)] = "string",
		[typeof(Guid)] = "Guid",
	};
	public static string GetDisplayName(Type runtimeType)
	{
		if (_typeToDisplayName.TryGetValue(runtimeType, out var name))
		{
			return name;
		}

		return runtimeType.Name;
	}
}

/// <summary>
/// Given some OpenAPISchema spec, this class helps turn it into a GenCodeTypeReference codedom type
/// </summary>
public class GenSchema
{
	public OpenApiSchema Schema;

	public GenSchema(OpenApiSchema schema)
	{
		Schema = schema;
	}

	public GenCodeTypeReference GetOptionalTypeReference()
	{
		var innerType = GetTypeReference();
		var clazzName = $"Optional{innerType.UpperDisplayName}";
		return new GenCodeTypeReference(clazzName);
	}

	public CodeTypeReference GetOptionalTypeReferenceGeneric()
	{
		var innerType = GetTypeReference();
		var typeRef = new CodeTypeReference(typeof(Optional<>));
		typeRef.TypeArguments.Add(innerType);
		return typeRef;
	}

	public GenCodeTypeReference GetTypeReference()
	{
		switch (Schema?.Type, Schema?.Format, Schema?.Reference?.Id)
		{
			case ("array", _, _) when Schema?.Items?.OneOf?.Count > 0:
				var className = UnityHelper.OneOfClassName(Schema.Items.OneOf);
				return new GenCodeTypeReference(className, 1);
			case ("array", _, _) when Schema.Items.Reference == null:
				var genElem = new GenSchema(Schema.Items);
				var elemType = genElem.GetTypeReference();
				var output = new GenCodeTypeReference(elemType, 1);

				return output;
			case ("array", _, _) when Schema.Items.Reference != null:
				var referenceType = new GenCodeTypeReference(Schema.Items.Reference.Id);
				return new GenCodeTypeReference(referenceType, 1);
			case ("object", _, var referenceId) when (referenceId == "OptionalJsonNodeWrapper" && (Schema?.Extensions.TryGetValue("x-beamable-json-object", out var _) ?? false)):
				return new GenCodeTypeReference(typeof(JsonString));
			case var (_, _, referenceId) when !string.IsNullOrEmpty(referenceId):
				return new GenCodeTypeReference(referenceId);
			case (_, _, _) when Schema.OneOf?.Count > 0:
				return new GenCodeTypeReference(UnityHelper.OneOfClassName(Schema.OneOf));
			case ("object", _, _) when Schema.Reference == null && Schema.AdditionalPropertiesAllowed:
				var genValues = new GenSchema(Schema.AdditionalProperties);
				var genType = genValues.GetTypeReference();
				var mapTypeName = $"MapOf{genType.UpperDisplayName}";
				var type = new GenCodeTypeReference(mapTypeName);
				return type;
			case ("object", _, _) when Schema.Reference == null && !Schema.AdditionalPropertiesAllowed:
				throw new Exception("Cannot build a reference to a schema that is just an object...");
			case ("number", "float", _):
				return new GenCodeTypeReference(typeof(float));
			case ("number", "double", _):
			case ("number", _, _):
				return new GenCodeTypeReference(typeof(double));
			case ("boolean", _, _):
				return new GenCodeTypeReference(typeof(bool));
			case ("string", "uuid", _):
				return new GenCodeTypeReference(typeof(Guid));
			case ("string", "byte", _):
				return new GenCodeTypeReference(typeof(byte));
			case ("string", "date-time", _):
				return new GenCodeTypeReference(typeof(DateTime));
			case ("string", _, _) when (Schema?.Extensions.TryGetValue("x-beamable-object-id", out var ext) ?? false):
				return new GenCodeTypeReference(typeof(string));
			case ("System.String", _, _):
			case ("string", _, _):
				return new GenCodeTypeReference(typeof(string));
			case ("integer", "int16", _):
				return new GenCodeTypeReference(typeof(short));
			case ("integer", "int32", _):
				return new GenCodeTypeReference(typeof(int));
			case ("integer", "int64", _):
				return new GenCodeTypeReference(typeof(long));
			case ("integer", _, _):
				return new GenCodeTypeReference(typeof(int));
			default:
				return new GenCodeTypeReference(typeof(object));
		}
	}
}
