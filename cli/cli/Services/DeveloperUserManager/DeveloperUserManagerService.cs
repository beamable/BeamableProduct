
using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Auth;
using Beamable.Api.Autogenerated.Inventory;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Realms;
using Beamable.Api.Autogenerated.Stats;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Realms;
using Beamable.Common.BeamCli;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Server;
using Beamable.Tooling.Common;
using cli.Content;
using Newtonsoft.Json;
using System.Runtime.CompilerServices;
using System.Threading.Channels;
using IInventoryApi = Beamable.Api.Autogenerated.Inventory.IInventoryApi;
using InventoryUpdateRequest = Beamable.Api.Autogenerated.Models.InventoryUpdateRequest;
using IRealmsApi = Beamable.Api.Autogenerated.Realms.IRealmsApi;
using ItemCreateRequest = Beamable.Api.Autogenerated.Models.ItemCreateRequest;
using ItemDeleteRequest = Beamable.Api.Autogenerated.Models.ItemDeleteRequest;

namespace cli.Services.DeveloperUserManager;

public enum DeveloperUserType
{
	Temporary,
	Shared,
	Local
}

public class LocalDeveloperUserFileChanges
{
	public List<ChangedDeveloperUserInfoFile> AllFileChanges;
}

[CliContractType, Serializable]
public class DeveloperUserResult
{
	public List<DeveloperUserData> CreatedUsers;
	public List<DeveloperUserData> DeletedUsers;
	public List<DeveloperUserData> UpdatedUsers;
	public List<DeveloperUserData> SavedUsers;
}

[CliContractType, Serializable]
public class DeveloperUserData
{
	public int DeveloperUserType;

	public long GamerTag;
	
	public long TemplatedGamerTag;
	
	public long CreateByGamerTag;

	public string AccessToken = "";
	public string RefreshToken = "";
	public long ExpiresIn;
	public string Pid = "";
	public string Cid = "";
	
	public string Alias = "";

	public string Description = "";
}


public struct ChangedDeveloperUserInfoFile
{
	public long GamerTag;
	
	public string FullFilePath;
	public string OldFullFilePath;

	public bool WasDeleted() => string.IsNullOrEmpty(FullFilePath) && !string.IsNullOrEmpty(OldFullFilePath);
	public bool WasCreated() => !string.IsNullOrEmpty(FullFilePath) && string.IsNullOrEmpty(OldFullFilePath);
	public bool WasRenamed() => !WasDeleted() && !WasCreated() && FullFilePath != OldFullFilePath;
	public bool WasChanged() => !WasCreated() && !WasDeleted() && FullFilePath == OldFullFilePath;
}


// This will represent the cached information for the developer user
[Serializable]
public struct DeveloperUser
{
	[JsonIgnore] 
	public string Identifier; // The identifier used to get this user
	
	// User Management Info
	[JsonIgnore]
	public long GamerTag;
	
	[JsonIgnore]
	public long CreatedDate;

	public long TemplateGamerTag; // Use to reset to template
	public string Alias;
	public string Description;
	public string[] Tags;
	
	// Backend info
	public string AccessToken;
	public string RefreshToken;
	public long ExpiresIn;
	public string Pid;
	public string Cid;
	public long CreatedByGamerTag;

	public DeveloperUser(long gamerTag, long templateGamerTag, TokenResponse tokenResponse, string cid, string pid, string alias, long createdByGamerTag, string description, string[] tags) : this()
	{
		UpdateToken(tokenResponse);
		Cid = cid;
		Pid = pid;
		GamerTag = gamerTag;
		CreatedByGamerTag = createdByGamerTag;
		TemplateGamerTag = templateGamerTag;
		
		Alias = alias;
		Description = description;
		Tags = tags;
	}



	public void UpdateToken(TokenResponse tokenResponse)
	{
		AccessToken = tokenResponse.access_token;
		RefreshToken = tokenResponse.refresh_token;
		ExpiresIn = tokenResponse.expires_in;
	}

	public void UpdateUserInfo(string alias, string description)
	{
		Alias = alias;
		Description = description;
	}

	public void UpdateUserTags(string[] tags)
	{
		Tags = tags;
	}
}

public class DeveloperUserInfo
{
	public bool HasDeveloperUserInfo; 
	
	public DeveloperUser DeveloperUser;
	
	public DeveloperUserType UserType;
}

public class DeveloperUserManagerService
{
	public static string TemporaryUserPath = "TemporaryUser";
	public static string SharedUserPath = "SharedUser";
	public static string LocalUserPath = "LocalUser";
	public static string BaseUserPath = "DeveloperUser";
	
	private IAppContext _appContext;
	private ConfigService _configService;
	private IDependencyProvider _dependencyProvider;
	
	
	// Watchers for the long run ps command
	// Pid / FileSystemWatcher
	private Dictionary<DeveloperUserType, FileSystemWatcher> _watchers = new();
	
	private readonly Channel<ChangedDeveloperUserInfoFile> _channelChangedDeveloperUserFiles;

	public DeveloperUserManagerService(IAppContext appContext, ConfigService configService, IDependencyProvider dependencyProvider)
	{
		_dependencyProvider = dependencyProvider;
		_configService = configService;
		_appContext = appContext;
		
		_channelChangedDeveloperUserFiles = Channel.CreateUnbounded<ChangedDeveloperUserInfoFile>(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = false, AllowSynchronousContinuations = true, });
	}
	public async Task CreateUserFromTemplate(string identifier, string alias = "", string description = "", string[] tags = null)
	{
		var authApi = _dependencyProvider.GetService<IAuthApi>();
		var accountApi = _dependencyProvider.GetService<IAccountsApi>();

		DeveloperUserInfo templateUserInfo = LoadCachedUserInfo(identifier);

		if (!CheckIfUserExists(templateUserInfo))
		{
			throw new CliException("Template user does not exist");
		}
		
		if (!string.IsNullOrEmpty(alias))
		{
			var allDeveloperUserInfo = LoadAllDeveloperUserInfo();
			
			foreach (var developerUserInfo in allDeveloperUserInfo)
			{
				if (developerUserInfo.DeveloperUser.Alias == alias)
				{
					throw new CliException($"The alias [{alias}] already exists.");
				}
			}
		}

		var adminMe = await accountApi.GetAdminMe();
		
		TokenResponse tokenResponse = await authApi.PostToken(new TokenRequestWrapper()
		{
			grant_type = "guest"
		}, includeAuthHeader: false);

		var accountsApi = CreateAccountsApi(tokenResponse.access_token, tokenResponse.refresh_token, _appContext.Cid, _appContext.Pid);
		
		AccountPlayerView accountPlayerView = await accountsApi.GetMe();

		DeveloperUser developerUser = new DeveloperUser(accountPlayerView.id, templateUserInfo.DeveloperUser.GamerTag, tokenResponse, _appContext.Cid, _appContext.Pid, alias, adminMe.id, description, tags);

		await SaveUser(developerUser, DeveloperUserType.Local);

		await CopyState(templateUserInfo.DeveloperUser, developerUser);
	}
	
	public async Task<List<DeveloperUser>> CreateUserFromTemplate(List<string> identifier, Dictionary<string, int> amountPerIdentifier, int rollingBufferSize)
	{
		var authApi = _dependencyProvider.GetService<IAuthApi>();
		var accountApi = _dependencyProvider.GetService<IAccountsApi>();
		
		var except = identifier.Except(amountPerIdentifier.Keys).ToList();
		if (except.Count() != 0)
		{
			throw new CliException($"Missing amount for identifiers {string.Join("-", except)}");
		}


		List<DeveloperUserInfo> templateUsersInfo = LoadCachedUsersInfo(identifier);

		List<string> missingUsers = new List<string>();
		foreach (var templateUserInfo in templateUsersInfo)
		{
			if (!CheckIfUserExists(templateUserInfo))
			{
				missingUsers.Add($"{templateUserInfo.DeveloperUser.Alias} - {templateUserInfo.DeveloperUser.GamerTag}");
			}
		}

		if (missingUsers.Count > 0)
		{
			throw new CliException($"Missing users for template {string.Join("-", missingUsers)}");
		}
		
		var adminMe = await accountApi.GetAdminMe();

		List<Task<DeveloperUser>> createUserTaskBatch = new List<Task<DeveloperUser>>();
		
		foreach (var templateUserInfo in templateUsersInfo)
		{
			for (int i = 0; i < amountPerIdentifier[templateUserInfo.DeveloperUser.Identifier]; i++)
			{
				createUserTaskBatch.Add(CreateUserFromTemplate(authApi, adminMe, templateUserInfo));
			}
		}

		await Task.WhenAll(createUserTaskBatch);

		RemoveOlderEntriesFromCachedBuffer(rollingBufferSize);

		return createUserTaskBatch.Select(developerTask => developerTask.Result).ToList();
	}

	private async Task<DeveloperUser> CreateUserFromTemplate(IAuthApi authApi, AccountPortalView adminMe, DeveloperUserInfo templateUserInfo)
	{
		TokenResponse tokenResponse = await authApi.PostToken(new TokenRequestWrapper()
		{
			grant_type = "guest"
		}, includeAuthHeader: false);

		var accountsApi = CreateAccountsApi(tokenResponse.access_token, tokenResponse.refresh_token, _appContext.Cid, _appContext.Pid);
		
		AccountPlayerView accountPlayerView = await accountsApi.GetMe();
		
		var temporaryDescription =  $"Created from template {templateUserInfo.DeveloperUser.Alias} - {templateUserInfo.DeveloperUser.GamerTag}"; 
		DeveloperUser developerUser = new DeveloperUser(accountPlayerView.id, templateUserInfo.DeveloperUser.GamerTag, tokenResponse, _appContext.Cid, _appContext.Pid, "", adminMe.id, temporaryDescription , new string[] { });

		await CopyState(templateUserInfo.DeveloperUser, developerUser);

		await SaveUser(developerUser);

		return developerUser;
	}

	private void RemoveOlderEntriesFromCachedBuffer(int rollingBufferSize)
	{

		List<DeveloperUser> developerUsers = GetAllUsersOfType(DeveloperUserType.Temporary);
		
		developerUsers.Sort((x, y) =>
		{
			return y.CreatedDate.CompareTo(x.CreatedDate);
		});

		for (int i = rollingBufferSize; i < developerUsers.Count; i++)
		{
			DeleteUser(developerUsers[i]);
		}
	}

	// Create a user from a template user
	public async Task CreateUser(string alias = "", string description = "", string[] tags = null)
	{
		if (!string.IsNullOrEmpty(alias))
		{
			var allDeveloperUserInfo = LoadAllDeveloperUserInfo();
			
			foreach (var developerUserInfo in allDeveloperUserInfo)
			{
				if (developerUserInfo.DeveloperUser.Alias == alias)
				{
					throw new CliException($"The alias [{alias}] already exists.");
				}
			}
		}

		var authApi = _dependencyProvider.GetService<AuthApi>();
		var accountApi = _dependencyProvider.GetService<IAccountsApi>();

		var adminMe = await accountApi.GetAdminMe();

		// Create a new guest user
		TokenResponse tokenResponse = await authApi.PostToken(new TokenRequestWrapper()
		{
			grant_type = "guest"
		}, includeAuthHeader: false);
		
		var accountsApi = CreateAccountsApi(tokenResponse.access_token, tokenResponse.refresh_token, _appContext.Cid, _appContext.Pid);
		
		// Get the new guest user info
		AccountPlayerView accountPlayerView = await accountsApi.GetMe();
		
		DeveloperUser developerUser = new DeveloperUser(accountPlayerView.id, 0, tokenResponse, _appContext.Cid, _appContext.Pid, alias, adminMe.id, description, tags);
		
		await SaveUser(developerUser);
	}

	// Copy state from a developer user to another
	public async Task CopyState(DeveloperUser sourceDeveloperUser, DeveloperUser targetDeveloperUser)
	{
		var realmsApi = _dependencyProvider.GetService<IRealmsApi>();
		var res = await realmsApi.GetAdminCustomer();
		var secretMap = res.customer.projects.ToDictionary(p => p.name, p=> p.secret);
		
		// Copy the inventory state from a source developer user to a target developer user
		await CopyInventoryState(sourceDeveloperUser, targetDeveloperUser, secretMap);

		// Copy the stats state from a source developer user to a target developer user
		await CopyStatsState(sourceDeveloperUser, targetDeveloperUser, secretMap);
	}

	private async Task CopyInventoryState(DeveloperUser sourceDeveloperUser, DeveloperUser targetDeveloperUser, Dictionary<string, string> secretMap)
	{
		if (!secretMap.ContainsKey(sourceDeveloperUser.Pid))
		{
			throw new CliException($"There's no secret realm key for the source developer pid {sourceDeveloperUser.Pid}");
		}

		if (!secretMap.ContainsKey(targetDeveloperUser.Pid))
		{
			throw new CliException($"There's no secret realm key for the target developer pid {sourceDeveloperUser.Pid}");
		}
	
		var sourceInventoryApi = CreateInventoryApi(sourceDeveloperUser.GamerTag, sourceDeveloperUser.Cid, sourceDeveloperUser.Pid, secretMap[sourceDeveloperUser.Pid]);
		
		var targetInventoryApi = CreateInventoryApi(targetDeveloperUser.GamerTag, targetDeveloperUser.Cid, targetDeveloperUser.Pid, secretMap[targetDeveloperUser.Pid]);

		
		// Get the target account
		InventoryView targetInventoryView = await targetInventoryApi.ObjectGet(targetDeveloperUser.GamerTag);
		
		// Get the source inventory
		InventoryView sourceInventoryView = await sourceInventoryApi.ObjectGet(sourceDeveloperUser.GamerTag);

		InventoryUpdateRequest inventoryUpdateRequest = new InventoryUpdateRequest();

		List<ItemDeleteRequest> deleteRequests = new List<ItemDeleteRequest>();
		
		// Delete items from the inventory 
		foreach (var itemGroup in targetInventoryView.items)
		{
			foreach (var item in itemGroup.items)
			{
				deleteRequests.Add(new ItemDeleteRequest()
				{
					contentId = itemGroup.id,
					id = item.id
				});
			}
		}
		
		inventoryUpdateRequest.deleteItems.Set(deleteRequests.ToArray());

		List<ItemCreateRequest> createdItems = new List<ItemCreateRequest>();
		
		// Add items from source to target
		foreach (var itemGroup in sourceInventoryView.items)
		{
			foreach (var item in itemGroup.items)
			{
				createdItems.Add(new ItemCreateRequest()
				{
					contentId = itemGroup.id,
					properties = item.properties
				});
			}
		}
		
		inventoryUpdateRequest.newItems.Set(createdItems.ToArray());
		
		MapOfLong currencies = new MapOfLong();
		// Set all currency to zero
		foreach (var currency in targetInventoryView.currencies)
		{
			currencies.Add(currency.id, -currency.amount);
		}
		
		// Set all currency as the source
		foreach (var currency in sourceInventoryView.currencies)
		{
			if (currencies.ContainsKey(currency.id))
			{
				currencies[currency.id] += currency.amount;
			}
			else
			{
				currencies.Add(currency.id, currency.amount);
			}

		}
		
		inventoryUpdateRequest.currencies.Set(currencies);
		
		await targetInventoryApi.ObjectPut(targetDeveloperUser.GamerTag, inventoryUpdateRequest);
	}

	private async Task CopyStatsState(DeveloperUser sourceDeveloperUser, DeveloperUser targetDeveloperUser, Dictionary<string, string> secretMap)
	{
		StatsApi adminStatsApi = CreateStatsApi(sourceDeveloperUser.GamerTag, _appContext.Cid, _appContext.Pid, secretMap[_appContext.Pid]);
		
		Dictionary<string, StatsResponse> sourceStatMap = await GetStatMap(sourceDeveloperUser.GamerTag, adminStatsApi);
		
		Dictionary<string, StatsResponse> targetStatMap = await GetStatMap(targetDeveloperUser.GamerTag, adminStatsApi);
		
		// return;
		// As we don't have a batch delete for stats it will delete one by one.
		List<Task> deleteStatTasks = new List<Task>();
		foreach (var targetStatKeyPair in targetStatMap)
		{
			foreach (var stat in targetStatKeyPair.Value.stats)
			{
				string objectId = string.Format(targetStatKeyPair.Key, targetDeveloperUser.GamerTag);
				deleteStatTasks.Add(adminStatsApi.ObjectDelete(objectId, new StatRequest
				{
					stats = new OptionalString(stat.Key)
				}).TaskFromPromise()); 
			}
		}
		
		await Task.WhenAll(deleteStatTasks.ToArray());
		
		foreach (var sourceStatKeyPair in sourceStatMap)
		{
			string objectId = string.Format(sourceStatKeyPair.Key, targetDeveloperUser.GamerTag);

			StatUpdateRequest statUpdateRequest = new StatUpdateRequest() { set = new OptionalMapOfString(sourceStatKeyPair.Value.stats) };
				
			await adminStatsApi.ObjectPost(objectId, statUpdateRequest);
		}
	}



	public async Task SaveUser(DeveloperUser developerUser, DeveloperUserType developerUserType = DeveloperUserType.Temporary)
	{
		// if exists don't
		string directoryPath = GetFullPath(developerUserType);
		
		if (string.IsNullOrEmpty(directoryPath))
		{
			throw new ArgumentNullException(nameof(directoryPath));
		}
		
		string developerUserJson = JsonConvert.SerializeObject(developerUser, Formatting.Indented);

		if (!Directory.Exists(directoryPath))
		{
			Directory.CreateDirectory(directoryPath);
		}
	
		string fileFullPath = Path.Combine(directoryPath, developerUser.GamerTag + ".json");
		await File.WriteAllTextAsync(fileFullPath, developerUserJson);
	}
	
	public async Task SaveUsers(List<DeveloperUser> developerUsers, DeveloperUserType developerUserType = DeveloperUserType.Temporary)
	{
		// if exists don't
		string directoryPath = GetFullPath(developerUserType);
		
		if (string.IsNullOrEmpty(directoryPath))
		{
			throw new ArgumentNullException(nameof(directoryPath));
		}

		List<Task> writeUserTasks = new List<Task>();
		foreach (var developerUser in developerUsers)
		{
			string developerUserJson = JsonConvert.SerializeObject(developerUser, Formatting.Indented);

			if (!Directory.Exists(directoryPath))
			{
				Directory.CreateDirectory(directoryPath);
			}
	
			string fileFullPath = Path.Combine(directoryPath, developerUser.GamerTag + ".json");
			writeUserTasks.Add( File.WriteAllTextAsync(fileFullPath, developerUserJson) );
		}
		
		await Task.WhenAll(writeUserTasks);
	}

	public void DeleteUser(DeveloperUser developerUser, DeveloperUserType developerUserType = DeveloperUserType.Temporary)
	{
		string directoryPath = GetFullPath(developerUserType);
		
		string fileFullPath = Path.Combine(directoryPath, developerUser.GamerTag + ".json");
		
		File.Delete(fileFullPath);
	}
	public DeveloperUserInfo LoadCachedUserInfo(string identifier)
	{
		return LoadCachedUsersInfo(new List<string>() { identifier })[0];
	}

	public List<DeveloperUserInfo> LoadCachedUsersInfo(List<string> identifiers)
	{
		List<DeveloperUserInfo> cachedUsersResult = new List<DeveloperUserInfo>();
		foreach (DeveloperUserType type in Enum.GetValues(typeof(DeveloperUserType)))
		{
			if (TryGetCachedUser(identifiers, type, out List<DeveloperUser> cachedUsers))
			{
				cachedUsersResult.AddRange(cachedUsers.Select(cachedUser => new DeveloperUserInfo
				{
					HasDeveloperUserInfo = true,
					DeveloperUser = cachedUser,
					UserType = type
				}));
			}
		}

		if (cachedUsersResult.Count == identifiers.Count)
		{
			return cachedUsersResult;
		}

		IEnumerable<string> missingIdentifiers = cachedUsersResult.Select(item => item.DeveloperUser.Alias);
		missingIdentifiers = missingIdentifiers.Concat(cachedUsersResult.Select(item => item.DeveloperUser.GamerTag.ToString()));
		
		return identifiers.Except(missingIdentifiers).Select(identifier =>  new DeveloperUserInfo
		{
			HasDeveloperUserInfo = false,
			DeveloperUser = new DeveloperUser
			{
				Alias = identifier
			}
		}).ToList();
	}

	public async IAsyncEnumerable<LocalDeveloperUserFileChanges> ListenToLocalDeveloperUserFileChanges(DeveloperUserType developerUserType, [EnumeratorCancellation] CancellationToken token = default)
	{

		_watchers.Add(developerUserType, new FileSystemWatcher());

		// We need to keep track of the last write time for each content file in order to disambiguate multiple events firing simultaneously for the same file.
		// For example, on Windows, a Created event is always fired alongside a Changed event of the same file (because of "reasons", I guess)
		// This dictionary helps us fire off only one relevant event at a time even when the file watcher gets confused about the desireable semantics...
		var eventDisambiguationHelper = new Dictionary<string, long>();
		
		// Set up the file watcher...
		var watcher = _watchers[developerUserType];
		watcher.BeginInit();
		watcher.Path = GetFullPath(developerUserType);
		watcher.IncludeSubdirectories = true;
		watcher.Filter = "*.json";
		watcher.EnableRaisingEvents = true;
		watcher.NotifyFilter = (NotifyFilters.Attributes |
		                        NotifyFilters.CreationTime |
		                        NotifyFilters.DirectoryName |
		                        NotifyFilters.FileName |
		                        NotifyFilters.LastWrite);
		watcher.Error += (_, e) => Log.Error(e.GetException().ToString());
		watcher.Disposed += (_, e) => Log.Error($"Disposed {e}");
		watcher.Created += (_, e) => { OnLocalRealmDeveloperUserFilesChanged(e); };
		watcher.Deleted += (_, e) => { OnLocalRealmDeveloperUserFilesChanged(e); };
		watcher.Renamed += (_, e) => { OnLocalRealmDeveloperUserFilesChanged(e); };
		watcher.Changed += (_, e) => { OnLocalRealmDeveloperUserFilesChanged(e); };
		watcher.EndInit();

		// Keep waiting for messages from the set up file watcher.
		var reader = _channelChangedDeveloperUserFiles.Reader;

		while (await reader.WaitToReadAsync(token))
		{
			// If the operation was cancelled, we break out.
			if (token.IsCancellationRequested)
			{
				break;
			}
			
			// For the case which multiple files are edited at the same time, the watcher triggers one message for each one.
			// So to batch it together we wait 100 ms and then try to read from the buffer.
			await Task.Delay(100, token);
			
			// Get all the files that were changed respecting the PID filter.
			var batchedChanges = new LocalDeveloperUserFileChanges() { AllFileChanges = new() };
			while (reader.TryRead(out var changed))
			{

				batchedChanges.AllFileChanges.Add(changed);
				
			}

			yield return batchedChanges;
		}

		yield break;

		void OnLocalRealmDeveloperUserFilesChanged(FileSystemEventArgs e)
		{
			var lastWriteTime = File.GetLastWriteTime(e.FullPath).ToFileTimeUtc();
			if (e.ChangeType == WatcherChangeTypes.Created)
			{
				var changedUserDeveloper = new ChangedDeveloperUserInfoFile() { };
				changedUserDeveloper.GamerTag = long.Parse(Path.GetFileNameWithoutExtension(e.Name)!);


				changedUserDeveloper.FullFilePath = e.FullPath;
				changedUserDeveloper.OldFullFilePath = "";

				if (!eventDisambiguationHelper.TryGetValue(e.FullPath, out var time) || time != lastWriteTime)
				{
					eventDisambiguationHelper[e.FullPath] = lastWriteTime;
					Log.Verbose($"Created file ({lastWriteTime}): {JsonConvert.SerializeObject(changedUserDeveloper)} ");
					_channelChangedDeveloperUserFiles.Writer.TryWrite(changedUserDeveloper);
				}
			}
			else if (e.ChangeType == WatcherChangeTypes.Deleted)
			{
				var changedUserDeveloper = new ChangedDeveloperUserInfoFile() { };
				changedUserDeveloper.GamerTag = long.Parse(Path.GetFileNameWithoutExtension(e.Name)!);
				
				changedUserDeveloper.FullFilePath = "";
				changedUserDeveloper.OldFullFilePath = e.FullPath;
				Log.Verbose($"Deleted file: {JsonConvert.SerializeObject(changedUserDeveloper)} ");
				_channelChangedDeveloperUserFiles.Writer.TryWrite(changedUserDeveloper);
			}
			else if (e.ChangeType == WatcherChangeTypes.Changed)
			{
				var changedDeveloperUser = new ChangedDeveloperUserInfoFile { };
				changedDeveloperUser.GamerTag = long.Parse(Path.GetFileNameWithoutExtension(e.Name)!);
				
				changedDeveloperUser.FullFilePath = changedDeveloperUser.OldFullFilePath = e.FullPath;

				if (!eventDisambiguationHelper.TryGetValue(e.FullPath, out var time) || time != lastWriteTime)
				{
					eventDisambiguationHelper[e.FullPath] = lastWriteTime;
					Log.Verbose($"Changed file ({lastWriteTime}): {JsonConvert.SerializeObject(changedDeveloperUser)} ");
					_channelChangedDeveloperUserFiles.Writer.TryWrite(changedDeveloperUser);
				}
			}
			else if (e.ChangeType == WatcherChangeTypes.Renamed)
			{
				if (e is RenamedEventArgs renamedEventArgs)
				{
					var renamedDeveloperUser = new ChangedDeveloperUserInfoFile() {  };
					renamedDeveloperUser.GamerTag = long.Parse(Path.GetFileNameWithoutExtension(renamedEventArgs.Name)!);
					
					renamedDeveloperUser.FullFilePath = renamedEventArgs.FullPath;
					renamedDeveloperUser.OldFullFilePath = renamedEventArgs.OldFullPath;
					Log.Verbose($"Renamed file: {JsonConvert.SerializeObject(renamedDeveloperUser)} ");

					_channelChangedDeveloperUserFiles.Writer.TryWrite(renamedDeveloperUser);
				}
			}
		}
	}
	
	public List<DeveloperUserInfo> LoadAllDeveloperUserInfo()
	{
		List<DeveloperUserInfo> developerUsersInfo = new List<DeveloperUserInfo>();

		foreach (DeveloperUserType type in Enum.GetValues(typeof(DeveloperUserType)))
		{
			string userPath = GetFullPath(type);

			if (!Directory.Exists(userPath))
			{
				Directory.CreateDirectory(userPath);
			}
			string[] files = Directory.GetFiles(userPath);

			// get all the developer info
			foreach (var file in files)
			{
				string cachedUserJson = File.ReadAllText(file);
				DeveloperUser developerUser = JsonConvert.DeserializeObject<DeveloperUser>(cachedUserJson);
				developerUser.GamerTag = long.Parse(Path.GetFileNameWithoutExtension(file));
				developerUser.CreatedDate = File.GetCreationTimeUtc(file).Ticks;;
				developerUsersInfo.Add(new DeveloperUserInfo() { HasDeveloperUserInfo = true, DeveloperUser = developerUser, UserType = type });
			}
		}

		return developerUsersInfo;
	}
	
	public List<DeveloperUser> LoadAllCachedDeveloperUsers(DeveloperUserType developerUserType)
	{
		List<DeveloperUser> cachedDevelopersUsers = new List<DeveloperUser>();
		
		string userPath = GetFullPath(developerUserType);

		string[] files = Directory.GetFiles(userPath);
		
		// get all users cached in this directory
		foreach (var file in files)
		{
			string cachedUserJson = File.ReadAllText(file);
			DeveloperUser developerUser = JsonConvert.DeserializeObject<DeveloperUser>(cachedUserJson);
			developerUser.GamerTag = long.Parse(Path.GetFileNameWithoutExtension(file));
			developerUser.CreatedDate = File.GetCreationTimeUtc(file).Ticks;
			
			cachedDevelopersUsers.Add(developerUser);
		}
		
		return cachedDevelopersUsers;
	}
	
	public async Task RefreshUserToken(string identifier)
	{
		DeveloperUserInfo cachedUserInfo = LoadCachedUserInfo(identifier);

		if (!CheckIfUserExists(cachedUserInfo))
		{
			return;
		}
		var authApi = _dependencyProvider.GetService<AuthApi>();
		
		TokenResponse tokenResponseSource = await authApi.PostToken(new TokenRequestWrapper()
		{
			refresh_token = cachedUserInfo.DeveloperUser.RefreshToken,
			grant_type = "refresh_token"
		}, includeAuthHeader: false);
		
		cachedUserInfo.DeveloperUser.UpdateToken(tokenResponseSource);
		
		await SaveUser(cachedUserInfo.DeveloperUser, cachedUserInfo.UserType);
	}

	public async Task<DeveloperUserInfo> UpdateUserInfo(string identifier, string alias, string description, string[] tags)
	{
		DeveloperUserInfo cachedUserInfo = LoadCachedUserInfo(identifier);
		
		if (!CheckIfUserExists(cachedUserInfo))
		{
			throw new CliException("User not found");
		}
		
		if (!string.IsNullOrEmpty(alias))
		{
			var allDeveloperUserInfo = LoadAllDeveloperUserInfo();
			
			foreach (var developerUserInfo in allDeveloperUserInfo)
			{
				if (developerUserInfo.DeveloperUser.Alias == alias && developerUserInfo.DeveloperUser.GamerTag != cachedUserInfo.DeveloperUser.GamerTag)
				{
					throw new CliException($"The alias [{alias}] already exists.");
				}
			}
		}
		
		cachedUserInfo.DeveloperUser.UpdateUserInfo(alias, description);
		
		cachedUserInfo.DeveloperUser.UpdateUserTags(tags);
		
		await SaveUser(cachedUserInfo.DeveloperUser, cachedUserInfo.UserType);

		return cachedUserInfo;
	}
	
	public List<DeveloperUserInfo> GetAllAvailableUserInfo()
	{
		return LoadAllDeveloperUserInfo();
	}

	public List<DeveloperUser> GetAllUsersOfType(DeveloperUserType type)
	{
		return LoadAllCachedDeveloperUsers(type);
	}

	private bool TryGetCachedUser(List<string> identifiers, DeveloperUserType developerUserType, out List<DeveloperUser> cachedUsers)
	{
		cachedUsers = new List<DeveloperUser>();
		
		string userPath = GetFullPath(developerUserType);

		string[] files = Directory.GetFiles(userPath);

		bool foundAny = false;
		
		// try get first from the file names
		foreach (var file in files)
		{
			string gamerTag = Path.GetFileNameWithoutExtension(file);
			if (identifiers.Contains(gamerTag))
			{
				string cachedUserJson = File.ReadAllText(file);
				DeveloperUser developerUser = JsonConvert.DeserializeObject<DeveloperUser>(cachedUserJson);
				developerUser.GamerTag = long.Parse(gamerTag);
				developerUser.CreatedDate = File.GetCreationTimeUtc(file).Ticks;
				
				developerUser.Identifier = gamerTag;
				
				cachedUsers.Add(developerUser);

				foundAny = true;
			}
		}

		// if there's no file name with the 
		foreach (var file in files)
		{
			string cachedUserJson = File.ReadAllText(file);
			DeveloperUser developerUser = JsonConvert.DeserializeObject<DeveloperUser>(cachedUserJson);

			if (identifiers.Contains(developerUser.Alias))
			{
				developerUser.GamerTag = long.Parse(Path.GetFileNameWithoutExtension(file));
				developerUser.CreatedDate = File.GetCreationTimeUtc(file).Ticks;
				developerUser.Identifier = developerUser.Alias;
				
				cachedUsers.Add(developerUser);
				
				foundAny = true;
			}
		}
		
		return foundAny;
	}
	
	private async Task<Dictionary<string, StatsResponse>> GetStatMap(long uid, StatsApi statApi)
	{
		string[] statsKeys = new string[]
		{
			"game.public.player.{0}",
			"game.private.player.{0}",
			"client.public.player.{0}",
			"client.private.player.{0}"
		};
		
		Dictionary<string, StatsResponse> statsResponses = new Dictionary<string, StatsResponse>();


		List<Task> statsTasks = new List<Task>();
		foreach (var statKey in statsKeys)
		{
			var statsPromise = statApi.ObjectGet(string.Format(statKey, uid)).Then(item => statsResponses.Add(statKey, item));
			
			statsTasks.Add(statsPromise.TaskFromPromise());
		}

		await Task.WhenAll(statsTasks.ToArray());
		
		return statsResponses;
	}
	
	private IRequester CreateSignedRequester(long gamerTag, string cid, string pid, string secret)
	{
		var requester = _dependencyProvider.GetService<HttpSignedRequester>();
		requester.SetRealmInfo(cid, pid, secret);
		requester.SetPlayerId(gamerTag);
		
		return requester;
	}
	private IRequester CreateRequester(string accessToken, string refreshToken, string cid, string pid)
	{
		RequesterInfo requesterInfo = new RequesterInfo(cid, pid, accessToken, refreshToken, _appContext.Host);
		return new CliRequester(requesterInfo);
	}
	
	private IAccountsApi CreateAccountsApi(string accessToken, string refreshToken, string cid, string pid)
	{
		IRequester requester = CreateRequester(accessToken, refreshToken, cid, pid);
		return new AccountsApi(requester);
	}
	
	private InventoryApi CreateInventoryApi(long gamerTag, string cid, string pid, string secret)
	{
		IRequester requester = CreateSignedRequester(gamerTag, cid, pid, secret);
		return new InventoryApi(requester);
	}

	private StatsApi CreateStatsApi(long gamerTag, string cid, string pid, string secret)
	{
		IRequester requester = CreateSignedRequester(gamerTag, cid, pid, secret);
		return new StatsApi(requester);
	}
	
	private string GetDeveloperUserFolder(DeveloperUserType developerUserType)
	{
		switch (developerUserType)
		{
			case DeveloperUserType.Local:
				return LocalUserPath;
			case DeveloperUserType.Shared:
				return SharedUserPath;
			default:
				return TemporaryUserPath;
		}
	}
	
	private string GetSharedDirectoryBasePath()
	{
		return Path.Combine(_configService.ConfigDirectoryPath, BaseUserPath);
	}
	private string GetNonVersionedDirectoryBasePath()
	{
		return Path.Combine(_configService.ConfigTempDirectoryPath, BaseUserPath);
	}
	private string GetFullPath(DeveloperUserType developerUserType)
	{
		if (developerUserType == DeveloperUserType.Shared)
		{
			return Path.Combine(GetSharedDirectoryBasePath(), GetDeveloperUserFolder(developerUserType));
		}
		else
		{
			return Path.Combine(GetNonVersionedDirectoryBasePath(), GetDeveloperUserFolder(developerUserType));
		}

	}

	private bool CheckIfUserExists(DeveloperUserInfo developerUserInfo)
	{
		if (!developerUserInfo.HasDeveloperUserInfo)
		{
			BeamableLogger.LogError($"Developer user not found with identifier: {developerUserInfo.DeveloperUser.Alias}");
		}
		return developerUserInfo.HasDeveloperUserInfo;
	}
	
}
