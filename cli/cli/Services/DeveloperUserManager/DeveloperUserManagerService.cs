
using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Auth;
using Beamable.Api.Autogenerated.Inventory;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Stats;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.BeamCli;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Server;
using Beamable.Tooling.Common;
using Newtonsoft.Json;
using System.Runtime.CompilerServices;
using System.Threading.Channels;
using InventoryUpdateRequest = Beamable.Api.Autogenerated.Models.InventoryUpdateRequest;
using IRealmsApi = Beamable.Api.Autogenerated.Realms.IRealmsApi;
using ItemCreateRequest = Beamable.Api.Autogenerated.Models.ItemCreateRequest;
using ItemDeleteRequest = Beamable.Api.Autogenerated.Models.ItemDeleteRequest;

namespace cli.Services.DeveloperUserManager;

public enum DeveloperUserType
{
	Captured = 0,
	Local = 1,
	Shared = 2,
}

public class LocalDeveloperUserFileChanges
{
	public List<ChangedDeveloperUserFile> AllFileChanges;
}

[CliContractType, Serializable]
public class DeveloperUserResult
{
	public List<DeveloperUserData> CreatedUsers = new List<DeveloperUserData>();
	public List<DeveloperUserData> DeletedUsers = new List<DeveloperUserData>();
	public List<DeveloperUserData> UpdatedUsers = new List<DeveloperUserData>();
	public List<DeveloperUserData> SavedUsers = new List<DeveloperUserData>();
}

public struct ChangedDeveloperUserFile
{
	public long GamerTag;
	
	public string FullFilePath;
	public string OldFullFilePath;

	public bool WasDeleted() => string.IsNullOrEmpty(FullFilePath) && !string.IsNullOrEmpty(OldFullFilePath);
	public bool WasCreated() => !string.IsNullOrEmpty(FullFilePath) && string.IsNullOrEmpty(OldFullFilePath);
	public bool WasRenamed() => !WasDeleted() && !WasCreated() && FullFilePath != OldFullFilePath;
	public bool WasChanged() => !WasCreated() && !WasDeleted() && FullFilePath == OldFullFilePath;
}

[CliContractType, Serializable]
public class DeveloperUserData
{
	// User Management Info
	public long GamerTag;
	public long TemplateGamerTag; // Use to reset to template
	
	public bool IsCorrupted;
	
	public int DeveloperUserType;
	
	public string Alias = string.Empty;
	public string Description = string.Empty;
	public List<string> Tags = new List<string>();
	
	// Backend info
	public string AccessToken = string.Empty;
	public string RefreshToken = string.Empty;
	public string Pid = string.Empty;
	public string Cid = string.Empty;
	public long ExpiresIn;
	public long IssuedAt;
	
	public long CreatedDate;
}

// This will represent the cached information for the developer user
[Serializable]
public struct DeveloperUser
{
	// User Management Info
	public long GamerTag;
	
	[JsonIgnore]
	public bool IsCorrupted;
	
	[JsonIgnore]
	public int DeveloperUserType;

	public long CreatedDate;
	public long TemplateGamerTag; // Use to reset to template
	
	public string Alias;
	public string Description;
	public List<string> Tags = new List<string>();
	
	// Backend info
	public string AccessToken;
	public string RefreshToken;
	public long ExpiresIn;
	public string Pid;
	public string Cid;
	public long CreatedByGamerTag;

	public long IssuedAt;
	
	/// <summary>
	/// We are preventing serialization for shared users of the AccessToken
	/// As those users are going to be versioned in git.\
	/// Docs: https://www.newtonsoft.com/json/help/html/conditionalproperties.htm#:~:text=To%20conditionally%20serialize%20a%20property,whether%20the%20property%20is%20serialized
	/// </summary>
	/// <returns></returns>
	public bool ShouldSerializeAccessToken()
	{
		return DeveloperUserType != (int)DeveloperUserManager.DeveloperUserType.Shared;
	}
	
	/// <summary>
	/// We are preventing serialization for shared users of the RefreshToken
	/// As those users are going to be versioned in git.
	/// Docs: https://www.newtonsoft.com/json/help/html/conditionalproperties.htm#:~:text=To%20conditionally%20serialize%20a%20property,whether%20the%20property%20is%20serialized
	/// </summary>
	/// <returns></returns>
	public bool ShouldSerializeRefreshToken()
	{
		return DeveloperUserType != (int)DeveloperUserManager.DeveloperUserType.Shared;
	}
	
	/// <summary>
	/// We are preventing serialization for shared users of the ExpiresIn
	/// As those users are going to be versioned in git.
	/// Docs: https://www.newtonsoft.com/json/help/html/conditionalproperties.htm#:~:text=To%20conditionally%20serialize%20a%20property,whether%20the%20property%20is%20serialized
	/// </summary>
	/// <returns></returns>
	public bool ShouldSerializeExpiresIn()
	{
		return DeveloperUserType != (int)DeveloperUserManager.DeveloperUserType.Shared;
	}
	
	public bool IsValidUser() => GamerTag != 0;
	
	public DeveloperUserType GetDeveloperUserType() => (DeveloperUserType)DeveloperUserType;

	public DeveloperUser(long gamerTag, long templateGamerTag, TokenResponse tokenResponse, string cid, string pid, string alias, long createdByGamerTag, string description, List<string> tags, long createdDate, DeveloperUserType developerUserType) : this()
	{
		UpdateToken(tokenResponse);
		Cid = cid;
		Pid = pid;
		GamerTag = gamerTag;
		CreatedByGamerTag = createdByGamerTag;
		TemplateGamerTag = templateGamerTag;
		CreatedDate = createdDate;
		DeveloperUserType = (int)developerUserType;
		
		Alias = alias;
		Description = description;
		Tags = tags;
	}
	
	public void UpdateToken(TokenResponse tokenResponse)
	{
		AccessToken = tokenResponse.access_token;
		RefreshToken = tokenResponse.refresh_token;
		ExpiresIn = tokenResponse.expires_in;
		IssuedAt = DateTime.UtcNow.Ticks;
	}

	public void UpdateToken(DeveloperUser developerUser)
	{
		AccessToken = developerUser.AccessToken;
		RefreshToken = developerUser.RefreshToken;
		ExpiresIn = developerUser.ExpiresIn;
		IssuedAt = DateTime.UtcNow.Ticks;
	}
	public void UpdateUserInfo(string alias, string description)
	{
		Alias = alias;
		Description = description;
	}

	public void UpdateUserTags(List<string> tags)
	{
		Tags = tags;
	}
}

public class DeveloperUserManagerService
{
	private static readonly string SharedUserPath = "sharedUser";
	
	private static readonly string CapturedUserPath = "capturedUser";
	private static readonly string LocalUserPath = "localUser";
	
	private static readonly string BaseUserPath = "developerUser";

	public static readonly int BACKEND_ERROR = 400;
	public static readonly int UNKOWN_SERVER_ERROR = 500;
	public static readonly int SAVE_FILE_ERROR = 300;
	
	private readonly IAppContext _appContext;
	private readonly ConfigService _configService;
	private readonly IDependencyProvider _dependencyProvider;
	
	
	// Watchers for the long run ps command
	private readonly Dictionary<DeveloperUserType, FileSystemWatcher> _watchers = new();
	
	private readonly Channel<ChangedDeveloperUserFile> _channelChangedDeveloperUserFiles;

	public DeveloperUserManagerService(IAppContext appContext, ConfigService configService, IDependencyProvider dependencyProvider)
	{
		_dependencyProvider = dependencyProvider;
		_configService = configService;
		_appContext = appContext;
		
		_channelChangedDeveloperUserFiles = Channel.CreateUnbounded<ChangedDeveloperUserFile>(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = false, AllowSynchronousContinuations = true, });
	}

	/// <summary>
	/// Create a new user and save in the disk,
	/// if you pass a valid template after the user creation it will copy the stats and inventory from the given template gamer tag
	/// </summary>
	/// <param name="templateGamerTag"></param>
	/// <param name="alias"></param>
	/// <param name="description"></param>
	/// <param name="tags"></param>
	/// <param name="developerUserType"></param>
	/// <param name="rollingBufferSize"></param>
	/// <exception cref="CliException"></exception>
	public async Task<DeveloperUser> CreateUser(string templateGamerTag = "", string alias = "", string description = "", List<string> tags = null, DeveloperUserType developerUserType = DeveloperUserType.Local,
		int rollingBufferSize = 0)
	{
		var authApi = _dependencyProvider.GetService<IAuthApi>();
		var accountApi = _dependencyProvider.GetService<IAccountsApi>();

		// Start the get me for the admin while do the other creation of the new user.
		var adminMeTask = accountApi.GetAdminMe();
		
		// Create the new user as a guest
		TokenResponse tokenResponse = await authApi.PostToken(new TokenRequestWrapper()
		{
			grant_type = "guest"
		}, includeAuthHeader: false);

		var accountsApi = CreateAccountsApi(tokenResponse.access_token, tokenResponse.refresh_token, _appContext.Cid, _appContext.Pid);

		long gamerTag = -1;
		long adminGamerTag = -1;
		try
		{
			// Get the account info to save in the local disk 
			AccountPlayerView accountPlayerView = await accountsApi.GetMe();
			gamerTag = accountPlayerView.id;

			// Wait for the admin me finish the process
			var adminMe = await adminMeTask;
			adminGamerTag = adminMe.id;
		}
		catch (RequesterException e) // Backend Exception
		{
			BeamableLogger.LogError(e);
			throw new CliException("Backend error on get the account or admin me", BACKEND_ERROR, true);
		}
		catch (Exception e) // Any generic exception
		{
			BeamableLogger.LogError(e);
			throw new CliException($"Generic error on get the account or admin me", UNKOWN_SERVER_ERROR, true);
		}
		
		// Create the new developer user
		DeveloperUser developerUser = new DeveloperUser(gamerTag, 0, tokenResponse, _appContext.Cid, _appContext.Pid, alias, adminGamerTag, description, tags, DateTime.UtcNow.Ticks, developerUserType);
		
		bool copyFromTemplate = !string.IsNullOrEmpty(templateGamerTag);
		
		// In the case of the user passes a template we should load this template and validate it to copy the state from the template to the new user. 
		if (copyFromTemplate)
		{
			DeveloperUser templateDeveloperUser;

			if (!TryLoadCachedDeveloperUser(templateGamerTag, out templateDeveloperUser))
			{
				throw new CliException($"There's no user with the given gamer tag: {templateGamerTag}");
			}
			
			developerUser.CreatedByGamerTag = templateDeveloperUser.CreatedByGamerTag;
			
			// This copy the state from the template to the new user.
			// Stats state and Inventory State.
			try
			{
				await CopyState(templateDeveloperUser, developerUser);
			}
			catch (RequesterException e) // Backend Exception
			{
				BeamableLogger.LogError(e);
				throw new CliException("Backend error on create the users from the template", BACKEND_ERROR, true);
			}
			catch (Exception e) // Any generic exception
			{
				BeamableLogger.LogError(e);
				throw new CliException($"Generic error on create the users from the template", UNKOWN_SERVER_ERROR, true);
			}
		}
		
		try{
			await SaveDeveloperUser(developerUser, developerUserType);
		}
		catch (Exception e) // Any generic exception on save the users
		{
			BeamableLogger.LogError(e);
				
			throw new CliException($"Generic error on save file", SAVE_FILE_ERROR, true);
		}
		
		RemoveOlderEntriesFromCachedBuffer(rollingBufferSize);
		
		return developerUser;
	}
	/// <summary>
	/// Create users in batch, mostly used for captured users or copy multiple users from different templates
	/// </summary>
	public async Task<List<DeveloperUser>> CreateUsersFromTemplateInBatch(List<string> gamerTags, Dictionary<string, int> amountPerGamerTag, int rollingBufferSize)
	{
		var authApi = _dependencyProvider.GetService<IAuthApi>();
		var accountApi = _dependencyProvider.GetService<IAccountsApi>();
		
		// Checking if all the gamerTags received is has a amountPerGamerTag key in the dictionary.
		var except = gamerTags.Except(amountPerGamerTag.Keys).ToList();
		if (except.Count() != 0)
		{
			throw new CliException($"Missing gamer tags {string.Join("-", except)}");
		}

		// Load all developer users for the given gamer tags
		List<DeveloperUser> templateDeveloperUsers = LoadCachedUsersInfo(gamerTags, out List<DeveloperUser> missingDeveloperUsers);
		
		// Throw an exception if there's any missing template in the batches
		if (missingDeveloperUsers.Count > 0)
		{
			throw new CliException($"Missing users for template gamer tags: {string.Join("-", missingDeveloperUsers.Select(item => item.Alias))}");
		}

		List<DeveloperUser> resultDeveloperUsers = new List<DeveloperUser>();
		
		List<Task> saveDeveloperUserTasks = new List<Task>();

		try
		{
			var adminMe = await accountApi.GetAdminMe();

			List<Task<DeveloperUser>> createUserTaskBatch = new List<Task<DeveloperUser>>();

			// Create a task for each user that needs to be created.
			foreach (var templateUserInfo in templateDeveloperUsers)
			{
				for (int i = 0; i < amountPerGamerTag[templateUserInfo.GamerTag.ToString()]; i++)
				{
					createUserTaskBatch.Add(CreateUserFromTemplate(authApi, adminMe, templateUserInfo));
				}
			}

			// Create user task in batch
			// If we throw any error here we will not save any developer user to local 

			// If there's any problem with the backend request it will trigger a error
			await Task.WhenAll(createUserTaskBatch);

			foreach (var createUserTask in createUserTaskBatch)
			{
				var developerUser = createUserTask.Result;

				resultDeveloperUsers.Add(developerUser);

				saveDeveloperUserTasks.Add(SaveDeveloperUser(developerUser));
			}

		}
		catch (RequesterException e) // Backend Exception
		{
			BeamableLogger.LogError(e);
			throw new CliException("Backend error on create the users from the template", BACKEND_ERROR, true);
		}catch (Exception e) // Any generic exception
		{
			BeamableLogger.LogError(e);
			throw new CliException($"Generic error on create the users from the template", UNKOWN_SERVER_ERROR, true);
		}
		

		try
		{
			// Wait until save all developer user
			await Task.WhenAll(saveDeveloperUserTasks);
		}
		catch (Exception e) // Any generic exception on save the users
		{
			BeamableLogger.LogError(e);
			
			throw new CliException($"Generic error on save file", SAVE_FILE_ERROR, true);
		}
		

		// In order to don't create infinity users in the manager we can set a value to be the max amount of users sorted by creation date
		RemoveOlderEntriesFromCachedBuffer(rollingBufferSize);

		return resultDeveloperUsers;
	}
	/// <summary>
	/// Copy state from a developer user to another
	/// </summary>
	/// <returns></returns>
	public async Task CopyState(DeveloperUser sourceDeveloperUser, DeveloperUser targetDeveloperUser)
	{
		var realmsApi = _dependencyProvider.GetService<IRealmsApi>();
		var res = await realmsApi.GetAdminCustomer();
		var secretMap = res.customer.projects.ToDictionary(p => p.name, p=> p.secret);
		
		List<Task> copyTasks = new List<Task>
		{
			CopyInventoryState(sourceDeveloperUser, targetDeveloperUser, secretMap), 
			CopyStatsState(sourceDeveloperUser, targetDeveloperUser, secretMap)
		};

		await Task.WhenAll(copyTasks);
	}
	
	/// <summary>
	/// Save one developer user entry.
	/// </summary>
	/// <param name="developerUser"></param>
	/// <param name="developerUserType"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public Task SaveDeveloperUser(DeveloperUser developerUser, DeveloperUserType developerUserType = DeveloperUserType.Captured)
	{
		return SaveDeveloperUsers(new List<DeveloperUser>(){developerUser}, developerUserType);
	}
	
	/// <summary>
	/// Save/refresh multiple developer users to disk in a batch
	/// </summary>
	/// <param name="developerUsers"></param>
	/// <param name="developerUserType"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public async Task SaveDeveloperUsers(List<DeveloperUser> developerUsers, DeveloperUserType developerUserType = DeveloperUserType.Captured)
	{
		List<Task> writeUserTasks = new List<Task>();
		foreach (DeveloperUser developerUser in developerUsers)
		{
			DeveloperUser developerUserCopy;

			// If there's a cached developer user we just update the token information.
			if (TryLoadCachedDeveloperUser(developerUser.GamerTag.ToString(), out developerUserCopy))
			{
				developerUserCopy.UpdateToken(developerUser);
			}
			else
			{
				developerUserCopy = developerUser;
				
				// Making sure that we are saving the developer user with the correct properties
				developerUserCopy.DeveloperUserType = (int)developerUserType;
				
				developerUserCopy.IssuedAt = DateTime.UtcNow.Ticks;
			}
			
			string developerUserJson = JsonConvert.SerializeObject(developerUserCopy, Formatting.Indented);

			string directoryPath = GetFullPath((DeveloperUserType)developerUserCopy.DeveloperUserType);
			
			if (!Directory.Exists(directoryPath))
			{
				Directory.CreateDirectory(directoryPath!);
			}
			
			// if the directory path is null or empty we should throw an exception.
			if (string.IsNullOrEmpty(directoryPath))
			{
				throw new ArgumentNullException(nameof(directoryPath));
			}
			
			string fileFullPath = Path.Combine(directoryPath, developerUser.GamerTag + ".json");
			writeUserTasks.Add( File.WriteAllTextAsync(fileFullPath, developerUserJson) );
		}
		
		await Task.WhenAll(writeUserTasks);
	}
	
	/// <summary>
	/// Remove a user for a given user gamer tag from local files
	/// OBS: It will not delete the user from the backend  
	/// </summary>
	public void DeleteUser(string gamerTag)
	{
		if (!TryLoadCachedDeveloperUser(gamerTag, out DeveloperUser developerUser))
		{
			throw new CliException($"There's no user with the given gamer tag {gamerTag}");
		}

		DeleteUser(developerUser, developerUser.GetDeveloperUserType());
	}
	
	/// <summary>
	/// Remove multiple users from local files
	/// OBS: It will not delete the user from the backend  
	/// </summary>
	public void DeleteUsers(List<string> gamerTags)
	{
		foreach (string gamerTag in gamerTags)
		{
			DeleteUser(gamerTag);
		}
	}
	
	/// <summary>
	/// Try Load from the local cache a user for a given gamer tag
	/// </summary>
	public bool TryLoadCachedDeveloperUser(string gamerTag, out DeveloperUser developerUser)
	{
		List<DeveloperUser> developerUsers = LoadCachedUsersInfo(new List<string>() { gamerTag }, out List<DeveloperUser> missingDeveloperUsers);
		if (missingDeveloperUsers.Count > 0)
		{
			developerUser = missingDeveloperUsers[0];
			return false;
		}
		developerUser = developerUsers[0];
		return true;
	}

	public async IAsyncEnumerable<LocalDeveloperUserFileChanges> ListenToLocalDeveloperUserFileChanges(DeveloperUserType developerUserType, [EnumeratorCancellation] CancellationToken token = default)
	{
		_watchers.Add(developerUserType, new FileSystemWatcher());

		// We need to keep track of the last write time for each content file in order to disambiguate multiple events firing simultaneously for the same file.
		// For example, on Windows, a Created event is always fired alongside a Changed event of the same file (because of "reasons", I guess)
		// This dictionary helps us fire off only one relevant event at a time even when the file watcher gets confused about the desirable semantics...
		var eventDisambiguationHelper = new Dictionary<string, long>();
		
		// Set up the file watcher...
		var watcher = _watchers[developerUserType];
		watcher.BeginInit();
		watcher.Path = GetFullPath(developerUserType);
		watcher.IncludeSubdirectories = true;
		watcher.Filter = "*.json";
		watcher.EnableRaisingEvents = true;
		watcher.NotifyFilter = (NotifyFilters.Attributes |
		                        NotifyFilters.CreationTime |
		                        NotifyFilters.DirectoryName |
		                        NotifyFilters.FileName |
		                        NotifyFilters.LastWrite);
		watcher.Error += (_, e) => Log.Error(e.GetException().ToString());
		watcher.Disposed += (_, e) => Log.Error($"Disposed {e}");
		watcher.Created += (_, e) => { OnLocalDeveloperUserFilesChanged(e); };
		watcher.Deleted += (_, e) => { OnLocalDeveloperUserFilesChanged(e); };
		watcher.Renamed += (_, e) => { OnLocalDeveloperUserFilesChanged(e); };
		watcher.Changed += (_, e) => { OnLocalDeveloperUserFilesChanged(e); };
		watcher.EndInit();

		// Keep waiting for messages from the set-up file watcher.
		var reader = _channelChangedDeveloperUserFiles.Reader;

		while (await reader.WaitToReadAsync(token))
		{
			// If the operation was cancelled, we break out.
			if (token.IsCancellationRequested)
			{
				break;
			}
			
			// For the case which multiple files are edited at the same time, the watcher triggers one message for each one.
			// So to batch it together we wait 100 ms and then try to read from the buffer.
			await Task.Delay(100, token);
			
			// Get all the files that were changed.
			var batchedChanges = new LocalDeveloperUserFileChanges() { AllFileChanges = new() };
			while (reader.TryRead(out var changed))
			{

				batchedChanges.AllFileChanges.Add(changed);
				
			}

			yield return batchedChanges;
		}

		yield break;

		void OnLocalDeveloperUserFilesChanged(FileSystemEventArgs e)
		{
			var lastWriteTime = File.GetLastWriteTime(e.FullPath).ToFileTimeUtc();
			if (e.ChangeType == WatcherChangeTypes.Created)
			{
				var changedUserDeveloper = new ChangedDeveloperUserFile
				{
					GamerTag = long.Parse(Path.GetFileNameWithoutExtension(e.Name)!),
					FullFilePath = e.FullPath, 
					OldFullFilePath = ""
				};
				
				if (!eventDisambiguationHelper.TryGetValue(e.FullPath, out var time) || time != lastWriteTime)
				{
					eventDisambiguationHelper[e.FullPath] = lastWriteTime;
					Log.Verbose($"Created file ({lastWriteTime}): {JsonConvert.SerializeObject(changedUserDeveloper)} ");
					_channelChangedDeveloperUserFiles.Writer.TryWrite(changedUserDeveloper);
				}
			}
			else if (e.ChangeType == WatcherChangeTypes.Deleted)
			{
				var changedUserDeveloper = new ChangedDeveloperUserFile
				{
					GamerTag = long.Parse(Path.GetFileNameWithoutExtension(e.Name)!), 
					FullFilePath = "", 
					OldFullFilePath = e.FullPath
				};

				Log.Verbose($"Deleted file: {JsonConvert.SerializeObject(changedUserDeveloper)} ");
				_channelChangedDeveloperUserFiles.Writer.TryWrite(changedUserDeveloper);
			}
			else if (e.ChangeType == WatcherChangeTypes.Changed)
			{
				var changedDeveloperUser = new ChangedDeveloperUserFile
				{
					GamerTag = long.Parse(Path.GetFileNameWithoutExtension(e.Name)!)
				};

				changedDeveloperUser.FullFilePath = changedDeveloperUser.OldFullFilePath = e.FullPath;

				if (!eventDisambiguationHelper.TryGetValue(e.FullPath, out var time) || time != lastWriteTime)
				{
					eventDisambiguationHelper[e.FullPath] = lastWriteTime;
					Log.Verbose($"Changed file ({lastWriteTime}): {JsonConvert.SerializeObject(changedDeveloperUser)} ");
					_channelChangedDeveloperUserFiles.Writer.TryWrite(changedDeveloperUser);
				}
			}
			else if (e.ChangeType == WatcherChangeTypes.Renamed)
			{
				if (e is RenamedEventArgs renamedEventArgs)
				{
					var renamedDeveloperUser = new ChangedDeveloperUserFile
					{
						GamerTag = long.Parse(Path.GetFileNameWithoutExtension(renamedEventArgs.Name)!),
						FullFilePath = renamedEventArgs.FullPath,
						OldFullFilePath = renamedEventArgs.OldFullPath
					};

					Log.Verbose($"Renamed file: {JsonConvert.SerializeObject(renamedDeveloperUser)} ");

					_channelChangedDeveloperUserFiles.Writer.TryWrite(renamedDeveloperUser);
				}
			}
		}
	}

	/// <summary>
	/// Update the developer user info, this will be used for update basically the local info state for editable engine information.
	/// </summary>
	/// <param name="gamerTag"></param>
	/// <param name="alias"></param>
	/// <param name="description"></param>
	/// <param name="createCopyOnStart"></param>
	/// <param name="tags"></param>
	/// <returns></returns>
	/// <exception cref="CliException"></exception>
	public async Task<DeveloperUser> UpdateDeveloperUserInfo(string gamerTag, string alias, string description, List<string> tags)
	{
		DeveloperUser cachedDeveloperUser;
		
		if (!TryLoadCachedDeveloperUser(gamerTag, out cachedDeveloperUser))
		{
			throw new CliException($"There's no user with the given gamer tag: {gamerTag}");
		}
		
		cachedDeveloperUser.UpdateUserInfo(alias, description);
		
		cachedDeveloperUser.UpdateUserTags(tags);
		try{
			await SaveDeveloperUser(cachedDeveloperUser, cachedDeveloperUser.GetDeveloperUserType());
		}
		catch (Exception e) // Any generic exception on save the users
		{
			// Ignored
			BeamableLogger.LogError(e);
				
			throw new CliException($"Generic error on save file", SAVE_FILE_ERROR, true);
		}
		return cachedDeveloperUser;
	}
	
	/// <summary>
	/// Get all the available users for all the Developer User Types
	/// </summary>
	/// <returns></returns>
	public List<DeveloperUser> GetAllAvailableUserInfo()
	{
		List<DeveloperUser> developerUsers = new List<DeveloperUser>();

		foreach (DeveloperUserType developerUserType in Enum.GetValues(typeof(DeveloperUserType)))
		{
			string userPath = GetFullPath(developerUserType);

			if (!Directory.Exists(userPath))
			{
				Directory.CreateDirectory(userPath!);
			}
			string[] files = Directory.GetFiles(userPath);

			// get all the developer info
			foreach (var file in files)
			{
				string cachedUserJson = File.ReadAllText(file);
				DeveloperUser developerUser;
				
				try
				{
					developerUser = JsonConvert.DeserializeObject<DeveloperUser>(cachedUserJson);
				}
				catch
				{
					developerUser = new DeveloperUser
					{
						Alias = file,
						IsCorrupted = true
					};
				}
				
				if (!long.TryParse(Path.GetFileNameWithoutExtension(file), out developerUser.GamerTag))
				{
					developerUser.IsCorrupted = true;
					developerUser.Alias = file;
				}
	
				developerUser.DeveloperUserType = (int)developerUserType; // Override the developer type based on the folder
				
				developerUsers.Add(developerUser);
			}
		}

		return developerUsers;
	}

	/// <summary>
	/// Get all the available users for a specific developer user type
	/// </summary>
	/// <returns></returns>
	public List<DeveloperUser> GetAllUsersOfType(DeveloperUserType developerUserType)
	{
		List<DeveloperUser> cachedDevelopersUsers = new List<DeveloperUser>();
		
		string userPath = GetFullPath(developerUserType);

		string[] files = Directory.GetFiles(userPath);
		
		// get all users cached in this directory
		foreach (var file in files)
		{
			string cachedUserJson = File.ReadAllText(file);
			DeveloperUser developerUser;
			try
			{
				developerUser = JsonConvert.DeserializeObject<DeveloperUser>(cachedUserJson);
			}
			catch
			{
				developerUser = new DeveloperUser
				{
					Alias = file,
					IsCorrupted = true
				};
			}
			
			if (!long.TryParse(Path.GetFileNameWithoutExtension(file), out developerUser.GamerTag))
			{
				developerUser.Alias = file;
				developerUser.IsCorrupted = true;
			}
			developerUser.DeveloperUserType = (int)developerUserType; // Override the developer type based on the folder
			
			cachedDevelopersUsers.Add(developerUser);
		}
		
		return cachedDevelopersUsers;
	}
	
		
	/// <summary>
	/// A utility that remove the captured entries if bigger than the rollingBufferSize 
	/// </summary>
	/// <param name="rollingBufferSize"></param>
	public List<DeveloperUser> RemoveOlderEntriesFromCachedBuffer(int rollingBufferSize)
	{
		var result = new List<DeveloperUser>();
		if(rollingBufferSize == 0)
			return result;
		
		List<DeveloperUser> developerUsers = GetAllUsersOfType(DeveloperUserType.Captured);
		
		developerUsers.Sort((x, y) => y.CreatedDate.CompareTo(x.CreatedDate));

		for (int i = rollingBufferSize; i < developerUsers.Count; i++)
		{
			result.Add(developerUsers[i]);
			DeleteUser(developerUsers[i]);
		}

		return result;
	}
	
	/// <summary>
	/// Load from the local cache all the users for a given list of gamer tags
	/// If the gamer tag is not found it will return in the out missingDeveloperUsers arg
	/// You can check if the items are valid using DeveloperUser.IsValidUser()
	/// </summary>
	private List<DeveloperUser> LoadCachedUsersInfo(List<string> gamerTags , out List<DeveloperUser> missingDeveloperUsers)
	{
		List<DeveloperUser> cachedUsersResult = new List<DeveloperUser>();
		
		// Search for all developer types trying to find the user by the gamer tag
		foreach (DeveloperUserType type in Enum.GetValues(typeof(DeveloperUserType)))
		{
			if (TryGetCachedUser(gamerTags, type, out List<DeveloperUser> cachedUsers))
			{
				cachedUsersResult.AddRange(cachedUsers);
			}
		}

		// Get the list of all gamer tags loaded as string to do an except with the received gamer tag list and check what was missing.
		IEnumerable<string> missingGamerTag = cachedUsersResult.Select(item => item.GamerTag.ToString());
		
		missingDeveloperUsers = gamerTags.Except(missingGamerTag).Select(gamerTag =>  new DeveloperUser()
		{
			Alias = gamerTag
		}).ToList();
		
		return cachedUsersResult;
	}

	
	/// <summary>
	/// Create and copy a user in optimized for a batch call
	/// </summary>
	/// <param name="authApi"></param>
	/// <param name="adminMe"></param>
	/// <param name="templateDeveloperUser"></param>
	/// <returns></returns>
	private async Task<DeveloperUser> CreateUserFromTemplate(IAuthApi authApi, AccountPortalView adminMe, DeveloperUser templateDeveloperUser)
	{
		TokenResponse tokenResponse = await authApi.PostToken(new TokenRequestWrapper()
		{
			grant_type = "guest"
		}, includeAuthHeader: false);

		var accountsApi = CreateAccountsApi(tokenResponse.access_token, tokenResponse.refresh_token, _appContext.Cid, _appContext.Pid);
		
		AccountPlayerView accountPlayerView = await accountsApi.GetMe();
		
		var temporaryDescription =  $"Created from template {templateDeveloperUser.Alias} - {templateDeveloperUser.GamerTag}"; 
		DeveloperUser developerUser = new DeveloperUser(accountPlayerView.id, templateDeveloperUser.GamerTag, tokenResponse, _appContext.Cid, _appContext.Pid, "", adminMe.id, temporaryDescription, new List<string>(), DateTime.UtcNow.Ticks, DeveloperUserType.Captured);

		await CopyState(templateDeveloperUser, developerUser);

		return developerUser;
	}

	
	/// <summary>
	/// Copy the inventory state from a developer user to another
	/// </summary>
	/// <param name="sourceDeveloperUser"></param>
	/// <param name="targetDeveloperUser"></param>
	/// <param name="secretMap"></param>
	/// <exception cref="CliException"></exception>
	private async Task CopyInventoryState(DeveloperUser sourceDeveloperUser, DeveloperUser targetDeveloperUser, Dictionary<string, string> secretMap)
	{
		if (!secretMap.ContainsKey(sourceDeveloperUser.Pid))
		{
			throw new CliException($"There's no secret realm key for the source developer pid {sourceDeveloperUser.Pid}");
		}

		if (!secretMap.ContainsKey(targetDeveloperUser.Pid))
		{
			throw new CliException($"There's no secret realm key for the target developer pid {targetDeveloperUser.Pid}");
		}
	
		var sourceInventoryApi = CreateInventoryApi(sourceDeveloperUser.GamerTag, sourceDeveloperUser.Cid, sourceDeveloperUser.Pid, secretMap[sourceDeveloperUser.Pid]);
		
		var targetInventoryApi = CreateInventoryApi(targetDeveloperUser.GamerTag, targetDeveloperUser.Cid, targetDeveloperUser.Pid, secretMap[targetDeveloperUser.Pid]);

		
		// Get the target account
		Promise<InventoryView> targetInventoryViewPromise = targetInventoryApi.ObjectGet(targetDeveloperUser.GamerTag);
		
		// Get the source inventory
		Promise<InventoryView> sourceInventoryViewPromise = sourceInventoryApi.ObjectGet(sourceDeveloperUser.GamerTag);
		
		InventoryView targetInventoryView = await targetInventoryViewPromise;
		
		InventoryView sourceInventoryView = await sourceInventoryViewPromise;
		
		InventoryUpdateRequest inventoryUpdateRequest = new InventoryUpdateRequest();

		List<ItemDeleteRequest> deleteRequests = new List<ItemDeleteRequest>();
		
		// Delete items from the inventory 
		foreach (var itemGroup in targetInventoryView.items)
		{
			foreach (var item in itemGroup.items)
			{
				deleteRequests.Add(new ItemDeleteRequest()
				{
					contentId = itemGroup.id,
					id = item.id
				});
			}
		}
		
		inventoryUpdateRequest.deleteItems.Set(deleteRequests.ToArray());

		List<ItemCreateRequest> createdItems = new List<ItemCreateRequest>();
		
		// Add items from source to target
		foreach (var itemGroup in sourceInventoryView.items)
		{
			foreach (var item in itemGroup.items)
			{
				createdItems.Add(new ItemCreateRequest()
				{
					contentId = itemGroup.id,
					properties = item.properties
				});
			}
		}
		
		inventoryUpdateRequest.newItems.Set(createdItems.ToArray());
		
		MapOfLong currencies = new MapOfLong();
		// Set all currency to zero
		foreach (var currency in targetInventoryView.currencies)
		{
			currencies.Add(currency.id, -currency.amount);
		}
		
		// Set all currency as the source
		foreach (var currency in sourceInventoryView.currencies)
		{
			if (currencies.ContainsKey(currency.id))
			{
				currencies[currency.id] += currency.amount;
			}
			else
			{
				currencies.Add(currency.id, currency.amount);
			}

		}
		
		inventoryUpdateRequest.currencies.Set(currencies);

		await targetInventoryApi.ObjectPut(targetDeveloperUser.GamerTag, inventoryUpdateRequest);
	}

	/// <summary>
	/// Copy the stats state from a developer user to another
	/// </summary>
	/// <param name="sourceDeveloperUser"></param>
	/// <param name="targetDeveloperUser"></param>
	/// <param name="secretMap"></param>
	private async Task CopyStatsState(DeveloperUser sourceDeveloperUser, DeveloperUser targetDeveloperUser, Dictionary<string, string> secretMap)
	{
		IStatsApi adminStatsApi = CreateStatsApi(sourceDeveloperUser.GamerTag, _appContext.Cid, _appContext.Pid, secretMap[_appContext.Pid]);
		
		
		Task<Dictionary<string, StatsResponse>> sourceStatMapTask = GetStatMap(sourceDeveloperUser.GamerTag, adminStatsApi);
		
		Task<Dictionary<string, StatsResponse>> targetStatMapTask = GetStatMap(targetDeveloperUser.GamerTag, adminStatsApi);

		await Task.WhenAll(sourceStatMapTask, targetStatMapTask);
		
		Dictionary<string, StatsResponse> sourceStatMap = sourceStatMapTask.Result;
		Dictionary<string, StatsResponse> targetStatMap = targetStatMapTask.Result;
		
		// As we don't have a batch delete for stats it will delete one by one.
		List<Task> deleteStatTasks = new List<Task>();
		foreach (var targetStatKeyPair in targetStatMap)
		{
			foreach (var stat in targetStatKeyPair.Value.stats)
			{
				string objectId = string.Format(targetStatKeyPair.Key, targetDeveloperUser.GamerTag);
				deleteStatTasks.Add(adminStatsApi.ObjectDelete(objectId, new StatRequest
				{
					stats = new OptionalString(stat.Key)
				}).TaskFromPromise()); 
			}
		}
		
		await Task.WhenAll(deleteStatTasks.ToArray());
		
		foreach (var sourceStatKeyPair in sourceStatMap)
		{
			string objectId = string.Format(sourceStatKeyPair.Key, targetDeveloperUser.GamerTag);

			StatUpdateRequest statUpdateRequest = new StatUpdateRequest() { set = new OptionalMapOfString(sourceStatKeyPair.Value.stats) };
				
			await adminStatsApi.ObjectPost(objectId, statUpdateRequest);
		}
	}

	
	/// <summary>
	/// Delete user from local files
	/// It will not delete the user from the portal, only from the files. 
	/// </summary>
	/// <param name="developerUser"></param>
	/// <param name="developerUserType"></param>
	private void DeleteUser(DeveloperUser developerUser, DeveloperUserType developerUserType = DeveloperUserType.Captured)
	{
		string directoryPath = GetFullPath(developerUserType);
		
		string fileFullPath = Path.Combine(directoryPath, developerUser.GamerTag + ".json");
		
		File.Delete(fileFullPath);
	}
	
	/// <summary>
	/// Create a signed requester by passing the gamer tag, cid, pid and secret
	/// </summary>
	/// <param name="gamerTag"></param>
	/// <param name="cid"></param>
	/// <param name="pid"></param>
	/// <param name="secret"></param>
	/// <returns></returns>
	private IRequester CreateSignedRequester(long gamerTag, string cid, string pid, string secret)
	{
		var requester = _dependencyProvider.GetService<HttpSignedRequester>();
		requester.SetRealmInfo(cid, pid, secret);
		requester.SetPlayerId(gamerTag);
		
		return requester;
	}
	
	/// <summary>
	/// Create a new default requester with the access token and refresh token
	/// </summary>
	/// <param name="accessToken"></param>
	/// <param name="refreshToken"></param>
	/// <param name="cid"></param>
	/// <param name="pid"></param>
	/// <returns></returns>
	private IRequester CreateRequester(string accessToken, string refreshToken, string cid, string pid)
	{
		RequesterInfo requesterInfo = new RequesterInfo(cid, pid, accessToken, refreshToken, _appContext.Host);
		return new CliRequester(requesterInfo);
	}
	
	/// <summary>
	/// Create an IAccountAPI from an access token and a refresh token
	/// </summary>
	/// <param name="accessToken"></param>
	/// <param name="refreshToken"></param>
	/// <param name="cid"></param>
	/// <param name="pid"></param>
	/// <returns></returns>
	private IAccountsApi CreateAccountsApi(string accessToken, string refreshToken, string cid, string pid)
	{
		IRequester requester = CreateRequester(accessToken, refreshToken, cid, pid);
		return new AccountsApi(requester);
	}
	
	/// <summary>
	/// Create an IInventoryAPI from a gamer tag with signed requester.
	/// </summary>
	/// <param name="gamerTag"></param>
	/// <param name="cid"></param>
	/// <param name="pid"></param>
	/// <param name="secret"></param>
	/// <returns></returns>
	private IInventoryApi CreateInventoryApi(long gamerTag, string cid, string pid, string secret)
	{
		IRequester requester = CreateSignedRequester(gamerTag, cid, pid, secret);
		return new InventoryApi(requester);
	}
	
	/// <summary>
	/// Create an IStatsApi from a gamer tag with signed requester.
	/// </summary>
	/// <param name="gamerTag"></param>
	/// <param name="cid"></param>
	/// <param name="pid"></param>
	/// <param name="secret"></param>
	/// <returns></returns>
	private IStatsApi CreateStatsApi(long gamerTag, string cid, string pid, string secret)
	{
		IRequester requester = CreateSignedRequester(gamerTag, cid, pid, secret);
		return new StatsApi(requester);
	}
	
	
	/// <summary>
	/// It will try to get the user developer from the local disk
	/// The file name is the gamer tag for the user developer
	/// <param name="developerUserType">Defines the folder that the user is saved.</param>
	/// </summary>
	private bool TryGetCachedUser(List<string> gamerTags, DeveloperUserType developerUserType, out List<DeveloperUser> cachedUsers)
	{
		cachedUsers = new List<DeveloperUser>();
		
		string userPath = GetFullPath(developerUserType);

		string[] files = Directory.GetFiles(userPath);

		bool foundAny = false;
		
		foreach (var file in files)
		{
			string gamerTag = Path.GetFileNameWithoutExtension(file);
			if (gamerTags.Contains(gamerTag))
			{
				string cachedUserJson = File.ReadAllText(file);
				DeveloperUser developerUser;
				try
				{
					developerUser = JsonConvert.DeserializeObject<DeveloperUser>(cachedUserJson);
				}
				catch
				{
					developerUser = new DeveloperUser
					{
						Alias = file,
						IsCorrupted = true
					};
				}

				if (!long.TryParse(gamerTag, out developerUser.GamerTag))
				{
					developerUser.IsCorrupted = true;
					developerUser.Alias = file;
				}

				developerUser.DeveloperUserType = (int)developerUserType; // Override the developer type based on the folder
				
				cachedUsers.Add(developerUser);

				foundAny = true;
			}
		}
		
		return foundAny;
	}
	
	/// <summary>
	/// A utility that get the current stats for a player using the stats API
	/// </summary>
	/// <param name="uid"></param>
	/// <param name="statApi"></param>
	/// <returns></returns>
	private async Task<Dictionary<string, StatsResponse>> GetStatMap(long uid, IStatsApi statApi)
	{
		string[] statsKeys = new string[]
		{
			"game.public.player.{0}",
			"game.private.player.{0}",
			"client.public.player.{0}",
			"client.private.player.{0}"
		};
		
		Dictionary<string, StatsResponse> statsResponses = new Dictionary<string, StatsResponse>();


		List<Task> statsTasks = new List<Task>();
		foreach (var statKey in statsKeys)
		{
			var statsPromise = statApi.ObjectGet(string.Format(statKey, uid)).Then(item => statsResponses.Add(statKey, item));
			
			statsTasks.Add(statsPromise.TaskFromPromise());
		}

		await Task.WhenAll(statsTasks.ToArray());
		
		return statsResponses;
	}
	
	
	/// <summary>
	/// A utility to get the folder path from the developer user type
	/// </summary>
	/// <param name="developerUserType"></param>
	/// <returns></returns>
	private string GetDeveloperUserFolder(DeveloperUserType developerUserType)
	{
		switch (developerUserType)
		{
			case DeveloperUserType.Local:
				return LocalUserPath;
			case DeveloperUserType.Shared:
				return SharedUserPath;
			default:
				return CapturedUserPath;
		}
	}
	
	/// <summary>
	/// A utility to get the full path for a given developer user type
	/// </summary>
	/// <param name="developerUserType"></param>
	/// <returns></returns>
	private string GetFullPath(DeveloperUserType developerUserType)
	{
		if (developerUserType == DeveloperUserType.Shared)
		{
			return Path.Combine(Path.Combine(_configService.ConfigDirectoryPath!, BaseUserPath), GetDeveloperUserFolder(developerUserType));
		}
		else
		{
			return Path.Combine(Path.Combine(_configService.ConfigTempDirectoryPath!, BaseUserPath), GetDeveloperUserFolder(developerUserType));
		}

	}

	/// <summary>
	/// A utility to check if a user is valid and log and error, the caller still needs to threat this case, but this helps to clean up a little the code.
	/// </summary>
	/// <param name="developerUser"></param>
	/// <returns></returns>
	private bool IsUserDeveloperValid(DeveloperUser developerUser)
	{
		if (!developerUser.IsValidUser())
		{
			BeamableLogger.LogError($"Developer user not found with gamer tag: {developerUser.Alias}");
		}
		return developerUser.IsValidUser();
	}

	public static IEnumerable<DeveloperUserData> DeveloperUsersToDeveloperUsersData(List<DeveloperUser> developerUsers)
	{
		return developerUsers.Select(DeveloperUserToDeveloperUserData);
	}
	public static DeveloperUserData DeveloperUserToDeveloperUserData(DeveloperUser developerUser)
	{
		DeveloperUserData developerUserData = new DeveloperUserData
		{
			GamerTag = !developerUser.IsCorrupted ? developerUser.GamerTag : new Random().NextInt64(0, Int64.MaxValue),
			TemplateGamerTag = developerUser.TemplateGamerTag,
			Alias	=  string.IsNullOrEmpty(developerUser.Alias) ? "" : developerUser.Alias,
			AccessToken = string.IsNullOrEmpty(developerUser.AccessToken) ? "" : developerUser.AccessToken,
			RefreshToken = string.IsNullOrEmpty(developerUser.RefreshToken) ? "" : developerUser.RefreshToken,
			Cid = string.IsNullOrEmpty(developerUser.Cid) ? "" : developerUser.Cid,
			Pid = string.IsNullOrEmpty(developerUser.Pid) ? "" : developerUser.Pid,
			Description = string.IsNullOrEmpty(developerUser.Description) ? "" : developerUser.Description,
			CreatedDate = developerUser.CreatedDate,
			DeveloperUserType = developerUser.DeveloperUserType,
			ExpiresIn = developerUser.ExpiresIn,
			IssuedAt = developerUser.IssuedAt,
			Tags = developerUser.Tags ?? new List<string>(),
			IsCorrupted = developerUser.IsCorrupted,
		};
		
		return developerUserData;
	}

}
