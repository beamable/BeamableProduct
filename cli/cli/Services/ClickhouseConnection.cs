using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.BeamCli.Contracts;
using Beamable.Server;
using cli.OtelCommands;
using ClickHouse.Client.ADO;
using Dapper;
using System.Globalization;

namespace cli.Services;

public static class ClickhouseConnection
{

	public static string ConnectionString(OtelAuthConfig config)
	{
		string uriString = config.endpoint;
		if (!config.endpoint.StartsWith("http://", StringComparison.OrdinalIgnoreCase) &&
		    !config.endpoint.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
		{
			uriString = "http://" + config.endpoint;
		}

		var uri = new Uri(uriString);

		var host = uri.Host;
		var port = uri.Port;

		var builder = new ClickHouseConnectionStringBuilder
		{
			Host = host,
			Port = (ushort)port,
			Username = config.username,
			Password = config.password,
			Protocol = "https"
		};

		return builder.ConnectionString;
	}

	public static async Task<List<FetchCommandLogRecord>> FetchLogs(OtelAuthConfig config, FetchTelemetryLogsCommandArgs args)
	{
		var connectionString = ConnectionString(config);

		var query = ComputeQueryWithFilters(args);
		var result = await ExecuteQuery(connectionString, query);

		return result;
	}

	private static string ComputeQueryWithFilters(FetchTelemetryLogsCommandArgs args)
	{

		List<string> allFilters = new List<string>();

		if (!string.IsNullOrEmpty(args.FromTime))
		{
			if (args.FromTime.Length < 2)
			{
				throw new Exception(
					"The string value must have at least 1 number and 1 character sinalizing time, examples: 1d, 12h, 30m, ...");
			}

			var time = args.FromTime.Substring(args.FromTime.Length - 1);
			var value = args.FromTime.Substring(0, args.FromTime.Length - 1);

			switch (time)
			{
				case "d":
				case "D":
					allFilters.Add(string.Format(ClickhouseQueries.WITHIN_DAYS, value));
					break;
				case "H":
				case "h":
					allFilters.Add(string.Format(ClickhouseQueries.WITHIN_HOURS, value));
					break;
				case "m":
				case "M":
					allFilters.Add(string.Format(ClickhouseQueries.WITHIN_MINUTES, value));
					break;
				default:
					throw new InvalidArgumentException("--from", $"The from option needs to end with either d, h or m. Got :[{time}]. Full time: [{args.FromTime}]");
			}
		}

		if (!string.IsNullOrEmpty(args.ServiceName))
		{
			var query = args.FullMatch ? ClickhouseQueries.SERVICE_NAME_FULL_MATCH : ClickhouseQueries.SERVICE_NAME_PARTIAL_MATCH;
			allFilters.Add(string.Format(query, args.ServiceName));
		}

		if (!string.IsNullOrEmpty(args.LogLevel))
		{
			allFilters.Add(string.Format(ClickhouseQueries.LOG_LEVEL_MATCH, args.LogLevel));
		}

		if (!string.IsNullOrEmpty(args.BodyMatch))
		{
			var query = args.FullMatch ? ClickhouseQueries.BODY_FULL_MATCH : ClickhouseQueries.BODY_PARTIAL_MATCH;
			allFilters.Add(string.Format(query, args.BodyMatch));
		}

		string filtersSql = string.Empty;

		if (allFilters.Count > 0)
		{
			filtersSql = $"{ClickhouseQueries.WHERE_OPERATION} {string.Join($" {ClickhouseQueries.AND_OPERATION} ", allFilters)} ";
		}

		var order = args.AscendingOrder ? "ASC" : "DESC";

		var queryFinal = string.Format(ClickhouseQueries.SELECT_TEMPLATE, filtersSql, order, args.LimitRows);

		return queryFinal;
	}

	private static async Task<List<FetchCommandLogRecord>> ExecuteQuery(string connectionString, string query)
	{
		await using var connection = new ClickHouseConnection(connectionString);

		Log.Verbose($"Running query: [{query}] in clickhouse");
		var allRows = await connection.QueryAsync(query);

		List<FetchCommandLogRecord> result = new List<FetchCommandLogRecord>();

		foreach (var row in allRows)
		{
			if (row != null)
			{
				DateTime convertedDate = DateTime.SpecifyKind(
					DateTime.Parse(row.Timestamp.ToString()),
					DateTimeKind.Utc);
				result.Add(new FetchCommandLogRecord()
				{
					Timestamp = convertedDate.ToLocalTime().ToString(CultureInfo.InvariantCulture),
					LogLevel = row.SeverityText,
					Message = row.Body,
					ServiceName = row.ServiceName
				});
			}

		}

		return result;
	}

	public static bool GetClickhouseAuthOverrides(out OtelAuthConfig config)
	{
		var endpoint = Environment.GetEnvironmentVariable(Beamable.Common.Constants.Features.Otel.ENV_COLLECTOR_CLICKHOUSE_ENDPOINT);
		var userName = Environment.GetEnvironmentVariable(Beamable.Common.Constants.Features.Otel.ENV_COLLECTOR_CLICKHOUSE_USERNAME);
		var passd = Environment.GetEnvironmentVariable(Beamable.Common.Constants.Features.Otel.ENV_COLLECTOR_CLICKHOUSE_PASSWORD);

		bool envVarsExist = !string.IsNullOrEmpty(endpoint) &&
		                    !string.IsNullOrEmpty(userName) &&
		                    !string.IsNullOrEmpty(passd);

		if (envVarsExist)
		{
			config = new OtelAuthConfig()
			{
				endpoint = endpoint,
				username = userName,
				password = passd
			};
			return true;
		}

		config = null;
		return false;
	}
}

[Serializable]
public record ClickHouseEndpoint
{
	public string Protocol { get; init; }
	public string Host { get; init; }
	public ushort Port { get; init; }
	public Uri Uri => new($"{Protocol}://{Host}:{Port}");
}
