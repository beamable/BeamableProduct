using Beamable.Server;
using cli.Services.Web.CodeGen;
using cli.Services.Web.Helpers;
using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Models;
using ServiceConstants = Beamable.Common.Constants.Features.Services;

namespace cli.Services.Web;

public class WebClientCodeGenerator
{
	private const string AUTOGEN_MODEL_NAMESPACE = "Beamable.Api.Autogenerated.Models";

	private static string _langType;
	private readonly TsFile _clientFile;
	private List<string> _modules = new();
	private readonly HashSet<string> _schemas = new();
	private static readonly HashSet<TsTypeAlias> ClientTypes = new();
	private static readonly List<(TsTypeAlias, List<string>)> ModuleTypes = new(); // (typeAlias, deps)

	private static readonly List<string> CallableMethodsToGenerate = new()
	{
		nameof(CallableAttribute),
		nameof(ServerCallableAttribute),
		nameof(ClientCallableAttribute),
		nameof(AdminOnlyCallableAttribute)
	};

	public WebClientCodeGenerator(OpenApiDocument document, string langType)
	{
		_langType = langType;
		var serviceName = document.Info.Title;
		var serviceClientClassName = $"{serviceName}Client";
		var tsClass = new TsClass(serviceClientClassName);

		var tsConstructor = new TsConstructor();
		var tsBeamConstructorParams = new TsConstructorParameter("beam", TsType.Of("BeamBase"), !IsTypeScript);

		var tsGetServiceNameMethod = new TsMethod("get serviceName", !IsTypeScript)
			.SetReturnType(TsType.String)
			.AddBody(new TsReturnStatement(new TsLiteralExpression(serviceName)));

		tsConstructor.AddParameter(tsBeamConstructorParams);
		tsConstructor.AddBody(
			new TsExpressionStatement(new TsInvokeExpression(new TsIdentifier("super"), new TsIdentifier("beam"))));

		tsClass.SetConstructor(tsConstructor);
		tsClass.SetExtends(new TsIdentifier("BeamMicroServiceClient"));
		tsClass.AddModifier(TsModifier.Export);
		tsClass.AddMethod(tsGetServiceNameMethod);

		AddFederationIdProps(tsClass, document);
		AddMethodsToClass(tsClass, document);

		_clientFile = new TsFile(serviceClientClassName);

		if (IsTypeScript)
		{
			ProcessClientTypes();
			GenerateBeamSDKModuleDeclaration(_clientFile, tsClass);
		}

		_clientFile.AddDeclaration(tsClass);

		var tsBeamSdkImport = new TsImport("beamable-sdk");
		tsBeamSdkImport.AddNamedImport("BeamMicroServiceClient");
		_clientFile.AddImport(tsBeamSdkImport);

		if (!IsTypeScript)
			return;
		
		tsBeamSdkImport.AddNamedImport("type BeamBase");

		if (_schemas.Count > 0)
		{
			var tsBeamSchemaImport =
				new TsImport("beamable-sdk/schema", defaultImport: "* as Schemas", typeImportOnly: true);
			_clientFile.AddImport(tsBeamSchemaImport);
		}

		if (ClientTypes.Count > 0)
		{
			var tsClientTypesImport = new TsImport("./types", defaultImport: "* as Types", typeImportOnly: true);
			_clientFile.AddImport(tsClientTypesImport);
		}
	}

	private void AddFederationIdProps(TsClass tsClass, OpenApiDocument document)
	{
		if (!document.Extensions.TryGetValue(ServiceConstants.MICROSERVICE_FEDERATED_COMPONENTS_V2_KEY, out var ext) ||
		    ext is not OpenApiArray { Count: > 0 } federationIds)
			return;

		const string federationIdsIdentifierName = "federationIds";
		var tsObjectLiteral = new TsObjectLiteralExpression();

		foreach (var id in federationIds)
		{
			if (id is not OpenApiObject obj || !obj.TryGetValue("federationId", out var raw) ||
			    raw is not OpenApiString { Value: var federationId })
				continue;

			// sanitize federationId to ensure it is a valid TypeScript identifier
			var sanitizedFederationId = federationId.Replace("-", "_").Replace(" ", "_").Replace(".", "_");
			tsObjectLiteral.AddMember(new TsIdentifier(sanitizedFederationId), new TsLiteralExpression(federationId));
		}

		var tsProperty = new TsProperty(federationIdsIdentifierName, emitJavaScript: !IsTypeScript)
			.AddModifier(TsModifier.Readonly)
			.WithInitializer(tsObjectLiteral)
			.AsConstAssertion(); // default TsType.Any will be ignored since this is a const assertion
		tsClass.AddProperty(tsProperty);
	}

	private void AddMethodsToClass(TsClass tsClass, OpenApiDocument document)
	{
		foreach ((string path, OpenApiPathItem item) in document.Paths)
		{
			if (item.Extensions.TryGetValue(ServiceConstants.METHOD_SKIP_CLIENT_GENERATION_KEY, out var isHidden) &&
			    isHidden is OpenApiBoolean { Value: true })
				continue;

			var methodName = path.Replace("/", string.Empty);
			foreach ((OperationType _, OpenApiOperation operation) in item.Operations)
			{
				// does the extension exist?
				if (!operation.Extensions.TryGetValue(ServiceConstants.OPERATION_CALLABLE_METHOD_TYPE_KEY,
					    out var ext))
					continue;

				// is it the right type?
				if (ext is not OpenApiString apiString)
					continue;

				// is it in our “to generate” list?
				if (!CallableMethodsToGenerate.Contains(apiString.Value))
					continue;

				// is there a success response?
				if (!operation.Responses.TryGetValue("200", out var response))
					continue;

				bool isBeamSchemaResponse = false;
				TsType responseType = TsType.Void;
				if (response.Content.TryGetValue("application/json", out var responseMediaType))
				{
					var responseSchema = responseMediaType.Schema;
					var responseSchemaRefId = responseSchema.Reference?.Id ?? "";
					if (responseSchemaRefId.Contains(AUTOGEN_MODEL_NAMESPACE))
					{
						isBeamSchemaResponse = true;
						responseType = HandleAutoGenSchema(responseSchema, responseSchemaRefId);
					}
					else
					{
						responseType = OpenApiTsTypeMapper.Map(responseSchema, ref _modules);
						HandleSchema(responseSchema, responseType);
					}
				}

				bool isBeamSchemaRequest = false;
				TsType requestType = null;
				if (operation.RequestBody?.Content?.TryGetValue("application/json", out var requestMediaType) ??
				    false)
				{
					var requestSchema = requestMediaType.Schema;
					var requestSchemaRefId = requestSchema.Reference?.Id ?? "";
					if (requestSchemaRefId.Contains(AUTOGEN_MODEL_NAMESPACE))
					{
						isBeamSchemaRequest = true;
						requestType = HandleAutoGenSchema(requestSchema, requestSchemaRefId);
					}
					else
					{
						requestType = OpenApiTsTypeMapper.Map(requestSchema, ref _modules);
						HandleSchema(requestSchema, requestType);
					}
				}

				AddCallableMethod(tsClass, methodName, requestType, responseType, _modules, isBeamSchemaRequest,
					isBeamSchemaResponse);
			}
		}
	}

	private void AddCallableMethod(TsClass tsClass, string methodName, TsType requestType, TsType returnType,
		List<string> modules, bool isBeamSchemaRequest, bool isBeamSchemaResponse)
	{
		var tsMethod = new TsMethod(StringHelper.ToCamelCaseIdentifier(methodName), !IsTypeScript);
		tsMethod.AddModifier(TsModifier.Async);

		if (requestType != null)
		{
			var requestTypeRender = requestType.Render();
			requestType = modules.Exists(m => requestTypeRender == m)
				? TsType.Of($"Types.{requestTypeRender}")
				: TsType.Of(isBeamSchemaRequest ? $"Schemas.{requestTypeRender}" : requestTypeRender);
			tsMethod.AddParameter(new TsFunctionParameter("params", requestType, !IsTypeScript));
		}

		var returnTypeRender = returnType.Render();
		TsType returnTypePromise = modules.Exists(m => returnTypeRender == m)
			? TsType.Generic("Promise", TsType.Of($"Types.{returnTypeRender}"))
			: TsType.Generic("Promise",
				TsType.Of(isBeamSchemaResponse ? $"Schemas.{returnTypeRender}" : returnTypeRender));

		tsMethod.SetReturnType(returnTypePromise);

		var tsRequestObjectLiteral = new TsObjectLiteralExpression();
		tsRequestObjectLiteral.AddMember(new TsIdentifier("endpoint"), new TsLiteralExpression(methodName));

		if (requestType != null)
			tsRequestObjectLiteral.AddMember(new TsIdentifier("payload"), new TsIdentifier("params"));

		tsRequestObjectLiteral.AddMember(new TsIdentifier("withAuth"), new TsLiteralExpression(true));

		var tsRequestInvocation =
			new TsInvokeExpression(new TsMemberAccessExpression(new TsIdentifier("this"), "request"),
				tsRequestObjectLiteral);
		var tsReturnStatement = new TsReturnStatement(tsRequestInvocation);
		tsMethod.AddBody(tsReturnStatement);
		tsClass.AddMethod(tsMethod);
	}

	private void HandleSchema(OpenApiSchema schema, TsType type)
	{
		if (schema.Type == "array")
			schema = schema.Items;

		var schemaProps = schema.Properties;
		if (schemaProps == null || schema.IsPrimitive())
			return;

		var modules = new List<string>();
		var objectPropTypes = new List<(string name, TsType type, TsType.PropType propType)>();
		foreach ((string propName, OpenApiSchema propSchema) in schemaProps)
		{
			var isRequired = schema.Required?.Contains(propName) ?? false;
			var propType = OpenApiTsTypeMapper.Map(propSchema, ref modules);
			objectPropTypes.Add((propName, propType,
				isRequired ? TsType.PropType.Required : TsType.PropType.Optional));

			var propSchemaProps = propSchema.Properties;
			if (propSchemaProps == null || schema.IsPrimitive())
				continue;

			// skip DateTime schema since we map it to string
			if (propSchema.Extensions.TryGetValue(ServiceConstants.MICROSERVICE_EXTENSION_BEAMABLE_TYPE_NAME,
				    out var beamableTypeName) && beamableTypeName is OpenApiString { Value: "DateTime" })
				continue;

			HandleSchema(propSchema, propType);
		}

		var typeRender = type.Render();
		if (typeRender.EndsWith("[]"))
			typeRender = typeRender.Substring(0, typeRender.Length - 2);

		ModuleTypes.Add(
			(new TsTypeAlias(typeRender)
				.AddModifier(TsModifier.Export)
				.SetType(TsType.Object(objectPropTypes.ToArray())), modules));
	}

	private TsType HandleAutoGenSchema(OpenApiSchema schema, string schemaRefId)
	{
		var isNullable = schema.Nullable;
		var schemaName = schemaRefId.Split('.').Last();
		_schemas.Add(schemaName);
		var schemaType = TsType.Of(schemaName);
		schemaType = isNullable ? TsType.Union(schemaType, TsType.Null) : schemaType;
		return schemaType;
	}
	
	private static void ProcessClientTypes()
	{
		foreach (var (moduleType, _) in ModuleTypes)
			ClientTypes.Add(moduleType);
	}

	private static void GenerateBeamSDKModuleDeclaration(TsFile clientFile, TsClass tsClass)
	{
		var className = tsClass.Name;
		var camelCaseClassName = StringHelper.ToCamelCaseIdentifier(className);
		var serviceName = tsClass.Name.Replace("Client", string.Empty);
		var tsModule = new TsModule("beamable-sdk");
		var tsInterface = new TsInterface("BeamBase");
		var tsProperty = new TsProperty(camelCaseClassName, TsType.Of(className));
		var tsComment = new TsComment(
			$"Access the {serviceName} microservice.\n@remarks Before accessing this property, register it first via the `use` method.\n@example\n```ts\n// client-side:\nbeam.use({className});\nbeam.{camelCaseClassName}.serviceName;\n// server-side:\nbeamServer.use({className});\nbeamServer.{camelCaseClassName}.serviceName;\n```",
			TsCommentStyle.Doc);
		tsProperty.AddComment(tsComment);
		tsInterface.AddProperty(tsProperty);
		tsModule.AddStatement(tsInterface);
		var tsDeclare = new TsDeclare(tsModule);
		clientFile.AddDeclaration(tsDeclare);
	}

	public string GenerateClientCode(string clientsOutputDirectory)
	{
		var extension = IsTypeScript ? ".ts" : ".js";
		Directory.CreateDirectory(clientsOutputDirectory);
		var clientFilePath = Path.Combine(clientsOutputDirectory, $"{_clientFile.FileName}{extension}");
		File.WriteAllText(clientFilePath, _clientFile.Render());
		return clientFilePath;
	}

	public static string GenerateClientTypes(string typesOutputDirectory)
	{
		if (ClientTypes.Count == 0)
			return string.Empty;

		var tsClientTypeFile = new TsFile("index");
		foreach (var clientType in ClientTypes)
			tsClientTypeFile.AddDeclaration(clientType);

		Directory.CreateDirectory(typesOutputDirectory);
		var clientTypeFilePath = Path.Combine(typesOutputDirectory, $"{tsClientTypeFile.FileName}.ts");
		File.WriteAllText(clientTypeFilePath, tsClientTypeFile.Render());
		return clientTypeFilePath;
	}

	public static bool IsTypeScript => _langType.Equals("typescript", StringComparison.InvariantCultureIgnoreCase) ||
	                                   _langType.Equals("ts", StringComparison.InvariantCultureIgnoreCase);
}
