using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Server;
using Beamable.Server.Common;
using cli.FederationCommands;
using cli.Utils;
using Newtonsoft.Json;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Text;

namespace cli.Services;

public class DiscoveryService
{
	private readonly BeamoLocalSystem _localSystem;
	private readonly IAppContext _appContext;

	private Task _localDiscoveryListen;
	private Task _dockerDiscoveryListen;
	private Task _routingDiscoveryListen;

	private ConcurrentDictionary<string, (long, ServiceDiscoveryEntry)> _localDiscoveryEntryWithTimestamp;
	private ConcurrentDictionary<string, string[]> _nameToRoutingKeys;
	private ConcurrentQueue<ServiceDiscoveryEvent> _evtQueue;


	public DiscoveryService(BeamoLocalSystem localSystem, IAppContext appContext)
	{
		_localSystem = localSystem;
		_appContext = appContext;
	}

	public async Task Stop()
	{
		await _localSystem.StopListeningToDocker();
	}

	public string[] GetRoutingKeys(string beamoId) => _nameToRoutingKeys[beamoId.ToLower()];

	public async IAsyncEnumerable<ServiceDiscoveryEvent> StartDiscovery(CommandArgs args, TimeSpan timeout = default, [EnumeratorCancellation] CancellationToken token = default)
	{
		_nameToRoutingKeys = new ConcurrentDictionary<string, string[]>();
		_localDiscoveryEntryWithTimestamp = new ConcurrentDictionary<string, (long, ServiceDiscoveryEntry)>();
		_evtQueue = new ConcurrentQueue<ServiceDiscoveryEvent>();

		// Get the list of registered services in the entire realm 
		var realmRegisteredServices = await ListServicesCommand.GetRunningServices(args.DependencyProvider);
		foreach (var s in realmRegisteredServices.services)
		{
			// This is lower-case cause the backend lower-cases this stuff for reasons...
			var beamoId = s.name;
			var routingKey = s.routingKey;
			if (!_nameToRoutingKeys.TryAdd(beamoId, new[] { routingKey }))
			{
				var currentKeys = GetRoutingKeys(beamoId).ToList();
				currentKeys.Add(routingKey);
				_nameToRoutingKeys[beamoId] = currentKeys.ToArray();
			}
		}

		// Prepare one event for every existing entry in the manifest
		var currentEntries = _localSystem.BeamoManifest.ServiceDefinitions.Select(sd => (Definition: sd, Entry: CreateEntryFromServiceDefinition(sd))).ToArray();
		foreach (var e in currentEntries)
		{
			var beamoId = e.Definition.BeamoId.ToLower();
			_nameToRoutingKeys.TryAdd(beamoId, Array.Empty<string>());
			_evtQueue.Enqueue(CreateEvent(e.Entry, e.Definition, GetRoutingKeys(beamoId)));
		}

		// Set up a task that will listens for messages broadcast by any locally running microservices
		// This then wraps it up in an event and enqueues it.
		var socketListener = new Socket(SocketType.Dgram, ProtocolType.Udp);
		_localDiscoveryListen = Task.Run(async () =>
		{
			try
			{
				var ed = new IPEndPoint(IPAddress.Any, Beamable.Common.Constants.Features.Services.DISCOVERY_PORT);
				socketListener.Bind(ed);
				
				var buffer = new ArraySegment<byte>(new byte[1024 * 2]);
				var toRemove = new HashSet<string>();
				do
				{
					// Block and wait for a socket message.
					var byteCount = await socketListener.ReceiveAsync(buffer);
					if (byteCount != 0)
					{
						var json = Encoding.UTF8.GetString(buffer.Array!, 0, byteCount);

						// Deserialize the entry into an entry.
						var service = JsonConvert.DeserializeObject<ServiceDiscoveryEntry>(json, UnitySerializationSettings.Instance);

						// If the message we got from a local service running that is not for this PID/CID, we ignore it.
						if (service.cid != _appContext.Cid || service.pid != _appContext.Pid)
							continue;

						// Find out frow which services we have not received messages in the past DISCOVERY_RECEIVE_PERIOD_MS  
						var now = DateTimeOffset.Now.ToUnixTimeMilliseconds();
						foreach (var kvp in _localDiscoveryEntryWithTimestamp)
						{
							var age = now - kvp.Value.Item1;
							if (age > Beamable.Common.Constants.Features.Services.DISCOVERY_RECEIVE_PERIOD_MS)
							{
								var sd = _localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == kvp.Key);
								_evtQueue.Enqueue(CreateEvent(kvp.Value.Item2, sd, GetRoutingKeys(sd.BeamoId), false));
								toRemove.Add(kvp.Key);
							}
						}

						// Remove all the entries that we haven't heard from in a while
						foreach (var x in toRemove) _localDiscoveryEntryWithTimestamp.Remove(x, out _);
						toRemove.Clear();

						// If we don't have the entry (in this map), we emit the event that the service is now running and store it in the map. 
						if (!_localDiscoveryEntryWithTimestamp.ContainsKey(service.serviceName))
						{
							var sd = _localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == service.serviceName);
							_evtQueue.Enqueue(CreateEvent(service, sd, GetRoutingKeys(sd.BeamoId)));
						}

						// We keep the last time we hear from a service in this dictionary so that we can know when it dies off.
						_localDiscoveryEntryWithTimestamp[service.serviceName] = (now, service);
					}

					if (token.IsCancellationRequested)
						break;
					
					await Task.Delay(50);
				} while (true);
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);

		// Start a websocket connection to listen for service registrations in the realm.
		// This will listen for routing information that services register with our backend
		// and enqueue events whenever updates are detected. 
		_routingDiscoveryListen = Task.Run(async () =>
		{
			try
			{
				var ws = await WebsocketUtil.ConfigureWebSocketForServerNotifications(args, new[] { "beamo.service_registration_changed" }, token);
				await WebsocketUtil.RunServerNotificationListenLoop(ws, message =>
				{
					var bodyJson = JsonConvert.SerializeObject(message.body);
					var data = JsonConvert.DeserializeObject<MicroserviceRegistrationsResponse>(bodyJson, UnitySerializationSettings.Instance);

					// We clear the list of keys as we rebuild it from the ground up every notification we receive --- then ensure there's an entry for all services.
					_nameToRoutingKeys.Clear();
					foreach (string id in _localSystem.BeamoManifest.ServiceDefinitions.Select(sd => sd.BeamoId))
						_nameToRoutingKeys.AddOrUpdate(id.ToLower(), Array.Empty<string>(), (_, _) => Array.Empty<string>());

					// Now we update the list of routing keys we do see.
					foreach (var registration in data.registrations)
					{
						// This is in the form {cid}.{pid}._micro{beamoId}.basic
						// beamoId here is already all lower-case 
						var splitServiceName = registration.serviceName.Split('.');
						var beamoId = splitServiceName[2].StartsWith("_micro") ? splitServiceName[2].Substring(5) : splitServiceName[2];
						var routingKey = registration.routingKey.GetNonEmptyOrElse(() => "");
						if (_nameToRoutingKeys.TryGetValue(beamoId, out var keys))
						{
							var currentKeys = keys.ToList();
							currentKeys.Add(routingKey);
							_nameToRoutingKeys.AddOrUpdate(beamoId, currentKeys.ToArray(), (_, _) => currentKeys.ToArray());
						}
					}

					// For each existing service, emit an event with the updated routing keys
					var existingServices = _localSystem.BeamoManifest.ServiceDefinitions;
					foreach (var sd in existingServices)
					{
						var latestEntry = _localDiscoveryEntryWithTimestamp.TryGetValue(sd.BeamoId, out var entry) ? entry.Item2 : CreateEntryFromServiceDefinition(sd);
						var latestEvent = CreateEvent(latestEntry, sd, GetRoutingKeys(sd.BeamoId));
						_evtQueue.Enqueue(latestEvent);
					}
				}, token);
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);

		// This looks for services running locally inside docker and emit events whenever they are turned on/off.
		// If docker isn't running, this checks for docker to be running every 1-second.
		_dockerDiscoveryListen = Task.Run(async () =>
		{
			try
			{
				var isListeningToDocker = false;
				var wasDockerRunningLastTick = false;
				do
				{
					// Check if docker's state changed (on/off) so we can reset isListeningToDocker.
					var isDockerRunning = await _localSystem.CheckIsRunning();
					if ((!isDockerRunning && wasDockerRunningLastTick) || (isDockerRunning && !wasDockerRunningLastTick)) isListeningToDocker = false;
					wasDockerRunningLastTick = isDockerRunning;

					// If docker isn't running, wait for X second and try again.
					// If we already are listening to docker, just keep checking if docker is still running every 1 second.
					if (!isDockerRunning || isListeningToDocker)
					{
						await Task.Delay(250, token);
					}
					// If we get here, its because we are not configured to listen to docker so...
					// We emit events for the current state and then hook up a listener to the docker process
					// so we get updates as users start/shutdown services. 
					else
					{
						var runningServices = await _localSystem.GetDockerRunningServices();
						foreach (KeyValuePair<string, string> pair in runningServices)
						{
							var beamoId = pair.Key;
							var serviceDefinition = _localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == beamoId);
							var service = await CreateEntryFromDocker(beamoId, pair.Value);

							var evt = CreateEvent(service, serviceDefinition, GetRoutingKeys(beamoId));
							_evtQueue.Enqueue(evt);
						}

						// This doesn't actually block
						await _localSystem.StartListeningToDockerRaw(async (beamoId, eventType, raw) =>
						{
							if (eventType != "start" && eventType != "destroy")
							{
								return;
							}

							var service = await CreateEntryFromDocker(beamoId, raw.ID);
							var serviceDefinition = _localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == beamoId);
							var evt = CreateEvent(service, serviceDefinition, GetRoutingKeys(beamoId));
							_evtQueue.Enqueue(evt);
						});

						isListeningToDocker = true;
					}

					if (token.IsCancellationRequested)
						break;

				} while (true);
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);

		// Cache the startup time
		var startTime = DateTimeOffset.Now;
		do
		{
			// return any messages to the caller.
			while (_evtQueue.TryDequeue(out var evt))
			{
				yield return evt;
			}
			_evtQueue.Clear();

			// check if we have exhausted our ps time.
			var nowTime = DateTimeOffset.Now;
			var duration = nowTime - startTime;
			if (timeout != default && timeout < duration)
			{
				break;
			}

			if (token.IsCancellationRequested)
			{
				break;
			}

			await Task.Delay(50, token);
		} while (true);

		// Here because if we don't kill of the "listening to docker" underlying process, this command's process never closes even after this function completes.
		var isDockerRunning = await _localSystem.CheckIsRunning();
		if (isDockerRunning)
		{
			await _localSystem.StopListeningToDocker();
		}
	}

	public ServiceDiscoveryEntry CreateEntryFromServiceDefinition(BeamoServiceDefinition definition)
	{
		return new ServiceDiscoveryEntry()
		{
			processId = 0,
			cid = _appContext.Cid,
			pid = _appContext.Pid,
			prefix = MachineHelper.GetUniqueDeviceId(),
			serviceName = definition.BeamoId,
			executionVersion = "",
			serviceType = definition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
			dataPort = 0,
			healthPort = 0,
			isContainer = false,
			containerId = "",
		};
	}

	public async Promise<ServiceDiscoveryEntry> CreateEntryFromDocker(string beamoId, string id)
	{
		var serviceDefinition = _localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == beamoId);
		if (serviceDefinition == null) return null;

		var healthPort = 0;
		var dataPort = 0;
		var version = "";

		if (serviceDefinition.Protocol == BeamoProtocolType.HttpMicroservice)
		{
			try
			{
				var labelsTask = _localSystem.GetImageLabels(beamoId);
				var port = await _localSystem.GetMicroserviceHostPort(beamoId);
				var labels = await labelsTask;
				healthPort = Convert.ToInt32(port);
				labels.TryGetValue("beamVersion", out version);
			}
			catch
			{
				// service is not running, therefore there is no port available
			}
		}
		else
		{
			try
			{
				var port = await _localSystem.GetStorageHostPort(beamoId);
				dataPort = Convert.ToInt32(port);
			}
			catch
			{
				// storage is not running, therefore there is no port available
			}
		}

		var service = new ServiceDiscoveryEntry()
		{
			processId = 0,
			cid = _appContext.Cid,
			pid = _appContext.Pid,
			prefix = MachineHelper.GetUniqueDeviceId(),
			serviceName = serviceDefinition.BeamoId,
			executionVersion = version,
			serviceType = serviceDefinition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
			dataPort = dataPort,
			healthPort = healthPort,
			isContainer = true,
			containerId = id,
		};

		return service;
	}

	public static ServiceDiscoveryEvent CreateEvent(ServiceDiscoveryEntry entry, BeamoServiceDefinition definition, string[] availableRoutingKeys, bool? isRunningOverride = null)
	{
		return new ServiceDiscoveryEvent
		{
			processId = entry.processId,
			isContainer = entry.isContainer,
			// In some cases, we need to explicitly set this as not running.
			// We can determine if the service is running or not based on these variables. (HealthPort is only there if the docker container is running).
			isRunning = isRunningOverride.HasValue ? isRunningOverride.Value : (entry.processId > 0 || entry.healthPort > 0),

			// Header stuff.
			service = entry.serviceName,
			pid = entry.pid,
			cid = entry.cid,
			serviceType = entry.serviceType,
			groups = definition.ServiceGroupTags,

			// This is no longer used by the backend/sdks
			prefix = entry.prefix,

			// Runtime only stuff
			executionVersion = entry.executionVersion,
			containerId = entry.containerId,
			healthPort = entry.healthPort,
			dataPort = entry.dataPort,
			routingKeys = availableRoutingKeys,
		};
	}
}
