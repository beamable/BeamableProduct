using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Serialization;
using Beamable.Server;
using Beamable.Server.Common;
using cli.Utils;
using Newtonsoft.Json;
using Serilog;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Text;
using FederationInstance = Beamable.Common.FederationInstance;
using SupportedFederation = Beamable.Api.Autogenerated.Models.SupportedFederation;

namespace cli.Services;

[Flags]
public enum DiscoveryMode
{
	/// <summary>
	/// This mode signals that all types of discovery should be used
	/// </summary>
	ALL = DiscoveryFlags.DOCKER + DiscoveryFlags.HOST + DiscoveryFlags.REMOTE,

	/// <summary>
	/// this mode signals that only local discovery methods should be used. 
	/// </summary>
	LOCAL = DiscoveryFlags.HOST + DiscoveryFlags.DOCKER,
}

/// <summary>
/// this enum is meant to be used in conjunction with <see cref="DiscoveryMode"/>.
/// Each flag represents a type of discovery.
/// </summary>
public enum DiscoveryFlags
{
	HOST = 1 << 0, // 1
	DOCKER = 1 << 1, // 2
	REMOTE = 1 << 2, // 4
}

public static class DiscoveryModeExtensions
{
	public static bool HasDiscoveryFlag(this DiscoveryMode mode, DiscoveryFlags flag)
	{
		return mode.HasFlag((DiscoveryMode)flag);
	}
}

public class DiscoveryService
{
	private readonly BeamoLocalSystem _localSystem;
	private readonly IAppContext _appContext;

	private Task _localDiscoveryListen;
	private Task _dockerDiscoveryListen;
	private Task _routingDiscoveryListen;

	private AccountPortalView _adminSelf;

	private long SelfAccountId => _adminSelf.id;

	/// <summary>
	/// true if there are any on-going discovery tasks.
	/// </summary>
	public bool IsDiscovering { get; private set; }

	public DiscoveryService(BeamoLocalSystem localSystem, IAppContext appContext)
	{
		_localSystem = localSystem;
		_appContext = appContext;
	}

	public async Task Stop()
	{
		await _localSystem.StopListeningToDocker();
	}

	/// <summary>
	/// 
	/// </summary>
	/// <param name="args"></param>
	/// <param name="timeout"></param>
	/// <param name="token"></param>
	/// <param name="includeServerEvents">
	///	When true (default), this discovery session will listen to server-side events over the beamable websocket to learn about services running remotely. 
	/// </param>
	/// <returns></returns>
	public async IAsyncEnumerable<IDiscoveryEvent> StartDiscovery(
		CommandArgs args,
		TimeSpan timeout = default,
		[EnumeratorCancellation] CancellationToken token = default,
		DiscoveryMode mode = DiscoveryMode.ALL)
	{
		if (IsDiscovering)
		{
			throw new CliException("Discovery is already on. This is a Beamable developer error. ");
		}

		IsDiscovering = true;
		try
		{
			var adminSelfTask = args.Provider.GetService<IAccountsApi>().GetAdminMe();
			var childCancellationToken = CancellationTokenSource.CreateLinkedTokenSource(token);

			var hostDiscoveryQueue = new ConcurrentQueue<HostServiceEvent>();
			var dockerDiscoveryQueue = new ConcurrentQueue<DockerServiceEvent>();
			var remoteDiscoveryQueue = new ConcurrentQueue<RemoteServiceEvent>();

			// start getting the list of registered services in the entire realm 
			var realmRegisteredServicesTask = args.Provider.GetService<IBeamoApi>().PostMicroserviceRegistrations(new MicroserviceRegistrationsQuery());
			// we must wait for the current user account before continuing
			_adminSelf = await adminSelfTask;


			var serviceDict = new Dictionary<string, RemoteServiceDescriptor>();

			// seed the event table with the services that are known to be running
			//  this can happen while the other detector systems are starting

			var _ = realmRegisteredServicesTask.Then(result =>
			{
				foreach (var registration in result.registrations)
				{
					// this is only important for remote services. Local services will be caught locally.
					if (registration.startedById == SelfAccountId)
						continue;

					if (!registration.beamoName.HasNonEmptyValue)
					{
						registration.beamoName = BeamoIdsFromServiceName(registration.serviceName, args.BeamoLocalSystem.BeamoManifest.LocalBeamoIds, out var closestMatch);
						if (registration.beamoName == null)
						{
							// This is guaranteed to exist because this does not implement ISkipManifest
							var remote = ProjectContextUtil._existingManifest.GetResult();
							registration.beamoName = BeamoIdsFromServiceName(registration.serviceName, remote.manifest.Select(sr => sr.serviceName), out closestMatch);
						}

						if (registration.beamoName == null)
							throw new CliException($"Failed to convert serviceName of service deployed with old CLI to BeamoName. Please redeploy this service with this new and fancy CLI version." +
							                       $" SERVICE_NAME={registration.serviceName}, CLOSEST_MATCH={closestMatch}");

						Log.Warning("Detected a remote service deployed with previous CLI version. Please redeploy this service. ServiceName={ServiceName}, DerivedBeamoName={BeamoName}", registration.serviceName,
							registration.beamoName.Value);
					}
					// TODO: subscription does not yet run on service exit

					// TODO: think about methodizing this group-thing
					var groups = Array.Empty<string>();
					if (_localSystem.BeamoManifest.TryGetDefinition(registration.beamoName, out var definition))
					{
						groups = definition.ServiceGroupTags;
					}

					// We are basically converting the data formats here.
					// One "SupportedFederation" per id+type exists. We want one "FederationInstance" per IFederationId that has a list of all the IFederation interfaces implementing that id. 
					var federationInstances = registration.federation.GetOrElse(Array.Empty<SupportedFederation>())
						.Select(sf => new FederationInstance()
						{
							FederationId = sf.nameSpace.GetOrElse(""), 
							FederationTypes = new[] { sf.type.ToString() },
							LocalSettings = new[] { sf.settings.GetOrElse(JsonString.FromJson("{}")).Json }
						})
						.GroupBy(fi => fi.FederationId)
						.Select(g => new FederationInstance()
						{
							FederationId = g.Key,
							FederationTypes = g.SelectMany(fi => fi.FederationTypes).ToArray(),
							LocalSettings = g.SelectMany(fi => fi.LocalSettings).ToArray()
						})
						.ToArray();

					var descriptor = new RemoteServiceDescriptor
					{
						startedByAccountId = registration.startedById,
						routingKey = registration.routingKey,
						service = registration.beamoName,
						groups = groups,
						federations = federationInstances
					};
					serviceDict[descriptor.PKey] = descriptor;
					remoteDiscoveryQueue.Enqueue(new RemoteServiceEvent { type = ServiceEventType.Running, descriptor = descriptor, });
				}

				return;
			});

			// Set up a task that will listens for messages broadcast by any locally running microservices
			// This then wraps it up in an event and enqueues it.
			if (mode.HasDiscoveryFlag(DiscoveryFlags.HOST))
			{
				Log.Verbose("starting host discovery");
				_localDiscoveryListen = StartHostDiscoveryTask(childCancellationToken.Token, hostDiscoveryQueue);
			}

			// Start a websocket connection to listen for service registrations in the realm.
			// This will listen for routing information that services register with our backend
			// and enqueue events whenever updates are detected. 
			if (mode.HasDiscoveryFlag(DiscoveryFlags.REMOTE))
			{
				Log.Verbose("starting remote discovery");
				_routingDiscoveryListen = StartRoutingDiscoveryTask(args, childCancellationToken.Token, remoteDiscoveryQueue, serviceDict);
			}

			// This looks for services running locally inside docker and emit events whenever they are turned on/off.
			// If docker isn't running, this checks for docker to be running every 1-second.
			if (mode.HasDiscoveryFlag(DiscoveryFlags.DOCKER))
			{
				Log.Verbose("starting docker discovery");
				_dockerDiscoveryListen = StartDockerDiscoveryTask(childCancellationToken.Token, dockerDiscoveryQueue);
			}


			var expireAt = DateTimeOffset.Now + timeout;
			while (!token.IsCancellationRequested)
			{
				while (hostDiscoveryQueue.Count > 0 && hostDiscoveryQueue.TryDequeue(out var evt))
				{
					yield return evt;
				}

				while (dockerDiscoveryQueue.Count > 0 && dockerDiscoveryQueue.TryDequeue(out var evt))
				{
					yield return evt;
				}

				while (remoteDiscoveryQueue.Count > 0 && remoteDiscoveryQueue.TryDequeue(out var evt))
				{
					yield return evt;
				}

				if (timeout.TotalMilliseconds > 0 && DateTimeOffset.Now > expireAt)
				{
					break;
				}

				await Task.Delay(10, token);
			}

			// cancel the sub tasks.
			await childCancellationToken.CancelAsync();

			if (_dockerDiscoveryListen != null)
			{
				Log.Verbose("waiting for docker discovery to end");
				await _dockerDiscoveryListen;
				_dockerDiscoveryListen = null;
			}

			if (_localDiscoveryListen != null)
			{
				Log.Verbose("waiting for local discovery to end");
				await _localDiscoveryListen;
				_localDiscoveryListen = null;
			}

			if (_routingDiscoveryListen != null)
			{
				Log.Verbose("waiting for routing discovery to end");
				await _routingDiscoveryListen;
				_routingDiscoveryListen = null;
			}

			Log.Verbose("waiting for docker local system to end");
			// Here because if we don't kill of the "listening to docker" underlying process, this command's process never closes even after this function completes.
			var isDockerRunning = await _localSystem.CheckIsRunning();
			if (isDockerRunning)
			{
				await _localSystem.StopListeningToDocker();
			}
		}
		finally
		{
			IsDiscovering = false;
		}
	}

	/// <summary>
	/// This parses the service name as it comes from <see cref="MicroserviceRegistrations.serviceName"/> and generates the correct BeamoId.
	/// Here's the format we are parsing:
	///
	/// CID.PID.micro_{beamo_name_all_lowercase}.basic
	/// </summary>
	private static string BeamoIdsFromServiceName(string serviceNameFromBeamo, IEnumerable<string> knownBeamoIds, out string closestMatch)
	{
		var split = serviceNameFromBeamo.Split('.');
		// ignore the first two elements to remove CID/PID
		split = split.Skip(2).ToArray();

		// get all elements except the last one
		split = split.Take(split.Length - 1).ToArray();

		// Join the remaining elements (we do this this way to handle the potential case of beamoNames that have "." in them --- I think this is disallowed, but I don't remember)
		var serviceName = string.Join("", split);

		if (serviceName.StartsWith("micro_"))
			serviceName = serviceName["micro_".Length..];

		closestMatch = serviceName;
		return knownBeamoIds.FirstOrDefault(knownBeamoId => knownBeamoId.Equals(serviceName, StringComparison.InvariantCultureIgnoreCase));
	}

	public Task StartDockerDiscoveryTask(CancellationToken token, ConcurrentQueue<DockerServiceEvent> evtQueue)
	{
		return Task.Run(async () =>
		{
			try
			{
				var isListeningToDocker = false;
				var wasDockerRunningLastTick = false;
				var containerIdToService = new Dictionary<string, DockerServiceDescriptor>();
				do
				{
					// Check if docker's state changed (on/off) so we can reset isListeningToDocker.
					var isDockerRunning = await _localSystem.CheckIsRunning();
					if ((!isDockerRunning && wasDockerRunningLastTick) ||
					    (isDockerRunning && !wasDockerRunningLastTick)) isListeningToDocker = false;
					wasDockerRunningLastTick = isDockerRunning;

					// If docker isn't running, wait for X second and try again.
					// If we already are listening to docker, just keep checking if docker is still running every 1 second.
					if (!isDockerRunning || isListeningToDocker)
					{
						await Task.Delay(250, token);
					}
					// If we get here, its because we are not configured to listen to docker so...
					// We emit events for the current state and then hook up a listener to the docker process
					// so we get updates as users start/shutdown services. 
					else
					{
						var runningServices = await _localSystem.GetDockerRunningServices();
						foreach (var (beamoId, containerId) in runningServices)
						{
							if (!_localSystem.BeamoManifest.TryGetDefinition(beamoId, out var serviceDefinition))
							{
								// if somehow there is a local running docker container for a service definition that no longer exists, log a warning
								Log.Warning($"Ignoring existing running container=[{containerId}] because no service definition was detected for beamoId=[{beamoId}]");
								continue;
							}

							var service = await CreateEntryFromDocker(serviceDefinition, containerId);
							containerIdToService[containerId] = service;

							evtQueue.Enqueue(new DockerServiceEvent { type = ServiceEventType.Running, descriptor = service });
						}

						// This doesn't actually block
						await _localSystem.StartListeningToDockerRaw(async (beamoId, eventType, raw) =>
						{
							var isCreated = eventType == "create" || eventType == "start";
							var isDeleted = eventType == "destroy";

							if (!isCreated && !isDeleted) return; // skip, because these events don't concern us

							if (!_localSystem.BeamoManifest.TryGetDefinition(beamoId, out var serviceDefinition))
							{
								Log.Warning($"Ignoring running container=[{raw.ID}] because no service definition was detected for beamoId=[{beamoId}]");
								return;
							}

							var service = await CreateEntryFromDocker(serviceDefinition, raw.ID);
							if (isCreated)
							{
								if (!containerIdToService.ContainsKey(raw.ID))
								{
									containerIdToService[raw.ID] = service;
									evtQueue.Enqueue(new DockerServiceEvent { type = ServiceEventType.Running, descriptor = service });
								}
							}
							else if (containerIdToService.ContainsKey(raw.ID))
							{
								containerIdToService.Remove(raw.ID);
								evtQueue.Enqueue(new DockerServiceEvent { type = ServiceEventType.Stopped, descriptor = service });
							}
						});

						isListeningToDocker = true;
					}

					if (token.IsCancellationRequested)
						break;
				} while (true);
			}
			catch (TaskCanceledException)
			{
				// this exception is "fine"
				//  we can exit the task as though everything is "fine"
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);
	}

	public Task StartRoutingDiscoveryTask(CommandArgs args, CancellationToken token, ConcurrentQueue<RemoteServiceEvent> evtQueue, Dictionary<string, RemoteServiceDescriptor> serviceDict)
	{
		return Task.Run(async () =>
		{
			try
			{
				var ws = await WebsocketUtil.ConfigureWebSocketForServerNotifications(args,
					new[] { "beamo.service_registration_changed" }, token);
				await WebsocketUtil.RunServerNotificationListenLoop(ws, message =>
				{
					var bodyJson = JsonConvert.SerializeObject(message.body);
					var data = JsonConvert.DeserializeObject<MicroserviceRegistrationsResponse>(bodyJson,
						UnitySerializationSettings.Instance);

					// Now we update the list of routing keys we do see.
					var unseen = new HashSet<string>(serviceDict.Keys);
					foreach (var registration in data.registrations)
					{
						/*
						 * If this service was started by the current CLI user, then
						 * the ASSUMPTION is that the service is actually running locally
						 * on this user's machine.
						 * IF that assumption is true, THEN, the local detection schemes will provide better
						 * detail about this service than the registration event, and thus, we can skip it.
						 *
						 * However, the assumption ignores the use case where a user is running C#MS on multiple
						 * machines, and is trying to manage them all together. Services started on another machine
						 * with the same account as the current machine will not appear.
						 */
						if (registration.startedById == SelfAccountId) continue;

						// This is here since we are not back-filling these values for existing deployed services...
						if (!registration.beamoName.HasNonEmptyValue)
						{
							// If the service is in the local manifest, we get it from here.
							registration.beamoName = BeamoIdsFromServiceName(registration.serviceName, args.BeamoLocalSystem.BeamoManifest.LocalBeamoIds, out var closestMatch);

							// This is here to handle cases where services are deployed but are no longer in the local manifest...
							if (registration.beamoName == null)
							{
								// This is guaranteed to exist because this does not implement ISkipManifest
								var remote = ProjectContextUtil._existingManifest.GetResult();
								registration.beamoName = BeamoIdsFromServiceName(registration.serviceName, remote.manifest.Select(sr => sr.serviceName), out closestMatch);
							}

							if (registration.beamoName == null)
								throw new CliException($"Failed to convert serviceName of service deployed with old CLI to BeamoName. Please redeploy this service with this new and fancy CLI version." +
								                       $" SERVICE_NAME={registration.serviceName}, CLOSEST_MATCH={closestMatch}");
						}

						var groups = Array.Empty<string>();
						if (_localSystem.BeamoManifest.TryGetDefinition(registration.beamoName, out var definition))
						{
							groups = definition.ServiceGroupTags;
						}

						// We are basically converting the data formats here.
						// One "SupportedFederation" per id+type exists. We want one "FederationInstance" per IFederationId that has a list of all the IFederation interfaces implementing that id. 
						var federationInstances = registration.federation.GetOrElse(Array.Empty<SupportedFederation>())
							.Select(sf => new FederationInstance()
							{
								FederationId = sf.nameSpace.GetOrElse(""),
								FederationTypes = new[] { sf.type.ToString() },
								LocalSettings = new[]{ sf.settings.GetOrElse(JsonString.FromJson("{}")).Json},
							})
							.GroupBy(fi => fi.FederationId)
							.Select(g => new FederationInstance()
							{
								FederationId = g.Key,
								FederationTypes = g.SelectMany(fi => fi.FederationTypes).ToArray(),
								LocalSettings = g.SelectMany(fi => fi.LocalSettings).ToArray()
							})
							.ToArray();

						var descriptor = new RemoteServiceDescriptor
						{
							startedByAccountId = registration.startedById,
							routingKey = registration.routingKey,
							service = registration.beamoName,
							groups = groups,
							federations = federationInstances,
						};

						unseen.Remove(descriptor.PKey);
						if (!serviceDict.TryGetValue(descriptor.PKey, out var existing))
						{
							evtQueue.Enqueue(new RemoteServiceEvent() { descriptor = descriptor, type = ServiceEventType.Running });
							serviceDict[descriptor.PKey] = descriptor;
						}
					}

					// emit remove events for the services that did not appear in the latest update!
					foreach (var unseenPKey in unseen)
					{
						var descriptor = serviceDict[unseenPKey];
						evtQueue.Enqueue(new RemoteServiceEvent() { descriptor = descriptor, type = ServiceEventType.Stopped });
						serviceDict.Remove(unseenPKey);
					}
				}, token);
			}
			catch (TaskCanceledException)
			{
				// this exception is "fine"
				//  we can exit the task as though everything is "fine"
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);
	}


	public Task StartHostDiscoveryTask(CancellationToken token, ConcurrentQueue<HostServiceEvent> evtQueue)
	{
		return Task.Run(async () =>
		{
			try
			{
				var processIdToEntry = new Dictionary<int, HostServiceDescriptor>();
				var socketListener = new Socket(SocketType.Dgram, ProtocolType.Udp);

				var ed = new IPEndPoint(IPAddress.Any, Beamable.Common.Constants.Features.Services.DISCOVERY_PORT);

				// by setting the receive timeout to a millisecond, this allows the ReceiveAsync function 
				//  to only block for a single millisecond, which means the Task code below can also
				//  check for service deletion
				socketListener.ReceiveTimeout = 1;

				// the important part is that this is a fixed number, the 4kb number is semi arbitrary.
				//  the C#MS host emits a message every 10ms, so if this application pauses (with a breakpoint), 
				//  then the buffer will fill up with messages every 10ms, which can result in ghost-like
				//  messages appearing in the socket-read code AFTER the C#MS has been stopped
				socketListener.ReceiveBufferSize = 4096;
				socketListener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
				socketListener.Bind(ed);

				var buffer = new ArraySegment<byte>(new byte[socketListener.ReceiveBufferSize]);
				while (!token.IsCancellationRequested)
				{
					{
						// the only reason to delay at all is to avoid task exhaustion on lower end systems. 
						//  this should happen at the start of the loop so that it cannot be accidentally skipped
						//  by `continue` statements
						await Task.Delay(Beamable.Common.Constants.Features.Services.DISCOVERY_BROADCAST_PERIOD_MS, token);
					}
					
					{
						// check that all services still exist.
						var toRemove = new HashSet<int>();
						foreach (var (processId, entry) in processIdToEntry)
						{
							try
							{
								Process.GetProcessById(processId);
							}
							catch
							{
								Log.Verbose("dotnet process removed " + entry.processId);
								evtQueue.Enqueue(new HostServiceEvent { descriptor = entry, type = ServiceEventType.Stopped });
								toRemove.Add(processId);
							}
						}

						foreach (var id in toRemove)
						{
							processIdToEntry.Remove(id);
						}
					}

					if (socketListener.Available == 0)
						continue; // there is nothing to read, so don't bother.

					// Block and wait for a socket message. 
					var byteCount = await socketListener.ReceiveAsync(buffer, token);

					if (byteCount == 0)
						continue;

					var json = Encoding.UTF8.GetString(buffer.Array!, 0, byteCount);

					// Deserialize the entry into an entry.
					var service = JsonConvert.DeserializeObject<ServiceDiscoveryEntry>(json, UnitySerializationSettings.Instance);


					{
						// it is POSSIBLE that a dead service's message is in the socket receive queue, 
						//  so before promising that this service exists, do a quick process-check to 
						//  make sure it is actually alive.
						var isProcessNotWorking = false;
						try
						{
							Process.GetProcessById(service.processId);
						}
						catch
						{
							isProcessNotWorking = true;
						}

						if (isProcessNotWorking)
							continue;
					}

					// If the message we got from a local service running that is not for this PID/CID, we ignore it.
					if (service.cid != _appContext.Cid || service.pid != _appContext.Pid)
						continue;

					if (!processIdToEntry.ContainsKey(service.processId))
					{
						var groups = Array.Empty<string>();
						var fedConfig = default(FederationsConfig);
						if (_localSystem.BeamoManifest.TryGetDefinition(service.serviceName, out var definition))
						{
							groups = definition.ServiceGroupTags;
							fedConfig = definition.SourceGenConfig.Federations;
						}

						var feds = fedConfig?.Select(kvp =>
							           new FederationInstance
							           {
								           FederationTypes = kvp.Value.Select(v => v.Interface).ToArray(),
								           FederationId = kvp.Key
							           }).ToArray()
						           ?? Array.Empty<FederationInstance>();
						var addition = processIdToEntry[service.processId] = new HostServiceDescriptor
						{
							processId = service.processId,
							service = service.serviceName,
							startedByAccountId = service.startedByAccountId,
							healthPort = service.healthPort,
							routingKey = service.prefix,
							groups = groups,
							federations = definition.SourceGenConfig.Federations.Select(kvp => new FederationInstance
							{
								FederationId = kvp.Key,
								FederationTypes = kvp.Value.Select(v => v.Interface).ToArray(),
								LocalSettings = kvp.Value.Select(v =>
								{
									var fedKey = FederationUtils.BuildLocalSettingKey(v.Interface, kvp.Key);
									if (_localSystem.BeamoManifest.HttpMicroserviceLocalProtocols[service.serviceName].Settings.TryGetSetting(fedKey, out var settingsJsonVal))
										return settingsJsonVal;
									return "{}";
								}).ToArray()
							}).ToArray()
						};
						evtQueue.Enqueue(new HostServiceEvent { type = ServiceEventType.Running, descriptor = addition });
						Log.Verbose("added dotnet process" + service.processId);
					}
					else
					{
						// it is not possible to change any of these fields while the service is running, so change detection 
						//  is not useful.
					}

				}
			}
			catch (TaskCanceledException)
			{
				// this exception is "fine"
				//  we can exit the task as though everything is "fine"
			}
			catch (OperationCanceledException)
			{
				// this comes from the ReceiveAsync being cancelled mid
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);
	}

	public async Promise<DockerServiceDescriptor> CreateEntryFromDocker(BeamoServiceDefinition serviceDefinition, string containerId)
	{
		if (serviceDefinition == null) return null;

		var healthPort = 0;
		var dataPort = 0;
		var startedByAccountId = 0L;
		var beamoId = serviceDefinition.BeamoId;

		// this is a best guess until we find the env variables, NAME_PREFIX, which may have been overriden for the container. 
		var prefix = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine();

		if (serviceDefinition.Protocol == BeamoProtocolType.HttpMicroservice)
		{
			try
			{
				var variablesTask = _localSystem.GetMicroserviceEnvironmentVariables(beamoId);
				var port = await _localSystem.GetMicroserviceHostPort(beamoId);
				var variables = await variablesTask;
				healthPort = Convert.ToInt32(port);
				if (variables.TryGetValue("NAME_PREFIX", out var foundPrefix))
				{
					prefix = foundPrefix;
				}

				if (variables.TryGetValue("USER_ACCOUNT_ID", out var accountId) && long.TryParse(accountId, out var accountIdLong))
				{
					startedByAccountId = accountIdLong;
				}
			}
			catch
			{
				// service is not running, therefore there is no port available
			}
		}
		else
		{
			try
			{
				var port = await _localSystem.GetStorageHostPort(beamoId);
				dataPort = Convert.ToInt32(port);
			}
			catch
			{
				// storage is not running, therefore there is no port available
			}
		}

		var groups = Array.Empty<string>();
		if (_localSystem.BeamoManifest.TryGetDefinition(beamoId, out var definition))
		{
			groups = definition.ServiceGroupTags;
		}

		var service = new DockerServiceDescriptor()
		{
			routingKey = prefix,
			service = serviceDefinition.BeamoId,
			serviceType = serviceDefinition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
			dataPort = dataPort,
			healthPort = healthPort,
			containerId = containerId,
			startedByAccountId = startedByAccountId,
			groups = groups,
			federations = serviceDefinition.Protocol == BeamoProtocolType.HttpMicroservice
				? definition.SourceGenConfig.Federations.Select(kvp => new FederationInstance
				{
					FederationId = kvp.Key,
					FederationTypes = kvp.Value.Select(v => v.Interface).ToArray(),
					LocalSettings = kvp.Value.Select(v =>
					{
						var fedKey = FederationUtils.BuildLocalSettingKey(v.Interface, kvp.Key);
						if (_localSystem.BeamoManifest.HttpMicroserviceLocalProtocols[serviceDefinition.BeamoId].Settings.TryGetSetting(fedKey, out var settingsJsonVal))
							return settingsJsonVal;
						return "{}";
					}).ToArray()
				}).ToArray()
				: Array.Empty<FederationInstance>(),
		};

		return service;
	}

	public class ServiceEvent<T>
	{
		public ServiceEventType type;
		public T descriptor;
	}
}

public enum ServiceEventType
{
	Running,
	Stopped
}

public class DockerServiceDescriptor
{
	public string service;
	public string serviceType;
	public string containerId;
	public int healthPort;
	public int dataPort;
	public string routingKey;
	public long startedByAccountId;
	public string[] groups;
	public FederationInstance[] federations;
}

public class HostServiceDescriptor
{
	public string service;
	public int processId;
	public int healthPort;
	public string routingKey;
	public long startedByAccountId;
	public string[] groups;
	public FederationInstance[] federations;
}

public class RemoteServiceDescriptor
{
	public string service;
	public string routingKey;
	public long startedByAccountId;
	public string[] groups;
	public FederationInstance[] federations;

	public string PKey => $"remote-{service}-{startedByAccountId}-{routingKey}";
}

public interface IDiscoveryEvent
{
	public ServiceEventType Type { get; }
	public long StartedByAccountId { get; }
	public string Service { get; }
	public string ServiceType { get; }
	public string RoutingKey { get; }
	public string PrimaryKey { get; }
}

public class DockerServiceEvent : DiscoveryService.ServiceEvent<DockerServiceDescriptor>, IDiscoveryEvent
{
	public ServiceEventType Type => type;
	public string Service => descriptor.service;
	public string ServiceType => descriptor.serviceType;
	public string RoutingKey => descriptor.routingKey;
	public string PrimaryKey => $"docker-{descriptor.containerId}";
	public long StartedByAccountId => descriptor.startedByAccountId;
}

public class HostServiceEvent : DiscoveryService.ServiceEvent<HostServiceDescriptor>, IDiscoveryEvent
{
	public ServiceEventType Type => type;
	public string Service => descriptor.service;
	public string ServiceType => "service"; // cannot run storages locally on the host without docker.
	public long StartedByAccountId => descriptor.startedByAccountId;
	public string RoutingKey => descriptor.routingKey;
	public string PrimaryKey => $"host-{descriptor.processId}";
}

public class RemoteServiceEvent : DiscoveryService.ServiceEvent<RemoteServiceDescriptor>, IDiscoveryEvent
{
	public ServiceEventType Type => type;
	public long StartedByAccountId => descriptor.startedByAccountId;
	public string Service => descriptor.service;
	public string ServiceType => "service"; // storages do not get broadcast
	public string RoutingKey => descriptor.routingKey;
	public string PrimaryKey => $"remote-{descriptor.service}-{descriptor.routingKey}";
}
