using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Server;
using Beamable.Server.Common;
using cli.FederationCommands;
using cli.Utils;
using Newtonsoft.Json;
using Serilog;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Text;

namespace cli.Services;

[Flags]
public enum DiscoveryMode
{
	/// <summary>
	/// This mode signals that all types of discovery should be used
	/// </summary>
	ALL = DiscoveryFlags.DOCKER + DiscoveryFlags.DOTNET + DiscoveryFlags.REMOTE,
	
	/// <summary>
	/// this mode signals that only local discovery methods should be used. 
	/// </summary>
	LOCAL = DiscoveryFlags.DOTNET + DiscoveryFlags.DOCKER,
}

/// <summary>
/// this enum is meant to be used in conjunction with <see cref="DiscoveryMode"/>.
/// Each flag represents a type of discovery.
/// </summary>
public enum DiscoveryFlags
{	
	DOTNET = 1 << 0, // 1
	DOCKER = 1 << 1, // 2
	REMOTE = 1 << 2, // 4
}

public static class DiscoveryModeExtensions
{
	public static bool HasDiscoveryFlag(this DiscoveryMode mode, DiscoveryFlags flag)
	{
		return mode.HasFlag((DiscoveryMode)flag);
	}
}

public class DiscoveryService
{
	private readonly BeamoLocalSystem _localSystem;
	private readonly IAppContext _appContext;

	private Task _localDiscoveryListen;
	private Task _dockerDiscoveryListen;
	private Task _routingDiscoveryListen;

	private ConcurrentDictionary<string, (long, ServiceDiscoveryEntry)> _localDiscoveryEntryWithTimestamp;
	private ConcurrentDictionary<string, string[]> _nameToRoutingKeys;
	private ConcurrentQueue<ServiceDiscoveryEvent> _evtQueue;

	/// <summary>
	/// true if there are any on-going discovery tasks.
	/// </summary>
	public bool IsDiscovering { get; private set; }
	
	public DiscoveryService(BeamoLocalSystem localSystem, IAppContext appContext)
	{
		_localSystem = localSystem;
		_appContext = appContext;
	}

	public async Task Stop()
	{
		await _localSystem.StopListeningToDocker();
	}

	public string[] GetRoutingKeys(string beamoId)
	{
		if (_nameToRoutingKeys.TryGetValue(beamoId, out var routingKeys))
		{
			return routingKeys;
		}

		throw new CliException(
			$"beamoId=[{beamoId}] does not exist in discovered routing key table. existing keys=[{string.Join(",", _nameToRoutingKeys.Keys)}]");
	}

	/// <summary>
	/// 
	/// </summary>
	/// <param name="args"></param>
	/// <param name="timeout"></param>
	/// <param name="token"></param>
	/// <param name="includeServerEvents">
	///	When true (default), this discovery session will listen to server-side events over the beamable websocket to learn about services running remotely. 
	/// </param>
	/// <returns></returns>
	public async IAsyncEnumerable<ServiceDiscoveryEvent> StartDiscovery(
		CommandArgs args, 
		TimeSpan timeout = default,
		[EnumeratorCancellation] CancellationToken token = default, 
		DiscoveryMode mode = DiscoveryMode.ALL)
	{
		if (IsDiscovering)
		{
			throw new CliException("Discovery is already on. This is a Beamable developer error. ");
		}

		IsDiscovering = true;
		try
		{
			_nameToRoutingKeys = new ConcurrentDictionary<string, string[]>();
			_localDiscoveryEntryWithTimestamp = new ConcurrentDictionary<string, (long, ServiceDiscoveryEntry)>();
			_evtQueue = new ConcurrentQueue<ServiceDiscoveryEvent>();
			var childCancellationToken = CancellationTokenSource.CreateLinkedTokenSource(token);
			
			// Get the list of registered services in the entire realm 
			var realmRegisteredServices = await ListServicesCommand.GetRunningServices(args.DependencyProvider);
			// TODO: does this contain remote running services? (we want it)

			foreach (var s in realmRegisteredServices.services)
			{
				// This is lower-case cause the backend lower-cases this stuff for reasons...
				var beamoId = s.beamoName;
				var routingKey = s.routingKey;
				if (!_nameToRoutingKeys.TryAdd(beamoId, new[] { routingKey }))
				{
					var currentKeys = GetRoutingKeys(beamoId).ToList();
					currentKeys.Add(routingKey);
					_nameToRoutingKeys[beamoId] = currentKeys.ToArray();
				}
			}

			// Prepare one event for every existing entry in the manifest
			var currentEntries = _localSystem.BeamoManifest.ServiceDefinitions
				.Select(sd => (Definition: sd, Entry: CreateEntryFromServiceDefinition(sd))).ToArray();
			foreach (var e in currentEntries)
			{
				var beamoId = e.Definition.BeamoId.ToLower();
				_nameToRoutingKeys.TryAdd(beamoId, Array.Empty<string>());
				_evtQueue.Enqueue(CreateEvent(e.Entry, e.Definition, GetRoutingKeys(beamoId)));
			}

			// Set up a task that will listens for messages broadcast by any locally running microservices
			// This then wraps it up in an event and enqueues it.
			if (mode.HasDiscoveryFlag(DiscoveryFlags.DOTNET))
			{
				Log.Verbose("starting local discovery");
				_localDiscoveryListen = StartLocalDiscoveryTask(childCancellationToken.Token);
			}

			// Start a websocket connection to listen for service registrations in the realm.
			// This will listen for routing information that services register with our backend
			// and enqueue events whenever updates are detected. 
			if (mode.HasDiscoveryFlag(DiscoveryFlags.REMOTE))
			{
				Log.Verbose("starting remote discovery");
				_routingDiscoveryListen = StartRoutingDiscoveryTask(args, childCancellationToken.Token);
			}

			// This looks for services running locally inside docker and emit events whenever they are turned on/off.
			// If docker isn't running, this checks for docker to be running every 1-second.
			if (mode.HasDiscoveryFlag(DiscoveryFlags.DOCKER))
			{
				Log.Verbose("starting docker discovery");
				_dockerDiscoveryListen = StartDockerDiscoveryTask(childCancellationToken.Token);
			}

			// Cache the startup time
			var toRemove = new HashSet<string>();
			var startTime = DateTimeOffset.Now;
			do
			{
				// return any messages to the caller.
				while (_evtQueue.TryDequeue(out var evt))
				{
					yield return evt;
				}

				_evtQueue.Clear();

				// check if we have exhausted our ps time.
				var nowTime = DateTimeOffset.Now;
				var duration = nowTime - startTime;
				if (timeout != default && timeout < duration)
				{
					break;
				}

				if (token.IsCancellationRequested)
				{
					break;
				}

				// Wait for a bit.
				await Task.Delay(50, token);

				// Find out frow which services we have not received messages in the past DISCOVERY_RECEIVE_PERIOD_MS  
				var now = DateTimeOffset.Now.ToUnixTimeMilliseconds();
				foreach (var kvp in _localDiscoveryEntryWithTimestamp)
				{
					var age = now - kvp.Value.Item1;
					if (age > Beamable.Common.Constants.Features.Services.DISCOVERY_RECEIVE_PERIOD_MS)
					{
						var sd = _localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(sd =>
							sd.BeamoId == kvp.Key);
						_evtQueue.Enqueue(CreateEvent(kvp.Value.Item2, sd, GetRoutingKeys(sd.BeamoId), false));
						toRemove.Add(kvp.Key);
					}
				}

				// Remove all the entries that we haven't heard from in a while
				foreach (var x in toRemove) _localDiscoveryEntryWithTimestamp.Remove(x, out _);
				toRemove.Clear();

			} while (true);
			
			// cancel the sub tasks.
			await childCancellationToken.CancelAsync();

			if (_dockerDiscoveryListen != null)
			{
				Log.Verbose("waiting for docker discovery to end");
				await _dockerDiscoveryListen;
				_dockerDiscoveryListen = null;
			}

			if (_localDiscoveryListen != null)
			{
				Log.Verbose("waiting for local discovery to end");
				await _localDiscoveryListen;
				_localDiscoveryListen = null;
			}

			if (_routingDiscoveryListen != null)
			{
				Log.Verbose("waiting for routing discovery to end");
				await _routingDiscoveryListen;
				_routingDiscoveryListen = null;
			}

			Log.Verbose("waiting for docker local system to end");
			// Here because if we don't kill of the "listening to docker" underlying process, this command's process never closes even after this function completes.
			var isDockerRunning = await _localSystem.CheckIsRunning();
			if (isDockerRunning)
			{
				await _localSystem.StopListeningToDocker();
			}
		}
		finally
		{
			IsDiscovering = false;
		}
	}

	public Task StartDockerDiscoveryTask(CancellationToken token)
	{
		return Task.Run(async () =>
		{
			try
			{
				var isListeningToDocker = false;
				var wasDockerRunningLastTick = false;
				do
				{
					// Check if docker's state changed (on/off) so we can reset isListeningToDocker.
					var isDockerRunning = await _localSystem.CheckIsRunning();
					if ((!isDockerRunning && wasDockerRunningLastTick) ||
					    (isDockerRunning && !wasDockerRunningLastTick)) isListeningToDocker = false;
					wasDockerRunningLastTick = isDockerRunning;

					// If docker isn't running, wait for X second and try again.
					// If we already are listening to docker, just keep checking if docker is still running every 1 second.
					if (!isDockerRunning || isListeningToDocker)
					{
						await Task.Delay(250, token);
					}
					// If we get here, its because we are not configured to listen to docker so...
					// We emit events for the current state and then hook up a listener to the docker process
					// so we get updates as users start/shutdown services. 
					else
					{
						var runningServices = await _localSystem.GetDockerRunningServices();
						foreach (KeyValuePair<string, string> pair in runningServices)
						{
							var beamoId = pair.Key;
							var serviceDefinition =
								_localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(
									sd => sd.BeamoId == beamoId);
							var service = await CreateEntryFromDocker(beamoId, pair.Value);

							var evt = CreateEvent(service, serviceDefinition, GetRoutingKeys(beamoId));
							_evtQueue.Enqueue(evt);
						}

						// This doesn't actually block
						await _localSystem.StartListeningToDockerRaw(async (beamoId, eventType, raw) =>
						{
							if (eventType != "start" && eventType != "destroy")
							{
								return;
							}

							var service = await CreateEntryFromDocker(beamoId, raw.ID);
							var serviceDefinition =
								_localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(
									sd => sd.BeamoId == beamoId);
							var evt = CreateEvent(service, serviceDefinition, GetRoutingKeys(beamoId));
							_evtQueue.Enqueue(evt);
						});

						isListeningToDocker = true;
					}

					if (token.IsCancellationRequested)
						break;

				} while (true);
			}
			catch (TaskCanceledException)
			{
				// this exception is "fine"
				//  we can exit the task as though everything is "fine"
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);
	}
	
	public Task StartRoutingDiscoveryTask(CommandArgs args, CancellationToken token)
	{
		return Task.Run(async () =>
		{
			try
			{
				var ws = await WebsocketUtil.ConfigureWebSocketForServerNotifications(args,
					new[] { "beamo.service_registration_changed" }, token);
				await WebsocketUtil.RunServerNotificationListenLoop(ws, message =>
				{
					var bodyJson = JsonConvert.SerializeObject(message.body);
					var data = JsonConvert.DeserializeObject<MicroserviceRegistrationsResponse>(bodyJson,
						UnitySerializationSettings.Instance);

					// We clear the list of keys as we rebuild it from the ground up every notification we receive --- then ensure there's an entry for all services.
					_nameToRoutingKeys.Clear();
					foreach (string id in _localSystem.BeamoManifest.ServiceDefinitions.Select(sd => sd.BeamoId))
						_nameToRoutingKeys.AddOrUpdate(id.ToLower(), Array.Empty<string>(),
							(_, _) => Array.Empty<string>());

					// Now we update the list of routing keys we do see.
					foreach (var registration in data.registrations)
					{
						var beamoId = registration.beamoName;
						var routingKey = registration.routingKey.GetNonEmptyOrElse(() => "");
						if (_nameToRoutingKeys.TryGetValue(beamoId, out var keys))
						{
							var currentKeys = keys.ToList();
							currentKeys.Add(routingKey);
							_nameToRoutingKeys.AddOrUpdate(beamoId, currentKeys.ToArray(),
								(_, _) => currentKeys.ToArray());
						}
					}

					// For each existing service, emit an event with the updated routing keys
					var existingServices = _localSystem.BeamoManifest.ServiceDefinitions;
					foreach (var sd in existingServices)
					{
						var latestEntry = _localDiscoveryEntryWithTimestamp.TryGetValue(sd.BeamoId, out var entry)
							? entry.Item2
							: CreateEntryFromServiceDefinition(sd);
						var latestEvent = CreateEvent(latestEntry, sd, GetRoutingKeys(sd.BeamoId));
						_evtQueue.Enqueue(latestEvent);
					}
				}, token);
			}
			catch (TaskCanceledException)
			{
				// this exception is "fine"
				//  we can exit the task as though everything is "fine"
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);
	}
	

	public Task StartLocalDiscoveryTask(CancellationToken token)
	{
		var socketListener = new Socket(SocketType.Dgram, ProtocolType.Udp);
		return Task.Run(async () =>
		{
			try
			{
				var ed = new IPEndPoint(IPAddress.Any, Beamable.Common.Constants.Features.Services.DISCOVERY_PORT);
				socketListener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
				socketListener.Bind(ed);
				
				var buffer = new ArraySegment<byte>(new byte[1024 * 2]);
				do
				{
					// Block and wait for a socket message.
					var byteCount = await socketListener.ReceiveAsync(buffer, token);
					if (byteCount != 0)
					{
						var json = Encoding.UTF8.GetString(buffer.Array!, 0, byteCount);

						// Deserialize the entry into an entry.
						var service = JsonConvert.DeserializeObject<ServiceDiscoveryEntry>(json, UnitySerializationSettings.Instance);

						// If the message we got from a local service running that is not for this PID/CID, we ignore it.
						if (service.cid != _appContext.Cid || service.pid != _appContext.Pid)
							continue;
					

						// If we don't have the entry (in this map), we emit the event that the service is now running and store it in the map. 
						if (!_localDiscoveryEntryWithTimestamp.ContainsKey(service.serviceName))
						{
							var sd = _localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == service.serviceName);
							_evtQueue.Enqueue(CreateEvent(service, sd, GetRoutingKeys(sd.BeamoId)));
						}

						// We keep the last time we hear from a service in this dictionary so that we can know when it dies off.
						_localDiscoveryEntryWithTimestamp[service.serviceName] = (DateTimeOffset.Now.ToUnixTimeMilliseconds(), service);
					}

					if (token.IsCancellationRequested)
						break;
					
					await Task.Delay(50, token);
				} while (true);
			}
			catch (TaskCanceledException)
			{
				// this exception is "fine"
				//  we can exit the task as though everything is "fine"
			}
			catch (OperationCanceledException)
			{
				// this comes from the ReceiveAsync being cancelled mid
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);
	}

	public ServiceDiscoveryEntry CreateEntryFromServiceDefinition(BeamoServiceDefinition definition)
	{
		return new ServiceDiscoveryEntry()
		{
			processId = 0,
			cid = _appContext.Cid,
			pid = _appContext.Pid,
			prefix = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine(),
			serviceName = definition.BeamoId,
			executionVersion = "",
			serviceType = definition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
			dataPort = 0,
			healthPort = 0,
			isContainer = false,
			containerId = "",
		};
	}

	public async Promise<ServiceDiscoveryEntry> CreateEntryFromDocker(string beamoId, string id)
	{
		var serviceDefinition = _localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == beamoId);
		if (serviceDefinition == null) return null;

		var healthPort = 0;
		var dataPort = 0;
		var version = "";

		if (serviceDefinition.Protocol == BeamoProtocolType.HttpMicroservice)
		{
			try
			{
				var labelsTask = _localSystem.GetImageLabels(beamoId);
				var port = await _localSystem.GetMicroserviceHostPort(beamoId);
				var labels = await labelsTask;
				healthPort = Convert.ToInt32(port);
				labels.TryGetValue("beamVersion", out version);
			}
			catch
			{
				// service is not running, therefore there is no port available
			}
		}
		else
		{
			try
			{
				var port = await _localSystem.GetStorageHostPort(beamoId);
				dataPort = Convert.ToInt32(port);
			}
			catch
			{
				// storage is not running, therefore there is no port available
			}
		}

		var service = new ServiceDiscoveryEntry()
		{
			processId = 0,
			cid = _appContext.Cid,
			pid = _appContext.Pid,
			prefix = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine(),
			serviceName = serviceDefinition.BeamoId,
			executionVersion = version,
			serviceType = serviceDefinition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
			dataPort = dataPort,
			healthPort = healthPort,
			isContainer = true,
			containerId = id,
		};

		return service;
	}

	public static ServiceDiscoveryEvent CreateEvent(ServiceDiscoveryEntry entry, BeamoServiceDefinition definition, string[] availableRoutingKeys, bool? isRunningOverride = null)
	{
		return new ServiceDiscoveryEvent
		{
			processId = entry.processId,
			isContainer = entry.isContainer,
			// In some cases, we need to explicitly set this as not running.
			// We can determine if the service is running or not based on these variables. (HealthPort is only there if the docker container is running).
			isRunning = isRunningOverride.HasValue ? isRunningOverride.Value : entry.healthPort > 0,

			// Header stuff.
			service = entry.serviceName,
			pid = entry.pid,
			cid = entry.cid,
			serviceType = entry.serviceType,
			groups = definition.ServiceGroupTags,

			// This is no longer used by the backend/sdks
			prefix = entry.prefix,

			// Runtime only stuff
			executionVersion = entry.executionVersion,
			containerId = entry.containerId,
			healthPort = entry.healthPort,
			dataPort = entry.dataPort,
			routingKeys = availableRoutingKeys,
		};
	}
}
