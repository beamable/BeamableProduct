using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Server;
using Beamable.Server.Common;
using cli.FederationCommands;
using cli.Utils;
using Newtonsoft.Json;
using Serilog;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Channels;

namespace cli.Services;

[Flags]
public enum DiscoveryMode
{
	/// <summary>
	/// This mode signals that all types of discovery should be used
	/// </summary>
	ALL = DiscoveryFlags.DOCKER + DiscoveryFlags.DOTNET + DiscoveryFlags.REMOTE,
	
	/// <summary>
	/// this mode signals that only local discovery methods should be used. 
	/// </summary>
	LOCAL = DiscoveryFlags.DOTNET + DiscoveryFlags.DOCKER,
}

/// <summary>
/// this enum is meant to be used in conjunction with <see cref="DiscoveryMode"/>.
/// Each flag represents a type of discovery.
/// </summary>
public enum DiscoveryFlags
{	
	DOTNET = 1 << 0, // 1
	DOCKER = 1 << 1, // 2
	REMOTE = 1 << 2, // 4
}

public static class DiscoveryModeExtensions
{
	public static bool HasDiscoveryFlag(this DiscoveryMode mode, DiscoveryFlags flag)
	{
		return mode.HasFlag((DiscoveryMode)flag);
	}
}

public enum ServiceDiscoverySource
{
	Unknown, Dotnet, Docker, Remote
}

[Serializable]
public class ServiceDiscoveryEvent
{
	/// <summary>
	/// Value has no semantic meaning when <see cref="isContainer"/> is true.
	/// Otherwise, has the OS-level process id for the running microservice task.
	/// </summary>
	public int processId;

	public string cid, pid;
	public string prefix;
	public string service;
	public bool isContainer;
	public string serviceType;
	public int healthPort;
	public int dataPort;
	public string containerId;
	public long startedByAccountId;
	public ServiceDiscoverySource source;
	/// <summary>
	/// Array of user-defined groups to which this service belongs.
	/// </summary>
	public string[] groups;

	public ServiceDiscoveryEvent()
	{
		
	}

	public ServiceDiscoveryEntryIdentity Identity =>
		new ServiceDiscoveryEntryIdentity(service, prefix, startedByAccountId);
}

public class ServiceState
{
	public string service;
	public string serviceType;
	public Dictionary<ServiceDiscoveryEntryIdentity, ServiceInstanceState> instances;
	
	public List<ServiceInstanceState> LocalInstances => instances.Where(kvp => kvp.Value.IsLocal).Select(kvp => kvp.Value).ToList();
}

public class ServiceInstanceState
{
	public ServiceDiscoverySource source;
	public string routingKey;
	public bool isContainer;
	public int healthPort;
	public int dataPort;
	public string containerId;
	public long startedByAccountId;
	public int processId;

	public bool IsLocal => healthPort != 0 || isContainer;
}

public class ServiceInstanceExpiration
{
	public DateTimeOffset? expiresAt;
}

public class DiscoveryService
{
	private readonly BeamoLocalSystem _localSystem;
	private readonly IAppContext _appContext;

	private Task _localDiscoveryListen;
	private Task _dockerDiscoveryListen;
	private Task _routingDiscoveryListen;

	private ConcurrentDictionary<ServiceDiscoveryEntryIdentity, ServiceInstanceExpiration> _serviceExpiration;
	// private ConcurrentDictionary<ServiceDiscoveryEntryIdentity, (long, ServiceDiscoveryEntry)> _localDiscoveryEntryWithTimestamp;
	private ConcurrentQueue<ServiceDiscoveryEvent> _evtQueue;
	
	// private Channel<ServiceDiscoveryEvent>

	private AccountPortalView _adminSelf;

	private long SelfAccountId => _adminSelf.id;

	/// <summary>
	/// true if there are any on-going discovery tasks.
	/// </summary>
	public bool IsDiscovering { get; private set; }
	
	public DiscoveryService(BeamoLocalSystem localSystem, IAppContext appContext)
	{
		_localSystem = localSystem;
		_appContext = appContext;
	}

	public async Task Stop()
	{
		await _localSystem.StopListeningToDocker();
	}

	/// <summary>
	/// 
	/// </summary>
	/// <param name="args"></param>
	/// <param name="timeout"></param>
	/// <param name="token"></param>
	/// <param name="includeServerEvents">
	///	When true (default), this discovery session will listen to server-side events over the beamable websocket to learn about services running remotely. 
	/// </param>
	/// <returns></returns>
	public async IAsyncEnumerable<ServiceState> StartDiscovery(
		CommandArgs args, 
		TimeSpan timeout = default,
		[EnumeratorCancellation] CancellationToken token = default, 
		DiscoveryMode mode = DiscoveryMode.ALL)
	{
		if (IsDiscovering)
		{
			throw new CliException("Discovery is already on. This is a Beamable developer error. ");
		}

		IsDiscovering = true;
		try
		{
			var adminSelfTask = args.Provider.GetService<IAccountsApi>().GetAdminMe();

			_serviceExpiration = new ConcurrentDictionary<ServiceDiscoveryEntryIdentity, ServiceInstanceExpiration>();
			_evtQueue = new ConcurrentQueue<ServiceDiscoveryEvent>();
			var childCancellationToken = CancellationTokenSource.CreateLinkedTokenSource(token);
			
			// start getting the list of registered services in the entire realm 
			var realmRegisteredServicesTask = args.Provider.GetService<IBeamoApi>().PostMicroserviceRegistrations(new MicroserviceRegistrationsQuery());
			// we must wait for the current user account before continuing
			_adminSelf = await adminSelfTask;
			
			
			// TODO: does this contain remote running services? (we want it)

			// seed the event table with the services that are known to be running
			//  this can happen while the other detector systems are starting
			var _ = realmRegisteredServicesTask.Then(result =>
			{
				foreach (var registration in result.registrations)
				{
					// this is only important for remote services. Local services will be caught locally.
					if (registration.startedById == SelfAccountId) continue; 
					
					var groups = Array.Empty<string>();
					if (_localSystem.BeamoManifest.TryGetDefinition(registration.beamoName, out var definition))
					{
						groups = definition.ServiceGroupTags;
					}
					var entry = CreateEntryFromRoutingRegistration(registration);
					var evt = CreateEvent(ServiceDiscoverySource.Remote, entry, groups, registration.startedById);
					// TODO: these instances need to live until we hear that they are no longer running...
					_evtQueue.Enqueue(evt);
				}
			});
			

			// Set up a task that will listens for messages broadcast by any locally running microservices
			// This then wraps it up in an event and enqueues it.
			if (mode.HasDiscoveryFlag(DiscoveryFlags.DOTNET))
			{
				Log.Verbose("starting local discovery");
				_localDiscoveryListen = StartLocalDiscoveryTask(childCancellationToken.Token);
			}

			// Start a websocket connection to listen for service registrations in the realm.
			// This will listen for routing information that services register with our backend
			// and enqueue events whenever updates are detected. 
			if (mode.HasDiscoveryFlag(DiscoveryFlags.REMOTE))
			{
				Log.Verbose("starting remote discovery");
				_routingDiscoveryListen = StartRoutingDiscoveryTask(args, childCancellationToken.Token);
			}

			// This looks for services running locally inside docker and emit events whenever they are turned on/off.
			// If docker isn't running, this checks for docker to be running every 1-second.
			if (mode.HasDiscoveryFlag(DiscoveryFlags.DOCKER))
			{
				Log.Verbose("starting docker discovery");
				_dockerDiscoveryListen = StartDockerDiscoveryTask(childCancellationToken.Token);
			}

			yield return new ServiceState();
			try
			{
				if (timeout.TotalMilliseconds <= 0)
				{
					await Task.Delay(-1, token);
				}
				else
				{
					await Task.Delay(timeout, token);
				}
			}
			catch
			{
				// it is fine if this delay() cancels early...
			}


			#region old code
			// Cache the startup time
			// var toRemove = new HashSet<ServiceDiscoveryEntryIdentity>();
			// var startTime = DateTimeOffset.Now;
			// var states = new Dictionary<string, ServiceState>();
			// var client = new HttpClient();
			// do
			// {
			// 	// exhaust the set of queued events
			// 	var changedStates = new HashSet<ServiceState>();
			// 	while (_evtQueue.TryDequeue(out var evt))
			// 	{
			// 		// the events need to be grouped by their common identity, the serviceName
			// 		if (!states.TryGetValue(evt.service, out var state))
			// 		{
			// 			state = states[evt.service] = new ServiceState
			// 			{
			// 				service = evt.service, 
			// 				serviceType = evt.serviceType,
			// 				instances = new Dictionary<ServiceDiscoveryEntryIdentity, ServiceInstanceState>()
			// 			};
			// 		}
			//
			// 		var identity = evt.Identity;
			// 		var nextInstance = new ServiceInstanceState
			// 		{
			// 			source = evt.source,
			// 			routingKey = evt.prefix,
			// 			containerId = evt.containerId,
			// 			isContainer = evt.isContainer,
			// 			startedByAccountId = evt.startedByAccountId,
			// 			dataPort = evt.dataPort,
			// 			healthPort = evt.healthPort,
			// 			processId = evt.processId,
			// 		};
			// 		
			// 		if (state.instances.TryGetValue(identity, out var existingInstance))
			// 		{
			// 			if (existingInstance.source != evt.source)
			// 			{
			// 				Log.Warning($"The service instance=[{identity}] has been detected by multiple sources, " +
			// 				            $"first=[{existingInstance.source}] second=[{evt.source}], and the CLI does not support this use case. " +
			// 				            $"The latest information will be ignored, which may produce unexpected behaviour. ");
			// 			}
			// 			else
			// 			{
			// 				// TODO: add change detection
			// 				// state.instances[identity] = nextInstance;
			// 				// changedStates.Add(state);
			// 			}
			// 		}
			// 		else
			// 		{
			// 			state.instances[identity] = nextInstance;
			// 			changedStates.Add(state);
			// 		}
			//
			// 	}
			// 	
			// 	// Find out which services need to be removed  
			// 	var now = DateTimeOffset.Now;
			//
			// 	foreach (var (service, state) in states)
			// 	{
			// 		var identsToRemove = new List<ServiceDiscoveryEntryIdentity>();
			// 		foreach (var (identity, instance) in state.instances)
			// 		{
			// 			switch (instance.source)
			// 			{
			// 				case ServiceDiscoverySource.Dotnet:
			// 					if (state.serviceType != "service")
			// 					{
			// 						Log.Warning($"service=[{service}] is not a microservice, this should not happen");
			// 						continue;
			// 					}
			// 					
			// 					// local instances should be able to respond to local health checks!
			// 					var passedHealthCheck = false;
			// 					try
			// 					{
			// 						var proc = Process.GetProcessById(instance.processId);
			// 						passedHealthCheck = true;
			// 						// var res = await client.GetAsync($"http://localhost:{instance.healthPort}/health");
			// 						// passedHealthCheck = res.IsSuccessStatusCode;
			// 					}
			// 					catch
			// 					{
			// 						// let it die. If anything went wrong, the health check didn't work.
			// 					}
			//
			// 					if (!passedHealthCheck)
			// 					{
			// 						// ah the thing is dead!!!
			// 						identsToRemove.Add(identity);
			// 					}
			// 					
			// 					break;
			// 			}
			//
			// 			foreach (var removedIdent in identsToRemove)
			// 			{
			// 				state.instances.Remove(removedIdent);
			// 			}
			//
			// 			if (identsToRemove.Count > 0)
			// 			{
			// 				changedStates.Add(state);
			// 			}
			// 		}
			// 	}
			// 	
			// 	
			// 	// foreach (var (identity, expiration) in _serviceExpiration)
			// 	// {
			// 	// 	if (!expiration.expiresAt.HasValue)
			// 	// 		continue;
			// 	//
			// 	// 	if (now > expiration.expiresAt.Value)
			// 	// 	{
			// 	// 		toRemove.Add(identity);
			// 	// 	}
			// 	// }
			// 	//
			// 	// Remove all the entries that we haven't heard from in a while
			// 	// foreach (var x in toRemove)
			// 	// {
			// 	// 	if (!states.TryGetValue(x.service, out var state))
			// 	// 		continue;
			// 	//
			// 	// 	_serviceExpiration.TryRemove(x, out var _);
			// 	// 	state.instances.Remove(x);
			// 	// 	changedStates.Add(state);
			// 	// }
			// 	//
			// 	// toRemove.Clear();
			// 	
			// 	// emit all states that have changed in this frame
			// 	foreach (var state in changedStates)
			// 	{
			// 		yield return state;
			// 	}
			//
			// 	_evtQueue.Clear();
			//
			// 	// check if we have exhausted our ps time.
			// 	var nowTime = DateTimeOffset.Now;
			// 	var duration = nowTime - startTime;
			// 	if (timeout != default && timeout < duration)
			// 	{
			// 		break;
			// 	}
			//
			// 	if (token.IsCancellationRequested)
			// 	{
			// 		break;
			// 	}
			//
			// 	// Wait for a bit.
			// 	await Task.Delay(50, token);
			//
			// } while (true);
			#endregion
			
			// cancel the sub tasks.
			await childCancellationToken.CancelAsync();

			if (_dockerDiscoveryListen != null)
			{
				Log.Verbose("waiting for docker discovery to end");
				await _dockerDiscoveryListen;
				_dockerDiscoveryListen = null;
			}

			if (_localDiscoveryListen != null)
			{
				Log.Verbose("waiting for local discovery to end");
				await _localDiscoveryListen;
				_localDiscoveryListen = null;
			}

			if (_routingDiscoveryListen != null)
			{
				Log.Verbose("waiting for routing discovery to end");
				await _routingDiscoveryListen;
				_routingDiscoveryListen = null;
			}

			Log.Verbose("waiting for docker local system to end");
			// Here because if we don't kill of the "listening to docker" underlying process, this command's process never closes even after this function completes.
			var isDockerRunning = await _localSystem.CheckIsRunning();
			if (isDockerRunning)
			{
				await _localSystem.StopListeningToDocker();
			}
		}
		finally
		{
			IsDiscovering = false;
		}
	}

	public Task StartDockerDiscoveryTask(CancellationToken token)
	{
		return Task.Run(async () =>
		{
			try
			{
				var isListeningToDocker = false;
				var wasDockerRunningLastTick = false;
				do
				{
					// Check if docker's state changed (on/off) so we can reset isListeningToDocker.
					var isDockerRunning = await _localSystem.CheckIsRunning();
					if ((!isDockerRunning && wasDockerRunningLastTick) ||
					    (isDockerRunning && !wasDockerRunningLastTick)) isListeningToDocker = false;
					wasDockerRunningLastTick = isDockerRunning;

					// If docker isn't running, wait for X second and try again.
					// If we already are listening to docker, just keep checking if docker is still running every 1 second.
					if (!isDockerRunning || isListeningToDocker)
					{
						await Task.Delay(250, token);
					}
					// If we get here, its because we are not configured to listen to docker so...
					// We emit events for the current state and then hook up a listener to the docker process
					// so we get updates as users start/shutdown services. 
					else
					{
						var runningServices = await _localSystem.GetDockerRunningServices();
						foreach (var (beamoId, containerId) in runningServices)
						{
							if (!_localSystem.BeamoManifest.TryGetDefinition(beamoId, out var serviceDefinition))
							{
								// if somehow there is a local running docker container for a service definition that no longer exists, log a warning
								Log.Warning($"Ignoring existing running container=[{containerId}] because no service definition was detected for beamoId=[{beamoId}]");
								continue;
							}
							
							var service = await CreateEntryFromDocker(serviceDefinition, containerId);
							var evt = CreateEvent(ServiceDiscoverySource.Docker, service, serviceDefinition.ServiceGroupTags, SelfAccountId);
							_evtQueue.Enqueue(evt);
						}

						// This doesn't actually block
						await _localSystem.StartListeningToDockerRaw(async (beamoId, eventType, raw) =>
						{
							if (eventType != "start" && eventType != "destroy")
							{
								return;
							}

							if (!_localSystem.BeamoManifest.TryGetDefinition(beamoId, out var serviceDefinition))
							{
								Log.Warning($"Ignoring running container=[{raw.ID}] because no service definition was detected for beamoId=[{beamoId}]");
								return;
							}

							var service = await CreateEntryFromDocker(serviceDefinition, raw.ID);
							var evt = CreateEvent(ServiceDiscoverySource.Docker, service, serviceDefinition.ServiceGroupTags, SelfAccountId);
							_evtQueue.Enqueue(evt);
						});

						isListeningToDocker = true;
					}

					if (token.IsCancellationRequested)
						break;

				} while (true);
			}
			catch (TaskCanceledException)
			{
				// this exception is "fine"
				//  we can exit the task as though everything is "fine"
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);
	}
	
	public Task StartRoutingDiscoveryTask(CommandArgs args, CancellationToken token)
	{
		return Task.Run(async () =>
		{
			try
			{
				var ws = await WebsocketUtil.ConfigureWebSocketForServerNotifications(args,
					new[] { "beamo.service_registration_changed" }, token);
				await WebsocketUtil.RunServerNotificationListenLoop(ws, message =>
				{
					var bodyJson = JsonConvert.SerializeObject(message.body);
					var data = JsonConvert.DeserializeObject<MicroserviceRegistrationsResponse>(bodyJson,
						UnitySerializationSettings.Instance);

					// Now we update the list of routing keys we do see.
					foreach (var registration in data.registrations)
					{
						/*
						 * If this service was started by the current CLI user, then
						 * the ASSUMPTION is that the service is actually running locally
						 * on this user's machine.
						 * IF that assumption is true, THEN, the local detection schemes will provide better
						 * detail about this service than the registration event, and thus, we can skip it.
						 *
						 * However, the assumption ignores the use case where a user is running C#MS on multiple
						 * machines, and is trying to manage them all together. Services started on another machine
						 * with the same account as the current machine will not appear. 
						 */
						if (registration.startedById == SelfAccountId) continue;
						
						var groups = Array.Empty<string>();
						if (_localSystem.BeamoManifest.TryGetDefinition(registration.beamoName, out var definition))
						{
							groups = definition.ServiceGroupTags;
						}
						
						var entry = CreateEntryFromRoutingRegistration(registration);
						var evt = CreateEvent(ServiceDiscoverySource.Remote, entry, groups, registration.startedById);
						// TODO: how to get rid of old services? 
						_evtQueue.Enqueue(evt);
					}
					
				}, token);
			}
			catch (TaskCanceledException)
			{
				// this exception is "fine"
				//  we can exit the task as though everything is "fine"
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);
	}
	

	public Task StartLocalDiscoveryTask(CancellationToken token)
	{

		return Task.Run(async () =>
		{
			try
			{
				var processIdToEntry = new Dictionary<int, ServiceDiscoveryEntry>();
				var socketListener = new Socket(SocketType.Dgram, ProtocolType.Udp);

				var ed = new IPEndPoint(IPAddress.Any, Beamable.Common.Constants.Features.Services.DISCOVERY_PORT);
				socketListener.ReceiveTimeout = 1;
				socketListener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
				socketListener.Bind(ed);
				
				var buffer = new ArraySegment<byte>(new byte[1024 * 2]);
				
				// var readTimeout = TimeSpan.FromMilliseconds(1);
				while (!token.IsCancellationRequested)
				{

					{ // check that all services still exist.
						var toRemove = new HashSet<int>();
						foreach (var (processId, entry) in processIdToEntry)
						{
							try
							{
								Process.GetProcessById(processId);
							}
							catch
							{
								// TODO: emit removed event.
								Log.Information("removed " + entry.processId);
								toRemove.Add(processId);
							}
						}

						foreach (var id in toRemove)
						{
							processIdToEntry.Remove(id);
						}
					}



					if (socketListener.Available == 0)
						continue; // there is nothing to read, so don't bother.
					// Block and wait for a socket message.
					var byteCount = await socketListener.ReceiveAsync(buffer, token);
					
					if (byteCount == 0)
						continue;
					
					var json = Encoding.UTF8.GetString(buffer.Array!, 0, byteCount);

					// Deserialize the entry into an entry.
					var service = JsonConvert.DeserializeObject<ServiceDiscoveryEntry>(json, UnitySerializationSettings.Instance);

					// If the message we got from a local service running that is not for this PID/CID, we ignore it.
					if (service.cid != _appContext.Cid || service.pid != _appContext.Pid)
						continue;
					
					if (!processIdToEntry.ContainsKey(service.processId))
					{
						// TODO: emit add event.
						processIdToEntry[service.processId] = service;
						Log.Information("added " + service.processId);
					}
					
					// the only reason to delay at all is to avoid task exhaustion on lower end systems. 
					await Task.Delay(Beamable.Common.Constants.Features.Services.DISCOVERY_BROADCAST_PERIOD_MS, token);
				}
			}
			catch (TaskCanceledException)
			{
				// this exception is "fine"
				//  we can exit the task as though everything is "fine"
			}
			catch (OperationCanceledException)
			{
				// this comes from the ReceiveAsync being cancelled mid
			}
			catch (Exception e)
			{
				BeamableLogger.LogException(e);
				throw;
			}
		}, token);
	}

	public ServiceDiscoveryEntry CreateEntryFromServiceDefinition(BeamoServiceDefinition definition)
	{
		return new ServiceDiscoveryEntry()
		{
			processId = 0,
			cid = _appContext.Cid,
			pid = _appContext.Pid,
			prefix = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine(),
			serviceName = definition.BeamoId,
			serviceType = definition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
			dataPort = 0,
			healthPort = 0,
			isContainer = false,
			containerId = "",
		};
	}
	
	public ServiceDiscoveryEntry CreateEntryFromRoutingRegistration(MicroserviceRegistrations registration)
	{
		return new ServiceDiscoveryEntry()
		{
			processId = 0,
			cid = _appContext.Cid,
			pid = _appContext.Pid,
			prefix = registration.routingKey.GetOrElse(""),
			serviceName = registration.beamoName,
			// it is safe to hardcode service here because only services CAN exist as routed registrations.
			serviceType = "service",
			dataPort = 0,
			healthPort = 0,
			isContainer = false,
			containerId = "",
		};
	}

	public async Promise<ServiceDiscoveryEntry> CreateEntryFromDocker(BeamoServiceDefinition serviceDefinition, string containerId)
	{
		// var serviceDefinition = _localSystem.BeamoManifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == beamoId);
		if (serviceDefinition == null) return null;

		var healthPort = 0;
		var dataPort = 0;
		var beamoId = serviceDefinition.BeamoId;
		
		// this is a best guess until we find the env variables, NAME_PREFIX, which may have been overriden for the container. 
		var prefix = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine();

		if (serviceDefinition.Protocol == BeamoProtocolType.HttpMicroservice)
		{
			try
			{
				var variablesTask = _localSystem.GetMicroserviceEnvironmentVariables(beamoId);
				var port = await _localSystem.GetMicroserviceHostPort(beamoId);
				var variables = await variablesTask;
				healthPort = Convert.ToInt32(port);
				if (variables.TryGetValue("NAME_PREFIX", out var foundPrefix))
				{
					prefix = foundPrefix;
				}
			}
			catch
			{
				// service is not running, therefore there is no port available
			}
		}
		else
		{
			try
			{
				var port = await _localSystem.GetStorageHostPort(beamoId);
				dataPort = Convert.ToInt32(port);
			}
			catch
			{
				// storage is not running, therefore there is no port available
			}
		}

		var service = new ServiceDiscoveryEntry()
		{
			processId = 0,
			cid = _appContext.Cid,
			pid = _appContext.Pid,
			prefix = prefix,
			serviceName = serviceDefinition.BeamoId,
			serviceType = serviceDefinition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
			dataPort = dataPort,
			healthPort = healthPort,
			isContainer = true,
			containerId = containerId,
		};

		return service;
	}

	public static ServiceDiscoveryEvent CreateEvent(
		ServiceDiscoverySource source,
		ServiceDiscoveryEntry entry, 
		string[] groupTags,
		long startedById)
	{
		return new ServiceDiscoveryEvent
		{
			source = source,
			processId = entry.processId,
			isContainer = entry.isContainer,
			service = entry.serviceName,
			pid = entry.pid,
			cid = entry.cid,
			serviceType = entry.serviceType,
			groups = groupTags,

			// This is no longer used by the backend/sdks
			prefix = entry.prefix,

			// Runtime only stuff
			containerId = entry.containerId,
			healthPort = entry.healthPort,
			dataPort = entry.dataPort,
			startedByAccountId = startedById,
		};
	}
}
