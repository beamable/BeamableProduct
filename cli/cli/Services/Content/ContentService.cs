using Beamable.Api.Autogenerated.Content;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Content;
using Beamable.Serialization.SmallerJSON;
using cli.Content;
using Spectre.Console;
using System.Text;

namespace cli.Services.Content;

public class ContentService
{
	public const string SERVICE = "/basic/content";
	const int DEFAULT_TABLE_LIMIT = 100;
	private readonly CliRequester _requester;
	private readonly IContentApi _contentApi;
	private readonly ConfigService _config;
	private readonly Dictionary<string, ContentLocalCache> _localCaches = new();


	public bool TryGetLocalCache(string manifestId, out ContentLocalCache localCache)
	{
		if (_localCaches.TryGetValue(manifestId, out localCache))
		{
			return true;
		}

		return false;
	}

	public ContentLocalCache GetLocalCache(string manifestId)
	{
		if (_localCaches.TryGetValue(manifestId, out ContentLocalCache localCache))
		{
			return localCache;
		}

		var newLocalCache = new ContentLocalCache(_config, manifestId, _requester);
		newLocalCache.Init();
		_localCaches.Add(newLocalCache.ManifestId, newLocalCache);

		return _localCaches[manifestId];
	}

	public ContentService(CliRequester requester, ConfigService config, IContentApi api)
	{
		_requester = requester;
		_config = config;
		_contentApi = api;
	}

	public Promise<ClientManifest> GetManifest(string manifestId)
	{
		if (string.IsNullOrWhiteSpace(manifestId))
		{
			throw new CliException($"This is not a valid manifestID: \"{manifestId}\"");
		}

		return GetLocalCache(manifestId).UpdateManifest();
	}

	public Promise<List<ContentDocument>> PullContent(string manifestId, bool saveToDisk = true)
	{
		return GetLocalCache(manifestId).PullContent(saveToDisk);
	}

	public async Task DisplayStatusTable(string manifestId, bool showUpToDate, int limit, int skipAmount)
	{
		var contentCache = GetLocalCache(manifestId);
		var localContentStatus = await contentCache.GetLocalContentStatus();
		var totalCount = localContentStatus.Count;
		var table = new Table();
		table.AddColumn("Current status");
		table.AddColumn("ID");
		table.AddColumn(new TableColumn("tags").RightAligned());

		if (!showUpToDate)
		{
			localContentStatus = localContentStatus.Where(content => content.status != ContentStatus.UpToDate).ToList();
		}

		if (!showUpToDate && localContentStatus.Count == 0)
		{
			AnsiConsole.MarkupLine("[green]Your local content is up to date with remote.[/]");
			return;
		}


		var range = localContentStatus.Skip(skipAmount).Take(limit > 0 ? limit : DEFAULT_TABLE_LIMIT).ToList();
		foreach (var content in range)
		{
			var tags = contentCache.GetContentTagsStatus(content.contentId).Select(pair =>
			{
				switch (pair.Value)
				{
					case TagStatus.LocalOnly:
						return $"[green][[+]]{pair.Key}[/]";
					case TagStatus.RemoteOnly:
						return $"[red][[-]]{pair.Key}[/]";
					case TagStatus.LocalAndRemote:
						return pair.Key;
					default:
						throw new ArgumentOutOfRangeException();
				}
			});
			table.AddRow(content.StatusString(), content.contentId, string.Join(",", tags));
		}

		AnsiConsole.Write(table);
		AnsiConsole.WriteLine($"Content: {range.Count} out of {totalCount}");
	}


	public async Promise<ContentManifest> PublishContentAndManifest(string manifestId)
	{
		if (string.IsNullOrWhiteSpace(manifestId))
		{
			throw new CliException($"This is not a valid manifestID: \"{manifestId}\"");
		}

		var contentSaveResponse = await PublishChangedContent(manifestId);
		var contentManifest = await PublishNewManifest(contentSaveResponse, manifestId);

		return contentManifest;
	}

	private async Promise<ContentManifest> PublishNewManifest(ContentSaveResponse contentSaveResponse, string manifestId)
	{
		var localCache = GetLocalCache(manifestId);

		var referenceSet = await localCache.BuildLocalManifestReferenceSupersets();
		contentSaveResponse.content.ForEach(entry =>
		{
			var reference = new ManifestReferenceSuperset
			{
				Checksum = entry.checksum,
				Id = entry.id,
				Tags = entry.tags,
				Uri = entry.uri,
				Version = entry.version,
				Visibility = entry.visibility,
				Type = "content",
				LastChanged = entry.lastChanged
			};
			var key = reference.Key;

			referenceSet[key] = reference;
		});
		var manifestRequest = new ManifestSaveRequest { id = manifestId, references = referenceSet.Values.ToList() };
		return await _requester.RequestJson<ContentManifest>(Method.POST, $"/basic/content/manifest?id={manifestId}",
			manifestRequest);
	}

	private async Promise<ContentSaveResponse> PublishChangedContent(string manifestId)
	{
		var contentLocal = GetLocalCache(manifestId);
		var localContent = await contentLocal.GetLocalContentStatus();
		var changedContent = localContent
			.Where(content => content.status is not (ContentStatus.Deleted or ContentStatus.UpToDate))
			.Select(content => contentLocal.PrepareContentForPublish(content.contentId)).ToList();


		var dict = new ArrayDict { { "content", changedContent } };
		var reqJson = Json.Serialize(dict, new StringBuilder());

		return await _requester.Request<ContentSaveResponse>(Method.POST, "/basic/content", reqJson);
	}

	public async Promise<string[]> PrepareManifestFilter(string[] filter, bool noFilterIsAll = true)
	{
		var manifests = await _contentApi.GetManifestChecksums();
		var existingManifestIds = manifests.manifests.Select(m => m.id).ToArray();

		// Make sure the given manifests are valid.
		if (filter.Length == 0 && noFilterIsAll)
			return existingManifestIds;


		// Check that the given manifest ids are valid and exist.
		var invalidManifestIds = existingManifestIds.Where(id => !filter.Contains(id)).ToArray();
		if (invalidManifestIds.Length != 0)
		{
			throw new CliException($"Content Manifests Not Found. MANIFEST_IDS_NOT_FOUND=[{invalidManifestIds}], AVAILABLE_IDS=[{existingManifestIds}]");
		}

		return filter;
	}

	public async Promise<IReadOnlyList<List<LocalContent>>> GetLocalContentForManifests(string[] manifestsToGet)
	{
		// Make requests for all local manifests
		var allLocalStates = new List<(string manifestId, Promise<List<LocalContent>> promise)>();
		foreach (string manifestId in manifestsToGet)
		{
			var localContentCache = GetLocalCache(manifestId);
			allLocalStates.Add((manifestId, localContentCache.GetLocalContentStatus()));
		}

		// Wait for all the local manifests
		_ = await Promise.Sequence(allLocalStates.Select(t => t.promise).ToList());

		// Return the resolved list of manifests
		return allLocalStates.Select(t => t.promise.GetResult()).ToArray();
	}

	public LocalContentState BuildLocalContentState(string[] manifestsToBuild, IReadOnlyList<List<LocalContent>> contents)
	{
		var localManifests = new List<LocalContentManifest>(manifestsToBuild.Length);
		for (int i = 0; i < manifestsToBuild.Length; i++)
		{
			var manifestId = manifestsToBuild[i];
			var localState = contents[i];

			var localManifest = new LocalContentManifest();
			localManifest.Entries = new LocalContentManifestEntry[localState.Count];
			for (int entryIdx = 0; entryIdx < localState.Count; entryIdx++)
			{
				var localContent = localState[entryIdx];
				var lastDotIdx = localContent.contentId.LastIndexOf(".", StringComparison.Ordinal);

				localManifest.Entries[entryIdx] = new LocalContentManifestEntry()
				{
					FullId = localContent.contentId,
					TypeName = localContent.contentId[..lastDotIdx],
					Name = localContent.contentId[(lastDotIdx + 1)..],
					CurrentStatus = (int)localContent.status,
					Tags = localContent.tags,
					Hash = localContent.hash,
				};
			}

			localManifest.ManifestId = manifestId;
			localManifests.Add(localManifest);
		}

		return new LocalContentState() { Manifests = localManifests.ToArray() };
	}
}
