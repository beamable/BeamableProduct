using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.BeamCli;
using Beamable.Common.Content;
using Beamable.Serialization;
using cli.Utils;
using Newtonsoft.Json.Linq;
using Serilog;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Text.RegularExpressions;
using System.Threading.Channels;
using ContentDefinition = Beamable.Api.Autogenerated.Models.ContentDefinition;

namespace cli.Content;

public class LocalContentFileChanges
{
	public List<ChangedContentFile> AllFileChanges;
}

public struct RemoteContentPublished
{
	public string OwnerCid;
	public string OwnerPid;
	public string PublisherAccountId;
	public string PublisherEmail;
	public string ReferenceUid;

	public ContentSyncReport AutoSyncReport;
}

public struct ChangedContentFile
{
	public string OwnerPid;
	public string OwnerManifestId;

	public string OldContentId;
	public string ContentId;

	public string FullFilePath;
	public string OldFullFilePath;

	public bool WasDeleted() => string.IsNullOrEmpty(FullFilePath) && !string.IsNullOrEmpty(OldFullFilePath);
	public bool WasRenamed() => !WasDeleted() && FullFilePath != OldFullFilePath;
	public bool WasCreated() => !string.IsNullOrEmpty(FullFilePath) && string.IsNullOrEmpty(OldFullFilePath);
	public bool WasChanged() => !WasCreated() && !WasDeleted() && FullFilePath == OldFullFilePath;
}

public class ContentService
{
	private const int ERR_CODE_PUBLISH_FAILED_INVALID_REFERENCE_MANIFEST = 3;

	private readonly CliRequester _requester;
	private readonly ConfigService _config;
	private readonly IContentApi _contentApi;
	private readonly IAccountsApi _accountsApi;

	private readonly Channel<ChangedContentFile> _channelChangedContentFiles;
	private readonly Channel<RemoteContentPublished> _channelRemoteContentPublishes;

	private static readonly ConcurrentDictionary<string, ClientManifestJsonResponse> _cachedManifests = new();
	private static readonly ConcurrentDictionary<long, string> _cachedAccountEmails = new();


	public ContentService(CliRequester requester, ConfigService config, IContentApi api, IAccountsApi accountsApi)
	{
		_requester = requester;
		_config = config;
		_contentApi = api;
		_accountsApi = accountsApi;

		_channelChangedContentFiles = Channel.CreateUnbounded<ChangedContentFile>(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = false, AllowSynchronousContinuations = true, });
		_channelRemoteContentPublishes = Channel.CreateUnbounded<RemoteContentPublished>(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = false, AllowSynchronousContinuations = true, });
	}

	private string RootContentPath => Path.Combine(_config.ConfigDirectoryPath!, Constants.CONTENT_DIRECTORY);

	private IEnumerable<string> GetPidsWithCachedLocalContent() => Directory.EnumerateDirectories(RootContentPath);
	private string GetCacheKeyForManifest(string cid, string pid, string manifestId, string manifestUid) => $"{cid}₢{pid}₢{manifestId}₢{manifestUid}";

	public string EnsureContentPathForRealmExists(out bool created, string pid, string manifest = "global")
	{
		created = false;

		var path = Path.Combine(RootContentPath, pid, manifest);
		if (!Directory.Exists(path))
		{
			Directory.CreateDirectory(path);
			created = true;
		}

		return path;
	}

	public async IAsyncEnumerable<LocalContentFileChanges> ListenToLocalContentFileChanges(string pid, string manifestId = "global", [EnumeratorCancellation] CancellationToken token = default)
	{
		// The caller of this function must ensure that a reset has happened at least once in this realm (hence the assert)
		var contentFolder = EnsureContentPathForRealmExists(out var created, _requester.Pid, manifestId);
		Debug.Assert(!created, "This should never happen. If does, this is a bug --- please report it to Beamable.");

		// Set up the file watcher...
		var watcher = new FileSystemWatcher();
		watcher.BeginInit();
		watcher.Path = contentFolder;
		watcher.IncludeSubdirectories = true;
		watcher.Filter = "*.*";
		watcher.EnableRaisingEvents = true;
		watcher.Created += async (_, e) => await OnLocalRealmContentFilesChanged(e);
		watcher.Deleted += async (_, e) => await OnLocalRealmContentFilesChanged(e);
		watcher.Renamed += async (_, e) => await OnLocalRealmContentFilesChanged(e);
		watcher.Changed += async (_, e) => await OnLocalRealmContentFilesChanged(e);
		watcher.EndInit();

		// Keep waiting for messages from the set up file watcher.
		var reader = _channelChangedContentFiles.Reader;

		while (await reader.WaitToReadAsync(token))
		{
			// If the operation was cancelled, we break out.
			if (token.IsCancellationRequested)
				break;

			// We sleep a bit to make sure all the file changes from a multi-edit operation show up in a single batch.
			Thread.Sleep(15);

			// Get all the files that were changed respecting the PID filter.
			var batchedChanges = new LocalContentFileChanges() { AllFileChanges = new() };
			while (reader.TryRead(out var changed))
			{
				if (changed.OwnerPid == pid)
				{
					batchedChanges.AllFileChanges.Add(changed);
				}
			}

			yield return batchedChanges;
		}

		yield break;

		async Task OnLocalRealmContentFilesChanged(FileSystemEventArgs e)
		{
			await Task.Run(() =>
			{
				if (e.ChangeType == WatcherChangeTypes.Created)
				{
					var changedContent = new ChangedContentFile { OwnerPid = pid };
					changedContent.OwnerPid = pid;
					changedContent.OwnerManifestId = manifestId;

					changedContent.ContentId = Path.GetFileNameWithoutExtension(e.Name);
					changedContent.FullFilePath = e.FullPath;
					changedContent.OldContentId = "";
					changedContent.OldFullFilePath = "";
					_channelChangedContentFiles.Writer.TryWrite(changedContent);
				}
				else if (e.ChangeType == WatcherChangeTypes.Deleted)
				{
					var changedContent = new ChangedContentFile { OwnerPid = pid };
					changedContent.OwnerPid = pid;
					changedContent.OwnerManifestId = manifestId;

					changedContent.ContentId = changedContent.OldContentId = Path.GetFileNameWithoutExtension(e.Name);
					changedContent.FullFilePath = "";
					changedContent.OldFullFilePath = e.FullPath;

					_channelChangedContentFiles.Writer.TryWrite(changedContent);
				}
				else if (e.ChangeType == WatcherChangeTypes.Changed)
				{
					var changedContent = new ChangedContentFile { OwnerPid = pid };
					changedContent.OwnerPid = pid;
					changedContent.OwnerManifestId = manifestId;
					changedContent.ContentId = changedContent.OldContentId = Path.GetFileNameWithoutExtension(e.Name);
					changedContent.FullFilePath = changedContent.OldFullFilePath = e.FullPath;
					_channelChangedContentFiles.Writer.TryWrite(changedContent);
				}
				else if (e.ChangeType == WatcherChangeTypes.Renamed)
				{
					if (e is RenamedEventArgs renamedEventArgs)
					{
						var renamedContent = new ChangedContentFile();
						renamedContent.OwnerPid = pid;
						renamedContent.OwnerManifestId = manifestId;
						renamedContent.ContentId = Path.GetFileNameWithoutExtension(renamedEventArgs.Name);
						renamedContent.FullFilePath = renamedEventArgs.FullPath;
						renamedContent.OldContentId = Path.GetFileNameWithoutExtension(renamedEventArgs.OldName);
						renamedContent.OldFullFilePath = renamedEventArgs.OldFullPath;

						_channelChangedContentFiles.Writer.TryWrite(renamedContent);
					}
				}
				else
				{
					throw new ArgumentOutOfRangeException();
				}
			}, token);
		}
	}

	public async IAsyncEnumerable<RemoteContentPublished> ListenToRemoteContentPublishes(CommandArgs args, string manifestId = "global", [EnumeratorCancellation] CancellationToken token = default)
	{
		// Subscribe to the content refresh notification for the realm we are targeting.
		var listenTask = Task.Run(async () =>
		{
			try
			{
				var handle = WebsocketUtil.ConfigureWebSocketForServerNotifications(args, new[] { "content.manifest" }, token);
				await WebsocketUtil.RunServerNotificationListenLoop(handle, message =>
				{
					OnContentPublished(message.body);
				}, token);
			}
			catch (Exception e)
			{
				Console.WriteLine(e);
				throw;
			}
		}, token);

		// Loop while we are listing to the published changes on this realm and emit an event out of this enumerable every time we get one. 
		var reader = _channelRemoteContentPublishes.Reader;
		while (await reader.WaitToReadAsync(token) && !token.IsCancellationRequested)
		{
			// Break if a cancellation request came in.
			if (token.IsCancellationRequested)
				break;

			// Get all the files that were changed respecting the PID filter.
			while (reader.TryRead(out var changed))
			{
				yield return changed;
			}
		}

		await listenTask;

		yield break;

		void OnContentPublished(object o)
		{
			Task.Run(async () =>
			{
				try
				{
					var payload = (JObject)o;

					var categories = payload.Property("categories")!.Value.Values<string>().ToArray();
					var manifestInfo = payload.Property("manifest")!.Value.ToObject<JObject>();

					var publishedManifestId = manifestInfo.Property("id")!.Value.ToObject<string>();
					var manifestUid = manifestInfo.Property("uid")!.Value.ToObject<string>();
					var manifestChecksum = manifestInfo.Property("checksum")!.Value.ToObject<string>();
					var createdTimestamp = manifestInfo.Property("created")!.Value.ToObject<long>();
					var publisherAccountId = manifestInfo.Property("publisherAccountId")!.Value.ToObject<long>();


					// We only emit an event if the published manifest matches the id we care about.
					if (manifestId == publishedManifestId)
					{
						var emailFetchTask = GetAccountEmail(publisherAccountId);
						var manifestFetchTask = GetManifest(publishedManifestId, manifestUid);

						var email = await emailFetchTask;
						var newManifest = await manifestFetchTask;

						// Let's sync the local content without synching created or modified files and ignoring conflicts.
						var syncReport = await SyncLocalContent(newManifest, manifestId, syncCreated: false, syncModified: false, forceSyncConflicts: false);

						// Put this on the channel so it gets picked up below.
						_channelRemoteContentPublishes.Writer.TryWrite(new RemoteContentPublished()
						{
							OwnerCid = _requester.Cid,
							OwnerPid = _requester.Pid,
							PublisherAccountId = publisherAccountId.ToString(),
							PublisherEmail = email,
							AutoSyncReport = syncReport,
						});
					}
				}
				catch (Exception e)
				{
					Log.Error(e, "Something went wrong when auto-synchronizing a remote publish with the local files.");
					throw;
				}
			}, token);
		}
	}

	/// <summary>
	/// This gets and caches the manifest with the given Id and UID. If a blank UID is provided, this will fetch the latest manifest (the latest manifest is un-cacheable).
	/// </summary>
	private async Task<ClientManifestJsonResponse> GetManifest(string manifestId = "global", string manifestUid = "")
	{
		var cacheKey = GetCacheKeyForManifest(_requester.Cid, _requester.Pid, manifestId, manifestUid);
		if (!_cachedManifests.TryGetValue(cacheKey, out var manifest))
		{
			if (string.IsNullOrEmpty(manifestUid))
			{
				manifest = await _contentApi.GetManifestPublicJson(manifestId);

				var specificCacheKey = GetCacheKeyForManifest(_requester.Cid, _requester.Pid, manifestId, manifest.uid.GetOrElse(""));
				_cachedManifests[specificCacheKey] = manifest;
			}
			else
			{
				_cachedManifests[cacheKey] = manifest = await _contentApi.GetManifestPublicJson(manifestId, manifestUid);
			}
		}

		return manifest;
	}

	private async Task<string> GetAccountEmail(long accountId)
	{
		if (accountId == 0) return "";
		if (_cachedAccountEmails.TryGetValue(accountId, out var email))
		{
			return email;
		}

		_cachedAccountEmails[accountId] = email = await _accountsApi
			.GetFind(accountId.ToString())
			.Map(res => res.email.GetOrElse(""));
		return email;
	}

	/// <summary>
	/// Returns the list of <see cref="ContentFile"/> relative to the given manifest.
	/// If no manifest is provided, we'll fetch it with the given <paramref name="manifestId"/>.
	/// If you provide a manifest, please make sure the <paramref name="manifestId"/> matches the given manifest.
	///
	/// The list of content files is a union (by content id) of:
	/// - Each content in the <paramref name="latestManifest"/>.
	/// - Each content file existent locally.
	///
	/// This means that it'll contain created, deleted, modified and up-to-date content alike.
	/// It gives you a full picture of the local content files relative to the given <paramref name="latestManifest"/>.
	///
	/// When <paramref name="getLocalStateOnly"/> is set, the resulting <see cref="ContentFile.ReferenceContent"/> will be empty and
	/// the <see cref="LocalContentFiles.ContentFiles"/> will ONLY contain the files that exist locally. In this case, the <see cref="ContentFile.GetStatus"/> is NOT semantically correct.
	/// As in, you can't use its value for anything.
	///
	/// If this is ever called on a manifest/realm combination for which we have no local folder, we will synchronize that folder with that realm's latest manifest before computing the <see cref="LocalContentFiles"/>.
	/// This ONLY happens if <paramref name="getLocalStateOnly"/> is false. 
	/// </summary>
	public async Task<LocalContentFiles> GetAllContentFiles(ClientManifestJsonResponse latestManifest = null, string manifestId = "global", bool getLocalStateOnly = false)
	{
		// Initialize the local files
		var localFiles = new LocalContentFiles() { ManifestId = manifestId, TargetManifest = latestManifest, ContentFiles = new(1024), };

		// If no reference manifest was provided, let's fetch the latest Manifest.
		if (!getLocalStateOnly) localFiles.TargetManifest ??= await GetManifest(manifestId);
		else localFiles.TargetManifest ??= new() { entries = Array.Empty<ClientContentInfoJson>(), };

		// Whenever we try to get the local state in relation to the remote one --- if we had never sync'ed before, we do a sync before computing the state. 
		var contentFolder = EnsureContentPathForRealmExists(out var created, _requester.Pid, manifestId);
		if (created && !getLocalStateOnly) await SyncLocalContent(localFiles.TargetManifest, manifestId, ContentFilterType.ExactIds, Array.Empty<string>(), true);

		// Build a list of tasks for computing a ContentFile structure for each relevant content id in this manifest.  
		var tasks =
			// For each existing file inside the content folder we care about, we'll have one entry.
			Directory.EnumerateFiles(contentFolder).Select(async fp =>
				{
					var text = await File.ReadAllTextAsync(fp);
					var json = JsonSerializer.Deserialize<JsonElement>(text, GetContentFileSerializationOptions());

					var id = Path.GetFileNameWithoutExtension(fp);
					var referenceContent = localFiles.TargetManifest.entries.FirstOrDefault(e => e.contentId == id);
					var properties = json.GetProperty(ContentFile.JSON_NAME_PROPERTIES);
					var contentFile = new ContentFile()
					{
						Id = id,
						LocalFilePath = fp,
						Properties = properties,
						Tags = json.GetProperty(ContentFile.JSON_NAME_TAGS),
						FetchedFromManifestUid = json.GetProperty(ContentFile.JSON_NAME_REFERENCE_MANIFEST_ID).GetString(),
						ReferenceContent = referenceContent,
					};
					contentFile.PropertiesChecksum = CalculateChecksum(in contentFile);

					return contentFile;
				})
				// We'll also have on entry for each entry in the reference manifest that is NOT represented in the local files.
				.Concat(
					localFiles.TargetManifest.entries.Where(e =>
					{
						var expectedPath = Path.Combine(contentFolder, $"{e.contentId}.json");
						return !File.Exists(expectedPath);
					}).Select(e => Task.FromResult(new ContentFile()
					{
						Id = e.contentId,
						LocalFilePath = "",
						Properties = default,
						Tags = JsonSerializer.SerializeToElement(e.tags),

						// For deletions, this is set as the reference manifest because it doesn't matter what the reference manifest was before deletion.
						// If someone publishes a manifest that has this guy in it, we'll auto sync it back up.
						// Using the target manifest uid, simplifies other cases (such as the initial sync) so we use this. 
						FetchedFromManifestUid = localFiles.TargetManifest.uid.GetOrElse(""),
						PropertiesChecksum = e.version,
						ReferenceContent = e
					}))
				).ToList();

		// Wait for all the content file tasks and return the list of ContentFile.
		try
		{
			localFiles.ContentFiles = (await Task.WhenAll(tasks)).ToList();
			localFiles.PerIdContentFiles = localFiles.ContentFiles.ToDictionary(g => g.Id, g => g);

			// Gather all the distinct reference manifests.
			localFiles.ReferenceManifestUids = localFiles.ContentFiles.Select(c => c.FetchedFromManifestUid).ToHashSet();

			// Fetch all the different reference manifests in parallel if we want not only the local state
			if (!getLocalStateOnly)
			{
				var allRefsPromises = localFiles.ReferenceManifestUids.Select(rm => GetManifest(manifestId, rm)).ToArray();
				localFiles.ReferenceManifests = (await Task.WhenAll(allRefsPromises)).ToDictionary(g => g.uid.Value, g => g);
			}

			return localFiles;
		}
		catch (Exception e)
		{
			if (e is AggregateException ae)
			{
				foreach (var aeInnerException in ae.InnerExceptions)
				{
					Log.Error(aeInnerException, "Error when loading content file");
				}
			}

			throw;
		}
	}

	/// <summary>
	/// Publishes the local changes made to the given <paramref name="manifestId"/> to the current <see cref="IAppContext.Pid"/>.
	///
	/// First, this checks if the last manifest we pulled is the same as the last manifest anyone published to that realm.
	/// If it isn't we error out with <see cref="ERR_CODE_PUBLISH_FAILED_INVALID_REFERENCE_MANIFEST"/>.
	///
	/// For now, users cannot publish UNLESS they make their changes against the latest published manifest.
	/// </summary>
	public async Task PublishContent(string manifestId = "global")
	{
		// Get the latest manifest id and generate the diff against local files. 
		var latestManifest = await GetManifest(manifestId);
		var localAgainstLatest = await GetAllContentFiles(latestManifest, manifestId);

		// Check for conflicts against the latest one.
		ComputeCorrectSyncOp(localAgainstLatest, false, out var conflicted, out _, out _);

		// If we have any conflicting modifications over the latest remote manifest, let's block the publish.  
		if (conflicted.Any())
		{
			throw new CliException(
				"You have conflicting changes that were made against an older manifest. " +
				$"Please run `dotnet beam content sync --force --filters {string.Join(",", conflicted)}` (this will discard all your local changes for the conflicting files)." +
				$"If you'd like, you can then re-apply your local ones before publishing. ",
				ERR_CODE_PUBLISH_FAILED_INVALID_REFERENCE_MANIFEST, true);
		}

		// Now, we compute our status against the latest manifest and get ONLY the files that weren't deleted (these are the ones that will be included in the new manifest).
		var changedContent = localAgainstLatest.ContentFiles
			.Where(c => !c.GetStatus().HasFlag(ContentStatus.Deleted))
			.Select(c =>
			{
				// Build the properties from the local data.
				var properties = new MapOfContentMeta();
				foreach (var prop in c.Properties.EnumerateObject())
				{
					var key = prop.Name;
					var val = prop.Value;

					var meta = new ContentMeta();
					if (val.TryGetProperty(nameof(ContentMeta.data), out var dataProp))
						meta.data = new OptionalJsonString(JsonString.FromJson(dataProp.GetRawText()));

					if (val.TryGetProperty(nameof(ContentMeta.text), out var textProp))
						meta.text = OptionalString.FromString(textProp.GetString());

					if (val.TryGetProperty("$link", out var linkProp) || val.TryGetProperty("link", out linkProp))
						meta.Link = OptionalString.FromString(linkProp.GetString());

					if (val.TryGetProperty("$links", out var linksProp) || val.TryGetProperty("link", out linksProp))
						meta.Links = new OptionalArrayOfString(linksProp.EnumerateArray().Select(j => j.GetString()));

					properties.Add(key, meta);
				}

				// Build the tags from the local data.
				var tags = new OptionalArrayOfString(c.Tags.EnumerateArray().Select(j => j.GetString()).ToArray());

				// Return the built content definition
				return new ContentDefinition
				{
					id = c.Id,
					checksum = c.PropertiesChecksum,
					properties = properties,
					tags = tags,

					// This is not really supported anymore so ignore it.
					// TODO: Investigate this with Ben or Ali to figure out if/when we can kill it.
					variants = null,
				};
			}).ToArray();

		// Then we save them to S3
		var saveContentRequest = new SaveContentRequest() { content = changedContent, };
		SaveContentResponse saveContentResponse;

		try
		{
			saveContentResponse = await _contentApi.Post(saveContentRequest);
		}
		catch (Exception e)
		{
			// Handle failure case by just stopping here and erroring out
			throw new CliException($"Failed to save the local content. Please try again. EXCEPTION={e.Data}");
		}

		// Prepare the save manifest request using the response from the save content request.
		var saveManifestRequest = new SaveManifestRequest()
		{
			// Manifest ID
			id = manifestId,

			// This is just a type-conversion
			references = saveContentResponse.content.Select(c => new ReferenceSuperset()
			{
				id = c.id,
				version = c.version,
				checksum = c.checksum,
				type = c.type.ToString().ToLower(),
				tags = new OptionalArrayOfString(c.tags),
				uri = c.id,
				visibility = c.visibility.ToString().ToLower(),
			}).ToArray(),
		};

		// Update the local reference manifest
		_ = await _contentApi.PostManifest(saveManifestRequest);
	}

	/// <summary>
	/// Compares the local state of each <see cref="ContentFile"/> to the given <paramref name="referenceManifestUid"/> and resets the local file content to whatever that content was at that version.
	/// If no <paramref name="referenceManifestUid"/> is provided, it'll use whatever is stored at <see cref="LocalContentConfig.LatestManifestDownloaded"/> for determining the <see cref="ContentFile.GetStatus"/> results.
	///
	/// The filters are applied in accordance to <see cref="ContentFilterType"/>'s semantics.
	/// When <paramref name="deleteCreated"/> is true, this will ALSO delete any local only files.
	/// </summary>
	public async Task SyncLocalContent(string manifestId,
		ContentFilterType filterType = ContentFilterType.ExactIds, string[] filters = null,
		bool deleteCreated = true, bool syncModified = true, bool forceSyncConflicts = true,
		string referenceManifestUid = "")
	{
		var targetManifest = await GetManifest(manifestId, referenceManifestUid);
		await SyncLocalContent(targetManifest, manifestId, filterType, filters, deleteCreated, syncModified, forceSyncConflicts);
	}

	/// <summary>
	/// <inheritdoc cref="SyncLocalContent(string,string[],cli.Content.ContentFilterType,bool,string)"/>
	/// </summary>
	public async Task<ContentSyncReport> SyncLocalContent(ClientManifestJsonResponse targetManifest, string manifestId,
		ContentFilterType filterType = ContentFilterType.ExactIds, string[] filters = null,
		bool syncCreated = true, bool syncModified = true, bool forceSyncConflicts = true)
	{
		var report = new ContentSyncReport();
		filters ??= Array.Empty<string>();

		// Load up all the content files for this pid and filter them accordingly.
		var targetManifestUid = targetManifest.uid.GetOrElse("");
		var localContentRelativeToNewManifest = await GetAllContentFiles(targetManifest, manifestId);
		FilterLocalContentFiles(ref localContentRelativeToNewManifest, filters, filterType);

		// Computes helper sets so that we can know about what can be auto-synchronized and what is in conflict. 
		ComputeCorrectSyncOp(localContentRelativeToNewManifest, syncModified, out HashSet<string> conflicts, out var autoSync, out var canUpdateReferenceWithoutDownload);

		// Get the list of modified and deleted content to re-download from the target manfiest
		// If given a list of content ids, will ONLY download the given ids
		// When ignore conflicts is true, we won't download content that is currently in conflict.
		var contentToDownload = localContentRelativeToNewManifest.ContentFiles
			.Where(c => forceSyncConflicts ? autoSync.Contains(c.Id) || conflicts.Contains(c.Id) : autoSync.Contains(c.Id))
			.ToArray();

		// Get the list of created content we need to delete (if requested).
		var contentToDelete = localContentRelativeToNewManifest.ContentFiles
			.Where(c => syncCreated && c.GetStatus().HasFlag(ContentStatus.Created))
			.ToArray();

		// Get the list of content that is up-to-date but the referenceManifestUid is not pointing at the latest one (so we can update the reference).
		var contentToUpdateManifestReference = localContentRelativeToNewManifest.ContentFiles
			.Where(c => canUpdateReferenceWithoutDownload.Contains(c.Id))
			.ToArray();

		// Update our sync report with what we intended to do
		report.ConflictingContents = conflicts.ToArray();
		report.AutoSynchedContents = autoSync.ToArray();
		report.ReferenceUpdatedContents = canUpdateReferenceWithoutDownload.ToArray();
		report.DeletedCreatedContents = contentToDelete.Select(c => c.Id).ToArray();

		// Download and overwrite the local content for things that have changed based on the hash or don't exist.
		var downloadPromises = contentToDownload.Select(async c =>
		{
			Log.Verbose("Downloading content with id. ID={Id}", c.Id);
			return (localContent: c, downloadedContent: await _requester.CustomRequest(Method.GET, c.ReferenceContent.uri, parser: s => JsonSerializer.Deserialize<JsonElement>(s)));
		}).ToArray();

		// Delete any files flagged for deletion, if any.
		foreach (var c in contentToDelete) File.Delete(c.LocalFilePath);

		// Let's try to download all the content paired with the local ContentFile representation.
		(ContentFile localContent, JsonElement downloadedContent)[] downloadedContent;
		try
		{
			downloadedContent = await Task.WhenAll(downloadPromises);
		}
		catch (Exception e)
		{
			// Let's just print out all the exceptions
			if (e is AggregateException ae)
			{
				foreach (var aeInnerException in ae.InnerExceptions)
				{
					Log.Error(aeInnerException, "Error when loading content file");
				}
			}
			else
			{
				Log.Error(e, "Error when saving content files. Undoing pull operation. EXCEPTION={Exception}", e.ToString());
			}

			throw;
		}

		// Makes sure the content folder for the current realm exists.
		// The caller of this function must ensure that a reset has happened at least once in this realm (hence the assert)
		var contentFolder = EnsureContentPathForRealmExists(out var created, _requester.Pid, manifestId);
		Debug.Assert(!created, "This should never happen. If does, this is a bug --- please report it to Beamable.");

		// Save the downloaded content to disk.
		var saveTasks = new List<Task>();
		foreach (var (c, j) in downloadedContent)
		{
			var contentFile = c;
			contentFile.Properties = j.GetProperty("properties");
			contentFile.Tags = JsonSerializer.SerializeToElement(c.ReferenceContent.tags);
			contentFile.FetchedFromManifestUid = targetManifestUid;
			saveTasks.Add(SaveContentFile(contentFolder, contentFile));
		}

		// Make the Up-to-Date content files reference the manifest to which we just synchronized.
		foreach (var c in contentToUpdateManifestReference)
		{
			var contentFile = c;
			contentFile.Tags = JsonSerializer.SerializeToElement(c.ReferenceContent.tags);
			contentFile.FetchedFromManifestUid = targetManifestUid;
			saveTasks.Add(SaveContentFile(contentFolder, contentFile));
		}

		// If any problem happens while we are saving to disk, let's undo the pull operation and log out the exceptions.
		try
		{
			await Task.WhenAll(saveTasks);
			return report;
		}
		catch (Exception e)
		{
			// Let's just print out all the exceptions
			if (e is AggregateException ae)
			{
				foreach (var aeInnerException in ae.InnerExceptions)
				{
					Log.Error(aeInnerException, "Error when saving content files. Undoing pull operation. EXCEPTION={Exception}", aeInnerException.ToString());
				}
			}
			else
			{
				Log.Error(e, "Error when saving content files. Undoing pull operation. EXCEPTION={Exception}", e.ToString());
			}

			// If any content failed, we re-write undo all the changes by re-serializing all the local content that we had before we downloaded.
			// This makes the operation atomic.
			var undoPullTasks = contentToDownload.Union(contentToDelete)
				.Where(c => c.GetStatus().HasFlag(ContentStatus.Deleted) | c.GetStatus().HasFlag(ContentStatus.Modified))
				.Select(async contentFile =>
				{
					var fileName = Path.Combine(contentFolder, $"{contentFile.Id}.json");
					var fileContents = JsonSerializer.Serialize(contentFile, GetContentFileSerializationOptions());
					await File.WriteAllTextAsync(fileName, fileContents);
				}).ToArray();

			await Task.WhenAll(undoPullTasks);

			report.Error = "Something went wrong when synchronizing your local content. Please look at the logs for details.";
			return report;
		}
	}

	public static void ComputeCorrectSyncOp(LocalContentFiles file, bool allowModifiedInAutoSync, out HashSet<string> conflictedContent, out HashSet<string> canAutoSync,
		out HashSet<string> canUpdateReferenceToTargetWithoutDownload)
	{
		conflictedContent = new();
		canAutoSync = new();
		canUpdateReferenceToTargetWithoutDownload = new();
		for (var i = 0; i < file.ContentFiles.Count; i++)
		{
			var contentFile = file.ContentFiles.ElementAt(i);
			var referenceContentFile = contentFile.ChangeReference(file.ReferenceManifests[contentFile.FetchedFromManifestUid]);

			var statusAgainstTarget = contentFile.GetStatus();
			var statusAgainstReference = referenceContentFile.GetStatus();

			// A conflict occurs whenever all of these are true:
			// A. A local change existed against our reference manifest.
			var localChangeExisted = statusAgainstReference == ContentStatus.Modified;
			// B. The local changed content that we have does not match the one in the new target manifest
			var localChangeDoesNotMatch = statusAgainstTarget == ContentStatus.Modified;
			// C. There is a change between our reference manifest and the new target manifest.
			var wasChangedFromReference = localChangeExisted && localChangeDoesNotMatch && contentFile.ReferenceContent.checksum.GetOrElse("") != referenceContentFile.ReferenceContent.checksum.GetOrElse("");
			
			// If all the above is true, this is a conflict.
			var wasConflict = localChangeExisted && localChangeDoesNotMatch && wasChangedFromReference;
			if (wasConflict)
			{
				conflictedContent.Add(contentFile.Id);
			}
			// If there was no conflict, we can decide whether we are allowed to download the content from the new target.
			else
			{
				// This happens when any one of these are true:
				// A. A local change had not been made against the reference manifest -- which means that we can fetch the new content if it is modified.
				var caseA = statusAgainstReference is ContentStatus.UpToDate && statusAgainstTarget is ContentStatus.Modified;
				// B. The content is deleted locally against our reference manifest AND there was a change between our reference manifest and the new target manifest.
				var caseB = statusAgainstTarget is ContentStatus.Deleted;
				// C. If we want to syncModified and the status against target is modified
				var caseC = allowModifiedInAutoSync && statusAgainstTarget is ContentStatus.Modified;
				// If either of the above cases are true, we can auto-sync this content.
				if (caseA || caseB || caseC) canAutoSync.Add(contentFile.Id);

				// We also need to check if we can to update the reference manifest uid without downloading the content.
				// A. Our local content is up-to-date against the target AND it doesn't reference the target.
				var isManifestReferenceWrong = contentFile.FetchedFromManifestUid != file.TargetManifest.uid.GetOrElse("");
				caseA = statusAgainstTarget is ContentStatus.UpToDate && isManifestReferenceWrong;
				// B. Our local content has changes relative to our current reference AND it was not a conflict. 
				caseB = statusAgainstReference is ContentStatus.Modified && isManifestReferenceWrong;
				// C. Our local content does not exist in the reference manifest AND it was not a conflict (it just shows up as a creation now referencing the latest manifest) 
				caseC = statusAgainstReference is ContentStatus.Created && isManifestReferenceWrong;
				if (caseA || caseB || caseC) canUpdateReferenceToTargetWithoutDownload.Add(contentFile.Id);
			}
		}
	}

	/// <summary>
	/// Given a <see cref="LocalContentFiles"/> list, filters its content list based on some filter semantics.
	/// </summary>
	public static void FilterLocalContentFiles(ref LocalContentFiles file, string[] filters, ContentFilterType filterType)
	{
		Func<ContentFile, bool> filterFunc;
		switch (filterType)
		{
			case ContentFilterType.ExactIds:
			{
				filterFunc = f => filters.Length == 0 || filters.Any(id => id == f.Id);
				break;
			}
			case ContentFilterType.TypeHierarchy:
			{
				filterFunc = f => filters.Length == 0 || filters.Any(contentType => f.Id.StartsWith(contentType));
				break;
			}
			case ContentFilterType.TypeHierarchyStrict:
			{
				filterFunc = f => filters.Length == 0 || filters.Any(contentType => GetContentType(in f) == contentType);
				break;
			}
			case ContentFilterType.Regexes:
			{
				var regexes = filters.Select(f => new Regex(f, RegexOptions.Compiled)).ToArray();
				filterFunc = f => filters.Length == 0 || regexes.Any(r => r.IsMatch(f.Id));
				break;
			}
			case ContentFilterType.Tags:
			{
				filterFunc = f => filters.Length == 0 || f.GetTagsArray().Intersect(filters).Any();
				break;
			}
			default:
				throw new ArgumentOutOfRangeException(nameof(filterType));
		}

		file.ContentFiles = file.ContentFiles.Where(filterFunc).ToList();
		file.PerIdContentFiles = file.ContentFiles.ToDictionary(f => f.Id, f => f);
	}

	/// <summary>
	/// <inheritdoc cref="AddTags(cli.Content.LocalContentFiles,string[])"/>
	/// </summary>
	public async Task AddTag(ContentFile f, string tag) =>
		await AddTags(new LocalContentFiles() { ContentFiles = new() { f }, PerIdContentFiles = new() { { f.Id, f } }, TargetManifest = null, }, new[] { tag });

	/// <summary>
	/// <inheritdoc cref="AddTags(cli.Content.LocalContentFiles,string[])"/>
	/// </summary>
	public async Task AddTags(ContentFile f, string[] tags) =>
		await AddTags(new LocalContentFiles() { ContentFiles = new() { f }, PerIdContentFiles = new() { { f.Id, f } }, TargetManifest = null, }, tags);

	/// <summary>
	/// Adds the given tags to each content file in the list of <see cref="LocalContentFiles"/>.
	///
	/// If <paramref name="addDuplicates"/> is false, we will only add tags to the files that don't already have that tag.
	/// Otherwise, it'll add it again.
	/// </summary>
	public async Task AddTags(LocalContentFiles localContentFiles, string[] tags)
	{
		// The caller of this function must ensure that a reset has happened at least once in this realm (hence the assert)
		var contentFolder = EnsureContentPathForRealmExists(out var created, _requester.Pid, localContentFiles.ManifestId);
		Debug.Assert(!created, "This should never happen. If does, this is a bug --- please report it to Beamable.");

		var saveTasks = new List<Task>();
		foreach (var contentFile in localContentFiles.ContentFiles)
		{
			var f = contentFile;

			var existingTags = f.GetTagsArray();
			var newTags = existingTags.Union(tags);

			f.Tags = JsonSerializer.SerializeToElement(newTags);
			saveTasks.Add(SaveContentFile(contentFolder, f));
		}

		await Task.WhenAll(saveTasks);
	}

	/// <summary>
	/// <inheritdoc cref="Beamable.Api.Autogenerated.Models.RemoveTags"/>
	/// </summary>
	public async Task RemoveTag(ContentFile f, string tag) =>
		await RemoveTags(new LocalContentFiles() { ContentFiles = new() { f }, PerIdContentFiles = new() { { f.Id, f } }, TargetManifest = null, }, new[] { tag });

	/// <summary>
	/// <inheritdoc cref="Beamable.Api.Autogenerated.Models.RemoveTags"/>
	/// </summary>
	public async Task RemoveTags(ContentFile f, string[] tags) =>
		await RemoveTags(new LocalContentFiles() { ContentFiles = new() { f }, PerIdContentFiles = new() { { f.Id, f } }, TargetManifest = null, }, tags);

	/// <summary>
	/// Removes the given tags to each content file in the list of <paramref name="localContentFiles"/>.
	///
	/// When <paramref name="maxRemoveCount"/> is 0, we'll remove every instance of that tag from the list of tags.
	/// If its any value ABOVE 0, we'll remove only that many instances of the tags from the list of content.
	/// </summary>
	public async Task RemoveTags(LocalContentFiles localContentFiles, string[] tags)
	{
		// The caller of this function must ensure that a reset has happened at least once in this realm (hence the assert)
		var contentFolder = EnsureContentPathForRealmExists(out var created, _requester.Pid, localContentFiles.ManifestId);
		Debug.Assert(!created, "This should never happen. If does, this is a bug --- please report it to Beamable.");

		var saveTasks = new List<Task>();
		foreach (var contentFile in localContentFiles.ContentFiles)
		{
			var f = contentFile;

			var existingTags = f.GetTagsArray().ToList();
			var newTags = existingTags.Except(tags);

			f.Tags = JsonSerializer.SerializeToElement(newTags);
			saveTasks.Add(SaveContentFile(contentFolder, f));
		}

		await Task.WhenAll(saveTasks);
	}

	/// <summary>
	/// Utility function that saves the given <see cref="ContentFile"/> to the folder storing the files for the given
	/// <paramref name="manifestId"/> and <paramref name="pid"/>.
	/// </summary>
	public async Task SaveContentFile(ContentFile f, string manifestId = "", string pid = null)
	{
		pid ??= _requester.Pid;
		// The caller of this function must ensure that a reset has happened at least once in this realm (hence the assert)
		var contentFolder = EnsureContentPathForRealmExists(out var created, _requester.Pid, manifestId);
		Debug.Assert(!created, "This should never happen. If does, this is a bug --- please report it to Beamable.");

		await SaveContentFile(contentFolder, f);
	}

	/// <summary>
	/// Utility function that saves the given <see cref="ContentFile"/> to the given folder.
	/// </summary>
	public async Task SaveContentFile(string contentFolder, ContentFile f)
	{
		var fileName = Path.Combine(contentFolder, $"{f.Id}.json");
		var fileContents = JsonSerializer.Serialize(f, GetContentFileSerializationOptions());
		await File.WriteAllTextAsync(fileName, fileContents);
	}

	/// <summary>
	/// Helper utility that converts a collection of <see cref="ContentFile"/>s to the public
	/// <see cref="LocalContentManifestEntry"/> format.
	/// </summary>
	public static IEnumerable<LocalContentManifestEntry> ContentFileToLocalContentManifestEntries(IEnumerable<ContentFile> files)
	{
		return files.Select(file =>
		{
			return new LocalContentManifestEntry()
			{
				FullId = file.Id,
				TypeName = GetContentType(file),
				Name = GetContentName(file),
				Hash = file.PropertiesChecksum,
				Tags = file.Tags.EnumerateArray().Select(ae => ae.GetString() ?? "").ToArray(),
				CurrentStatus = (int)file.GetStatus(),
				JsonFilePath = file.LocalFilePath,
				ReferenceManifestUid = file.FetchedFromManifestUid,
			};
		});
	}

	/// <summary>
	/// Serializes just the <see cref="ContentFile.Properties"/> object.
	/// We need this because we compute checksums ignoring tags.
	/// </summary>
	public static string SerializeProperties(in ContentFile file) => JsonSerializer.Serialize(file.Properties, GetContentFileSerializationOptions(false));

	/// <summary>
	/// Our ContentId is a '.'-separated string whose final component is a name and the substring before it, its type hierarchy.
	/// This extracts the substring representing the Content Type hierarchy for this object. 
	/// </summary>
	public static string GetContentType(in ContentFile file) => file.Id[..file.Id.LastIndexOf('.')];

	/// <summary>
	/// Our ContentId is a '.'-separated string whose final component is a name and the substring before it, its type hierarchy.
	/// This extracts the substring representing the content's name. 
	/// </summary>
	public static string GetContentName(in ContentFile file) => file.Id[(file.Id.LastIndexOf('.') + 1)..];

	/// <summary>
	/// Computes the SHA1 checksum we use for content-file diff'ing by hashing the serialized <see cref="ContentFile.Properties"/>.
	/// Serialization of the properties must use <see cref="GetContentFileSerializationOptions"/> (with indent as false)  to ensure field ordering. 
	/// </summary>
	public static string CalculateChecksum(in ContentFile file) => CalculateChecksum(SerializeProperties(in file));

	/// <summary>
	/// <inheritdoc cref="CalculateChecksum(in cli.Content.ContentFile)"/> 
	/// </summary>
	public static string CalculateChecksum(string propertiesJsonWithoutIndent)
	{
		var bytes = Encoding.UTF8.GetBytes(propertiesJsonWithoutIndent);
		var hash = SHA1.HashData(bytes);
		var checksum = Convert.ToHexString(hash).ToLower();
		return checksum;
	}

	/// <summary>
	/// This returns a <see cref="JsonSerializerOptions"/> that will correctly serialize a <see cref="ContentFile"/>.
	/// </summary>
	public static JsonSerializerOptions GetContentFileSerializationOptions(bool indent = true)
	{
		return new JsonSerializerOptions()
		{
			WriteIndented = indent,
			IncludeFields = true,
			TypeInfoResolver = new DefaultJsonTypeInfoResolver()
			{
				Modifiers =
				{
					typeInfo =>
					{
						if (typeInfo.Kind != JsonTypeInfoKind.Object)
							return;
						var properties = typeInfo.Properties.OrderBy(p => p.Name, StringComparer.Ordinal).ToList();
						typeInfo.Properties.Clear();
						for (int i = 0; i < properties.Count; i++)
						{
							properties[i].Order = i;
							typeInfo.Properties.Add(properties[i]);
						}
					}
				}
			}
		};
	}

	public async Task<bool> ContentExistByIds(string[] contentIds)
	{
		var asd = await GetAllContentFiles(getLocalStateOnly: true);
		FilterLocalContentFiles(ref asd, contentIds, ContentFilterType.ExactIds);
		return asd.ContentFiles.Select(c => c.Id).Intersect(contentIds).Count() == contentIds.Length;
	}
}

public class ContentSyncReport
{
	public bool Success => string.IsNullOrEmpty(Error);

	public string Error;

	public string[] ConflictingContents;
	public string[] AutoSynchedContents;
	public string[] ReferenceUpdatedContents;
	public string[] DeletedCreatedContents;
}

/// <summary>
/// Helper struct built by <see cref="ContentService.GetAllContentFiles"/> that represents a "local manifest in relation to a published manifest".
/// </summary>
public struct LocalContentFiles
{
	public string ManifestId;
	public ClientManifestJsonResponse TargetManifest;
	public List<ContentFile> ContentFiles;
	public Dictionary<string, ContentFile> PerIdContentFiles;
	public HashSet<string> ReferenceManifestUids;
	public Dictionary<string, ClientManifestJsonResponse> ReferenceManifests;
}

[Serializable]
public struct ContentFile : IEquatable<ContentFile>
{
	public const string JSON_NAME_PROPERTIES = "properties";
	public const string JSON_NAME_TAGS = "tags";
	public const string JSON_NAME_REFERENCE_MANIFEST_ID = "referenceManifestId";

	[JsonIgnore] public string Id;
	[JsonIgnore] public string LocalFilePath;
	[JsonIgnore] public string PropertiesChecksum;
	[JsonIgnore] public ClientContentInfoJson ReferenceContent;
	[JsonIgnore] public bool IsInConflictWithLatest;

	[JsonPropertyName(JSON_NAME_PROPERTIES)]
	public JsonElement Properties;

	[JsonPropertyName(JSON_NAME_TAGS)] public JsonElement Tags;

	[JsonPropertyName(JSON_NAME_REFERENCE_MANIFEST_ID)]
	public string FetchedFromManifestUid;


	public ContentStatus GetStatus()
	{
		ContentStatus ret;
		if (ReferenceContent == null) ret = ContentStatus.Created;
		else if (Properties.ValueKind == JsonValueKind.Undefined || Tags.ValueKind == JsonValueKind.Undefined) ret = ContentStatus.Deleted;
		else if (ReferenceContent.checksum != PropertiesChecksum || IsTagsDiff()) ret = ContentStatus.Modified;
		else ret = ContentStatus.UpToDate;
		return ret;
	}

	public ContentFile ChangeReference(ClientManifestJsonResponse newReferenceManifest)
	{
		var copy = this;
		copy.ReferenceContent = newReferenceManifest.entries.FirstOrDefault(j => j.contentId == copy.Id);
		return copy;
	}

	public string[] GetTagsArray() => Tags.EnumerateArray().Select(f => f.GetString()).ToArray();

	public bool IsTagsDiff()
	{
		var status = GetTagStatus();
		return status.Count != 0 && !status.Values.Any(s => s is not TagStatus.LocalAndRemote);
	}

	public string GetStatusString()
	{
		var status = GetStatus();
		var applyPrefix = IsInConflictWithLatest;
		var prefix = applyPrefix ? "[red]conflict[/] - " : "";
		if (status.HasFlag(ContentStatus.Created)) return $"{prefix}[green]created[/]";
		if (status.HasFlag(ContentStatus.Deleted)) return $"{prefix}[red]deleted[/]";
		if (status.HasFlag(ContentStatus.Modified)) return $"{prefix}[yellow]modified[/]";
		if (status.HasFlag(ContentStatus.UpToDate)) return $"{prefix}up to date";

		throw new ArgumentOutOfRangeException(nameof(GetStatus), GetStatus(), null);
	}

	public Dictionary<string, TagStatus> GetTagStatus()
	{
		var remoteTags = ReferenceContent?.tags ?? Array.Empty<string>();
		var localTags = Tags.EnumerateArray().Select(j => j.GetString()).ToArray();

		var remoteOnlyTags = remoteTags.Except(localTags);
		var localOnlyTags = localTags.Except(remoteTags);
		var bothTags = localTags.Intersect(remoteTags);

		var res = new Dictionary<string, TagStatus>();
		foreach (var t in bothTags) res.Add(t, TagStatus.LocalAndRemote);
		foreach (var t in remoteOnlyTags) res.Add(t, TagStatus.RemoteOnly);
		foreach (var t in localOnlyTags) res.Add(t, TagStatus.LocalOnly);

		return res;
	}

	public bool Equals(ContentFile other) => Id == other.Id;

	public override bool Equals(object obj) => obj is ContentFile other && Equals(other);

	public override int GetHashCode() => (Id != null ? Id.GetHashCode() : 0);

	public static bool operator ==(ContentFile left, ContentFile right) => left.Equals(right);

	public static bool operator !=(ContentFile left, ContentFile right) => !left.Equals(right);
}

[CliContractType, Flags]
public enum ContentStatus
{
	Invalid = 0,
	Created = 1 << 0,
	Deleted = 1 << 1,
	Modified = 1 << 2,
	UpToDate = 1 << 3,
}

public enum TagStatus
{
	LocalOnly,
	RemoteOnly,
	LocalAndRemote
}

/// <summary>
/// Filters that can be applied to <see cref="ContentService.FilterLocalContentFiles"/> to get a subset of content files.
/// </summary>
public enum ContentFilterType
{
	/// <summary>
	/// Matches the given array of filters as though they were fully formed ContentIds.
	/// </summary>
	ExactIds,

	/// <summary>
	/// Matches the given array of filters as though they were fully formed ContentTypeIds.
	/// The comparison is a StartsWith so... 'items' will return ANY item or its subclasses.
	/// </summary>
	TypeHierarchy,

	/// <summary>
	/// Matches the given array of filters as though they were fully formed ContentTypeIds.
	/// The comparison is an equals so... 'items' will return only content files that are exactly of the `items` content type (no subclasses).
	/// </summary>
	TypeHierarchyStrict,

	/// <summary>
	/// Matches the given array of filters as though they were C# regexes.
	/// </summary>
	Regexes,

	/// <summary>
	/// Matches the given array of filters as though they were tags.
	/// Any content file that has any of the filter tags will be included in the filtered list.
	/// </summary>
	Tags,
}
