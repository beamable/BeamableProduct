// using Beamable.Api.Autogenerated.Beamo;
// using Beamable.Common.Dependencies;

using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Realms;
using Beamable.Common.Dependencies;
using Beamable.Serialization;
using Beamable.Serialization.SmallerJSON;
using cli.DeploymentCommands;
using cli.Services;
using Docker.DotNet.Models;
using Serilog;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using BeamoLocalManifest = cli.Services.BeamoLocalManifest;
using PostManifestRequest = Beamable.Api.Autogenerated.Models.PostManifestRequest;
using ServiceReference = Beamable.Api.Autogenerated.Models.ServiceReference;
using ServiceStorageReference = Beamable.Api.Autogenerated.Models.ServiceStorageReference;

namespace cli.Deployment.Services;

public enum DeployMode
{
	/// <summary>
	/// A deployment mode that only adds services found locally at the time of the deployment.
	/// Any existing services that are not part of the local environment will remain unchanged. 
	/// </summary>
	Additive, 
	
	/// <summary>
	/// A deployment mode that will remove everything unless it is found locally during the time
	/// of deployment. 
	/// </summary>
	Replace
}

public class DeploymentPlan : JsonSerializable.ISerializable
{
	
	/// <summary>
	/// This checksum represents the checksum of the remote manifest at the time the plan was made.
	/// If the plan is going to be <i>used</i>, the checksum should be checked. When the checksum
	/// does not match the latest remote checksum, this plan should be considered out of date.  
	/// </summary>
	public string builtFromRemoteChecksum;

	
	public DeployMode mode;
	
	/// <summary>
	/// The resulting manifest. After the plan is released, the server-side manifest will be this manifest. 
	/// </summary>
	public ManifestView manifest;
	public DeploymentDiffSummary diff;
	public List<string> servicesToUpload = new List<string>();
	public bool ranHealthChecks;
	
	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(builtFromRemoteChecksum), ref builtFromRemoteChecksum);
		s.SerializeEnum(nameof(mode), ref mode);
		s.Serialize(nameof(manifest), ref manifest);
		s.Serialize(nameof(diff), ref diff);
		s.Serialize(nameof(ranHealthChecks), ref ranHealthChecks);
		s.SerializeList(nameof(servicesToUpload), ref servicesToUpload);
	}
}


public enum DeploymentChangeType
{
	Added,
	Removed,
	Changed
}

public class DeploymentDiffSummary : JsonSerializable.ISerializable
{
	public DiffChangeSummary jsonChanges;
	public List<string> addedServices = new List<string>();
	public List<string> removedServices = new List<string>();
	
	public List<string> disabledServices = new List<string>();
	public List<string> enabledServices = new List<string>();
	
	public List<string> addedStorage = new List<string>();
	public List<string> removedStorage = new List<string>();
	
	public List<string> disabledStorages = new List<string>();
	public List<string> enabledStorages = new List<string>();

	public List<ServiceImageIdChange> serviceImageIdChanges = new List<ServiceImageIdChange>();
	
	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(jsonChanges), ref jsonChanges);
		s.SerializeList(nameof(addedServices), ref addedServices);
		s.SerializeList(nameof(removedServices), ref removedServices);
		s.SerializeList(nameof(disabledServices), ref disabledServices);
		s.SerializeList(nameof(enabledServices), ref enabledServices);
		s.SerializeList(nameof(addedStorage), ref addedStorage);
		s.SerializeList(nameof(removedStorage), ref removedStorage);
		s.SerializeList(nameof(disabledStorages), ref disabledStorages);
		s.SerializeList(nameof(enabledStorages), ref enabledStorages);
		s.SerializeList(nameof(serviceImageIdChanges), ref serviceImageIdChanges);
	}
}

public interface IServiceChangeDisplay
{
	string ToChangeString();
}

public struct ServiceImageIdChange : IServiceChangeDisplay, JsonSerializable.ISerializable
{
	public string service;
	public string oldImageId;
	public string nextImageId;

	public string ToChangeString()
	{
		return $"{service} [{oldImageId}]->[{nextImageId}]";
	}

	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(service), ref service);
		s.Serialize(nameof(oldImageId), ref oldImageId);
		s.Serialize(nameof(nextImageId), ref nextImageId);
	}
}

public partial class DeployUtil
{

	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[(\\d+)\\]", RegexOptions.None)]
	public static partial Regex GetServiceRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[(\\d+)\\]", RegexOptions.None)]
	public static partial Regex GetStorageRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.serviceName)}", RegexOptions.None)]
	public static partial Regex GetServiceNameRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.enabled)}", RegexOptions.None)]
	public static partial Regex GetServiceEnabledRegex();
	
		
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.archived)}", RegexOptions.None)]
	public static partial Regex GetServiceArchivedRegex();

	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[\\d+\\].{nameof(ServiceReference.archived)}", RegexOptions.None)]
	public static partial Regex GetStorageArchivedRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.imageId)}", RegexOptions.None)]
	public static partial Regex GetServiceImageIdRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[\\d+\\].{nameof(ServiceStorageReference.id)}", RegexOptions.None)]
	public static partial Regex GetStorageNameRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[\\d+\\].{nameof(ServiceStorageReference.enabled)}", RegexOptions.None)]
	public static partial Regex GetStorageEnabledRegex();
	
	public static DeploymentDiffSummary FindChanges(ManifestView old, ManifestView next)
	{
		var summary = new DeploymentDiffSummary();
		
		// get the exact json field diff
		summary.jsonChanges = DiffStream.FindChanges(old, next);

		// there are certain semantic changes that we should highlight
		foreach (var change in summary.jsonChanges.changes)
		{
			switch (change.type)
			{
				case DiffType.Changed:
					if (GetServiceNameRegex().IsMatch(change.jsonPath))
					{
						// summary.removedServices.Add(change.currentValue);
						summary.addedServices.Add(change.nextValue);
					} else if (GetStorageNameRegex().IsMatch(change.jsonPath))
					{
						// summary.removedStorage.Add(change.currentValue);
						summary.addedStorage.Add(change.nextValue);
					} 
					else if (GetServiceArchivedRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isArchived))
						{
							// extract the service name...
							var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.manifest[serviceIndex].serviceName;
							if (isArchived)
							{
								summary.removedServices.Add(name);
							}
							else
							{
								summary.addedServices.Add(name);
							}
						}
					}
					else if (GetStorageArchivedRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isArchived))
						{
							// extract the service name...
							var storageIndex = int.Parse(GetStorageRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.storageReference.Value[storageIndex].id;
							if (isArchived)
							{
								summary.removedStorage.Add(name);
							}
							else
							{
								summary.addedStorage.Add(name);
							}
						}
					}
					else if (GetServiceEnabledRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isEnabled))
						{
							// extract the service name...
							var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.manifest[serviceIndex].serviceName;
							if (isEnabled)
							{
								summary.enabledServices.Add(name);
							}
							else
							{
								summary.disabledServices.Add(name);
							}
						}
					} else if (GetStorageEnabledRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isEnabled))
						{
							// extract the storage name...
							var storageIndex = int.Parse(GetStorageRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.storageReference.Value[storageIndex].id;
							if (isEnabled)
							{
								summary.enabledStorages.Add(name);
							}
							else
							{
								summary.disabledStorages.Add(name);
							}
						}
					} else if (GetServiceImageIdRegex().IsMatch(change.jsonPath))
					{
						var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
						var name = next.manifest[serviceIndex].serviceName;
						summary.serviceImageIdChanges.Add(new ServiceImageIdChange
						{
							service = name,
							oldImageId = change.currentValue,
							nextImageId = change.nextValue
						});
					}
					

					break;
				case DiffType.Added:
					if (GetServiceNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedServices.Add(change.nextValue);
					} else if (GetStorageNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedStorage.Add(change.nextValue);
					}
					break;
				case DiffType.Removed:
					if (GetServiceNameRegex().IsMatch(change.jsonPath))
					{
						throw new CliException($"cannot remove a service reference=[{change.currentValue}] from the manifest");
						// summary.removedServices.Add(change.currentValue);
					} else if (GetStorageNameRegex().IsMatch(change.jsonPath))
					{
						throw new CliException($"cannot remove a storage reference=[{change.currentValue}] from the manifest");
						// summary.removedStorage.Add(change.currentValue);
					}
					break;
			}
		}
		

		return summary;
	}

	public static ManifestView MergeAdditive(ManifestView current, ManifestView next)
	{
		// clone the current...
		var final = current.Copy();
		var finalServices = new List<ServiceReference>(final.manifest ?? Array.Empty<ServiceReference>());
		var finalStorages =
			new List<ServiceStorageReference>(final.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()));

		{ // set the comment string; this may be changed later, but comments are not part of the diffing.
			final.comments = current.comments;
			
			// note: all the other random field stuff (as of Oct 1 2024) are computed by the server.
		}
		
		{ // each service in the next set should be added in and/or overwrite the existing service for the name
			foreach (var nextService in next.manifest)
			{
				var found = false;
				for (var i = 0; i < finalServices.Count; i++)
				{
					var currentService = finalServices[i];
					if (!string.Equals(nextService.serviceName, currentService.serviceName))
						continue;
					
					if (!nextService.enabled && string.IsNullOrEmpty(nextService.imageId))
					{
						// inherit the imageId from the existing service reference if we don't have one.
						//  This could happen if you are rolling back a service without the source code. 
						nextService.imageId = currentService.imageId;
					}

					// inherit the comments from the remote reference. Comments can be adjusted later, but
					//  they don't matter as part of the diff.
					nextService.comments = currentService.comments;
					
					// this serviceName already exists in the final set!
					// overwrite it!
					finalServices[i] = nextService;

				
					found = true;
					break;
				}

				if (!found)
				{
					// the serviceName was not found, so we can add it!
					finalServices.Add(nextService);
				}
			}
		}

		{ // update the storages
			foreach (var nextStorage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
			{
				var found = false;
				for (var i = 0; i < finalStorages.Count; i++)
				{
					var currentStorage = finalStorages[i];
					if (!string.Equals(currentStorage.id, nextStorage.id))
						continue;

					found = true;
					finalStorages[i] = nextStorage;
					break;
				}

				if (!found)
				{
					finalStorages.Add(nextStorage);
				}
			}
		}

		final.manifest = finalServices.ToArray();
		final.storageReference = new OptionalArrayOfServiceStorageReference(finalStorages.ToArray());
		
		return final;
	}

	public static ManifestView MergeReplacement(ManifestView current, ManifestView next)
	{
		// create an additive plan first, 
		// and then adjust the elements to handle "deletions" 
		var additive = MergeAdditive(current, next);
		var nextStorages = next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>());

		// everything that is in current that IS NOT in next, should be marked as archived, and disabled. 
		{
			foreach (var service in additive.manifest)
			{
				var existsInNext = next.manifest.Any(x => x.serviceName == service.serviceName);
				if (existsInNext) continue;

				service.archived = true;
				service.enabled = false;
			}
		}

		// disable and archive all storages that are not in the next manifest
		{
			foreach (var storage in additive.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
			{
				var existsInNext = nextStorages.Any(x => x.id == storage.id);
				if (existsInNext) continue;

				storage.archived = true;
				storage.enabled = false;
			}
		}
		
		return additive;
	}

	public static bool TryValidate(ManifestView current, out List<string> errors)
	{
		errors = new List<string>();
		
		// validate services
		foreach (var service in current.manifest)
		{
			// every service must have a valid imageId
			if (string.IsNullOrEmpty(service.imageId))
			{
				errors.Add($"service=[{service.serviceName}] cannot have a blank imageId. ");
			}

			if (service.archived && service.enabled)
			{
				errors.Add($"service=[{service.serviceName}] cannot be archived and enabled. ");
			}
		}
		
		
		// validate storages
		foreach (var storage in current.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
		{
			if (storage.archived && storage.enabled)
			{
				errors.Add($"storage=[{storage.id}] cannot be archived and enabled. ");
			}
		}

		return errors.Count == 0;
	}

	public static ManifestView EnsureEntriesHaveChecksums(ManifestView current)
	{
		var next = current.Copy();
		// compute the checksums for all services and storages
		foreach (var service in next.manifest)
		{
			service.ResetChecksum();
		}

		foreach (var storage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
		{
			storage.ResetChecksum();
		}

		return next;
	}
	
	public static ManifestView EnsureArchivedServicesAreDisabled(ManifestView current)
	{
		var next = current.Copy();
		// if a service or storage is archived, then it cannot be enabled. 
		foreach (var service in next.manifest)
		{
			if (service.archived)
			{
				service.enabled = false;
			}
		}

		foreach (var storage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
		{
			if (storage.archived)
			{
				storage.enabled = false;
			}
		}

		return next;
	}
	
	public static ManifestView EnsureOnlyActiveStoragesAreEnabled(ManifestView current)
	{
		var next = current.Copy();
		// there is a rule on the backend that a storage can only be enabled 
		//  IF there is an enabled service that is referencing that storage. 
		//  The rule exists to prevent folks from having unreachable storages. 
		//  NOTE: technically it is possible to get a secure connection string 
		//        to a remote storage, but it isn't currently a well designed UX.
		
		var referencedStorageIds = new HashSet<string>();
		
		// scan through all services and keep track of the referenced storage names
		{
			foreach (var service in next.manifest)
			{
				if (!service.enabled)
					// only accumulate referenced storage ids from services that are actually enabled. 
					//  otherwise, the storage is still "unreachable", because the service isn't running.
					continue;
				
				var deps = service.dependencies.GetOrElse(Array.Empty<ServiceDependencyReference>());
				foreach (var dep in deps)
				{
					referencedStorageIds.Add(dep.id);
				}
			}
		}

		// scan through storages, and identify those that weren't referenced
		{
			foreach (var storage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
			{
				if (referencedStorageIds.Contains(storage.id))
					// this storage was referenced by an enabled service
					continue;

				storage.enabled = false;
			}
		}

		return next;
	}

	public static string GetPlanTempFolder(IDependencyProvider provider)
	{
		// save the plan to a temp file
		var config = provider.GetService<ConfigService>();
		var logDir = Path.Combine(config.ConfigDirectoryPath, "temp", "plans");
		return logDir;
	}

	public static string GetLatestPlanFilePath(IDependencyProvider provider)
	{
		var logDir = GetPlanTempFolder(provider);
		if (!Directory.Exists(logDir)) return null;
		var info = new DirectoryInfo(logDir);
		var file = info.GetFiles().MaxBy(p => p.CreationTime);
		return file?.FullName;
	}
	
	public static async Task<string> SavePlanToTempFolder(IDependencyProvider provider, DeploymentPlan plan)
	{
		var logDir = GetPlanTempFolder(provider);
		Directory.CreateDirectory(logDir);

		{ // delete files so that only the most recent 10 exist. 
			var info = new DirectoryInfo(logDir);
			var files = info.GetFiles().OrderByDescending(p => p.CreationTime).ToList();
			for (var i = 10; i < files.Count; i++)
			{
				Log.Verbose($"Deleting old plan file=[{files[i].Name}]");
				files[i].Delete();
			}
		}
			
		var planJson = JsonSerializable.ToJson(plan);
		var planPath = Path.Combine(logDir,$"plan-{DateTimeOffset.Now.ToUnixTimeMilliseconds()}.plan.json");
		Log.Verbose($"Saving plan: {planPath}");
		await File.WriteAllTextAsync(planPath, planJson);

		return planPath;
	}
	
	public static void PrintPlanNextSteps(string planFile, bool hasChanges)
	{
		var isSavingPlan = !string.IsNullOrEmpty(planFile);
		switch (isSavingPlan, hasChanges)
		{
			case (isSavingPlan: true, hasChanges: true):
				Log.Information($"To release, use `dotnet beam deploy release --plan {planFile}`");
				break;
			case (isSavingPlan: false, hasChanges: true):
				Log.Information(@"To release, either
 - re-run this command with the --to-file option, and then run `dotnet beam deploy release --plan <your-file>`, 
 - or run the `dotnet beam deploy release` command to create a plan and release it sequentially. ");
				break;
			case (isSavingPlan: _, hasChanges: false):
				Log.Information("Even though there are no changes, the `dotnet beam deploy release` command can still be used to roll the services. ");
				break;
		}
	}
	
	public static void PrintPlanInfo(DeploymentPlan plan, IHasDeployPlanArgs args, out bool hasChanges)
	{
		var detectedChangeCount = PrintChangesAndNoticeChange(plan.diff.disabledServices, "Disabling", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.removedServices, "Removing", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.addedServices, "Adding", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.enabledServices, "Enabling", "service");
		detectedChangeCount += PrintChangesAndNoticeChangeT(plan.diff.serviceImageIdChanges, "Updating", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.disabledStorages, "Disabling", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.removedStorage, "Removing", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.addedStorage, "Adding", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.enabledStorages, "Enabling", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.servicesToUpload, "Uploading", "service");

		hasChanges = plan.diff.jsonChanges.changes.Count > 0;
		var hasDetectedChanges = detectedChangeCount > 0;
		if (hasChanges)
		{
			if (!plan.ranHealthChecks && plan.servicesToUpload.Count > 0)
			{
				Log.Information("Local Health-checks were not run! Services may work as expected, but they have not been explicitly tested locally. Consider re-running a plan command with the `--health` option. ");
			}
		}
		switch (hasChanges, hasDetectedChanges)
		{
			case (true, true):
				if (detectedChangeCount == 1)
				{
					Log.Information($"This plan has 1 pending change! ");
				}
				else
				{
					Log.Information($"This plan has {detectedChangeCount} pending changes! ");
				}

				if (args.UseLatestDeployedManifest)
				{
					Log.Information("Somehow a change has been detected while trying to restart the services. Please try again, or contact Beamable. ");
				}
				break;
			case (true, false):
				Log.Information("This plan has uncommon changes! Please inspect the plan file for more details. ");
				break;
			case (false, false):
				if (args.UseLatestDeployedManifest)
				{
					Log.Information("There are no changes, because you are restarting the services.");
				}
				else
				{
					Log.Information("There are no changes.");
				}
				break;
			case (false, true):
				throw new CliException("The plan has an invalid detection. Please report this to Beamable");
		}


		int PrintChangesAndNoticeChangeT<T>(List<T> changes, string verb, string noun) where T : IServiceChangeDisplay
		{
			return PrintChangesAndNoticeChange(changes.Select(x => x.ToChangeString()).ToList(), verb, noun);
		}
		
		int PrintChangesAndNoticeChange(List<string> changes, string verb, string noun)
		{
		
			if (changes.Count == 0) return 0;
			var sb = new StringBuilder();
			sb.Append(verb);
			sb.Append(" ");
			sb.Append(changes.Count);
			sb.Append(" ");
			sb.AppendLine(changes.Count == 1 ? noun : $"{noun}s");
			for (var i = 0; i < changes.Count; i++)
			{
				sb.AppendLine($" - {changes[i].ToString()}");
			}
		
			Log.Warning(sb.ToString());
			return changes.Count;
		}
	}

	public static bool IsJsonAPlan(IDictionary<string, object> data)
	{
		return data != null
		        && data.ContainsKey(nameof(DeploymentPlan.builtFromRemoteChecksum))
		        && data.ContainsKey(nameof(DeploymentPlan.servicesToUpload))
		        && data.ContainsKey(nameof(DeploymentPlan.manifest))
		        && data.ContainsKey(nameof(DeploymentPlan.diff))
		        && data.ContainsKey(nameof(DeploymentPlan.mode))
		        && data.ContainsKey(nameof(DeploymentPlan.ranHealthChecks))
			;
	}
	public static bool IsJsonAManifest(IDictionary<string, object> data)
	{
		return data != null
		        && data.ContainsKey(nameof(ManifestView.checksum))
		        && data.ContainsKey(nameof(ManifestView.manifest))
		        && data.ContainsKey(nameof(ManifestView.id))
			// there are more fields we could check, btu this is "good enough"
			;
	}
	
	public static async Task<(DeploymentPlan, List<BuildImageOutput>)> Plan(
		IDependencyProvider provider, 
		IHasDeployPlanArgs args,
		ProgressHandler progressHandler)
	{
		const string FetchManifestProgressName = "fetching latest";
		const string MergingManifestProgressName = "calculating plan";

		
		var api = provider.GetService<IBeamoApi>();
		var beamo = provider.GetService<BeamoLocalSystem>();

		var isLoadingManifestFile = !string.IsNullOrEmpty(args.FromManifestFile);
		var isLoadingManifestId = !string.IsNullOrEmpty(args.ManifestId);
		var isLoadingMostRecent = args.UseLatestDeployedManifest;

		{
			// validate that we are only loading a manifest from one location.
			var sources = new bool[] { isLoadingManifestFile, isLoadingManifestId, isLoadingMostRecent };
			var sourceNames = new string[] { "--from-manifest", "--from-manifest-id", "--restart" };
			var requestedSources = sources.Count(x => x);

			if (requestedSources > 1)
			{
				var sb = new StringBuilder();
				sb.AppendLine("Cannot load a manifest from more than one location. Please only specify one of the following,");
				for (var i = 0; i < sources.Length && i < sourceNames.Length; i++)
				{
					if (sources[i])
					{
						sb.AppendLine("  " + sourceNames[i]);
					}
				}

				throw new CliException(sb.ToString());
			}
		}
		
		ManifestView localManifest = null;
		ManifestView remote = null;
		List<BuildImageOutput> localBuildReports = null;
		Task<(ManifestView, List<BuildImageOutput>)> localTask = null;
		
		progressHandler?.Invoke(FetchManifestProgressName, 0);
		var remoteTask = CreateReleaseManifestFromRealm(api);

		if (isLoadingManifestFile)
		{
			localTask = CreateReleaseManifestFromFile(provider, args.FromManifestFile, progressHandler);
		} else if (isLoadingManifestId)
		{
			localTask = CreateReleaseManifestFromId(provider, args.ManifestId, progressHandler);
		} else if (isLoadingMostRecent)
		{
			localTask = CreateReleaseManifestFromId(remoteTask);
		}
		else
		{
			localTask = CreateReleaseManifestFromLocal(provider, beamo.BeamoManifest, progressHandler);
		}
		progressHandler?.Invoke(MergingManifestProgressName, 0);
		
		remote = await remoteTask;
		progressHandler?.Invoke(FetchManifestProgressName, 1);
		
		(localManifest, localBuildReports) = await localTask;

		{ // if there are ANY failures in the build, then the entire plan is a failure.
			if (localBuildReports.Any(r => !r.success))
			{
				return (null, localBuildReports);
			}
		}
		
		ManifestView next = null;
		DeploymentDiffSummary diff = null;
		
		switch (args.DeployMode)
		{
			case DeployMode.Additive:
				next = MergeAdditive(remote, localManifest);
				break;
			case DeployMode.Replace:
				next = MergeReplacement(remote, localManifest);
				break;
			default:
				throw new NotImplementedException(
					$"The only two supported deploy modes are {nameof(DeployMode.Additive)} and {nameof(DeployMode.Replace)}");
		}
		
		// process transforms
		{
			var transforms = new List<Func<ManifestView, ManifestView>>
			{
				EnsureArchivedServicesAreDisabled, 
				EnsureOnlyActiveStoragesAreEnabled, 
				EnsureEntriesHaveChecksums
			};
			for (var i = 0; i < transforms.Count; i++)
			{
				var r = .5f * ((i + 1f) / transforms.Count);
				next = transforms[i](next);
				progressHandler?.Invoke(MergingManifestProgressName, r);
			}
		}

		progressHandler?.Invoke(MergingManifestProgressName, .5f);
		diff = FindChanges(remote, next);

		if (!TryValidate(next, out var validationErrors))
		{
			throw new CliException($"The plan is invalid.\n{string.Join("\n -", validationErrors)}");
		}

		var servicesToUpload = new List<string>();
		{ 
			// calculate the set of services that actually need to build. 
			//  it is the intersection of services that have differing imageIds in remote/local, 
			//  AND those services that we just built locally. 
			//  If a service was not built locally, then we must assume the image already exists remotely. 
			var locallyBuiltServices = localBuildReports.Select(x => x.service).ToArray();
			foreach (var locallyBuiltService in locallyBuiltServices)
			{
				// find the service in the local and remote
				var localService = next.manifest.FirstOrDefault(x => x.serviceName == locallyBuiltService);
				var remoteService = remote.manifest.FirstOrDefault(x => x.serviceName == locallyBuiltService);
				if (localService == null)
					throw new CliException("local service cannot be null. This is a beamable bug, please report");
				if (remoteService == null || localService.imageId != remoteService.imageId)
				{
					servicesToUpload.Add(locallyBuiltService);
				}
			}
		}


		if (args.RunHealthChecks)
		{
			// start up all containers 
			foreach (var service in servicesToUpload)
			{
				var localService = next.manifest.FirstOrDefault(x => x.serviceName == service);
				if (localService == null)
					throw new CliException("local service cannot be null. This is a beamable bug, please report");

				
				progressHandler?.Invoke("verifying " + service, 0);
				if (!beamo.BeamoManifest.TryGetDefinition(service, out var definition))
					throw new CliException("local definition cannot be null. This is a beamable bug, please report");

				if (!beamo.BeamoManifest.HttpMicroserviceLocalProtocols.TryGetValue(service, out var http))
					throw new CliException("local http service cannot be null. This is a beamable bug, please report");

				var container = BeamoLocalSystem.GetBeamIdAsMicroserviceContainer(definition.BeamoId);
				try
				{
					await beamo.StopContainer(container);
				}
				catch
				{
					// do nothing.
				}

				var routingKey = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine() + "_healthCheck";
				await beamo.RunLocalHttpMicroservice(definition, http, beamo, true, 
					CancellationToken.None, 
					disableInitHooks: true,
					imageIdOverride: localService.imageId,
					routingKey: routingKey);
				progressHandler?.Invoke("verifying " + service, .5f);
				
				var routingHeader = $"{Beamable.Common.Constants.Requester.HEADER_ROUTINGKEY}=micro_{service}:{routingKey}";
				await RetryRequest(provider, container, service, routingHeader);
				
				progressHandler?.Invoke("verifying " + service, .9f);
				try
				{
					// stop the container to clean up.
					await beamo.StopContainer(container);
				}
				catch
				{
					// do nothing.
				}
				
				progressHandler?.Invoke("verifying " + service, 1);

				
			}
		}
		
		progressHandler?.Invoke(MergingManifestProgressName, 1);
		
		return (new DeploymentPlan
		{
			ranHealthChecks = args.RunHealthChecks,
			builtFromRemoteChecksum = remote.checksum,
			mode = args.DeployMode,
			diff = diff, 
			manifest = next,
			servicesToUpload = servicesToUpload
		}, localBuildReports);
	}

	
	private static async Promise<string> RetryRequest(IDependencyProvider provider, string containerName, string serviceName, string routingHeader)
	{
		var app = provider.GetService<IAppContext>();
		var url = $"/basic/{app.Cid}.{app.Pid}.micro_{serviceName}/admin/Metadata";
		var requester = provider.GetService<CliRequester>();
	
		var isRunning = false;
		string request = null;
	
		do
		{
			isRunning = false;
			try
			{
				request = await requester.CustomRequest(Method.GET, url, null, true, (s => s),
					customHeaders: new[] { routingHeader });
				Log.Verbose($"got response from health check for {containerName}");
			}
			catch (Exception e)
			{
				Log.Verbose($"Exception happened while trying to reach service Metadata endpoint. Message = [{e.Message}] Stacktrace = [{e.StackTrace}]");
				await Task.Delay(500); // Waiting a bit before retrying
				try
				{
					ContainerInspectResponse response = await provider.GetService<BeamoLocalSystem>().Client.Containers
						.InspectContainerAsync(containerName);
					isRunning = response.State.Running;
				}
				catch
				{
					isRunning = false;
				}
			}
	
		} while (isRunning);
	
		if (string.IsNullOrEmpty(request))
		{
			throw new CliException($"The service [{serviceName}] failed to register itself with Beamable.");
		}
	
		return request;
	}
	
	public static async Task Deploy(DeploymentPlan plan, IDependencyProvider provider, ProgressHandler progressHandler, Task<ManifestView> remoteManifestTask=null)
	{
		var api = provider.GetService<IBeamoApi>();
		var beamoService = provider.GetService<BeamoService>();

		var gamePidPromise = provider.GetService<IRealmsApi>().GetRealm();
		var dockerRegistryUrlPromise = beamoService.GetDockerImageRegistryUri();
		
		var remote = await (remoteManifestTask ?? CreateReleaseManifestFromRealm(api));
		var gamePid = (await gamePidPromise).FindRoot().Pid; // TODO I really think we should move this to _ctx/ConfigService and grab it during init...
		var dockerRegistryUrl = await dockerRegistryUrlPromise;

		if (remote.checksum != plan.builtFromRemoteChecksum)
		{
			throw new CliException(
				"The given deployment plan was created with a different configuration of remote services than exists now. Please create a new plan and try again.");
		}
		
		// identity the services we need to upload.
		var uploadTasks = new List<Task>();
		var servicesToUpload = new HashSet<string>(plan.servicesToUpload);
		foreach (var service in plan.manifest.manifest)
		{
			var needsUpload = servicesToUpload.Contains(service.serviceName);
			if (!needsUpload)
				continue;

			var progressTaskName = $"upload {service.serviceName}";
			var uploadTask = ServiceUploadUtil.Upload(
				provider: provider,
				beamoId: service.serviceName,
				imageId: service.imageId, 
				gamePid: gamePid,
				dockerRegistryUrl: dockerRegistryUrl, 
				ct: CancellationToken.None, 
				onProgressCallback: progressRatio =>
				{
					progressHandler?.Invoke(progressTaskName, progressRatio);
				});

			uploadTasks.Add(uploadTask);
		}

		progressHandler?.Invoke("publish", 0);
		await Task.WhenAll(uploadTasks);
		
		// publish manifest. 
		var manifest = new PostManifestRequest
		{
			manifest = plan.manifest.manifest,
			storageReferences = plan.manifest.storageReference,
			autoDeploy = true,
			comments = plan.manifest.comments
		};
		progressHandler?.Invoke("publish", .1f, false);

		await api.PostManifest(manifest);
		progressHandler?.Invoke("publish", 1, false);

	}

	public static async Task<ManifestView> CreateReleaseManifestFromRealm(IBeamoApi beamo)
	{
		try
		{
			var current = await beamo.GetManifestCurrent();
			return current.manifest;
		}
		catch (RequesterException requesterException) when (requesterException.Status == 404)
		{
			// there is no existing manifest.
			return new ManifestView
			{
				manifest = Array.Empty<ServiceReference>(),
				storageReference = new OptionalArrayOfServiceStorageReference(Array.Empty<ServiceStorageReference>())
			};
		}
	}

	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromId(IDependencyProvider provider, string manifestId, ProgressHandler progressHandler)
	{
		var api = provider.GetService<IBeamoApi>();
		progressHandler?.Invoke("fetching manifest", 0);
		var manifest = await api.GetManifest(manifestId);
		progressHandler?.Invoke("fetching manifest", 1);
		return (manifest.manifest, new List<BuildImageOutput>());
	}
	
	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromId(Task<ManifestView> remoteTask)
	{
		var manifest = await remoteTask;
		return (manifest, new List<BuildImageOutput>());
	}

	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromFile(IDependencyProvider provider, string manifestFile, ProgressHandler progressHandler)
	{
		const string ReadingLocalManifestProgressName = "reading manifest file";

		progressHandler?.Invoke(ReadingLocalManifestProgressName, 0);
		var manifestJson = await File.ReadAllTextAsync(manifestFile);
		var data = Json.Deserialize(manifestJson) as IDictionary<string, object>;
		if (!IsJsonAManifest(data))
		{
			if (IsJsonAPlan(data))
			{
				throw new CliException(
					$"The file=[{manifestFile}] appears to contain a plan file, but should contain a manifest. " +
					$"To use the plan, use the `--from-plan` option.");
			}

			throw new CliException($"The file=[{manifestFile}] does not contain a valid plan file");
		}
			
			
		progressHandler?.Invoke(ReadingLocalManifestProgressName, 1);

		
		var localManifest = JsonSerializable.FromJson<ManifestView>(manifestJson);
		return (localManifest, new List<BuildImageOutput>());
	}
	
	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromLocal(IDependencyProvider provider, BeamoLocalManifest localManifest, ProgressHandler progressHandler)
	{
		var services = new ServiceReference[localManifest.HttpMicroserviceLocalProtocols.Count];
		var storages = new ServiceStorageReference[localManifest.EmbeddedMongoDbLocalProtocols.Count];

		var serviceIndex = 0;
		var storageIndex = 0;
		var pendingTasks = new List<Task>();
		var buildReports = new List<BuildImageOutput>();
		for (var i = 0; i < localManifest.ServiceDefinitions.Count; i++)
		{
			var definition = localManifest.ServiceDefinitions[i];
			
			if (!definition.IsLocal)
				// this function is explicitly about creating services from local source code.
				continue;
			
			switch (definition.Protocol)
			{
				case BeamoProtocolType.HttpMicroservice:

					var index = serviceIndex++;
					var task = CreateServiceReference(
						provider, 
						definition, 
						localManifest.HttpMicroserviceLocalProtocols[definition.BeamoId],
						progressHandler
					).ContinueWith(continueTask =>
					{
						if (continueTask.IsCompletedSuccessfully)
						{
							services[index] = continueTask.Result.Item1;
							buildReports.Add(continueTask.Result.Item2);
						}
						else
						{
							throw new CliException("Failed to build " + definition.BeamoId);
						}
					});
					pendingTasks.Add(task);
					break;
				case BeamoProtocolType.EmbeddedMongoDb:
					storages[storageIndex++] = CreateStorageReference(
						definition,
						localManifest.EmbeddedMongoDbLocalProtocols[definition.BeamoId]
					);
					break;
			}
		}

		await Task.WhenAll(pendingTasks);
		
		return (new ManifestView
		{
			manifest = services,
			storageReference = new OptionalArrayOfServiceStorageReference(storages)
		}, buildReports);
	}

	static ServiceStorageReference CreateStorageReference(
		BeamoServiceDefinition definition,
		EmbeddedMongoDbLocalProtocol mongo)
	{
		
		var reference = new ServiceStorageReference
		{
			storageType = "mongov1",
			archived = false,
			enabled = definition.ShouldBeEnabledOnRemote,
			templateId = "small",
			id = definition.BeamoId,
		};
		
		return reference;
	}

	


	static async Task<(ServiceReference, BuildImageOutput)> CreateServiceReference(
		IDependencyProvider provider,
		BeamoServiceDefinition definition,
		HttpMicroserviceLocalProtocol http,
		ProgressHandler progressHandler)
	{

		string imageId = null;
		BuildImageOutput report = default;
		if (definition.ShouldBeEnabledOnRemote)
		{
			var progressName = "build " + definition.BeamoId;
			try
			{
				progressHandler?.Invoke(progressName, 0);
				var sb = new StringBuilder();
				report = await ServicesBuildCommand.Build(provider, definition.BeamoId,
					forceCpu: true,
					logMessage: log =>
					{
						sb.AppendLine(log.message);
						if (log.isFailure)
						{
							Log.Error($"Failed to build service=[{definition.BeamoId}]\n{sb.ToString()}");
						}
					}, progressMessage: progress =>
					{
						progressHandler?.Invoke(progressName, progress.Ratio);
					});
				progressHandler?.Invoke(progressName, 1);
				imageId = report.ShortImageId;
			}
			catch (Exception ex)
			{
				progressHandler?.Invoke(progressName, -1);
				Log.Error($"Could not build service=[{definition.BeamoId}] message=[{ex.Message}] stack=[{ex.StackTrace}]");
				imageId = null;
			}
		}  else
		{
			progressHandler?.Invoke("skip  " + definition.BeamoId, 1);
		}

		var reference = new ServiceReference
		{
			serviceName = definition.BeamoId,
			enabled = definition.ShouldBeEnabledOnRemote,
			templateId = "small",
			archived = false,
			imageId = imageId,
			// TODO: Pedro is working on the ability to get access to federatedComponents via the local manifest
			components = new OptionalArrayOfServiceComponent(),
			dependencies = new OptionalArrayOfServiceDependencyReference(http.StorageDependencyBeamIds.Select(x => new ServiceDependencyReference
			{
				storageType = "mongov1",
				id = x
			}).ToArray())
		};
		
		return (reference, report);
	}
}
