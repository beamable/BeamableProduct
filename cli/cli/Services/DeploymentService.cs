// using Beamable.Api.Autogenerated.Beamo;
// using Beamable.Common.Dependencies;

using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Realms;
using Beamable.Common.Dependencies;
using Beamable.Experimental.Api.Lobbies;
using Beamable.Serialization;
using Beamable.Serialization.SmallerJSON;
using Beamable.Server;
using cli.DeploymentCommands;
using cli.Services;
using Docker.DotNet.Models;
using Serilog;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using BeamoLocalManifest = cli.Services.BeamoLocalManifest;
using PostManifestRequest = Beamable.Api.Autogenerated.Models.PostManifestRequest;
using ServiceReference = Beamable.Api.Autogenerated.Models.ServiceReference;
using ServiceStorageReference = Beamable.Api.Autogenerated.Models.ServiceStorageReference;

namespace cli.Deployment.Services;

public enum DeployMode
{
	/// <summary>
	/// A deployment mode that only adds services found locally at the time of the deployment.
	/// Any existing services that are not part of the local environment will remain unchanged. 
	/// </summary>
	Additive, 
	
	/// <summary>
	/// A deployment mode that will remove everything unless it is found locally during the time
	/// of deployment. 
	/// </summary>
	Replace
}

public class DeployablePlan : JsonSerializable.ISerializable
{
	
	/// <summary>
	/// This checksum represents the checksum of the remote manifest at the time the plan was made.
	/// If the plan is going to be <i>used</i>, the checksum should be checked. When the checksum
	/// does not match the latest remote checksum, this plan should be considered out of date.  
	/// </summary>
	public string builtFromRemoteChecksum;

	
	public DeployMode mode;
	
	/// <summary>
	/// The resulting manifest. After the plan is released, the server-side manifest will be this manifest. 
	/// </summary>
	public ManifestView manifest;
	public DeploymentDiffSummary diff;
	public List<string> servicesToUpload = new List<string>();
	public bool ranHealthChecks;
	public int changeCount;
	
	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(builtFromRemoteChecksum), ref builtFromRemoteChecksum);
		s.SerializeEnum(nameof(mode), ref mode);
		s.Serialize(nameof(manifest), ref manifest);
		s.Serialize(nameof(diff), ref diff);
		s.Serialize(nameof(changeCount), ref changeCount);
		s.Serialize(nameof(ranHealthChecks), ref ranHealthChecks);
		s.SerializeList(nameof(servicesToUpload), ref servicesToUpload);
	}
}


public enum DeploymentChangeType
{
	Added,
	Removed,
	Changed
}

public class DeploymentManifestJsonDiff : JsonSerializable.ISerializable
{
	public string jsonPath;
	public string type;
	public string currentValue;
	public string nextValue;
	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(jsonPath), ref jsonPath);
		s.Serialize(nameof(type), ref type);
		s.Serialize(nameof(currentValue), ref currentValue);
		s.Serialize(nameof(nextValue), ref nextValue);
	}

	public bool TryGetNextBooleanValue(out bool isTruthy)
	{
		return bool.TryParse(nextValue, out isTruthy);
	}
}

public class DeploymentDiffSummary : JsonSerializable.ISerializable
{
	public List<DeploymentManifestJsonDiff> jsonChanges = new List<DeploymentManifestJsonDiff>();
	public List<string> addedServices = new List<string>();
	public List<string> removedServices = new List<string>();
	
	public List<string> disabledServices = new List<string>();
	public List<string> enabledServices = new List<string>();
	
	public List<string> addedStorage = new List<string>();
	public List<string> removedStorage = new List<string>();
	
	public List<string> disabledStorages = new List<string>();
	public List<string> enabledStorages = new List<string>();

	public List<ServiceFederationChange> addedFederations = new List<ServiceFederationChange>();
	public List<ServiceFederationChange> removedFederations = new List<ServiceFederationChange>();
	public List<ServiceImageIdChange> serviceImageIdChanges = new List<ServiceImageIdChange>();
	
	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.SerializeList(nameof(jsonChanges), ref jsonChanges);
		s.SerializeList(nameof(addedServices), ref addedServices);
		s.SerializeList(nameof(removedServices), ref removedServices);
		s.SerializeList(nameof(disabledServices), ref disabledServices);
		s.SerializeList(nameof(enabledServices), ref enabledServices);
		s.SerializeList(nameof(addedStorage), ref addedStorage);
		s.SerializeList(nameof(removedStorage), ref removedStorage);
		s.SerializeList(nameof(disabledStorages), ref disabledStorages);
		s.SerializeList(nameof(enabledStorages), ref enabledStorages);
		s.SerializeList(nameof(serviceImageIdChanges), ref serviceImageIdChanges);
		s.SerializeList(nameof(addedFederations), ref addedFederations);
		s.SerializeList(nameof(removedFederations), ref removedFederations);
	}
}

public interface IServiceChangeDisplay
{
	string ToChangeString();
}

public struct ServiceFederationChange : IServiceChangeDisplay, JsonSerializable.ISerializable
{
	public string service;
	public string federationId;
	public string federationInterface;
	
	public string ToChangeString()
	{
		return $"{service} [{federationInterface}/{federationId}]";
	}

	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(service), ref service);
		s.Serialize(nameof(federationId), ref federationId);
		s.Serialize(nameof(federationInterface), ref federationInterface);
	}
}

public struct ServiceImageIdChange : IServiceChangeDisplay, JsonSerializable.ISerializable
{
	public string service;
	public string oldImageId;
	public string nextImageId;

	public string ToChangeString()
	{
		return $"{service} [{oldImageId}]->[{nextImageId}]";
	}

	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(service), ref service);
		s.Serialize(nameof(oldImageId), ref oldImageId);
		s.Serialize(nameof(nextImageId), ref nextImageId);
	}
}

public partial class DeployUtil
{
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[(\\d+)\\].{nameof(ServiceReference.components)}\\[(\\d+)\\].{nameof(ServiceComponent.name)}", RegexOptions.None)]
	public static partial Regex GetFederationRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[(\\d+)\\]", RegexOptions.None)]
	public static partial Regex GetServiceRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[(\\d+)\\]", RegexOptions.None)]
	public static partial Regex GetStorageRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.serviceName)}", RegexOptions.None)]
	public static partial Regex GetServiceNameRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.enabled)}", RegexOptions.None)]
	public static partial Regex GetServiceEnabledRegex();
	
		
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.archived)}", RegexOptions.None)]
	public static partial Regex GetServiceArchivedRegex();

	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[\\d+\\].{nameof(ServiceReference.archived)}", RegexOptions.None)]
	public static partial Regex GetStorageArchivedRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.imageId)}", RegexOptions.None)]
	public static partial Regex GetServiceImageIdRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[\\d+\\].{nameof(ServiceStorageReference.id)}", RegexOptions.None)]
	public static partial Regex GetStorageNameRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[\\d+\\].{nameof(ServiceStorageReference.enabled)}", RegexOptions.None)]
	public static partial Regex GetStorageEnabledRegex();
	
	public static DeploymentDiffSummary FindChanges(ManifestView old, ManifestView next)
	{
		var summary = new DeploymentDiffSummary();
		
		// get the exact json field diff
		summary.jsonChanges = DiffStream.FindChanges(old, next).changes.Select(x =>
		{
			return new DeploymentManifestJsonDiff
			{
				jsonPath = x.jsonPath,
				nextValue = x.nextValue,
				currentValue = x.currentValue,
				type = x.type switch
				{
					DiffType.Removed => "removed",
					DiffType.Added => "added",
					DiffType.Changed => "changed",
					_ => throw new CliException("unknown json diff type")
				}
			};
		}).ToList();

		// there are certain semantic changes that we should highlight
		foreach (var change in summary.jsonChanges)
		{
			var diffType = change.type switch
			{
				"added" => DiffType.Added,
				"removed" => DiffType.Removed,
				"changed" => DiffType.Changed,
				_ => throw new CliException("unknown change type")
			};
			if (GetFederationRegex().IsMatch(change.jsonPath))
			{
				var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
				var name = next.manifest[serviceIndex].serviceName;

				if (!string.IsNullOrEmpty(change.nextValue) && change.nextValue.Length > 0)
				{
					var nextParts = change.nextValue?.Split("/", StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
					var add = new ServiceFederationChange
					{
						service = name,
						federationId = nextParts[1],
						federationInterface = nextParts[0]
					};
					summary.addedFederations.Add(add);
				}
				
				if (!string.IsNullOrEmpty(change.currentValue) && change.currentValue.Length > 0)
				{
					var nextParts = change.currentValue?.Split("/", StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
					var remove = new ServiceFederationChange
					{
						service = name,
						federationId = nextParts[1],
						federationInterface = nextParts[0]
					};
					summary.removedFederations.Add(remove);
				}
				
			}
			switch (diffType)
			{
				case DiffType.Changed:
					if (GetServiceNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedServices.Add(change.nextValue);
					} else if (GetStorageNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedStorage.Add(change.nextValue);
					} 
					else if (GetServiceArchivedRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isArchived))
						{
							// extract the service name...
							var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.manifest[serviceIndex].serviceName;
							if (isArchived)
							{
								summary.removedServices.Add(name);
							}
							else
							{
								summary.addedServices.Add(name);
							}
						}
					}
					else if (GetStorageArchivedRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isArchived))
						{
							// extract the service name...
							var storageIndex = int.Parse(GetStorageRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.storageReference.Value[storageIndex].id;
							if (isArchived)
							{
								summary.removedStorage.Add(name);
							}
							else
							{
								summary.addedStorage.Add(name);
							}
						}
					}
					else if (GetServiceEnabledRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isEnabled))
						{
							// extract the service name...
							var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.manifest[serviceIndex].serviceName;
							if (isEnabled)
							{
								summary.enabledServices.Add(name);
							}
							else
							{
								summary.disabledServices.Add(name);
							}
						}
					} else if (GetStorageEnabledRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isEnabled))
						{
							// extract the storage name...
							var storageIndex = int.Parse(GetStorageRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.storageReference.Value[storageIndex].id;
							if (isEnabled)
							{
								summary.enabledStorages.Add(name);
							}
							else
							{
								summary.disabledStorages.Add(name);
							}
						}
					} else if (GetServiceImageIdRegex().IsMatch(change.jsonPath))
					{
						var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
						var name = next.manifest[serviceIndex].serviceName;
						summary.serviceImageIdChanges.Add(new ServiceImageIdChange
						{
							service = name,
							oldImageId = change.currentValue,
							nextImageId = change.nextValue
						});
					}
					

					break;
				case DiffType.Added:
					if (GetServiceNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedServices.Add(change.nextValue);
					} else if (GetStorageNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedStorage.Add(change.nextValue);
					}
					break;
				case DiffType.Removed:
					if (GetServiceNameRegex().IsMatch(change.jsonPath))
					{
						summary.removedServices.Add(change.currentValue);
					} else if (GetStorageNameRegex().IsMatch(change.jsonPath))
					{
						summary.removedStorage.Add(change.currentValue);
					}
					break;
			}
		}
		

		return summary;
	}

	public static ManifestView MergeAdditive(ManifestView remote, ManifestView next)
	{
		// clone the current...
		var final = remote.Copy();
		var finalServices = new List<ServiceReference>(final.manifest ?? Array.Empty<ServiceReference>());
		var finalStorages =
			new List<ServiceStorageReference>(final.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()));

		{ // set the comment string; this may be changed later, but comments are not part of the diffing.
			final.comments = remote.comments;
			
			// note: all the other random field stuff (as of Oct 1 2024) are computed by the server.
		}
		
		{ // each service in the next set should be added in and/or overwrite the existing service for the name
			foreach (var nextService in next.manifest)
			{
				var found = false;
				for (var i = 0; i < finalServices.Count; i++)
				{
					var currentService = finalServices[i];
					if (!string.Equals(nextService.serviceName, currentService.serviceName))
						continue;
					
					if (!nextService.enabled && string.IsNullOrEmpty(nextService.imageId))
					{
						// inherit the imageId from the existing service reference if we don't have one.
						//  This could happen if you are rolling back a service without the source code. 
						nextService.imageId = currentService.imageId;
					}

					// inherit the comments from the remote reference. Comments can be adjusted later, but
					//  they don't matter as part of the diff.
					nextService.comments = currentService.comments;
					
					// this serviceName already exists in the final set!
					// overwrite it!
					finalServices[i] = nextService;

				
					found = true;
					break;
				}

				if (!found)
				{
					// the serviceName was not found, so we can add it!
					finalServices.Add(nextService);
				}
			}
		}

		{ // update the storages
			foreach (var nextStorage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
			{
				var found = false;
				for (var i = 0; i < finalStorages.Count; i++)
				{
					var currentStorage = finalStorages[i];
					if (!string.Equals(currentStorage.id, nextStorage.id))
						continue;

					found = true;
					finalStorages[i] = nextStorage;
					break;
				}

				if (!found)
				{
					finalStorages.Add(nextStorage);
				}
			}
		}

		final.manifest = finalServices.ToArray();
		final.storageReference = new OptionalArrayOfServiceStorageReference(finalStorages.ToArray());
		
		return final;
	}

	public static ManifestView MergeReplacement(ManifestView remote, ManifestView next)
	{
		// create an additive plan first, 
		// and then adjust the elements to handle "deletions" 
		var additive = MergeAdditive(remote, next);
		var nextStorages = next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>());

		// everything that is in current that IS NOT in next, should be marked as archived, and disabled. 
		{
			foreach (var service in additive.manifest)
			{
				var existsInNext = next.manifest.Any(x => x.serviceName == service.serviceName);
				if (existsInNext) continue;

				service.archived = true;
				service.enabled = false;
			}
		}

		// disable and archive all storages that are not in the next manifest
		{
			foreach (var storage in additive.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
			{
				var existsInNext = nextStorages.Any(x => x.id == storage.id);
				if (existsInNext) continue;

				storage.archived = true;
				storage.enabled = false;
			}
		}
		
		return additive;
	}

	public static bool TryValidate(ManifestView current, out List<string> errors)
	{
		errors = new List<string>();
		
		// validate services
		foreach (var service in current.manifest)
		{
			// every service must have a valid imageId
			if (string.IsNullOrEmpty(service.imageId))
			{
				errors.Add($"service=[{service.serviceName}] cannot have a blank imageId. ");
			}

			if (service.archived && service.enabled)
			{
				errors.Add($"service=[{service.serviceName}] cannot be archived and enabled. ");
			}
		}
		
		
		// validate storages
		foreach (var storage in current.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
		{
			if (storage.archived && storage.enabled)
			{
				errors.Add($"storage=[{storage.id}] cannot be archived and enabled. ");
			}
		}

		return errors.Count == 0;
	}

	public static ManifestView EnsureEntriesHaveChecksums(ManifestView current, ManifestView remote)
	{
		var next = current.Copy();
		// compute the checksums for all services and storages
		foreach (var service in next.manifest)
		{
			service.ResetChecksum();
		}

		foreach (var storage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
		{
			storage.ResetChecksum();
		}

		return next;
	}
	
	public static ManifestView RemoveDisabledServicesThatWereNeverDeployed(ManifestView current, ManifestView remote)
	{
		var next = current.Copy();
		var storagesToKeep = new HashSet<ServiceDependencyReference>();

		var services = next.manifest.ToList();
		for (int i = services.Count - 1; i >= 0; i--)
		{
			var sr = services[i];
			
			// If we have this service as disabled and have never published, we just remove them.
			if (!sr.enabled && !remote.manifest.Any(s => s.serviceName.Equals(sr.serviceName)))
			{
				services.RemoveAt(i);
			}
			// Otherwise, we keep track of their dependencies so we can fix up the Storage References in another pass.
			else
			{
				if (sr.dependencies.TryGet(out var deps))
				{
					foreach (ServiceDependencyReference serviceDependencyReference in deps)
						storagesToKeep.Add(serviceDependencyReference);
				}
			}
		}

		next.manifest = services.ToArray();

		// Make sure we are not adding storage object references for services that won't get uploaded.
		var storages = next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()).ToList();
		var remoteStorages = remote.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()).ToList();
		for (int i = storages.Count - 1; i >= 0; i--)
		{
			ServiceStorageReference serviceStorageReference = storages[i];
			var shouldKeep = storagesToKeep.Any(s => s.id.Equals(serviceStorageReference.id));
			var existsInRemote = remoteStorages.Any(s => s.id.Equals(serviceStorageReference.id));
			if (!shouldKeep && !existsInRemote)
			{
				storages.RemoveAt(i);
			}
		}
		next.storageReference.Set(storages.ToArray());

		return next;
	}
	
	public static ManifestView EnsureArchivedServicesAreDisabled(ManifestView current, ManifestView remote)
	{
		var next = current.Copy();
		// if a service or storage is archived, then it cannot be enabled. 
		foreach (var service in next.manifest)
		{
			if (service.archived)
			{
				service.enabled = false;
			}
		}

		foreach (var storage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
		{
			if (storage.archived)
			{
				storage.enabled = false;
			}
		}

		return next;
	}
	
	public static ManifestView EnsureOnlyActiveStoragesAreEnabled(ManifestView current, ManifestView remote)
	{
		var next = current.Copy();
		// there is a rule on the backend that a storage can only be enabled 
		//  IF there is an enabled service that is referencing that storage. 
		//  The rule exists to prevent folks from having unreachable storages. 
		//  NOTE: technically it is possible to get a secure connection string 
		//        to a remote storage, but it isn't currently a well designed UX.
		
		var referencedStorageIds = new HashSet<string>();
		
		// scan through all services and keep track of the referenced storage names
		{
			foreach (var service in next.manifest)
			{
				if (!service.enabled)
					// only accumulate referenced storage ids from services that are actually enabled. 
					//  otherwise, the storage is still "unreachable", because the service isn't running.
					continue;
				
				var deps = service.dependencies.GetOrElse(Array.Empty<ServiceDependencyReference>());
				foreach (var dep in deps)
				{
					referencedStorageIds.Add(dep.id);
				}
			}
		}

		// scan through storages, and identify those that weren't referenced
		{
			foreach (var storage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
			{
				if (referencedStorageIds.Contains(storage.id))
					// this storage was referenced by an enabled service
					continue;

				storage.enabled = false;
			}
		}

		return next;
	}

	public static string GetPlanTempFolder(IDependencyProvider provider)
	{
		// save the plan to a temp file
		var config = provider.GetService<ConfigService>();
		var logDir = Path.Combine(config.ConfigDirectoryPath, "temp", "plans");
		return logDir;
	}

	public static string GetLatestPlanFilePath(IDependencyProvider provider)
	{
		var logDir = GetPlanTempFolder(provider);
		if (!Directory.Exists(logDir)) return null;
		var info = new DirectoryInfo(logDir);
		var file = info.GetFiles().MaxBy(p => p.CreationTime);
		return file?.FullName;
	}
	
	public static async Task<string> SavePlanToTempFolder(IDependencyProvider provider, DeployablePlan plan)
	{
		var logDir = GetPlanTempFolder(provider);
		Directory.CreateDirectory(logDir);

		{ // delete files so that only the most recent 10 exist. 
			var info = new DirectoryInfo(logDir);
			var files = info.GetFiles().OrderByDescending(p => p.CreationTime).ToList();
			for (var i = 10; i < files.Count; i++)
			{
				Log.Verbose($"Deleting old plan file=[{files[i].Name}]");
				files[i].Delete();
			}
		}
			
		var planJson = JsonSerializable.ToJson(plan);
		var planPath = Path.Combine(logDir,$"plan-{DateTimeOffset.Now.ToUnixTimeMilliseconds()}.plan.json");
		Log.Verbose($"Saving plan: {planPath}");
		await File.WriteAllTextAsync(planPath, planJson);

		return planPath;
	}
	
	public static void PrintPlanNextSteps(string planFile, bool hasChanges)
	{
		var isSavingPlan = !string.IsNullOrEmpty(planFile);
		switch (isSavingPlan, hasChanges)
		{
			case (isSavingPlan: true, hasChanges: true):
				Log.Information($"To release, use `dotnet beam deploy release --plan {planFile}`");
				break;
			case (isSavingPlan: false, hasChanges: true):
				Log.Information(@"To release, either
 - re-run this command with the --to-file option, and then run `dotnet beam deploy release --plan <your-file>`, 
 - or run the `dotnet beam deploy release` command to create a plan and release it sequentially. ");
				break;
			case (isSavingPlan: _, hasChanges: false):
				Log.Information("Even though there are no changes, the `dotnet beam deploy release` command can still be used to roll the services. ");
				break;
		}
	}
	
	public static void PrintPlanInfo(DeployablePlan plan, IHasDeployPlanArgs args, out bool hasChanges)
	{
		var detectedChangeCount = PrintChangesAndNoticeChange(plan.diff.disabledServices, "Disabling", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.removedServices, "Removing", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.addedServices, "Adding", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.enabledServices, "Enabling", "service");
		detectedChangeCount += PrintChangesAndNoticeChangeT(plan.diff.serviceImageIdChanges, "Updating", "service");
		detectedChangeCount += PrintChangesAndNoticeChangeT(plan.diff.addedFederations, "Enabling", "federation");
		detectedChangeCount += PrintChangesAndNoticeChangeT(plan.diff.removedFederations, "Disabling", "federation");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.disabledStorages, "Disabling", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.removedStorage, "Removing", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.addedStorage, "Adding", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.enabledStorages, "Enabling", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.servicesToUpload, "Uploading", "service");

		hasChanges = plan.diff.jsonChanges.Count > 0;
		var hasDetectedChanges = detectedChangeCount > 0;
		if (hasChanges)
		{
			if (!plan.ranHealthChecks && plan.servicesToUpload.Count > 0)
			{
				Log.Warning("Local Health-checks were not run! Services may work as expected, but they have not been explicitly tested locally. \n" +
				            "Consider re-running a plan command with the `--health` option. ");
			}
		}
		switch (hasChanges, hasDetectedChanges)
		{
			case (true, true):
				if (detectedChangeCount == 1)
				{
					Log.Information("This plan has 1 pending change! ");
				}
				else
				{
					Log.Information($"This plan has {detectedChangeCount} pending changes! ");
				}

				if (args.UseLatestDeployedManifest)
				{
					Log.Warning("Somehow a change has been detected while trying to restart the services. Please try again, or contact Beamable. ");
				}
				break;
			case (true, false):
				Log.Information("This plan has uncommon changes! Please inspect the plan file for more details. ");
				break;
			case (false, false):
				if (args.UseLatestDeployedManifest)
				{
					Log.Information("There are no changes, because you are restarting the services.");
				}
				else
				{
					Log.Information("There are no changes.");
				}
				break;
			case (false, true):
				throw new CliException("The plan has an invalid detection. Please report this to Beamable");
		}


		int PrintChangesAndNoticeChangeT<T>(List<T> changes, string verb, string noun) where T : IServiceChangeDisplay
		{
			return PrintChangesAndNoticeChange(changes.Select(x => x.ToChangeString()).ToList(), verb, noun);
		}
		
		int PrintChangesAndNoticeChange(List<string> changes, string verb, string noun)
		{
			if (changes.Count == 0) return 0;
			var sb = new StringBuilder();
			sb.Append(verb);
			sb.Append(" ");
			sb.Append(changes.Count);
			sb.Append(" ");
			sb.AppendLine(changes.Count == 1 ? noun : $"{noun}s");
			for (var i = 0; i < changes.Count; i++)
			{
				sb.AppendLine($" - {changes[i].ToString()}");
			}
		
			Log.Warning(sb.ToString());
			return changes.Count;
		}
	}

	public static bool IsJsonAPlan(IDictionary<string, object> data)
	{
		return data != null
		        && data.ContainsKey(nameof(DeployablePlan.builtFromRemoteChecksum))
		        && data.ContainsKey(nameof(DeployablePlan.servicesToUpload))
		        && data.ContainsKey(nameof(DeployablePlan.manifest))
		        && data.ContainsKey(nameof(DeployablePlan.diff))
		        && data.ContainsKey(nameof(DeployablePlan.mode))
		        && data.ContainsKey(nameof(DeployablePlan.ranHealthChecks))
			;
	}
	public static bool IsJsonAManifest(IDictionary<string, object> data)
	{
		return data != null
		        && data.ContainsKey(nameof(ManifestView.checksum))
		        && data.ContainsKey(nameof(ManifestView.manifest))
		        && data.ContainsKey(nameof(ManifestView.id))
			// there are more fields we could check, btu this is "good enough"
			;
	}
	
	public static async Task<(DeployablePlan, List<BuildImageOutput>)> Plan(
		IDependencyProvider provider, 
		IHasDeployPlanArgs args,
		ProgressHandler progressHandler)
	{
		const string FetchManifestProgressName = "fetching latest";
		const string MergingManifestProgressName = "calculating plan";

		
		var api = provider.GetService<IBeamoApi>();
		var beamo = provider.GetService<BeamoLocalSystem>();

		var isLoadingManifestFile = !string.IsNullOrEmpty(args.FromManifestFile);
		var isLoadingManifestId = !string.IsNullOrEmpty(args.ManifestId);
		var isLoadingMostRecent = args.UseLatestDeployedManifest;

		// TODO: explain the first step; set up util variables
		{
			// validate that we are only loading a manifest from one location.
			var sources = new bool[] { isLoadingManifestFile, isLoadingManifestId, isLoadingMostRecent };
			var sourceNames = new string[] { "--from-manifest", "--from-manifest-id", "--restart" };
			var requestedSources = sources.Count(x => x);

			if (requestedSources > 1)
			{
				var sb = new StringBuilder();
				sb.AppendLine("Cannot load a manifest from more than one location. Please only specify one of the following,");
				for (var i = 0; i < sources.Length && i < sourceNames.Length; i++)
				{
					if (sources[i])
					{
						sb.AppendLine("  " + sourceNames[i]);
					}
				}

				throw new CliException(sb.ToString());
			}
		}
		
		ManifestView localManifest = null;
		ManifestView remote = null;
		List<BuildImageOutput> localBuildReports = null;
		Task<(ManifestView, List<BuildImageOutput>)> localTask = null;
		
		progressHandler?.Invoke(FetchManifestProgressName, 0);
		var remoteTask = CreateReleaseManifestFromRealm(api);

		// TODO: scope better; explain how to resolve remote and local manifest
		if (isLoadingManifestFile)
		{
			localTask = CreateReleaseManifestFromFile(provider, args.FromManifestFile, progressHandler);
		} else if (isLoadingManifestId)
		{
			localTask = CreateReleaseManifestFromId(provider, args.ManifestId, progressHandler);
		} else if (isLoadingMostRecent)
		{
			localTask = CreateReleaseManifestFromId(remoteTask);
		}
		else
		{
			localTask = CreateReleaseManifestFromLocal(provider, beamo.BeamoManifest, progressHandler);
		}
		progressHandler?.Invoke(MergingManifestProgressName, 0);
		
		remote = await remoteTask;
		progressHandler?.Invoke(FetchManifestProgressName, 1);
		
		(localManifest, localBuildReports) = await localTask;

		{ // if there are ANY failures in the build, then the entire plan is a failure.
			if (localBuildReports.Any(r => !r.success))
			{
				return (null, localBuildReports);
			}
		}
		
		ManifestView next = null;
		DeploymentDiffSummary diff = null;
		
		switch (args.DeployMode)
		{
			case DeployMode.Additive:
				next = MergeAdditive(remote, localManifest);
				break;
			case DeployMode.Replace:
				next = MergeReplacement(remote, localManifest);
				break;
			default:
				throw new NotImplementedException(
					$"The only two supported deploy modes are {nameof(DeployMode.Additive)} and {nameof(DeployMode.Replace)}");
		}
		
		// process transforms
		{
			var transforms = new List<Func<ManifestView, ManifestView, ManifestView>>
			{
				RemoveDisabledServicesThatWereNeverDeployed,
				EnsureArchivedServicesAreDisabled, 
				EnsureOnlyActiveStoragesAreEnabled, 
				EnsureEntriesHaveChecksums
			};
			for (var i = 0; i < transforms.Count; i++)
			{
				var r = .5f * ((i + 1f) / transforms.Count);
				next = transforms[i](next, remote);
				progressHandler?.Invoke(MergingManifestProgressName, r);
			}
		}

		progressHandler?.Invoke(MergingManifestProgressName, .5f);
		diff = FindChanges(remote, next);

		if (!TryValidate(next, out var validationErrors))
		{
			throw new CliException($"The plan is invalid.\n{string.Join("\n -", validationErrors)}");
		}

		var servicesToUpload = new List<string>();
		{ 
			// calculate the set of services that actually need to build. 
			//  it is the intersection of services that have differing imageIds in remote/local, 
			//  AND those services that we just built locally. 
			//  If a service was not built locally, then we must assume the image already exists remotely. 
			var locallyBuiltServices = localBuildReports.Select(x => x.service).ToArray();
			foreach (var serviceInManifest in next.manifest)
			{
				// find the service in the local and remote
				var localService = locallyBuiltServices.FirstOrDefault(x => x == serviceInManifest.serviceName);
				var remoteService = remote.manifest.FirstOrDefault(x => x.serviceName == serviceInManifest.serviceName);
				
				// If the service is enabled and it wasn't built locally, this is a bug.
				if (serviceInManifest.enabled && localService == null)
					throw new CliException("local service cannot be null. This is a beamable bug, please report");
				
				// If an enabled service did not exist in the remote service OR any service had its imageId change relative to the one in the manifest, it means we have to upload this new image.  
				if ((serviceInManifest.enabled && remoteService == null) || (remoteService != null && serviceInManifest.imageId != remoteService.imageId)) 
					servicesToUpload.Add(serviceInManifest.serviceName);
			}
		}


		if (args.RunHealthChecks)
		{
			// start up all containers 
			foreach (var service in servicesToUpload)
			{
				var localService = next.manifest.FirstOrDefault(x => x.serviceName == service);
				if (localService == null)
					throw new CliException("local service cannot be null. This is a beamable bug, please report");

				
				progressHandler?.Invoke("verifying " + service, 0);
				if (!beamo.BeamoManifest.TryGetDefinition(service, out var definition))
					throw new CliException("local definition cannot be null. This is a beamable bug, please report");

				if (!beamo.BeamoManifest.HttpMicroserviceLocalProtocols.TryGetValue(service, out var http))
					throw new CliException("local http service cannot be null. This is a beamable bug, please report");

				var container = BeamoLocalSystem.GetBeamIdAsMicroserviceContainer(definition.BeamoId);
				try
				{
					await beamo.StopContainer(container);
				}
				catch
				{
					// do nothing.
				}

				var routingKey = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine() + "_healthCheck";
				await beamo.RunLocalHttpMicroservice(definition, http, beamo, true, 
					CancellationToken.None, 
					disableInitHooks: true, // TODO: should we make this false?
					imageIdOverride: localService.imageId,
					routingKey: routingKey);
				progressHandler?.Invoke("verifying " + service, .5f);
				
				var routingHeader = $"{Beamable.Common.Constants.Requester.HEADER_ROUTINGKEY}=micro_{service}:{routingKey}";
				await RetryRequest(provider, container, service, routingHeader);
				
				progressHandler?.Invoke("verifying " + service, .9f);
				try
				{
					// stop the container to clean up.
					await beamo.StopContainer(container);
				}
				catch
				{
					// do nothing.
				}
				
				progressHandler?.Invoke("verifying " + service, 1);

				
			}
		}
		
		progressHandler?.Invoke(MergingManifestProgressName, 1);

		return (new DeployablePlan
		{
			ranHealthChecks = args.RunHealthChecks,
			builtFromRemoteChecksum = remote.checksum,
			mode = args.DeployMode,
			diff = diff,
			manifest = next,
			servicesToUpload = servicesToUpload,
			changeCount = diff.addedStorage.Count
			              + diff.removedStorage.Count
			              + diff.disabledStorages.Count
			              + diff.enabledStorages.Count
			              + diff.addedServices.Count
			              + diff.removedServices.Count
			              + diff.disabledServices.Count
			              + diff.enabledServices.Count
			              + diff.serviceImageIdChanges.Count
			              + diff.addedFederations.Count
			              + diff.removedFederations.Count
		}, localBuildReports);
	}

	
	private static async Promise<string> RetryRequest(IDependencyProvider provider, string containerName, string serviceName, string routingHeader)
	{
		var app = provider.GetService<IAppContext>();
		var url = $"/basic/{app.Cid}.{app.Pid}.micro_{serviceName}/admin/Metadata";
		var requester = provider.GetService<CliRequester>();
	
		var isRunning = false;
		string request = null;
	
		do
		{
			isRunning = false;
			try
			{
				request = await requester.CustomRequest(Method.GET, url, null, true, (s => s),
					customHeaders: new[] { routingHeader });
				Log.Verbose($"got response from health check for {containerName}");
			}
			catch (Exception e)
			{
				Log.Verbose($"Exception happened while trying to reach service Metadata endpoint. Message = [{e.Message}] Stacktrace = [{e.StackTrace}]");
				await Task.Delay(500); // Waiting a bit before retrying
				try
				{
					ContainerInspectResponse response = await provider.GetService<BeamoLocalSystem>().Client.Containers
						.InspectContainerAsync(containerName);
					isRunning = response.State.Running;
				}
				catch
				{
					isRunning = false;
				}
			}
	
		} while (isRunning);
	
		if (string.IsNullOrEmpty(request))
		{
			throw new CliException($"The service [{serviceName}] failed to register itself with Beamable.");
		}
	
		return request;
	}
	
	public static async Task Deploy(
		DeployablePlan plan, 
		IDependencyProvider provider, 
		ProgressHandler progressHandler, 
		CancellationTokenSource cts,
		Task<ManifestView> remoteManifestTask=null)
	{
		var api = provider.GetService<IBeamoApi>();
		var beamoService = provider.GetService<BeamoService>();

		var gamePidPromise = provider.GetService<IRealmsApi>().GetRealm();
		var dockerRegistryUrlPromise = beamoService.GetDockerImageRegistryUri();
		
		var remote = await (remoteManifestTask ?? CreateReleaseManifestFromRealm(api));
		var gamePid = (await gamePidPromise).FindRoot().Pid; // TODO I really think we should move this to _ctx/ConfigService and grab it during init...
		var dockerRegistryUrl = await dockerRegistryUrlPromise;

		if (remote.checksum != plan.builtFromRemoteChecksum)
		{
			throw new CliException(
				"The given deployment plan was created with a different configuration of remote services than exists now. Please create a new plan and try again.");
		}
		
		// identity the services we need to upload.
		var uploadTasks = new List<Task>();
		var servicesToUpload = new HashSet<string>(plan.servicesToUpload);
		foreach (var service in plan.manifest.manifest)
		{
			var needsUpload = servicesToUpload.Contains(service.serviceName);
			if (!needsUpload)
				continue;

			var serviceName = service.serviceName;
			var progressTaskName = $"upload {serviceName}";
			var uploadTask = ServiceUploadUtil.Upload(
				provider: provider,
				beamoId: service.serviceName,
				imageId: service.imageId, 
				gamePid: gamePid,
				dockerRegistryUrl: dockerRegistryUrl, 
				cts: cts, 
				onProgressCallback: progressRatio =>
				{
					progressHandler?.Invoke(progressTaskName, progressRatio, serviceName: serviceName);
				});

			uploadTasks.Add(uploadTask);
		}

		progressHandler?.Invoke("publish", 0);
		await Task.WhenAll(uploadTasks);

		cts.Token.ThrowIfCancellationRequested();
		
		// publish manifest. 
		var manifest = new PostManifestRequest
		{
			manifest = plan.manifest.manifest,
			storageReferences = plan.manifest.storageReference,
			autoDeploy = true,
			comments = plan.manifest.comments
		};
		progressHandler?.Invoke("publish", .1f, false);

		await api.PostManifest(manifest);
		progressHandler?.Invoke("publish", 1, false);

	}

	public static async Task<ManifestView> CreateReleaseManifestFromRealm(IBeamoApi beamo)
	{
		try
		{
			var current = await beamo.GetManifestCurrent();
			return current.manifest;
		}
		catch (RequesterException requesterException) when (requesterException.Status == 404)
		{
			// there is no existing manifest.
			return new ManifestView
			{
				manifest = Array.Empty<ServiceReference>(),
				storageReference = new OptionalArrayOfServiceStorageReference(Array.Empty<ServiceStorageReference>())
			};
		}
	}

	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromId(IDependencyProvider provider, string manifestId, ProgressHandler progressHandler)
	{
		var api = provider.GetService<IBeamoApi>();
		progressHandler?.Invoke("fetching manifest", 0);
		var manifest = await api.GetManifest(manifestId);
		progressHandler?.Invoke("fetching manifest", 1);
		return (manifest.manifest, new List<BuildImageOutput>());
	}
	
	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromId(Task<ManifestView> remoteTask)
	{
		var manifest = await remoteTask;
		return (manifest, new List<BuildImageOutput>());
	}

	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromFile(IDependencyProvider provider, string manifestFile, ProgressHandler progressHandler)
	{
		const string ReadingLocalManifestProgressName = "reading manifest file";

		progressHandler?.Invoke(ReadingLocalManifestProgressName, 0);
		var manifestJson = await File.ReadAllTextAsync(manifestFile);
		var data = Json.Deserialize(manifestJson) as IDictionary<string, object>;
		if (!IsJsonAManifest(data))
		{
			if (IsJsonAPlan(data))
			{
				throw new CliException(
					$"The file=[{manifestFile}] appears to contain a plan file, but should contain a manifest. " +
					$"To use the plan, use the `--from-plan` option.");
			}

			throw new CliException($"The file=[{manifestFile}] does not contain a valid plan file");
		}
			
			
		progressHandler?.Invoke(ReadingLocalManifestProgressName, 1);

		
		var localManifest = JsonSerializable.FromJson<ManifestView>(manifestJson);
		return (localManifest, new List<BuildImageOutput>());
	}
	
	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromLocal(IDependencyProvider provider, BeamoLocalManifest localManifest, ProgressHandler progressHandler)
	{
		var services = new ServiceReference[localManifest.HttpMicroserviceLocalProtocols.Count];
		var storages = new ServiceStorageReference[localManifest.EmbeddedMongoDbLocalProtocols.Count];

		var serviceIndex = 0;
		var storageIndex = 0;
		var pendingTasks = new List<Task>();
		var buildReports = new List<BuildImageOutput>();
		for (var i = 0; i < localManifest.ServiceDefinitions.Count; i++)
		{
			var definition = localManifest.ServiceDefinitions[i];
			
			if (!definition.IsLocal)
				// this function is explicitly about creating services from local source code.
				continue;
			
			switch (definition.Protocol)
			{
				case BeamoProtocolType.HttpMicroservice:

					var index = serviceIndex++;
					var task = CreateServiceReference(
						provider, 
						definition, 
						localManifest.HttpMicroserviceLocalProtocols[definition.BeamoId],
						progressHandler
					).ContinueWith(continueTask =>
					{
						if (continueTask.IsCompletedSuccessfully)
						{
							services[index] = continueTask.Result.Item1;
							buildReports.Add(continueTask.Result.Item2);
						}
						else
						{
							throw new CliException("Failed to build " + definition.BeamoId);
						}
					});
					pendingTasks.Add(task);
					break;
				case BeamoProtocolType.EmbeddedMongoDb:
					storages[storageIndex++] = CreateStorageReference(
						definition,
						localManifest.EmbeddedMongoDbLocalProtocols[definition.BeamoId]
					);
					break;
			}
		}

		await Task.WhenAll(pendingTasks);
		
		return (new ManifestView
		{
			manifest = services,
			storageReference = new OptionalArrayOfServiceStorageReference(storages)
		}, buildReports);
	}

	static ServiceStorageReference CreateStorageReference(
		BeamoServiceDefinition definition,
		EmbeddedMongoDbLocalProtocol mongo)
	{
		
		var reference = new ServiceStorageReference
		{
			storageType = "mongov1",
			archived = false,
			enabled = definition.ShouldBeEnabledOnRemote,
			templateId = "small",
			id = definition.BeamoId,
		};
		
		return reference;
	}

	


	static async Task<(ServiceReference, BuildImageOutput)> CreateServiceReference(
		IDependencyProvider provider,
		BeamoServiceDefinition definition,
		HttpMicroserviceLocalProtocol http,
		ProgressHandler progressHandler)
	{
		string imageId = null;
		BuildImageOutput report = default;
		if (definition.ShouldBeEnabledOnRemote)
		{
			var progressName = "build " + definition.BeamoId;
			try
			{
				progressHandler?.Invoke(progressName, 0, serviceName: definition.BeamoId);
				var sb = new StringBuilder();
				report = await ServicesBuildCommand.Build(provider, definition.BeamoId,
					forceCpu: true,
					logMessage: log =>
					{
						sb.AppendLine(log.message);
						if (log.isFailure)
						{
							Log.Error($"Failed to build service=[{definition.BeamoId}]\n{sb.ToString()}");
						}
					}, progressMessage: progress =>
					{
						progressHandler?.Invoke(progressName, progress.Ratio, serviceName: definition.BeamoId);
					});
				progressHandler?.Invoke(progressName, 1);
				imageId = report.ShortImageId;
			}
			catch (Exception ex)
			{
				progressHandler?.Invoke(progressName, -1, serviceName: definition.BeamoId);
				Log.Error($"Could not build service=[{definition.BeamoId}] message=[{ex.Message}] stack=[{ex.StackTrace}]");
				imageId = null;
			}
		}  else
		{
			report = new BuildImageOutput { success = true };
			progressHandler?.Invoke("skip  " + definition.BeamoId, 1, serviceName: definition.BeamoId);
		}

		var feds = definition.FederationsConfig?.Federations ?? new FederationsConfig();
		var components = feds.SelectMany(kvp =>
		{
			return kvp.Value.Select(x => new ServiceComponent
			{
				name = $"{x.Interface}/{kvp.Key}"
			});
		}).ToArray();
		
		var reference = new ServiceReference
		{
			serviceName = definition.BeamoId,
			enabled = definition.ShouldBeEnabledOnRemote,
			templateId = "small",
			archived = false,
			imageId = imageId,
			components = new OptionalArrayOfServiceComponent(components),
			dependencies = new OptionalArrayOfServiceDependencyReference(http.StorageDependencyBeamIds.Select(x => new ServiceDependencyReference
			{
				storageType = "mongov1",
				id = x
			}).ToArray())
		};
		
		return (reference, report);
	}
}
