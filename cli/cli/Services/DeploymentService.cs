// using Beamable.Api.Autogenerated.Beamo;
// using Beamable.Common.Dependencies;

using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Realms;
using Beamable.Common.Dependencies;
using Beamable.Serialization;
using Beamable.Serialization.SmallerJSON;
using Beamable.Server;
using cli.DeploymentCommands;
using cli.Services;
using Docker.DotNet.Models;
using System.Text;
using System.Text.RegularExpressions;
using cli.Commands.Project;
using cli.DockerCommands;
using cli.Dotnet;
using cli.Utils;
using CliWrap;
using Microsoft.Build.Framework;
using BeamoLocalManifest = cli.Services.BeamoLocalManifest;
using PostManifestRequest = Beamable.Api.Autogenerated.Models.PostManifestRequest;
using ServiceReference = Beamable.Api.Autogenerated.Models.ServiceReference;
using ServiceStorageReference = Beamable.Api.Autogenerated.Models.ServiceStorageReference;

namespace cli.Deployment.Services;

public enum DeployMode
{
	/// <summary>
	/// A deployment mode that only adds services found locally at the time of the deployment.
	/// Any existing services that are not part of the local environment will remain unchanged. 
	/// </summary>
	Additive, 
	
	/// <summary>
	/// A deployment mode that will remove everything unless it is found locally during the time
	/// of deployment. 
	/// </summary>
	Replace
}

public class DeployablePlan : JsonSerializable.ISerializable
{
	
	/// <summary>
	/// This checksum represents the checksum of the remote manifest at the time the plan was made.
	/// If the plan is going to be <i>used</i>, the checksum should be checked. When the checksum
	/// does not match the latest remote checksum, this plan should be considered out of date.  
	/// </summary>
	public string builtFromRemoteChecksum;

	
	public DeployMode mode;
	
	/// <summary>
	/// The resulting manifest. After the plan is released, the server-side manifest will be this manifest. 
	/// </summary>
	public ManifestView manifest;
	public DeploymentDiffSummary diff;
	public Dictionary<string, List<string>> notes = new Dictionary<string, List<string>>();
	public List<string> servicesToUpload = new List<string>();
	public bool ranHealthChecks;
	public int changeCount;
	
	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(builtFromRemoteChecksum), ref builtFromRemoteChecksum);
		s.SerializeEnum(nameof(mode), ref mode);
		s.Serialize(nameof(manifest), ref manifest);
		s.Serialize(nameof(diff), ref diff);
		s.Serialize(nameof(changeCount), ref changeCount);
		s.Serialize(nameof(ranHealthChecks), ref ranHealthChecks);
		s.SerializeDictionary(nameof(notes), ref notes);
		s.SerializeList(nameof(servicesToUpload), ref servicesToUpload);
	}
}


public enum DeploymentChangeType
{
	Added,
	Removed,
	Changed
}

public class DeploymentManifestJsonDiff : JsonSerializable.ISerializable
{
	public string jsonPath;
	public string type;
	public string currentValue;
	public string nextValue;
	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(jsonPath), ref jsonPath);
		s.Serialize(nameof(type), ref type);
		s.Serialize(nameof(currentValue), ref currentValue);
		s.Serialize(nameof(nextValue), ref nextValue);
	}

	public bool TryGetNextBooleanValue(out bool isTruthy)
	{
		return bool.TryParse(nextValue, out isTruthy);
	}
}

public class DeploymentDiffSummary : JsonSerializable.ISerializable
{
	public List<DeploymentManifestJsonDiff> jsonChanges = new List<DeploymentManifestJsonDiff>();
	public List<string> addedServices = new List<string>();
	public List<string> removedServices = new List<string>();
	
	public List<string> disabledServices = new List<string>();
	public List<string> enabledServices = new List<string>();
	
	public List<string> addedStorage = new List<string>();
	public List<string> removedStorage = new List<string>();
	
	public List<string> disabledStorages = new List<string>();
	public List<string> enabledStorages = new List<string>();

	public List<ServiceLogProviderChange> servicesSwitchingLogProvider = new List<ServiceLogProviderChange>();

	public List<ServiceFederationChange> addedFederations = new List<ServiceFederationChange>();
	public List<ServiceFederationChange> removedFederations = new List<ServiceFederationChange>();
	public List<ServiceImageIdChange> serviceImageIdChanges = new List<ServiceImageIdChange>();
	
	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.SerializeList(nameof(jsonChanges), ref jsonChanges);
		s.SerializeList(nameof(addedServices), ref addedServices);
		s.SerializeList(nameof(removedServices), ref removedServices);
		s.SerializeList(nameof(disabledServices), ref disabledServices);
		s.SerializeList(nameof(enabledServices), ref enabledServices);
		s.SerializeList(nameof(addedStorage), ref addedStorage);
		s.SerializeList(nameof(removedStorage), ref removedStorage);
		s.SerializeList(nameof(disabledStorages), ref disabledStorages);
		s.SerializeList(nameof(enabledStorages), ref enabledStorages);
		s.SerializeList(nameof(serviceImageIdChanges), ref serviceImageIdChanges);
		s.SerializeList(nameof(addedFederations), ref addedFederations);
		s.SerializeList(nameof(removedFederations), ref removedFederations);
		s.SerializeList(nameof(servicesSwitchingLogProvider), ref servicesSwitchingLogProvider);
	}
}

public interface IServiceChangeDisplay
{
	string ToChangeString();
}

public struct ServiceFederationChange : IServiceChangeDisplay, JsonSerializable.ISerializable
{
	public string service;
	public string federationId;
	public string federationInterface;
	
	public string ToChangeString()
	{
		return $"{service} [{federationInterface}/{federationId}]";
	}

	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(service), ref service);
		s.Serialize(nameof(federationId), ref federationId);
		s.Serialize(nameof(federationInterface), ref federationInterface);
	}
}

public struct ServiceImageIdChange : IServiceChangeDisplay, JsonSerializable.ISerializable
{
	public string service;
	public string oldImageId;
	public string nextImageId;

	public string ToChangeString()
	{
		return $"{service} [{oldImageId}]->[{nextImageId}]";
	}

	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(service), ref service);
		s.Serialize(nameof(oldImageId), ref oldImageId);
		s.Serialize(nameof(nextImageId), ref nextImageId);
	}
}

public struct ServiceLogProviderChange : IServiceChangeDisplay, JsonSerializable.ISerializable
{
	public string service;
	public string oldProvider;
	public string newProvider;

	public string ToChangeString()
	{
		return $"{service} [{oldProvider}]->[{newProvider}]";
	}

	public void Serialize(JsonSerializable.IStreamSerializer s)
	{
		s.Serialize(nameof(service), ref service);
		s.Serialize(nameof(oldProvider), ref oldProvider);
		s.Serialize(nameof(newProvider), ref newProvider);
	}
}

public partial class DeployUtil
{
	public static async Task CreateDockerComposeFile<TArgs>(DeployablePlan plan, string secret, TArgs args)
		where TArgs : CommandArgs, IHasDockerComposeArgs
	{
		var sb = new StringBuilder();
		
		var tasks = new List<Task>();
		
		Directory.CreateDirectory(args.DockerComposeDirectoryPath);
		string envDir = Path.Combine(args.DockerComposeDirectoryPath, "env");
		Directory.CreateDirectory(envDir);

		string dockerComposePath = Path.Combine(args.DockerComposeDirectoryPath, "docker-compose.yml");
		string gitIgnorePath = Path.Combine(args.DockerComposeDirectoryPath, ".gitignore");
		
		tasks.Add(File.WriteAllTextAsync(gitIgnorePath, @"/env
.env"));

		sb.AppendLine("version: \"4\"");
		sb.AppendLine("services:");
		for (var i = 0; i < plan.manifest.manifest.Length; i ++)
		{		
			var service = plan.manifest.manifest[i];
			if (!service.enabled) continue;

			var env = GenerateEnvFileCommand.CreateDockerEnv(args, secret);
			var envFileName = $"{service.serviceName.ToLowerInvariant()}.env";
			tasks.Add(GenerateEnvFileCommand.WriteEnvToFile(Path.Combine(envDir, envFileName), env));
			
			sb.AppendLine($"  {service.serviceName}:");
			sb.AppendLine($"    image: {service.serviceName.ToLowerInvariant()}");

			sb.AppendLine($"    env_file:");
			sb.AppendLine($"      - {Path.Combine("env", envFileName)}");

			if (service.dependencies.TryGet(out var deps) && deps.Length > 0)
			{
				sb.AppendLine($"    environment:");
				for (var s = 0; s < deps.Length; s++)
				{
					sb.AppendLine($"      STORAGE_CONNSTR_{deps[s].id}: 'mongodb://beamable:beamable@{deps[s].id}:27017'");
				}
				
				sb.AppendLine($"    depends_on:");
				for (var s = 0; s < deps.Length; s++)
				{
					sb.AppendLine($"      - {deps[s].id}");
				}
			}
			
		}

		if (plan.manifest.storageReference.TryGet(out var storages))
		{
			for (var i = 0; i < storages.Length; i++)
			{
				var storage = storages[i];
				if (!storage.enabled) continue;
				sb.AppendLine($"  {storage.id}:");
				sb.AppendLine($"    image: mongo:7.0");
				sb.AppendLine($"    environment:");
				sb.AppendLine($"      MONGO_INITDB_ROOT_USERNAME: 'beamable'");
				sb.AppendLine($"      MONGO_INITDB_ROOT_PASSWORD: 'beamable'");
			}
		}

		sb.AppendLine("");
		tasks.Add(File.WriteAllTextAsync(dockerComposePath, sb.ToString()));

		foreach (var t in tasks)
		{
			await t;
		}
	}
}

public partial class DeployUtil
{
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[(\\d+)\\].{nameof(ServiceReference.components)}\\[(\\d+)\\].{nameof(ServiceComponent.name)}", RegexOptions.None)]
	public static partial Regex GetFederationRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[(\\d+)\\]", RegexOptions.None)]
	public static partial Regex GetServiceRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[(\\d+)\\]", RegexOptions.None)]
	public static partial Regex GetStorageRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.serviceName)}", RegexOptions.None)]
	public static partial Regex GetServiceNameRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.enabled)}", RegexOptions.None)]
	public static partial Regex GetServiceEnabledRegex();
	
		
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.archived)}", RegexOptions.None)]
	public static partial Regex GetServiceArchivedRegex();

	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[\\d+\\].{nameof(ServiceReference.archived)}", RegexOptions.None)]
	public static partial Regex GetStorageArchivedRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.manifest)}\\[\\d+\\].{nameof(ServiceReference.imageId)}", RegexOptions.None)]
	public static partial Regex GetServiceImageIdRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[\\d+\\].{nameof(ServiceStorageReference.id)}", RegexOptions.None)]
	public static partial Regex GetStorageNameRegex();
	
	[GeneratedRegex($"^{nameof(ManifestView.storageReference)}\\[\\d+\\].{nameof(ServiceStorageReference.enabled)}", RegexOptions.None)]
	public static partial Regex GetStorageEnabledRegex();
	
	public static DeploymentDiffSummary FindChanges(ManifestView old, ManifestView next)
	{
		var summary = new DeploymentDiffSummary();
		
		// get the exact json field diff
		summary.jsonChanges = DiffStream.FindChanges(old, next).changes.Select(x =>
		{
			return new DeploymentManifestJsonDiff
			{
				jsonPath = x.jsonPath,
				nextValue = x.nextValue,
				currentValue = x.currentValue,
				type = x.type switch
				{
					DiffType.Removed => "removed",
					DiffType.Added => "added",
					DiffType.Changed => "changed",
					_ => throw new CliException("unknown json diff type")
				}
			};
		}).ToList();

		// there are certain semantic changes that we should highlight
		foreach (var change in summary.jsonChanges)
		{
			var diffType = change.type switch
			{
				"added" => DiffType.Added,
				"removed" => DiffType.Removed,
				"changed" => DiffType.Changed,
				_ => throw new CliException("unknown change type")
			};
			if (GetFederationRegex().IsMatch(change.jsonPath))
			{
				var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
				var name = next.manifest[serviceIndex].serviceName;

				if (!string.IsNullOrEmpty(change.nextValue) && change.nextValue.Length > 0)
				{
					var nextParts = change.nextValue?.Split("/", StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
					var add = new ServiceFederationChange
					{
						service = name,
						federationId = nextParts[1],
						federationInterface = nextParts[0]
					};
					summary.addedFederations.Add(add);
				}
				
				if (!string.IsNullOrEmpty(change.currentValue) && change.currentValue.Length > 0)
				{
					var nextParts = change.currentValue?.Split("/", StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
					var remove = new ServiceFederationChange
					{
						service = name,
						federationId = nextParts[1],
						federationInterface = nextParts[0]
					};
					summary.removedFederations.Add(remove);
				}
				
			}
			switch (diffType)
			{
				case DiffType.Changed:
					if (GetServiceNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedServices.Add(change.nextValue);
					} else if (GetStorageNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedStorage.Add(change.nextValue);
					} 
					else if (GetServiceArchivedRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isArchived))
						{
							// extract the service name...
							var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.manifest[serviceIndex].serviceName;
							if (isArchived)
							{
								summary.removedServices.Add(name);
							}
							else
							{
								summary.addedServices.Add(name);
							}
						}
					}
					else if (GetStorageArchivedRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isArchived))
						{
							// extract the service name...
							var storageIndex = int.Parse(GetStorageRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.storageReference.Value[storageIndex].id;
							if (isArchived)
							{
								summary.removedStorage.Add(name);
							}
							else
							{
								summary.addedStorage.Add(name);
							}
						}
					}
					else if (GetServiceEnabledRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isEnabled))
						{
							// extract the service name...
							var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.manifest[serviceIndex].serviceName;
							if (isEnabled)
							{
								summary.enabledServices.Add(name);
							}
							else
							{
								summary.disabledServices.Add(name);
							}
						}
					} else if (GetStorageEnabledRegex().IsMatch(change.jsonPath))
					{
						if (change.TryGetNextBooleanValue(out var isEnabled))
						{
							// extract the storage name...
							var storageIndex = int.Parse(GetStorageRegex().Match(change.jsonPath).Groups[1].Value);
							var name = next.storageReference.Value[storageIndex].id;
							if (isEnabled)
							{
								summary.enabledStorages.Add(name);
							}
							else
							{
								summary.disabledStorages.Add(name);
							}
						}
					} else if (GetServiceImageIdRegex().IsMatch(change.jsonPath))
					{
						var serviceIndex = int.Parse(GetServiceRegex().Match(change.jsonPath).Groups[1].Value);
						var name = next.manifest[serviceIndex].serviceName;
						summary.serviceImageIdChanges.Add(new ServiceImageIdChange
						{
							service = name,
							oldImageId = change.currentValue,
							nextImageId = change.nextValue
						});
					}
					

					break;
				case DiffType.Added:
					if (GetServiceNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedServices.Add(change.nextValue);
					} else if (GetStorageNameRegex().IsMatch(change.jsonPath))
					{
						summary.addedStorage.Add(change.nextValue);
					}
					break;
				case DiffType.Removed:
					if (GetServiceNameRegex().IsMatch(change.jsonPath))
					{
						summary.removedServices.Add(change.currentValue);
					} else if (GetStorageNameRegex().IsMatch(change.jsonPath))
					{
						summary.removedStorage.Add(change.currentValue);
					}
					break;
			}
		}
		

		return summary;
	}

	public static ManifestView MergeAdditive(ManifestView remote, ManifestView next)
	{
		// clone the current...
		var final = remote.Copy();
		var finalServices = new List<ServiceReference>(final.manifest ?? Array.Empty<ServiceReference>());
		var finalStorages =
			new List<ServiceStorageReference>(final.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()));

		{ // set the comment string; this may be changed later, but comments are not part of the diffing.
			final.comments = remote.comments;
			
			// note: all the other random field stuff (as of Oct 1 2024) are computed by the server.
		}
		
		{ // each service in the next set should be added in and/or overwrite the existing service for the name
			foreach (var nextService in next.manifest)
			{
				var found = false;
				for (var i = 0; i < finalServices.Count; i++)
				{
					var currentService = finalServices[i];
					if (!string.Equals(nextService.serviceName, currentService.serviceName))
						continue;
					
					if (!nextService.enabled && string.IsNullOrEmpty(nextService.imageId))
					{
						// inherit the imageId from the existing service reference if we don't have one.
						//  This could happen if you are rolling back a service without the source code. 
						nextService.imageId = currentService.imageId;
					}

					// inherit the comments from the remote reference. Comments can be adjusted later, but
					//  they don't matter as part of the diff.
					nextService.comments = currentService.comments;
					
					// this serviceName already exists in the final set!
					// overwrite it!
					finalServices[i] = nextService;

				
					found = true;
					break;
				}

				if (!found)
				{
					// the serviceName was not found, so we can add it!
					finalServices.Add(nextService);
				}
			}
		}

		{ // update the storages
			foreach (var nextStorage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
			{
				var found = false;
				for (var i = 0; i < finalStorages.Count; i++)
				{
					var currentStorage = finalStorages[i];
					if (!string.Equals(currentStorage.id, nextStorage.id))
						continue;

					found = true;
					finalStorages[i] = nextStorage;
					break;
				}

				if (!found)
				{
					finalStorages.Add(nextStorage);
				}
			}
		}

		final.manifest = finalServices.ToArray();
		final.storageReference = new OptionalArrayOfServiceStorageReference(finalStorages.ToArray());
		
		return final;
	}

	public static ManifestView MergeReplacement(ManifestView remote, ManifestView next, HashSet<string> ignoredBeamoIds)
	{
		// create an additive plan first, 
		// and then adjust the elements to handle "deletions" 
		var additive = MergeAdditive(remote, next);
		var nextStorages = next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>());

		// everything that is in current that IS NOT in next, should be marked as archived, and disabled. 
		{
			foreach (var service in additive.manifest)
			{
				var existsInNext = next.manifest.Any(x => x.serviceName == service.serviceName);
				if (existsInNext) continue;

				var ignored = ignoredBeamoIds.Contains(service.serviceName);
				if (ignored) continue;

				service.archived = true;
				service.enabled = false;
			}
		}

		// disable and archive all storages that are not in the next manifest
		{
			foreach (var storage in additive.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
			{
				var existsInNext = nextStorages.Any(x => x.id == storage.id);
				if (existsInNext) continue;
				
				var ignored = ignoredBeamoIds.Contains(storage.id);
				if (ignored) continue;

				storage.archived = true;
				storage.enabled = false;
			}
		}
		
		return additive;
	}

	public static bool TryValidate(ManifestView current, out List<string> errors)
	{
		errors = new List<string>();
		
		// validate services
		foreach (var service in current.manifest)
		{
			// every service must have a valid imageId
			if (string.IsNullOrEmpty(service.imageId))
			{
				errors.Add($"service=[{service.serviceName}] cannot have a blank imageId. ");
			}

			if (service.archived && service.enabled)
			{
				errors.Add($"service=[{service.serviceName}] cannot be archived and enabled. ");
			}
		}
		
		
		// validate storages
		foreach (var storage in current.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
		{
			if (storage.archived && storage.enabled)
			{
				errors.Add($"storage=[{storage.id}] cannot be archived and enabled. ");
			}
		}

		return errors.Count == 0;
	}

	public static ManifestTransformOutput EnsureEntriesHaveChecksums(ManifestTransformArgs args)
	{
		var current = args.current;
		var remote = args.remote;
		var next = current.Copy();
		// compute the checksums for all services and storages
		foreach (var service in next.manifest)
		{
			service.ResetChecksum();
		}

		foreach (var storage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
		{
			storage.ResetChecksum();
		}
		return new ManifestTransformOutput
		{
			next = next
		};
	}

	public struct ManifestTransformArgs
	{
		public ManifestView current;
		public ManifestView remote;
		public HashSet<string> ignoreIds;
	}

	public struct ManifestTransformOutput
	{
		public ManifestView next;
		public Dictionary<string, List<string>> beamoIdToNotes;
	}
	
	public static ManifestTransformOutput RemoveDisabledServicesThatWereNeverDeployed(ManifestTransformArgs args)
	{
		var current = args.current;
		var remote = args.remote;
		var next = current.Copy();
		var storagesToKeep = new HashSet<ServiceDependencyReference>();

		var services = next.manifest.ToList();
		for (int i = services.Count - 1; i >= 0; i--)
		{
			var sr = services[i];
			
			// If we have this service as disabled and have never published, we just remove them.
			if (!sr.enabled && !remote.manifest.Any(s => s.serviceName.Equals(sr.serviceName)))
			{
				services.RemoveAt(i);
			}
			// Otherwise, we keep track of their dependencies so we can fix up the Storage References in another pass.
			else
			{
				if (sr.dependencies.TryGet(out var deps))
				{
					foreach (ServiceDependencyReference serviceDependencyReference in deps)
						storagesToKeep.Add(serviceDependencyReference);
				}
			}
		}

		next.manifest = services.ToArray();

		// Make sure we are not adding storage object references for services that won't get uploaded.
		var storages = next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()).ToList();
		var remoteStorages = remote.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()).ToList();
		for (int i = storages.Count - 1; i >= 0; i--)
		{
			ServiceStorageReference serviceStorageReference = storages[i];
			var shouldKeep = storagesToKeep.Any(s => s.id.Equals(serviceStorageReference.id));
			var existsInRemote = remoteStorages.Any(s => s.id.Equals(serviceStorageReference.id));
			if (!shouldKeep && !existsInRemote)
			{
				storages.RemoveAt(i);
			}
		}
		next.storageReference.Set(storages.ToArray());

		return new ManifestTransformOutput
		{
			next = next
		};
	}
	
	public static ManifestTransformOutput EnsureArchivedServicesAreDisabled(ManifestTransformArgs args)
	{
		var current = args.current;
		var remote = args.remote;
		var next = current.Copy();
		// if a service or storage is archived, then it cannot be enabled. 
		foreach (var service in next.manifest)
		{
			if (service.archived)
			{
				service.enabled = false;
			}
		}

		foreach (var storage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
		{
			if (storage.archived)
			{
				storage.enabled = false;
			}
		}
		return new ManifestTransformOutput
		{
			next = next
		};
	}
	
	public static ManifestTransformOutput EnsureOnlyActiveStoragesAreEnabled(ManifestTransformArgs args)
	{
		var current = args.current;
		var remote = args.remote;
		var next = current.Copy();
		var notes = new Dictionary<string, List<string>>();
		// there is a rule on the backend that a storage can only be enabled 
		//  IF there is an enabled service that is referencing that storage. 
		//  The rule exists to prevent folks from having unreachable storages. 
		//  NOTE: technically it is possible to get a secure connection string 
		//        to a remote storage, but it isn't currently a well designed UX.
		
		var referencedStorageIds = new HashSet<string>();
		
		// scan through all services and keep track of the referenced storage names
		{
			foreach (var service in next.manifest)
			{
				if (!service.enabled)
					// only accumulate referenced storage ids from services that are actually enabled. 
					//  otherwise, the storage is still "unreachable", because the service isn't running.
					continue;
				
				var deps = service.dependencies.GetOrElse(Array.Empty<ServiceDependencyReference>());
				foreach (var dep in deps)
				{
					referencedStorageIds.Add(dep.id);
				}
			}
		}

		// scan through storages, and identify those that weren't referenced
		{
			foreach (var storage in next.storageReference.GetOrElse(Array.Empty<ServiceStorageReference>()))
			{
				if (referencedStorageIds.Contains(storage.id))
					// this storage was referenced by an enabled service
					continue;

				if (!storage.enabled)
					// the storage is ALREADY disabled; so no need to do anything.
					continue; 
				
				storage.enabled = false;
				notes[storage.id] = new List<string>
				{
					"Is being disabled because it was not referenced by any active service. "
				};
			}
		}

		return new ManifestTransformOutput
		{
			next = next,
			beamoIdToNotes = notes
		};
	}

	public static string GetPlanTempFolder(IDependencyProvider provider)
	{
		// save the plan to a temp file
		var config = provider.GetService<ConfigService>();
		var logDir = Path.Combine(config.ConfigDirectoryPath, "temp", "plans");
		return logDir;
	}

	public static string GetLatestPlanFilePath(IDependencyProvider provider)
	{
		var logDir = GetPlanTempFolder(provider);
		if (!Directory.Exists(logDir)) return null;
		var info = new DirectoryInfo(logDir);
		var file = info.GetFiles().MaxBy(p => p.CreationTime);
		return file?.FullName;
	}
	
	public static async Task<string> SavePlanToTempFolder(IDependencyProvider provider, DeployablePlan plan)
	{
		var logDir = GetPlanTempFolder(provider);
		Directory.CreateDirectory(logDir);

		{ // delete files so that only the most recent 10 exist. 
			var info = new DirectoryInfo(logDir);
			var files = info.GetFiles().OrderByDescending(p => p.CreationTime).ToList();
			for (var i = 10; i < files.Count; i++)
			{
				Log.Verbose($"Deleting old plan file=[{files[i].Name}]");
				files[i].Delete();
			}
		}
			
		var planJson = JsonSerializable.ToJson(plan);
		var planPath = Path.Combine(logDir,$"plan-{DateTimeOffset.Now.ToUnixTimeMilliseconds()}.plan.json").LocalizeSlashes();
		Log.Verbose($"Saving plan: {planPath}");
		await File.WriteAllTextAsync(planPath, planJson);

		return planPath;
	}
	
	public static void PrintPlanNextSteps(string planFile, bool hasChanges)
	{
		var isSavingPlan = !string.IsNullOrEmpty(planFile);
		switch (isSavingPlan, hasChanges)
		{
			case (isSavingPlan: true, hasChanges: true):
				Log.Information($"To release, use `dotnet beam deploy release --plan {planFile}`");
				break;
			case (isSavingPlan: false, hasChanges: true):
				Log.Information(@"To release, either
 - re-run this command with the --to-file option, and then run `dotnet beam deploy release --plan <your-file>`, 
 - or run the `dotnet beam deploy release` command to create a plan and release it sequentially. ");
				break;
			case (isSavingPlan: _, hasChanges: false):
				Log.Information("Even though there are no changes, the `dotnet beam deploy release` command can still be used to roll the services. ");
				break;
		}
	}
	
	public static void PrintPlanInfo(DeployablePlan plan, IHasDeployPlanArgs args, out bool hasChanges)
	{
		var detectedChangeCount = PrintChangesAndNoticeChange(plan.diff.disabledServices, "Disabling", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.removedServices, "Removing", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.addedServices, "Adding", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.enabledServices, "Enabling", "service");
		detectedChangeCount += PrintChangesAndNoticeChangeT(plan.diff.serviceImageIdChanges, "Updating", "service");
		detectedChangeCount += PrintChangesAndNoticeChangeT(plan.diff.addedFederations, "Enabling", "federation");
		detectedChangeCount += PrintChangesAndNoticeChangeT(plan.diff.removedFederations, "Disabling", "federation");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.disabledStorages, "Disabling", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.removedStorage, "Removing", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.addedStorage, "Adding", "storage");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.diff.enabledStorages, "Enabling", "storage");
		detectedChangeCount += PrintChangesAndNoticeChangeT(plan.diff.servicesSwitchingLogProvider, "Switching LogProvider", "service");
		detectedChangeCount += PrintChangesAndNoticeChange(plan.servicesToUpload, "Uploading", "service");

		hasChanges = plan.diff.jsonChanges.Count > 0;
		var hasDetectedChanges = detectedChangeCount > 0;
		if (hasChanges)
		{
			if (!plan.ranHealthChecks && plan.servicesToUpload.Count > 0)
			{
				Log.Warning("Local Health-checks were not run! Services may work as expected, but they have not been explicitly tested locally. \n" +
				            "Consider re-running a plan command with the `--health` option. ");
			}
		}

		if (plan.notes?.Count > 0)
		{
			Log.Information("Notes:");
			foreach (var kvp in plan.notes)
			{
				Log.Information($" {kvp.Key}");
				foreach (var note in kvp.Value)
				{
					Log.Information($"   {note}");
				}
			}
		}

		switch (hasChanges, hasDetectedChanges)
		{
			case (true, true):
				if (detectedChangeCount == 1)
				{
					Log.Information("This plan has 1 pending change! ");
				}
				else
				{
					Log.Information($"This plan has {detectedChangeCount} pending changes! ");
				}

				if (args.UseLatestDeployedManifest)
				{
					Log.Warning("Somehow a change has been detected while trying to restart the services. Please try again, or contact Beamable. ");
				}
				break;
			case (true, false):
				Log.Information("This plan has uncommon changes! Please inspect the plan file for more details. ");
				break;
			case (false, false):
				if (args.UseLatestDeployedManifest)
				{
					Log.Information("There are no changes, because you are restarting the services.");
				}
				else
				{
					Log.Information("There are no changes.");
				}
				break;
			case (false, true):
				throw new CliException("The plan has an invalid detection. Please report this to Beamable");
		}


		int PrintChangesAndNoticeChangeT<T>(List<T> changes, string verb, string noun) where T : IServiceChangeDisplay
		{
			return PrintChangesAndNoticeChange(changes.Select(x => x.ToChangeString()).ToList(), verb, noun);
		}
		
		int PrintChangesAndNoticeChange(List<string> changes, string verb, string noun)
		{
			if (changes.Count == 0) return 0;
			var sb = new StringBuilder();
			sb.Append(verb);
			sb.Append(" ");
			sb.Append(changes.Count);
			sb.Append(" ");
			sb.AppendLine(changes.Count == 1 ? noun : $"{noun}s");
			for (var i = 0; i < changes.Count; i++)
			{
				sb.AppendLine($" - {changes[i].ToString()}");
			}
		
			Log.Warning(sb.ToString());
			return changes.Count;
		}
	}

	public static bool IsJsonAPlan(IDictionary<string, object> data)
	{
		return data != null
		        && data.ContainsKey(nameof(DeployablePlan.builtFromRemoteChecksum))
		        && data.ContainsKey(nameof(DeployablePlan.servicesToUpload))
		        && data.ContainsKey(nameof(DeployablePlan.manifest))
		        && data.ContainsKey(nameof(DeployablePlan.diff))
		        && data.ContainsKey(nameof(DeployablePlan.mode))
		        && data.ContainsKey(nameof(DeployablePlan.ranHealthChecks))
			;
	}
	public static bool IsJsonAManifest(IDictionary<string, object> data)
	{
		return data != null
		        && data.ContainsKey(nameof(ManifestView.checksum))
		        && data.ContainsKey(nameof(ManifestView.manifest))
		        && data.ContainsKey(nameof(ManifestView.id))
			// there are more fields we could check, btu this is "good enough"
			;
	}
	
	public static async Task<(DeployablePlan, List<BuildImageOutput>)> Plan<TArgs>(
		IDependencyProvider provider, 
		TArgs args,
		ProgressHandler progressHandler)
	where TArgs : CommandArgs, IHasDeployPlanArgs
	{
		const string FetchManifestProgressName = "fetching latest";
		const string MergingManifestProgressName = "calculating plan";

		
		var api = provider.GetService<IBeamoApi>();
		var beamo = provider.GetService<BeamoLocalSystem>();
		var beamoApi = provider.GetService<IBeamBeamoApi>();

		var isLoadingManifestFile = !string.IsNullOrEmpty(args.FromManifestFile);
		var isLoadingManifestId = !string.IsNullOrEmpty(args.ManifestId);
		var isLoadingMostRecent = args.UseLatestDeployedManifest;

		// TODO: explain the first step; set up util variables
		{
			// validate that we are only loading a manifest from one location.
			var sources = new bool[] { isLoadingManifestFile, isLoadingManifestId, isLoadingMostRecent };
			var sourceNames = new string[] { "--from-manifest", "--from-manifest-id", "--restart" };
			var requestedSources = sources.Count(x => x);

			if (requestedSources > 1)
			{
				var sb = new StringBuilder();
				sb.AppendLine("Cannot load a manifest from more than one location. Please only specify one of the following,");
				for (var i = 0; i < sources.Length && i < sourceNames.Length; i++)
				{
					if (sources[i])
					{
						sb.AppendLine("  " + sourceNames[i]);
					}
				}

				throw new CliException(sb.ToString());
			}
		}
		
		ManifestView localManifest = null;
		ManifestView remote = null;
		List<BuildImageOutput> localBuildReports = null;
		Task<(ManifestView, List<BuildImageOutput>)> localTask = null;
		
		progressHandler?.Invoke(FetchManifestProgressName, 0);
		var remoteTask = CreateReleaseManifestFromRealm(api);
		var beamoV2ManifestTask = CreateReleaseManifestFromRealmV2(beamoApi);

		// TODO: scope better; explain how to resolve remote and local manifest
		if (isLoadingManifestFile)
		{
			localTask = CreateReleaseManifestFromFile(provider, args.FromManifestFile, progressHandler);
		} else if (isLoadingManifestId)
		{
			localTask = CreateReleaseManifestFromId(provider, args.ManifestId, progressHandler);
		} else if (isLoadingMostRecent)
		{
			localTask = CreateReleaseManifestFromId(remoteTask);
		}
		else
		{
			var dockerStatus = await DockerStatusCommand.CheckDocker(provider);
			if (!dockerStatus.isDaemonRunning)
			{
				throw CliExceptions.DOCKER_NOT_RUNNING;
			}

			localTask = CreateReleaseManifestFromLocal(args, provider, beamo.BeamoManifest, progressHandler, useSequentialBuild: args.UseSequentialBuild, maxParallelCount: args.MaxParallelCount);
		}
		progressHandler?.Invoke(MergingManifestProgressName, 0);
		remote = await remoteTask;
		progressHandler?.Invoke(FetchManifestProgressName, 1);
		
		(localManifest, localBuildReports) = await localTask;

		{ // if there are ANY failures in the build, then the entire plan is a failure.
			if (localBuildReports.Any(r => !r.success))
			{
				return (null, localBuildReports);
			}
		}
		
		ManifestView next = null;
		DeploymentDiffSummary diff = null;
		
		switch (args.DeployMode)
		{
			case DeployMode.Additive:
				next = MergeAdditive(remote, localManifest);
				break;
			case DeployMode.Replace:
				next = MergeReplacement(remote, localManifest, beamo.BeamoManifest.LocallyIgnoredBeamoIds);
				break;
			default:
				throw new NotImplementedException(
					$"The only two supported deploy modes are {nameof(DeployMode.Additive)} and {nameof(DeployMode.Replace)}");
		}
		
		// process transforms
		var notes = new Dictionary<string, List<string>>();
		
		{
			var transforms = new List<Func<ManifestTransformArgs, ManifestTransformOutput>>
			{
				RemoveDisabledServicesThatWereNeverDeployed,
				EnsureArchivedServicesAreDisabled, 
				EnsureOnlyActiveStoragesAreEnabled, 
				EnsureEntriesHaveChecksums
			};
			for (var i = 0; i < transforms.Count; i++)
			{
				var r = .5f * ((i + 1f) / transforms.Count);
				var output = transforms[i](new ManifestTransformArgs
				{
					current = next, remote = remote, ignoreIds = beamo.BeamoManifest.LocallyIgnoredBeamoIds
				});
				next = output.next;
				if (output.beamoIdToNotes != null)
				{
					foreach (var kvp in output.beamoIdToNotes)
					{
						if (!notes.TryGetValue(kvp.Key, out var existingNotes))
						{
							notes[kvp.Key] = existingNotes = new List<string>();
						}
						existingNotes.AddRange(kvp.Value);
					}
				}
				
				progressHandler?.Invoke(MergingManifestProgressName, r);
			}
		}

		progressHandler?.Invoke(MergingManifestProgressName, .5f);
		diff = FindChanges(remote, next);
		
		if (!TryValidate(next, out var validationErrors))
		{
			throw new CliException($"The plan is invalid.\n{string.Join("\n -", validationErrors)}");
		}

		var servicesToUpload = new List<string>();
		{ 
			// calculate the set of services that actually need to build. 
			//  it is the intersection of services that have differing imageIds in remote/local, 
			//  AND those services that we just built locally. 
			//  If a service was not built locally, then we must assume the image already exists remotely. 
			foreach (var serviceInManifest in next.manifest)
			{
				// find the service in the local and remote
				var remoteService = remote.manifest.FirstOrDefault(x => x.serviceName == serviceInManifest.serviceName);
				
				// If an enabled service did not exist in the remote service OR any service had its imageId change relative to the one in the manifest, it means we have to upload this new image.  
				if ((serviceInManifest.enabled && remoteService == null) || (remoteService != null && serviceInManifest.imageId != remoteService.imageId)) 
					servicesToUpload.Add(serviceInManifest.serviceName);
			}
		}
		
		
		var beamoV2Manifest = await beamoV2ManifestTask;
		
		BeamoV2ServiceReference[] beamoV2ServiceReferences = beamoV2Manifest.serviceReferences.GetOrElse(Array.Empty<BeamoV2ServiceReference>());
		// Get Which services are going to upgrade to the new version
		if (beamoV2Manifest != null)
		{
			List<ServiceLogProviderChange> logProviderChanges = new List<ServiceLogProviderChange>();
			foreach (BeamoV2ServiceReference serviceRef in beamoV2ServiceReferences)
			{
				BeamoV2LogProvider localProvider =
					beamo.BeamoManifest.HttpMicroserviceLocalProtocols.TryGetValue(serviceRef.serviceName,
						out HttpMicroserviceLocalProtocol httpMicroserviceLocalProtocol)
						? httpMicroserviceLocalProtocol.DefaultLogProvider
						: BeamoV2LogProvider.Clickhouse;
				if (serviceRef.serviceName.HasValue && servicesToUpload.Contains(serviceRef.serviceName) &&
				    serviceRef.logProvider != localProvider)
				{
					logProviderChanges.Add( new ServiceLogProviderChange
					{
						service = serviceRef.serviceName,
						oldProvider = serviceRef.logProvider.GetOrElse(BeamoV2LogProvider.Cloudwatch).ToString(),
						newProvider = localProvider.ToString()
					});
				}
			}

			diff.servicesSwitchingLogProvider = logProviderChanges;
		}


		if (args.RunHealthChecks)
		{
			// start up all containers 
			foreach (var service in servicesToUpload)
			{
				var localService = next.manifest.FirstOrDefault(x => x.serviceName == service);
				if (localService == null)
					throw new CliException($"local service=[{service}] cannot be null. This is a beamable bug, please report");

				
				progressHandler?.Invoke("verifying " + service, 0);
				if (!beamo.BeamoManifest.TryGetDefinition(service, out var definition))
					throw new CliException($"local definition=[{service}] cannot be null. This is a beamable bug, please report");

				if (!beamo.BeamoManifest.HttpMicroserviceLocalProtocols.TryGetValue(service, out var http))
					throw new CliException($"local http service=[{service}] cannot be null. This is a beamable bug, please report");

				var container = BeamoLocalSystem.GetBeamIdAsMicroserviceContainer(definition.BeamoId);
				try
				{
					await beamo.StopContainer(container);
				}
				catch
				{
					// do nothing.
				}

				var routingKey = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine() + "_healthCheck";
				await beamo.RunLocalHttpMicroservice(definition, http, beamo, true, 
					CancellationToken.None, 
					disableInitHooks: true, // TODO: should we make this false?
					imageIdOverride: localService.imageId,
					routingKey: routingKey);
				progressHandler?.Invoke("verifying " + service, .5f);
				
				var routingHeader = $"{Beamable.Common.Constants.Requester.HEADER_ROUTINGKEY}=micro_{service}:{routingKey}";
				await RetryRequest(provider, container, service, routingHeader);
				
				progressHandler?.Invoke("verifying " + service, .9f);
				try
				{
					// stop the container to clean up.
					await beamo.StopContainer(container);
				}
				catch
				{
					// do nothing.
				}
				
				progressHandler?.Invoke("verifying " + service, 1);

				
			}
		}
		
		progressHandler?.Invoke(MergingManifestProgressName, 1);

		return (new DeployablePlan
		{
			ranHealthChecks = args.RunHealthChecks,
			builtFromRemoteChecksum = remote.checksum,
			mode = args.DeployMode,
			diff = diff,
			manifest = next,
			notes = notes,
			servicesToUpload = servicesToUpload,
			changeCount = diff.addedStorage.Count
			              + diff.removedStorage.Count
			              + diff.disabledStorages.Count
			              + diff.enabledStorages.Count
			              + diff.addedServices.Count
			              + diff.removedServices.Count
			              + diff.disabledServices.Count
			              + diff.enabledServices.Count
			              + diff.serviceImageIdChanges.Count
			              + diff.addedFederations.Count
			              + diff.removedFederations.Count
		}, localBuildReports);
	}

	
	private static async Promise<string> RetryRequest(IDependencyProvider provider, string containerName, string serviceName, string routingHeader)
	{
		var app = provider.GetService<IAppContext>();
		var url = $"/basic/{app.Cid}.{app.Pid}.micro_{serviceName}/admin/Metadata";
		var requester = provider.GetService<CliRequester>();
	
		var isRunning = false;
		string request = null;
	
		do
		{
			isRunning = false;
			try
			{
				request = await requester.CustomRequest(Method.GET, url, null, true, (s => s),
					customHeaders: new[] { routingHeader });
				Log.Verbose($"got response from health check for {containerName}");
			}
			catch (Exception e)
			{
				Log.Verbose($"Exception happened while trying to reach service Metadata endpoint. Message = [{e.Message}] Stacktrace = [{e.StackTrace}]");
				await Task.Delay(500); // Waiting a bit before retrying
				try
				{
					ContainerInspectResponse response = await provider.GetService<BeamoLocalSystem>().Client.Containers
						.InspectContainerAsync(containerName);
					isRunning = response.State.Running;
				}
				catch
				{
					isRunning = false;
				}
			}
	
		} while (isRunning);
	
		if (string.IsNullOrEmpty(request))
		{
			throw new CliException($"The service [{serviceName}] failed to register itself with Beamable.");
		}
	
		return request;
	}
	
	public static async Task Deploy(
		DeployablePlan plan, 
		IDependencyProvider provider, 
		ProgressHandler progressHandler, 
		CancellationTokenSource cts,
		Task<ManifestView> remoteManifestTask=null)
	{
		var api = provider.GetService<IBeamoApi>();
		var beamoApi = provider.GetService<IBeamBeamoApi>();
		var beamoService = provider.GetService<BeamoService>();
		var beamo = provider.GetService<BeamoLocalSystem>();

		var gamePidPromise = provider.GetService<IRealmsApi>().GetRealm();
		var dockerRegistryUrlPromise = beamoService.GetDockerImageRegistryUri();
		
		var beamoV2Manifest = await CreateReleaseManifestFromRealmV2(beamoApi);
		
		var remote = await (remoteManifestTask ?? CreateReleaseManifestFromRealm(api));
		var gamePid = (await gamePidPromise).FindRoot().Pid; // TODO I really think we should move this to _ctx/ConfigService and grab it during init...
		var dockerRegistryUrl = await dockerRegistryUrlPromise;

		if (remote.checksum != plan.builtFromRemoteChecksum)
		{
			throw new CliException(
				"The given deployment plan was created with a different configuration of remote services than exists now. Please create a new plan and try again.");
		}
		
		// identity the services we need to upload.
		var uploadTasks = new List<Task>();
		
		var servicesToUpload = new HashSet<string>(plan.servicesToUpload);

		if (servicesToUpload.Count > 0)
		{
			var dockerStatus = await DockerStatusCommand.CheckDocker(provider);
			if (!dockerStatus.isDaemonRunning)
			{
				throw CliExceptions.DOCKER_NOT_RUNNING;
			}
		}
		
		foreach (var service in plan.manifest.manifest)
		{
			var needsUpload = servicesToUpload.Contains(service.serviceName);
			if (!needsUpload)
				continue;

			var serviceName = service.serviceName;
			var progressTaskName = $"upload {serviceName}";
			var uploadTask = ServiceUploadUtil.Upload(
				provider: provider,
				beamoId: service.serviceName,
				imageId: service.imageId, 
				gamePid: gamePid,
				dockerRegistryUrl: dockerRegistryUrl, 
				cts: cts, 
				onProgressCallback: progressRatio =>
				{
					progressHandler?.Invoke(progressTaskName, progressRatio, serviceName: serviceName);
				});

			uploadTasks.Add(uploadTask);
		}

		progressHandler?.Invoke("publish", 0);
		await Task.WhenAll(uploadTasks);

		cts.Token.ThrowIfCancellationRequested();
		
		// publish manifest. 
		// ConvertToBeamoV2 will change the Legacy DTO to the BeamoV2 DTO.
		BeamoV2ServiceReference[] beamoV2ServiceReferences = plan.manifest.manifest.ConvertToBeamoV2();

		Dictionary<string, BeamoV2LogProvider> servicesDefaultProvider = beamoV2ServiceReferences
			.Where(reference => reference.serviceName.HasValue &&
			                    beamo.BeamoManifest.HttpMicroserviceLocalProtocols.ContainsKey(reference.serviceName
				                    .Value)).ToDictionary(reference => reference.serviceName.Value,
				reference => beamo.BeamoManifest.HttpMicroserviceLocalProtocols[reference.serviceName.Value].DefaultLogProvider);
			
		
		SetServicesLogProvider(beamoV2ServiceReferences, servicesToUpload, beamoV2Manifest, servicesDefaultProvider);
		
		var beamoV2PostManifestRequest = new BeamoV2PostManifestRequest
		{
			manifest = new OptionalArrayOfBeamoV2ServiceReference(beamoV2ServiceReferences),
			storageReferences = new OptionalArrayOfBeamoV2ServiceStorageReference()
			{
				HasValue = plan.manifest.storageReference.HasValue, Value = plan.manifest.storageReference.Value.ConvertToBeamoV2(),
			},
			autoDeploy = true,
			comments = plan.manifest.comments,
		};
		
		progressHandler?.Invoke("publish", .1f, false);
		
		await beamoApi.PostManifests(beamoV2PostManifestRequest);
		
		progressHandler?.Invoke("publish", 1, false);

	}

	private static void SetServicesLogProvider(BeamoV2ServiceReference[] beamoV2ServiceReferences, HashSet<string> servicesToUpload,
		BeamoV2Manifest beamoV2Manifest, Dictionary<string, BeamoV2LogProvider> servicesDefaultProvider)
	{
		foreach (BeamoV2ServiceReference reference in beamoV2ServiceReferences)
		{
			
			BeamoV2LogProvider logProvider;
			bool serviceWillBeUploaded = reference.serviceName.HasValue && servicesToUpload.Contains(reference.serviceName.Value);
			if (serviceWillBeUploaded && servicesDefaultProvider.TryGetValue(reference.serviceName, out var defaultLogProvider))
			{
				logProvider = defaultLogProvider;
			}
			else
			{
				logProvider = GetLogProviderFromManifest(reference.serviceName);
			}
			
			reference.logProvider = new OptionalBeamoV2LogProvider(logProvider);
		}

		BeamoV2LogProvider GetLogProviderFromManifest(string serviceName)
		{
			if (beamoV2Manifest == null || !beamoV2Manifest.serviceReferences.HasValue ||
			    beamoV2Manifest.serviceReferences.Value.All(service => service.serviceName != serviceName))
			{
				return BeamoV2LogProvider.Clickhouse;
			}
			
			var serviceReference = beamoV2Manifest.serviceReferences.Value
				.FirstOrDefault(item => item.serviceName == serviceName);
			
			return serviceReference?.logProvider.GetOrElse(BeamoV2LogProvider.Cloudwatch) 
			       ?? BeamoV2LogProvider.Clickhouse;
		}
	}

	public static async Task<ManifestView> CreateReleaseManifestFromRealm(IBeamoApi beamo)
	{
		try
		{
			var current = await beamo.GetManifestCurrent();
			return current.manifest;
		}
		catch (RequesterException requesterException) when (requesterException.Status == 404)
		{
			// there is no existing manifest.
			return new ManifestView
			{
				manifest = Array.Empty<ServiceReference>(),
				storageReference = new OptionalArrayOfServiceStorageReference(Array.Empty<ServiceStorageReference>())
			};
		}
	}

	public static async Task<BeamoV2Manifest> CreateReleaseManifestFromRealmV2(IBeamBeamoApi beamBeamo)
	{
		try
		{
			return await beamBeamo.GetManifestsCurrent();
		}
		catch (RequesterException requesterException) when (requesterException.Status == 404)
		{
			return new BeamoV2Manifest();
		}
	}

	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromId(IDependencyProvider provider, string manifestId, ProgressHandler progressHandler)
	{
		var api = provider.GetService<IBeamoApi>();
		progressHandler?.Invoke("fetching manifest", 0);
		var manifest = await api.GetManifest(manifestId);
		progressHandler?.Invoke("fetching manifest", 1);
		return (manifest.manifest, new List<BuildImageOutput>());
	}
	
	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromId(Task<ManifestView> remoteTask)
	{
		var manifest = await remoteTask;
		return (manifest, new List<BuildImageOutput>());
	}

	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromFile(IDependencyProvider provider, string manifestFile, ProgressHandler progressHandler)
	{
		const string ReadingLocalManifestProgressName = "reading manifest file";

		progressHandler?.Invoke(ReadingLocalManifestProgressName, 0);
		var manifestJson = await File.ReadAllTextAsync(manifestFile);
		var data = Json.Deserialize(manifestJson) as IDictionary<string, object>;
		if (!IsJsonAManifest(data))
		{
			if (IsJsonAPlan(data))
			{
				throw new CliException(
					$"The file=[{manifestFile}] appears to contain a plan file, but should contain a manifest. " +
					$"To use the plan, use the `--from-plan` option.");
			}

			throw new CliException($"The file=[{manifestFile}] does not contain a valid plan file");
		}
			
			
		progressHandler?.Invoke(ReadingLocalManifestProgressName, 1);

		
		var localManifest = JsonSerializable.FromJson<ManifestView>(manifestJson);
		return (localManifest, new List<BuildImageOutput>());
	}
	
	public static async Task<(ManifestView, List<BuildImageOutput>)> CreateReleaseManifestFromLocal<TArg>(TArg slnArg, IDependencyProvider provider, BeamoLocalManifest localManifest, ProgressHandler progressHandler, bool useSequentialBuild=false, int maxParallelCount=8)
		where TArg : CommandArgs, IHasSolutionFileArg
	{
		var services = new ServiceReference[localManifest.HttpMicroserviceLocalProtocols.Count];
		var storages = new ServiceStorageReference[localManifest.EmbeddedMongoDbLocalProtocols.Count];

		var serviceIndex = 0;
		var storageIndex = 0;
		var pendingTasks = new List<Task<(ServiceReference, BuildImageOutput, int)>>();
		var buildReports = new List<BuildImageOutput>();
		
		// build all the local services first as a solution level build.
		var beamoIdToReport = new Dictionary<string, BuildImageSourceOutput>();
		if (!useSequentialBuild)
		{
			// when using a sequential build; we'll fall back to one at a time
			beamoIdToReport = await BuildSolutionCommand.Build(slnArg, forDeployment: true, forceCpu: true);
		}

		for (var i = 0; i < localManifest.ServiceDefinitions.Count; i++)
		{
			var definition = localManifest.ServiceDefinitions[i];
			if (!definition.IsLocal)
				// this function is explicitly about creating services from local source code.
				continue;
			
			switch (definition.Protocol)
			{
				case BeamoProtocolType.HttpMicroservice:

					var index = serviceIndex++;
					progressHandler?.Invoke(BUILD_PROGRESS_PREFIX + definition.BeamoId, 0, serviceName: definition.BeamoId);
					beamoIdToReport.TryGetValue(definition.BeamoId, out var existingBuildReport);
					var buildTask = CreateServiceReference(
						provider, 
						definition, 
						localManifest.HttpMicroserviceLocalProtocols[definition.BeamoId],
						progressHandler, 
						index,
						existingSourceReport: existingBuildReport
					);
					
					pendingTasks.Add(buildTask);
					if (useSequentialBuild)
					{
						await buildTask;
					}
					else
					{
						// Throttle parallel builds to avoid memory exhaustion
						// Wait for at least one task to complete if we've reached the limit
						var incompleteTasks = pendingTasks.Where(t => !t.IsCompleted).ToList();
						while (incompleteTasks.Count >= maxParallelCount)
						{
							await Task.WhenAny(incompleteTasks);
							incompleteTasks = pendingTasks.Where(t => !t.IsCompleted).ToList();
						}
					}
					break;
				case BeamoProtocolType.EmbeddedMongoDb:
					storages[storageIndex++] = CreateStorageReference(
						definition,
						localManifest.EmbeddedMongoDbLocalProtocols[definition.BeamoId]
					);
					break;
			}
		}

		try
		{
			var results = await Task.WhenAll(pendingTasks);
			foreach (var (reference, output, index) in results)
			{
				services[index] = reference;
				buildReports.Add(output);
			}
		}
		catch (Exception)
		{
			Log.Error("Failed to collect build report.");
			foreach (var task in pendingTasks)
			{
				if (task.IsFaulted)
				{
					Log.Error($"- Inner build report failure. message=[{task.Exception.Message}]");
				}
			}
			throw;
		}

		return (new ManifestView
		{
			manifest = services,
			storageReference = new OptionalArrayOfServiceStorageReference(storages)
		}, buildReports);
	}

	static ServiceStorageReference CreateStorageReference(
		BeamoServiceDefinition definition,
		EmbeddedMongoDbLocalProtocol mongo)
	{
		
		var reference = new ServiceStorageReference
		{
			storageType = "mongov1",
			archived = false,
			enabled = definition.ShouldBeEnabledOnRemote,
			templateId = "small",
			id = definition.BeamoId,
		};
		
		return reference;
	}



	public const string BUILD_PROGRESS_PREFIX = "build ";

	static async Task<(ServiceReference, BuildImageOutput, int)> CreateServiceReference(
		IDependencyProvider provider,
		BeamoServiceDefinition definition,
		HttpMicroserviceLocalProtocol http,
		ProgressHandler progressHandler, 
		int serviceIndex,
		BuildImageSourceOutput existingSourceReport=default
		)
	{
		string imageId = null;
		BuildImageOutput report = default;
		string stopServiceReason = "Stopped service to generate Release Plan.";
		if (definition.ShouldBeEnabledOnRemote)
		{
			var progressName = BUILD_PROGRESS_PREFIX + definition.BeamoId;
			try
			{
				progressHandler?.Invoke(progressName, .01f, serviceName: definition.BeamoId);
				var sb = new StringBuilder();
				report = await ServicesBuildCommand.Build(provider, definition.BeamoId,
					forceCpu: true,
					
					// passing in the report may prevent the actual build from happening!
					//  this makes sense when a solution-level build has ALREADY happened. 
					report: existingSourceReport,
					logMessage: log =>
					{
						sb.AppendLine(log.message);
						if (log.isFailure)
						{
							Log.Error($"Failed to build service=[{definition.BeamoId}]\n{sb.ToString()}");
						}
					}, progressMessage: progress =>
					{
						progressHandler?.Invoke(progressName, progress.Ratio, serviceName: definition.BeamoId);
					});
				progressHandler?.Invoke(progressName, 1);
				imageId = report.ShortImageId;
			}
			catch (Exception ex)
			{
				progressHandler?.Invoke(progressName, -1, serviceName: definition.BeamoId);
				Log.Error($"Could not build service=[{definition.BeamoId}] message=[{ex.Message}] stack=[{ex.StackTrace}]");
				imageId = null;
			}
		}  else
		{
			report = new BuildImageOutput { success = true };
			progressHandler?.Invoke("skip  " + definition.BeamoId, 1, serviceName: definition.BeamoId);
		}

		// reload the federation definition to use whatever was in the latest build.
		//  because we are publishing, we are building a unix version of the service,
		//  which means we cannot RUN the built version.
		//  To get the federation data from the oapi, we need to make sure there is a 
		//  clean version of the oapi document... That can be generated via a native
		//  `dotnet run` invocation. 
		{
			char separator = Path.DirectorySeparatorChar;
			var targetFramework = http.Metadata.msbuildProject.GetProperty("TargetFramework").EvaluatedValue;
			var targetReleaseFolder = $"Release{separator}{targetFramework}{separator}unix-x64";

			var releaseOapiPath = definition.OpenApiPath.Replace(
				$"{separator}Debug{separator}{targetFramework}{separator}",
				$"{separator}{targetReleaseFolder}{separator}");

			var command = CliExtensions.GetDotnetCommand(provider.GetService<IAppContext>().DotnetPath,
					$"run --project {definition.ProjectPath} --generate-oapi")
				.WithEnvironmentVariables(new Dictionary<string, string>
					{
						["DOTNET_WATCH_SUPPRESS_EMOJIS"] = "1",
						["DOTNET_WATCH_RESTART_ON_RUDE_EDIT"] = "1",
						["OPEN_API_OUTPUT_PATH"] = Path.Combine(definition.ProjectDirectory, "bin", "Release",
							targetFramework, "unix-x64"),
						["BEAM_STOP_SERVICE_REASON"] = stopServiceReason
					}
				)
				.WithStandardOutputPipe(PipeTarget.ToDelegate(line =>
				{
					if (line == null) return;
					Log.Debug($"generate oapi service=[{definition.BeamoId}] output=[{line}]");
				}))
				.WithStandardErrorPipe(PipeTarget.ToDelegate(line =>
				{
					if (line == null) return;
					Log.Error($"generate oapi service=[{definition.BeamoId}] error=[{line}]");
				}))
				.WithValidation(CommandResultValidation.None)
				.ExecuteAsync();
			await command;

			definition.FederationsConfig = await BeamoServiceDefinition.ReloadFederationsData(releaseOapiPath);
		}
		
		var feds = definition.FederationsConfig?.Federations ?? new FederationsConfig();
		var components = feds.SelectMany(kvp =>
		{
			return kvp.Value.Select(x => new ServiceComponent
			{
				name = $"{x.Interface}/{kvp.Key}"
			});
		}).ToArray();
		
		var reference = new ServiceReference
		{
			serviceName = definition.BeamoId,
			enabled = definition.ShouldBeEnabledOnRemote,
			templateId = "small",
			archived = false,
			imageId = imageId,
			components = new OptionalArrayOfServiceComponent(components),
			dependencies = new OptionalArrayOfServiceDependencyReference(http.StorageDependencyBeamIds.Select(x => new ServiceDependencyReference
			{
				storageType = "mongov1",
				id = x
			}).ToArray())
		};
		
		return (reference, report, serviceIndex);
	}
}
