using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Auth;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Server;
using Serilog;
using System.CommandLine;

namespace cli.TokenCommands;


public class GetTokenDetailsCommandArgs : CommandArgs
{
	public string token;
	public bool autoResolve;
}

public class GetTokenDetailsCommandOutput
{
	public bool wasRefreshToken;
	public OptionalLong accountId = new OptionalLong();
	public long cid;
	public long created;
	public OptionalString device = new OptionalString();
	public OptionalLong expiresMs = new OptionalLong();
	public OptionalLong gamerTag = new OptionalLong();
	public OptionalString pid = new OptionalString();
	public OptionalString platform = new OptionalString();
	public OptionalBool revoked = new OptionalBool();
	public OptionalArrayOfString scopes = new OptionalArrayOfString();
	public string token;
	public string type;
}

public class GetTokenDetailsCommand : AtomicCommand<GetTokenDetailsCommandArgs, GetTokenDetailsCommandOutput>
{
	public GetTokenDetailsCommand() : base("inspect", "get token information")
	{
	}

	public override void Configure()
	{
		AddOption(new Option<bool>(name: "--resolve",
				getDefaultValue: () => false,
			description: "this command normally only works for an access token. However, if this option is enabled and a refresh token is given, then it will be automatically converted to the access token and this command is rerun"), 
			(args, b) => args.autoResolve = b, 
			new string[]{"-r"});
		
		var tokenOpt = new Option<string>("--token",
			"the token that you want to get information for. This must be an access token. By default, the current access token of the .beamable context is used");
		tokenOpt.AddAlias("-t");
		AddOption(tokenOpt, (args, context, value) =>
		{
			if (!string.IsNullOrEmpty(value))
			{
				args.token = value;
				return;
			}
			
			var provider = context.GetService<AppServices>();
			var ctx = provider.GetService<IAppContext>();
			args.token = ctx.Token.Token;
			return;
		});
	}

	public static async Promise<(Token, bool)> ResolveToken(CommandArgs args, bool autoResolve, string token)
	{
		token = token?.Replace("\"", "");

		Token res = null;
		var api = args.Provider.GetService<IAuthApi>();
		var wasRefresh = false;
		try
		{
			res = await api.GetToken(token, false);
		}
		catch (RequesterException ex) when (ex.Status == 401 && ex.RequestError.error == "TokenValidationError")
		{
			if (!autoResolve)
			{
				Log.Warning("the given token was a refresh-token. Pass the `-r` flag to automatically resolve it.");
				throw;
			}
			Log.Information("The given token was a refresh-token");
			wasRefresh = true;

			var newToken = await api.PostToken(new TokenRequestWrapper { refresh_token = token, grant_type = "refresh_token" }, false);
			res = await api.GetToken(newToken.access_token, false);
		}

		return (res, wasRefresh);
	}

	public override async Task<GetTokenDetailsCommandOutput> GetResult(GetTokenDetailsCommandArgs args)
	{
		Log.Information("Checking for token " + args.token);

		var api = new AccountsApi(args.Requester);
		
		var (res, wasRefresh) = await ResolveToken(args, args.autoResolve, args.token);
		return new GetTokenDetailsCommandOutput
		{
			wasRefreshToken = wasRefresh,
			accountId = res.accountId,
			platform = res.platform,
			gamerTag = res.gamerTag,
			created = res.created,
			scopes = res.scopes,
			expiresMs = res.expiresMs,
			type = res.type,
			device = res.device,
			revoked = res.revoked,
			token = res.token,
			cid = res.cid,
			pid = res.pid,
			
		};
	}
}
