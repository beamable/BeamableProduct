using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Auth;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.BeamCli;
using Beamable.Server;
using System.CommandLine;

namespace cli.TokenCommands;


public class GetTokenDetailsCommandArgs : CommandArgs
{
	public string token;
	public bool autoResolve;
}

public class GetTokenDetailsCommandOutput
{
	public bool wasRefreshToken;
	public long accountId;
	public long cid;
	public long created;
	public string device;
	public long expiresMs;
	public long gamerTag;
	public string pid;
	public string platform;
	public bool revoked;
	public string[] scopes;
	public string token;
	public string type;
}

public class InvalidTokenErrorOutput : ErrorOutput
{
	public string refreshToken;
}

public class GetTokenDetailsCommand : AtomicCommand<GetTokenDetailsCommandArgs, GetTokenDetailsCommandOutput>,
	IReportException<InvalidTokenErrorOutput>, ISkipManifest
{
	public GetTokenDetailsCommand() : base("inspect", "Get token information")
	{
	}

	public override void Configure()
	{
		AddOption(new Option<bool>(name: "--resolve",
				getDefaultValue: () => false,
			description: "This command normally only works for an access token. However, if this option is enabled and a refresh token is given, then it will be automatically converted to the access token and this command is rerun"), 
			(args, b) => args.autoResolve = b, 
			new string[]{"-r"});
		
		var tokenOpt = new Option<string>("--token",
			"The token that you want to get information for. This must be an access token. By default, the current access token of the .beamable context is used");
		tokenOpt.AddAlias("-t");
		AddOption(tokenOpt, (args, context, value) =>
		{
			if (!string.IsNullOrEmpty(value))
			{
				args.token = value;
				return;
			}
			
			var provider = context.GetService<AppServices>();
			var ctx = provider.GetService<IAppContext>();
			args.token = ctx.Token.Token;
			return;
		});
	}

	public static async Promise<(Token, bool)> ResolveToken(CommandArgs args, bool autoResolve, string token)
	{
		token = token?.Replace("\"", "");

		Token res = null;
		var api = args.Provider.GetService<IAuthApi>();
		var wasRefresh = false;
		try
		{
			res = await api.GetToken(token, false);
		}
		catch (RequesterException ex) when (ex.Status == 401 && ex.RequestError.error == "TokenValidationError")
		{
			throw new CliException<InvalidTokenErrorOutput>(
				"The given token was a refresh-token. You must pass an access-token")
			{
				payload = new InvalidTokenErrorOutput
				{
					refreshToken = token,
				}
			};
			
			// // TODO: it isn't a good idea to generate a new access token for this use-case :( 
			// if (!autoResolve)
			// {
			// 	Log.Warning("the given token was a refresh-token. Pass the `-r` flag to automatically resolve it.");
			// 	throw;
			// }
			// Log.Information("The given token was a refresh-token");
			// wasRefresh = true;
			//
			// var newToken = await api.PostToken(new TokenRequestWrapper { refresh_token = token, grant_type = "refresh_token" }, false);
			// res = await api.GetToken(newToken.access_token, false);
		}

		return (res, wasRefresh);
	}

	public override async Task<GetTokenDetailsCommandOutput> GetResult(GetTokenDetailsCommandArgs args)
	{
		Log.Information("Checking for token " + args.token);

		var api = new AccountsApi(args.Requester);
		
		var (res, wasRefresh) = await ResolveToken(args, args.autoResolve, args.token);
		
		return new GetTokenDetailsCommandOutput
		{
			wasRefreshToken = wasRefresh,
			accountId = res.accountId,
			platform = res.platform,
			gamerTag = res.gamerTag,
			created = res.created,
			scopes = res.scopes,
			expiresMs = res.expiresMs,
			type = res.type,
			device = res.device,
			revoked = res.revoked,
			token = res.token,
			cid = res.cid,
			pid = res.pid,
			
		};
	}
}
