using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.BeamCli;
using cli.Services.Content;
using Microsoft.Extensions.DependencyInjection;

namespace cli.Content;

public class ContentLocalManifestCommand : AtomicCommand<ContentLocalManifestCommandArgs, LocalContentState>
{
	private ContentService _contentService;

	public ContentLocalManifestCommand() : base("local-manifest", "Gets the current local manifest")
	{
	}

	public override bool IsForInternalUse => true;

	public override void Configure()
	{
		AddOption(ContentCommand.MANIFESTS_FILTER_OPTION, (args, s) => args.ManifestFilter = s);
	}

	public override async Task<LocalContentState> GetResult(ContentLocalManifestCommandArgs args)
	{
		_contentService = args.ContentService;

		var contentApi = args.Provider.GetService<IContentApi>();
		var manifests = await contentApi.GetManifestChecksums();
		var existingManifestIds = manifests.manifests.Select(m => m.id).ToArray();

		// Make sure the given manifests are valid.
		var manifestsToGet = args.ManifestFilter;
		if (args.ManifestFilter.Length == 0)
		{
			manifestsToGet = existingManifestIds;
		}
		else
		{
			var invalidManifestIds = existingManifestIds.Where(id => !manifestsToGet.Contains(id)).ToArray();
			if (invalidManifestIds.Length != 0)
			{
				throw new CliException($"Content Manifests Not Found. MANIFEST_IDS_NOT_FOUND=[{invalidManifestIds}], AVAILABLE_IDS=[{existingManifestIds}]");
			}
		}

		var localManifests = new List<LocalContentManifest>(manifestsToGet.Length);

		// Make requests for all local manifests
		var allLocalStates = new List<(string manifestId, Promise<List<LocalContent>> promise)>();
		foreach (string manifestId in manifestsToGet)
		{
			var localContentCache = _contentService.GetLocalCache(manifestId);
			allLocalStates.Add((manifestId, localContentCache.GetLocalContentStatus()));
		}

		// Wait for all the local manifests
		_ = await Promise.Sequence(allLocalStates.Select(t => t.promise).ToList());

		for (int i = 0; i < allLocalStates.Count; i++)
		{
			var manifestId = allLocalStates[i].manifestId;
			var localState = allLocalStates[i].promise.GetResult();

			var localManifest = new LocalContentManifest();
			localManifest.Entries = new LocalContentManifestEntry[localState.Count];
			for (int entryIdx = 0; entryIdx < localState.Count; entryIdx++)
			{
				var localContent = localState[entryIdx];
				var lastDotIdx = localContent.contentId.LastIndexOf(".", StringComparison.Ordinal);

				localManifest.Entries[entryIdx] = new LocalContentManifestEntry()
				{
					FullId = localContent.contentId,
					TypeName = localContent.contentId[..lastDotIdx],
					Name = localContent.contentId[(lastDotIdx + 1)..],
					CurrentStatus = (int)localContent.status,
					Tags = localContent.tags,
					Hash = localContent.hash,
				};
			}

			localManifest.ManifestId = manifestId;
			localManifests.Add(localManifest);
		}

		return new LocalContentState() { Manifests = localManifests.ToArray() };
	}
}

public class ContentLocalManifestCommandArgs : ContentCommandArgs
{
	public string[] ManifestFilter;
}

[CliContractType]
public struct LocalContentManifestEntry
{
	public string FullId;
	public string TypeName;
	public string Name;

	/// <summary>
	/// Tied to <see cref="ContentStatus"/>.
	/// </summary>
	public int CurrentStatus;

	public string Hash;

	public string[] Tags;
}

[CliContractType]
public class LocalContentManifest
{
	public string ManifestId;
	public LocalContentManifestEntry[] Entries;
}

[CliContractType]
public class LocalContentState
{
	public LocalContentManifest[] Manifests;
}
