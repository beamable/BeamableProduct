using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.BeamCli;
using Beamable.Common.Content;
using Beamable.Serialization;
using cli.Services.Content;
using cli.Utils;
using Serilog;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Text.RegularExpressions;
using System.Threading.Channels;
using ContentDefinition = Beamable.Api.Autogenerated.Models.ContentDefinition;

namespace cli.Content;

public class LocalContentFileChanges
{
	public List<ChangedContentFile> AllFileChanges;
}

public struct RemoteContentPublished
{
	public string OwnerCid;
	public string OwnerPid;
	public string PublisherGamerTag;
	public string ReferenceUid;
}

public struct ChangedContentFile
{
	public string OwnerPid;
	public string OwnerManifestId;

	public string OldContentId;
	public string ContentId;

	public string FullFilePath;
	public string OldFullFilePath;

	public bool WasDeleted() => string.IsNullOrEmpty(FullFilePath) && !string.IsNullOrEmpty(OldFullFilePath);
	public bool WasRenamed() => !WasDeleted() && FullFilePath != OldFullFilePath;
	public bool WasCreated() => !string.IsNullOrEmpty(FullFilePath) && string.IsNullOrEmpty(OldFullFilePath);
	public bool WasChanged() => !WasCreated() && !WasDeleted() && FullFilePath == OldFullFilePath;
}

/// <summary>
/// Helper struct built by <see cref="ContentService.GetAllContentFiles"/>.
/// </summary>
public struct LocalContentFiles
{
	public string ManifestId;
	public ClientManifestJsonResponse ReferenceManifest;
	public List<ContentFile> ContentFiles;
	public Dictionary<string, ContentFile> PerIdContentFiles;
}

/// <summary>
/// Filters that can be applied to <see cref="ContentService.FilterLocalContentFiles"/> to get a subset of content files.
/// </summary>
public enum ContentFilterType
{
	/// <summary>
	/// Matches the given array of filters as though they were fully formed ContentIds.
	/// </summary>
	ExactIds,

	/// <summary>
	/// Matches the given array of filters as though they were fully formed ContentTypeIds.
	/// The comparison is a StartsWith so... 'items' will return ANY item or its subclasses.
	/// </summary>
	TypeHierarchy,

	/// <summary>
	/// Matches the given array of filters as though they were fully formed ContentTypeIds.
	/// The comparison is an equals so... 'items' will return only content files that are exactly of the `items` content type (no subclasses).
	/// </summary>
	TypeHierarchyStrict,

	/// <summary>
	/// Matches the given array of filters as though they were C# regexes.
	/// </summary>
	Regexes,

	/// <summary>
	/// Matches the given array of filters as though they were tags.
	/// Any content file that has any of the filter tags will be included in the filtered list.
	/// </summary>
	Tags,
}

public class ContentService
{
	private const int ERR_CODE_PUBLISH_FAILED_INVALID_REFERENCE_MANIFEST = 3;

	private readonly CliRequester _requester;
	private readonly ConfigService _config;
	private readonly IContentApi _contentApi;

	private readonly Channel<ChangedContentFile> _channelChangedContentFiles;
	private readonly Channel<RemoteContentPublished> _channelRemoteContentPublishes;
	private readonly ThreadLocal<Random> _rng;

	public ContentService(CliRequester requester, ConfigService config, IContentApi api)
	{
		_requester = requester;
		_config = config;
		_contentApi = api;

		_rng = new ThreadLocal<Random>(() => new Random(DateTime.Now.Millisecond));

		_channelChangedContentFiles = Channel.CreateUnbounded<ChangedContentFile>(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = false, AllowSynchronousContinuations = true, });
		_channelRemoteContentPublishes = Channel.CreateUnbounded<RemoteContentPublished>(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = false, AllowSynchronousContinuations = true, });
	}

	private string RootContentPath => Path.Combine(_config.ConfigDirectoryPath!, Constants.CONTENT_DIRECTORY);
	private string ContentLocalConfigPath => Path.Combine(_config.ConfigTempDirectoryPath!, Constants.CONFIG_LOCAL_CONTENT);

	private IEnumerable<string> GetPidsWithCachedLocalContent() => Directory.EnumerateDirectories(RootContentPath);

	public string EnsureContentPathForRealmExists(string pid, string manifest = "global")
	{
		var path = Path.Combine(RootContentPath, pid, manifest);
		if (!Directory.Exists(path)) Directory.CreateDirectory(path);
		return path;
	}

	public async IAsyncEnumerable<LocalContentFileChanges> ListenToLocalContentFileChanges(string pid, string manifestId = "global", [EnumeratorCancellation] CancellationToken token = default)
	{
		var watcher = new FileSystemWatcher();
		watcher.BeginInit();
		watcher.Path = EnsureContentPathForRealmExists(pid, manifestId);
		watcher.IncludeSubdirectories = true;
		watcher.Filter = "*.*";
		watcher.EnableRaisingEvents = true;
		watcher.Created += async (_, e) => await OnLocalRealmContentFilesChanged(e);
		watcher.Deleted += async (_, e) => await OnLocalRealmContentFilesChanged(e);
		watcher.Renamed += async (_, e) => await OnLocalRealmContentFilesChanged(e);
		watcher.Changed += async (_, e) => await OnLocalRealmContentFilesChanged(e);
		watcher.EndInit();

		// TODO: Get the local reference manifest for this guy and... we keep track
		// TODO: Usage of the Content PS command is:
		// TODO:  - Every time you change the local reference, you need to stop and re-run this command.
		// TODO:  - Must be run ONCE per realm you care about.

		// Keep waiting for messages from the set up file watcher.
		var reader = _channelChangedContentFiles.Reader;

		while (await reader.WaitToReadAsync(token))
		{
			// If the operation was cancelled, we break out.
			if (token.IsCancellationRequested)
				break;

			// We sleep a bit to make sure all the file changes from a multi-edit operation show up in a single batch.
			Thread.Sleep(15);

			// Get all the files that were changed respecting the PID filter.
			var batchedChanges = new LocalContentFileChanges() { AllFileChanges = new() };
			while (reader.TryRead(out var changed))
			{
				if (changed.OwnerPid == pid)
				{
					batchedChanges.AllFileChanges.Add(changed);
				}
			}

			yield return batchedChanges;
		}

		yield break;

		async Task OnLocalRealmContentFilesChanged(FileSystemEventArgs e)
		{
			await Task.Run(() =>
			{
				if (e.ChangeType == WatcherChangeTypes.Created)
				{
					var changedContent = new ChangedContentFile { OwnerPid = pid };
					changedContent.OwnerPid = pid;
					changedContent.OwnerManifestId = manifestId;

					changedContent.ContentId = Path.GetFileNameWithoutExtension(e.Name);
					changedContent.FullFilePath = e.FullPath;
					changedContent.OldContentId = "";
					changedContent.OldFullFilePath = "";
					_channelChangedContentFiles.Writer.TryWrite(changedContent);
				}
				else if (e.ChangeType == WatcherChangeTypes.Deleted)
				{
					var changedContent = new ChangedContentFile { OwnerPid = pid };
					changedContent.OwnerPid = pid;
					changedContent.OwnerManifestId = manifestId;

					changedContent.ContentId = changedContent.OldContentId = Path.GetFileNameWithoutExtension(e.Name);
					changedContent.FullFilePath = "";
					changedContent.OldFullFilePath = e.FullPath;

					_channelChangedContentFiles.Writer.TryWrite(changedContent);
				}
				else if (e.ChangeType == WatcherChangeTypes.Changed)
				{
					var changedContent = new ChangedContentFile { OwnerPid = pid };
					changedContent.OwnerPid = pid;
					changedContent.OwnerManifestId = manifestId;
					changedContent.ContentId = changedContent.OldContentId = Path.GetFileNameWithoutExtension(e.Name);
					changedContent.FullFilePath = changedContent.OldFullFilePath = e.FullPath;
					_channelChangedContentFiles.Writer.TryWrite(changedContent);
				}
				else if (e.ChangeType == WatcherChangeTypes.Renamed)
				{
					if (e is RenamedEventArgs renamedEventArgs)
					{
						var renamedContent = new ChangedContentFile();
						renamedContent.OwnerPid = pid;
						renamedContent.OwnerManifestId = manifestId;
						renamedContent.ContentId = Path.GetFileNameWithoutExtension(renamedEventArgs.Name);
						renamedContent.FullFilePath = renamedEventArgs.FullPath;
						renamedContent.OldContentId = Path.GetFileNameWithoutExtension(renamedEventArgs.OldName);
						renamedContent.OldFullFilePath = renamedEventArgs.OldFullPath;

						_channelChangedContentFiles.Writer.TryWrite(renamedContent);
					}
				}
				else
				{
					throw new ArgumentOutOfRangeException();
				}
			}, token);
		}
	}

	public async IAsyncEnumerable<RemoteContentPublished> ListenToRemoteContentPublishes(CommandArgs args, string manifestId = "global", [EnumeratorCancellation] CancellationToken token = default)
	{
		// Subscribe to the content refresh notification for the realm we are targeting.
		var listenTask = Task.Run(async () =>
		{
			var handle = WebsocketUtil.ConfigureWebSocketForServerNotifications(args, new[] { "content.refresh" }, token);
			await WebsocketUtil.RunServerNotificationListenLoop(handle, message =>
			{
				OnContentPublished(message.body);
			}, token);
		}, token);

		// Loop while we are listing to the published changes on this realm and emit an event out of this enumerable every time we get one. 
		var reader = _channelRemoteContentPublishes.Reader;
		while (await reader.WaitToReadAsync(token) && !token.IsCancellationRequested)
		{
			// Break if a cancellation request came in.
			if (token.IsCancellationRequested)
				break;

			// Get all the files that were changed respecting the PID filter.
			while (reader.TryRead(out var changed))
			{
				yield return changed;
			}
		}

		await listenTask;

		yield break;

		void OnContentPublished(object o)
		{
			Task.Run(() =>
			{
				var payload = o as IDictionary<string, object>;

				object delayRaw;
				var publishedManifestId = "";
				var delay = 0;
				if (payload != null)
				{
					if (payload.TryGetValue("delay", out delayRaw))
					{
						_ = int.TryParse(delayRaw!.ToString(), out delay);
					}

					if (payload.TryGetValue("scopes", out var cool))
					{
						if (cool is List<object> listOfScopes)
						{
							if (listOfScopes.Count > 0 && listOfScopes[0] is string manifestIdRaw)
							{
								publishedManifestId = manifestIdRaw;
							}
						}
					}
				}

				BeamableLogger.Log($"Got notification that content was published! PUBLISH={JsonSerializer.Serialize(o)}");
				// We only emit an event if the published manifest matches the id we care about.
				if (manifestId == publishedManifestId)
				{
					//var asd = await GetEmail()
					// Put this on the channel so it gets picked up below.
					_channelRemoteContentPublishes.Writer.TryWrite(new RemoteContentPublished() { OwnerCid = _requester.Cid, OwnerPid = _requester.Pid, PublisherGamerTag = "0", });
				}
			}, token);

			static async Task<string> GetEmail(long accountId, ConcurrentDictionary<long, string> accountIdToEmail, IAccountsApi accountApi)
			{
				if (accountId == 0) return "";
				if (accountIdToEmail.TryGetValue(accountId, out var email))
				{
					return email;
				}

				accountIdToEmail[accountId] = email = await accountApi
					.GetFind(accountId.ToString())
					.Map(res => res.email.GetOrElse(""));
				return email;
			}
		}
	}

	/// <summary>
	/// Returns the list of <see cref="ContentFile"/> relative to the given manifest.
	/// If no manifest is provided, we'll fetch it with the given <paramref name="manifestId"/>.
	/// If you provide a manifest, please make sure the <paramref name="manifestId"/> matches the given manifest.
	///
	/// The list of content files is a union (by content id) of:
	/// - Each content in the reference manifest.
	/// - Each content file existent locally.
	///
	/// This means that it'll contain created, deleted, modified and up-to-date content alike.
	/// It gives you a full picture of the local content files relative to the given manifest.
	///
	/// When <paramref name="getLocalStateOnly"/> is set, the resulting <see cref="ContentFile.ReferenceContent"/> will be empty and the <see cref="LocalContentFiles.ContentFiles"/> will ONLY contain the
	/// files that exist locally. Use this flag to get the list of 
	/// </summary>
	public async Task<LocalContentFiles> GetAllContentFiles(ClientManifestJsonResponse referenceManifest = null, string manifestId = "global", bool getLocalStateOnly = false)
	{
		// Initialize the local files
		var localFiles = new LocalContentFiles() { ManifestId = manifestId, ReferenceManifest = referenceManifest, ContentFiles = new(1024), };

		// If no reference manifest was provided, let's fetch the latest Manifest.
		if (!getLocalStateOnly) localFiles.ReferenceManifest ??= await _contentApi.GetManifestPublicJson(manifestId);
		else localFiles.ReferenceManifest ??= new();

		// Gets the path to the content folder from which we'll be reading.
		var contentFolder = EnsureContentPathForRealmExists(_requester.Pid, manifestId);

		// Build a list of tasks for computing a ContentFile structure for each relevant content id in this manifest.  
		var tasks =
			// For each existing file inside the content folder we care about, we'll have one entry.
			Directory.EnumerateFiles(contentFolder).Select(async fp =>
				{
					var text = await File.ReadAllTextAsync(fp);
					var json = JsonSerializer.Deserialize<JsonElement>(text, GetContentFileSerializationOptions());

					var id = Path.GetFileNameWithoutExtension(fp);
					var checksum = CalculateChecksum(json.GetProperty(ContentFile.JSON_NAME_PROPERTIES).GetRawText());
					var referenceContent = localFiles.ReferenceManifest.entries.FirstOrDefault(e => e.contentId == id);
					var contentFile = new ContentFile()
					{
						Id = id,
						LocalFilePath = fp,
						Properties = json.GetProperty(ContentFile.JSON_NAME_PROPERTIES),
						Tags = json.GetProperty(ContentFile.JSON_NAME_TAGS),
						FetchedFromManifestUid = json.GetProperty(ContentFile.JSON_NAME_REFERENCE_MANIFEST_ID).GetString(),
						PropertiesChecksum = checksum,
						ReferenceContent = referenceContent,
					};
					return contentFile;
				})
				// We'll also have on entry for each entry in the reference manifest that is NOT represented in the local files.
				.Concat(
					localFiles.ReferenceManifest.entries.Where(e =>
					{
						var expectedPath = Path.Combine(contentFolder, $"{e.contentId}.json");
						return !File.Exists(expectedPath);
					}).Select(e => Task.FromResult(new ContentFile()
					{
						Id = e.contentId,
						LocalFilePath = "",
						Properties = default,
						Tags = JsonSerializer.SerializeToElement(e.tags),
						FetchedFromManifestUid = "",
						PropertiesChecksum = e.version,
						ReferenceContent = e
					}))
				).ToList();

		// Wait for all the content file tasks and return the list of ContentFile.
		try
		{
			localFiles.ContentFiles = (await Task.WhenAll(tasks)).ToList();
			localFiles.PerIdContentFiles = localFiles.ContentFiles.ToDictionary(g => g.Id, g => g);
			return localFiles;
		}
		catch (Exception e)
		{
			if (e is AggregateException ae)
			{
				foreach (var aeInnerException in ae.InnerExceptions)
				{
					Log.Error(aeInnerException, "Error when loading content file");
				}
			}

			throw;
		}
	}

	/// <summary>
	/// Publishes the local changes made to the given <paramref name="manifestId"/> to the current <see cref="IAppContext.Pid"/>.
	///
	/// First, this checks if the last manifest we pulled is the same as the last manifest anyone published to that realm.
	/// If it isn't we error out with <see cref="ERR_CODE_PUBLISH_FAILED_INVALID_REFERENCE_MANIFEST"/>.
	///
	/// For now, users cannot publish UNLESS they make their changes against the latest published manifest.
	/// </summary>
	public async Task PublishContent(string manifestId = "global")
	{
		// Get the latest manifest id and generate the diff against local files. 
		var latestManifest = await _contentApi.GetManifestPublicJson(manifestId);
		var localAgainstLatest = await GetAllContentFiles(latestManifest, manifestId);


		// If we have any conflicting modifications over the latest remote manifest, let's block the publish.  
		if (localAgainstLatest.ContentFiles.Any(f => f.GetStatus() is ContentStatus.ModifiedOverRemote))
		{
			throw new CliException(
				"Your changes were made against an older manifest. Please pull changes and re-apply your local ones before publishing. If you don't you'd be overriding other developer's changes (we're working on removing this limitation).",
				ERR_CODE_PUBLISH_FAILED_INVALID_REFERENCE_MANIFEST, true);
		}

		// Now, we compute our status against the latest manifest and get ONLY the files that weren't deleted (these are the ones that will be included in the new manifest).
		var localContent = await GetAllContentFiles(latestManifest, manifestId);
		var changedContent = localContent.ContentFiles
			.Where(c => c.GetStatus() is not ContentStatus.Deleted)
			.Select(c =>
			{
				// Build the properties from the local data.
				var properties = new MapOfContentMeta();
				foreach (var prop in c.Properties.EnumerateObject())
				{
					var key = prop.Name;
					var val = prop.Value;

					var meta = new ContentMeta();
					if (val.TryGetProperty(nameof(ContentMeta.data), out var dataProp))
						meta.data = new OptionalJsonString(JsonString.FromJson(dataProp.GetRawText()));

					if (val.TryGetProperty(nameof(ContentMeta.text), out var textProp))
						meta.text = OptionalString.FromString(textProp.GetString());

					// if (val.TryGetProperty(nameof(ContentMeta.link), out var linkProp))
					// 	meta.link = OptionalString.FromString(linkProp.GetString());

					// if (val.TryGetProperty(nameof(ContentMeta.links), out var linksProp))
					// 	meta.links = new OptionalArrayOfString(linksProp.EnumerateArray().Select(j => j.GetString()));

					properties.Add(key, meta);
				}

				// Build the tags from the local data.
				var tags = new OptionalArrayOfString(c.Tags.EnumerateArray().Select(j => j.GetString()).ToArray());

				// Return the built content definition
				return new ContentDefinition
				{
					id = c.Id,
					checksum = c.PropertiesChecksum,
					properties = properties,
					tags = tags,

					// This is not really supported anymore so ignore it.
					// TODO: Investigate this with Ben or Ali to figure out if/when we can kill it.
					variants = null,
				};
			}).ToArray();

		// Then we save them to S3
		var saveContentRequest = new SaveContentRequest() { content = changedContent, };
		SaveContentResponse saveContentResponse;

		try
		{
			saveContentResponse = await _contentApi.Post(saveContentRequest);
		}
		catch (Exception e)
		{
			// Handle failure case by just stopping here and erroring out
			throw new CliException($"Failed to save the local content. Please try again. EXCEPTION={e.Data}");
		}

		// Prepare the save manifest request using the response from the save content request.
		var saveManifestRequest = new SaveManifestRequest()
		{
			// Manifest ID
			id = manifestId,

			// This is just a type-conversion
			references = saveContentResponse.content.Select(c => new ReferenceSuperset()
			{
				id = c.id,
				version = c.version,
				checksum = c.checksum,
				type = c.type.ToString().ToLower(),
				tags = new OptionalArrayOfString(c.tags),
				uri = c.id,
				visibility = c.visibility.ToString().ToLower(),
			}).ToArray(),
		};

		// Update the local reference manifest
		_ = await _contentApi.PostManifest(saveManifestRequest);
	}

	/// <summary>
	/// Downloads the content files for the manifest with the given <paramref name="referenceManifestUid"/> and changes the local reference manifest (this is like which "commit" we are working against in the git analogy)
	/// to that uid.
	///
	/// This will only download the files that are modified or deleted relative to the given <see cref="referenceManifestUid"/>. 
	/// This also triggers <see cref="ListenToLocalContentFileChanges"/> as this function writes to the content folder.
	///
	/// If no <paramref name="referenceManifestUid"/> is provided, it'll download the latest one.
	///
	/// If any errors occur while modifying the local files, we'll revert the local files back to their previous state, and we WON'T update the reference manifest uid.
	/// 
	/// Finally, this also updates the local user's reference manifest (we keep track of this for future diff'ing).
	/// </summary>
	public async Promise<ClientManifestJsonResponse> PullContent(string manifestId = "global", string referenceManifestUid = null)
	{
		// Fetches the manifest.
		var optReferenceId = referenceManifestUid == null ? new Optional<string>() : (Optional<string>)referenceManifestUid;
		var targetManifest = await _contentApi.GetManifestPublicJson(manifestId, optReferenceId);

		// Load up all the content files for this pid
		var localContentRelativeToNewManifest = await GetAllContentFiles(targetManifest, manifestId);

		// Get the list of modified and deleted content (if given a list of content ids, will ONLY download the given ids).
		var contentToDownload = localContentRelativeToNewManifest.ContentFiles.Where(c => c.GetStatus() is ContentStatus.Deleted or ContentStatus.Modified).ToArray();

		// Download and overwrite the local content for things that have changed based on the hash or don't exist.
		var downloadPromises = contentToDownload.Select(async c =>
		{
			Log.Verbose("Downloading content with id. ID={Id}", c.Id);
			return (localContent: c, downloadedContent: await _requester.CustomRequest(Method.GET, c.ReferenceContent.uri, parser: s => JsonSerializer.Deserialize<JsonElement>(s)));
		}).ToArray();

		// Let's try to download all the content paired with the local ContentFile representation.
		(ContentFile localContent, JsonElement downloadedContent)[] downloadedContent;
		try
		{
			downloadedContent = await Task.WhenAll(downloadPromises);
		}
		catch (Exception e)
		{
			// Let's just print out all the exceptions
			if (e is AggregateException ae)
			{
				foreach (var aeInnerException in ae.InnerExceptions)
				{
					Log.Error(aeInnerException, "Error when loading content file");
				}
			}
			else
			{
				Log.Error(e, "Error when saving content files. Undoing pull operation. EXCEPTION={Exception}", e.ToString());
			}

			throw;
		}


		// Makes sure the content folder for the current realm exists.
		var contentFolder = EnsureContentPathForRealmExists(_requester.Pid, manifestId);

		// Save the downloaded content to disk.
		var saveTasks = new List<Task>();
		foreach (var (c, j) in downloadedContent)
		{
			var contentFile = c;
			contentFile.Properties = j.GetProperty("properties");
			contentFile.Tags = JsonSerializer.SerializeToElement(c.ReferenceContent.tags);
			saveTasks.Add(SaveContentFile(contentFolder, contentFile));
		}

		// If any problem happens while we are saving to disk, let's undo the pull operation and log out the exceptions.
		try
		{
			await Task.WhenAll(saveTasks);
		}
		catch (Exception e)
		{
			// Let's just print out all the exceptions
			if (e is AggregateException ae)
			{
				foreach (var aeInnerException in ae.InnerExceptions)
				{
					Log.Error(aeInnerException, "Error when saving content files. Undoing pull operation. EXCEPTION={Exception}", aeInnerException.ToString());
				}
			}
			else
			{
				Log.Error(e, "Error when saving content files. Undoing pull operation. EXCEPTION={Exception}", e.ToString());
			}

			// If any content failed, we re-write undo all the changes by re-serializing all the local content that we had before we downloaded.
			// This makes the operation atomic.
			var undoPullTasks = localContentRelativeToNewManifest.ContentFiles.Where(c => c.GetStatus() is ContentStatus.Modified or ContentStatus.Deleted).Select(async contentFile =>
			{
				var fileName = Path.Combine(contentFolder, $"{contentFile.Id}.json");
				var fileContents = JsonSerializer.Serialize(contentFile, GetContentFileSerializationOptions());
				await File.WriteAllTextAsync(fileName, fileContents);
			}).ToArray();
			await Task.WhenAll(undoPullTasks);

			throw;
		}

		return targetManifest;
	}

	/// <summary>
	/// Compares the local state of each <see cref="ContentFile"/> to the given <paramref name="referenceManifestUid"/> and resets the local file content to whatever that content was at that version.
	/// If no <paramref name="referenceManifestUid"/> is provided, it'll use whatever is stored at <see cref="LocalContentConfig.LatestManifestDownloaded"/> for determining the <see cref="ContentFile.GetStatus"/> results.
	///
	/// The filters are applied in accordance to <see cref="ContentFilterType"/>'s semantics.
	/// When <paramref name="deleteCreated"/> is true, this will ALSO delete any local only files.
	/// </summary>
	public async Promise<ClientManifestJsonResponse> ResetLocalContent(string manifestId, string[] filters, ContentFilterType filterType, bool deleteCreated = false, string referenceManifestUid = null)
	{
		// Fetches the manifest.
		var targetManifest = await _contentApi.GetManifestPublicJson(manifestId, string.IsNullOrEmpty(referenceManifestUid) ? new Optional<string>() : (Optional<string>)referenceManifestUid);

		// Load up all the content files for this pid and filter them accordingly.
		var localContentRelativeToNewManifest = await GetAllContentFiles(targetManifest, manifestId);
		FilterLocalContentFiles(ref localContentRelativeToNewManifest, filters, filterType);

		// Get the list of modified and deleted content to re-download from the target manfiest
		// If given a list of content ids, will ONLY download the given ids
		var contentToDownload = localContentRelativeToNewManifest.ContentFiles
			.Where(c => c.GetStatus() is ContentStatus.Deleted or ContentStatus.Modified)
			.ToArray();

		// Get the list of created content we need to delete (if requested).
		var contentToDelete = localContentRelativeToNewManifest.ContentFiles
			.Where(c => deleteCreated && c.GetStatus() is ContentStatus.Created)
			.ToArray();

		// Download and overwrite the local content for things that have changed based on the hash or don't exist.
		var downloadPromises = contentToDownload.Select(async c =>
		{
			Log.Verbose("Downloading content with id. ID={Id}", c.Id);
			return (localContent: c, downloadedContent: await _requester.CustomRequest(Method.GET, c.ReferenceContent.uri, parser: s => JsonSerializer.Deserialize<JsonElement>(s)));
		}).ToArray();

		// Delete any files flagged for deletion, if any.
		foreach (var c in contentToDelete) File.Delete(c.LocalFilePath);

		// Let's try to download all the content paired with the local ContentFile representation.
		(ContentFile localContent, JsonElement downloadedContent)[] downloadedContent;
		try
		{
			downloadedContent = await Task.WhenAll(downloadPromises);
		}
		catch (Exception e)
		{
			// Let's just print out all the exceptions
			if (e is AggregateException ae)
			{
				foreach (var aeInnerException in ae.InnerExceptions)
				{
					Log.Error(aeInnerException, "Error when loading content file");
				}
			}
			else
			{
				Log.Error(e, "Error when saving content files. Undoing pull operation. EXCEPTION={Exception}", e.ToString());
			}

			throw;
		}

		// Makes sure the content folder for the current realm exists.
		var contentFolder = EnsureContentPathForRealmExists(_requester.Pid, manifestId);

		// Save the downloaded content to disk.
		var saveTasks = new List<Task>();
		foreach (var (c, j) in downloadedContent)
		{
			var contentFile = c;
			contentFile.Properties = j.GetProperty("properties");
			contentFile.Tags = JsonSerializer.SerializeToElement(c.ReferenceContent.tags);
			contentFile.FetchedFromManifestUid = targetManifest.uid.Value;
			saveTasks.Add(SaveContentFile(contentFolder, contentFile));
		}

		// If any problem happens while we are saving to disk, let's undo the pull operation and log out the exceptions.
		try
		{
			await Task.WhenAll(saveTasks);
		}
		catch (Exception e)
		{
			// Let's just print out all the exceptions
			if (e is AggregateException ae)
			{
				foreach (var aeInnerException in ae.InnerExceptions)
				{
					Log.Error(aeInnerException, "Error when saving content files. Undoing pull operation. EXCEPTION={Exception}", aeInnerException.ToString());
				}
			}
			else
			{
				Log.Error(e, "Error when saving content files. Undoing pull operation. EXCEPTION={Exception}", e.ToString());
			}

			// If any content failed, we re-write undo all the changes by re-serializing all the local content that we had before we downloaded.
			// This makes the operation atomic.
			var undoPullTasks = contentToDownload.Union(contentToDelete).Where(c => c.GetStatus() is ContentStatus.Modified or ContentStatus.Deleted).Select(async contentFile =>
			{
				var fileName = Path.Combine(contentFolder, $"{contentFile.Id}.json");
				var fileContents = JsonSerializer.Serialize(contentFile, GetContentFileSerializationOptions());
				await File.WriteAllTextAsync(fileName, fileContents);
			}).ToArray();
			await Task.WhenAll(undoPullTasks);

			throw;
		}

		return targetManifest;
	}

	/// <summary>
	/// Given a <see cref="LocalContentFiles"/> list, filters its content list based on some filter semantics.
	/// </summary>
	public void FilterLocalContentFiles(ref LocalContentFiles file, string[] filters, ContentFilterType filterType)
	{
		Func<ContentFile, bool> filterFunc;
		switch (filterType)
		{
			case ContentFilterType.ExactIds:
			{
				filterFunc = f => filters.Length == 0 || filters.Any(id => id == f.Id);
				break;
			}
			case ContentFilterType.TypeHierarchy:
			{
				filterFunc = f => filters.Length == 0 || filters.Any(contentType => f.Id.StartsWith(contentType));
				break;
			}
			case ContentFilterType.TypeHierarchyStrict:
			{
				filterFunc = f => filters.Length == 0 || filters.Any(contentType => GetContentType(in f) == contentType);
				break;
			}
			case ContentFilterType.Regexes:
			{
				var regexes = filters.Select(f => new Regex(f, RegexOptions.Compiled)).ToArray();
				filterFunc = f => filters.Length == 0 || regexes.Any(r => r.IsMatch(f.Id));
				break;
			}
			case ContentFilterType.Tags:
			{
				filterFunc = f => filters.Length == 0 || f.GetTagsArray().Intersect(filters).Any();
				break;
			}
			default:
				throw new ArgumentOutOfRangeException(nameof(filterType));
		}

		file.ContentFiles = file.ContentFiles.Where(filterFunc).ToList();
		file.PerIdContentFiles = file.ContentFiles.ToDictionary(f => f.Id, f => f);
	}

	/// <summary>
	/// <inheritdoc cref="AddTags(cli.Content.LocalContentFiles,string[])"/>
	/// </summary>
	public async Task AddTag(ContentFile f, string tag) =>
		await AddTags(new LocalContentFiles() { ContentFiles = new() { f }, PerIdContentFiles = new() { { f.Id, f } }, ReferenceManifest = null, }, new[] { tag });

	/// <summary>
	/// <inheritdoc cref="AddTags(cli.Content.LocalContentFiles,string[])"/>
	/// </summary>
	public async Task AddTags(ContentFile f, string[] tags) =>
		await AddTags(new LocalContentFiles() { ContentFiles = new() { f }, PerIdContentFiles = new() { { f.Id, f } }, ReferenceManifest = null, }, tags);

	/// <summary>
	/// Adds the given tags to each content file in the list of <see cref="LocalContentFiles"/>.
	///
	/// If <paramref name="addDuplicates"/> is false, we will only add tags to the files that don't already have that tag.
	/// Otherwise, it'll add it again.
	/// </summary>
	public async Task AddTags(LocalContentFiles localContentFiles, string[] tags)
	{
		var contentFolder = EnsureContentPathForRealmExists(_requester.Pid, localContentFiles.ManifestId);
		var saveTasks = new List<Task>();
		foreach (var contentFile in localContentFiles.ContentFiles)
		{
			var f = contentFile;

			var existingTags = f.GetTagsArray();
			var newTags = existingTags.Union(tags);

			f.Tags = JsonSerializer.SerializeToElement(newTags);
			saveTasks.Add(SaveContentFile(contentFolder, f));
		}

		await Task.WhenAll(saveTasks);
	}

	/// <summary>
	/// <inheritdoc cref="Beamable.Api.Autogenerated.Models.RemoveTags"/>
	/// </summary>
	public async Task RemoveTag(ContentFile f, string tag) =>
		await RemoveTags(new LocalContentFiles() { ContentFiles = new() { f }, PerIdContentFiles = new() { { f.Id, f } }, ReferenceManifest = null, }, new[] { tag });

	/// <summary>
	/// <inheritdoc cref="Beamable.Api.Autogenerated.Models.RemoveTags"/>
	/// </summary>
	public async Task RemoveTags(ContentFile f, string[] tags) =>
		await RemoveTags(new LocalContentFiles() { ContentFiles = new() { f }, PerIdContentFiles = new() { { f.Id, f } }, ReferenceManifest = null, }, tags);

	/// <summary>
	/// Removes the given tags to each content file in the list of <paramref name="localContentFiles"/>.
	///
	/// When <paramref name="maxRemoveCount"/> is 0, we'll remove every instance of that tag from the list of tags.
	/// If its any value ABOVE 0, we'll remove only that many instances of the tags from the list of content.
	/// </summary>
	public async Task RemoveTags(LocalContentFiles localContentFiles, string[] tags)
	{
		var contentFolder = EnsureContentPathForRealmExists(_requester.Pid, localContentFiles.ManifestId);
		var saveTasks = new List<Task>();
		foreach (var contentFile in localContentFiles.ContentFiles)
		{
			var f = contentFile;

			var existingTags = f.GetTagsArray().ToList();
			var newTags = existingTags.Except(tags);

			f.Tags = JsonSerializer.SerializeToElement(newTags);
			saveTasks.Add(SaveContentFile(contentFolder, f));
		}

		await Task.WhenAll(saveTasks);
	}

	/// <summary>
	/// Utility function that saves the given <see cref="ContentFile"/> to the folder storing the files for the given
	/// <paramref name="manifestId"/> and <paramref name="pid"/>.
	/// </summary>
	public async Task SaveContentFile(ContentFile f, string manifestId = "", string pid = null)
	{
		pid ??= _requester.Pid;
		var contentFolder = EnsureContentPathForRealmExists(pid, manifestId);
		await SaveContentFile(contentFolder, f);
	}

	/// <summary>
	/// Utility function that saves the given <see cref="ContentFile"/> to the given folder.
	/// </summary>
	public async Task SaveContentFile(string contentFolder, ContentFile f)
	{
		var fileName = Path.Combine(contentFolder, $"{f.Id}.json");
		var fileContents = JsonSerializer.Serialize(f, GetContentFileSerializationOptions());
		await File.WriteAllTextAsync(fileName, fileContents);
	}

	/// <summary>
	/// Helper utility that converts a collection of <see cref="ContentFile"/>s to the public
	/// <see cref="LocalContentManifestEntry"/> format.
	/// </summary>
	public static IEnumerable<LocalContentManifestEntry> ContentFileToLocalContentManifestEntries(IEnumerable<ContentFile> files)
	{
		return files.Select(file =>
		{
			return new LocalContentManifestEntry()
			{
				FullId = file.Id,
				TypeName = GetContentType(file),
				Name = GetContentName(file),
				Hash = file.PropertiesChecksum,
				Tags = file.Tags.EnumerateArray().Select(ae => ae.GetString() ?? "").ToArray(),
				CurrentStatus = (int)file.GetStatus(),
				JsonFilePath = file.LocalFilePath
			};
		});
	}

	/// <summary>
	/// Serializes just the <see cref="ContentFile.Properties"/> object.
	/// We need this because we compute checksums ignoring tags.
	/// </summary>
	public static string SerializeProperties(in ContentFile file) => JsonSerializer.Serialize(file.Properties, new JsonSerializerOptions { WriteIndented = false });

	/// <summary>
	/// Our ContentId is a '.'-separated string whose final component is a name and the substring before it, its type hierarchy.
	/// This extracts the substring representing the Content Type hierarchy for this object. 
	/// </summary>
	public static string GetContentType(in ContentFile file) => file.Id[..file.Id.LastIndexOf('.')];

	/// <summary>
	/// Our ContentId is a '.'-separated string whose final component is a name and the substring before it, its type hierarchy.
	/// This extracts the substring representing the content's name. 
	/// </summary>
	public static string GetContentName(in ContentFile file) => file.Id[(file.Id.LastIndexOf('.') + 1)..];

	/// <summary>
	/// Computes the MD5 checksum we use for content-file diff'ing by hashing the serialized <see cref="ContentFile.Properties"/>.
	/// Serialization of the properties must use <see cref="GetContentFileSerializationOptions"/> to ensure field ordering. 
	/// </summary>
	public static string CalculateChecksum(in ContentFile file) => CalculateChecksum(SerializeProperties(in file));

	/// <summary>
	/// <inheritdoc cref="CalculateChecksum(in cli.Content.ContentFile)"/> 
	/// </summary>
	public static string CalculateChecksum(string serializedPropertiesJson)
	{
		var bytes = Encoding.UTF8.GetBytes(serializedPropertiesJson);
		var hash = MD5.HashData(bytes);
		var checksum = Convert.ToHexString(hash).ToLower();
		return checksum;
	}

	/// <summary>
	/// This returns a <see cref="JsonSerializerOptions"/> that will correctly serialize a <see cref="ContentFile"/>.
	/// </summary>
	public static JsonSerializerOptions GetContentFileSerializationOptions(bool indent = true)
	{
		return new JsonSerializerOptions()
		{
			WriteIndented = indent,
			IncludeFields = true,
			TypeInfoResolver = new DefaultJsonTypeInfoResolver()
			{
				Modifiers =
				{
					typeInfo =>
					{
						if (typeInfo.Kind != JsonTypeInfoKind.Object)
							return;
						var properties = typeInfo.Properties.OrderBy(p => p.Name, StringComparer.Ordinal).ToList();
						typeInfo.Properties.Clear();
						for (int i = 0; i < properties.Count; i++)
						{
							properties[i].Order = i;
							typeInfo.Properties.Add(properties[i]);
						}
					}
				}
			}
		};
	}
}

[Serializable]
public struct ContentFile : IEquatable<ContentFile>
{
	public const string JSON_NAME_PROPERTIES = "properties";
	public const string JSON_NAME_TAGS = "tags";
	public const string JSON_NAME_REFERENCE_MANIFEST_ID = "referenceManifestId";

	[JsonIgnore] public string Id;
	[JsonIgnore] public string LocalFilePath;
	[JsonIgnore] public string PropertiesChecksum;
	[JsonIgnore] public ClientContentInfoJson ReferenceContent;

	public ContentStatus GetStatus()
	{
		if (ReferenceContent == null) return ContentStatus.Created;
		if (Properties.ValueKind == JsonValueKind.Undefined || Tags.ValueKind == JsonValueKind.Undefined) return ContentStatus.Deleted;
		if (ReferenceContent.checksum != PropertiesChecksum || IsTagsDiff()) return ContentStatus.Modified;
		return ContentStatus.UpToDate;
	}

	[JsonPropertyName(JSON_NAME_PROPERTIES)]
	public JsonElement Properties;

	[JsonPropertyName(JSON_NAME_TAGS)] public JsonElement Tags;

	[JsonPropertyName(JSON_NAME_REFERENCE_MANIFEST_ID)]
	public string FetchedFromManifestUid;

	public string[] GetTagsArray() => Tags.EnumerateArray().Select(f => f.GetString()).ToArray();

	public bool IsTagsDiff()
	{
		var status = GetTagStatus();
		return !status.Values.Any(s => s is not TagStatus.LocalAndRemote);
	}

	public string GetStatusString() =>
		GetStatus() switch
		{
			ContentStatus.Created => "[green]created[/]",
			ContentStatus.Deleted => "[red]deleted[/]",
			ContentStatus.Modified => "[yellow]modified[/]",
			ContentStatus.UpToDate => "up to date",
			_ => throw new ArgumentOutOfRangeException(nameof(GetStatus), GetStatus(), null)
		};

	public OrderedDictionary<string, TagStatus> GetTagStatus()
	{
		var remoteTags = ReferenceContent?.tags ?? Array.Empty<string>();
		var localTags = Tags.EnumerateArray().Select(j => j.GetString()).ToArray();

		var remoteOnlyTags = remoteTags.Except(localTags);
		var localOnlyTags = localTags.Except(remoteTags);
		var bothTags = localTags.Intersect(remoteTags);

		var res = new OrderedDictionary<string, TagStatus>();
		foreach (var t in bothTags) res.Add(t, TagStatus.LocalAndRemote);
		foreach (var t in remoteOnlyTags) res.Add(t, TagStatus.RemoteOnly);
		foreach (var t in localOnlyTags) res.Add(t, TagStatus.LocalOnly);

		return res;
	}

	public bool Equals(ContentFile other) => Id == other.Id;

	public override bool Equals(object obj) => obj is ContentFile other && Equals(other);

	public override int GetHashCode() => (Id != null ? Id.GetHashCode() : 0);

	public static bool operator ==(ContentFile left, ContentFile right) => left.Equals(right);

	public static bool operator !=(ContentFile left, ContentFile right) => !left.Equals(right);
}

[CliContractType, Flags]
public enum ContentStatus
{
	Created = 0,
	Deleted = 1 << 0,
	Modified = 1 << 1,
	UpToDate = 1 << 2,

	ModifiedOverRemote = 1 << 31,
}
