using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.BeamCli;
using Beamable.Common.BeamCli.Contracts;
using Beamable.Common.Content;
using Beamable.Server;
using cli.Dotnet;
using Spectre.Console;
using Spectre.Console.Json;
using System.Text.Json;

namespace cli.Content;

[Serializable]
public class ContentPsProgressMessage
{
	public int total;
	public int completed;
	public string message;
}

public class ContentPsCommand 
	: AppCommand<ContentPsCommandArgs>
	, IResultSteam<DefaultStreamResultChannel, ContentPsCommandEvent>
	, IResultSteam<ProgressStreamResultChannel, ContentPsProgressMessage>
	, ISkipManifest
{
	public ContentPsCommand() : base("ps", "List the running status of local services not running in docker")
	{
	}

	public override void Configure()
	{
		ProjectCommand.AddWatchOption(this, (args, i) => args.Watch = i);
		AddOption(ContentCommand.MANIFESTS_FILTER_OPTION, (args, s) => args.ManifestId = s[0]);
		AddOption(new RequireProcessIdOption(), (args, i) => args.RequireProcessId = i);
	}

	public override async Task Handle(ContentPsCommandArgs args)
	{
		RequireProcessIdOption.ConfigureRequiredProcessIdWatcher(args.RequireProcessId);

		var cid = args.AppContext.Cid;
		var pid = args.AppContext.Pid;
		var manifestId = args.ManifestId ?? "global";

		var contentService = args.DependencyProvider.GetService<ContentService>();

		// Declarations of the manifest variables we care about during this command's lifecycle.
		Promise<ClientManifestJsonResponse> latestManifest = contentService.GetManifest(manifestId).ToPromise();
		await latestManifest;

		void OnMessage(ContentProgressUpdateData data)
		{
			if (data.EventType != ContentProgressUpdateData.EVT_TYPE_UpdateProcessedItemCount)
			{
				// we only care about progress messages
				return;
			}
			
			this.SendResults<ProgressStreamResultChannel, ContentPsProgressMessage>(new ContentPsProgressMessage
			{
				total = data.totalItems,
				completed = data.processedItems,
				message = "syncing local content"
			});
		}
		
		// If we are just creating the local representation for this realm+manifest combo, let's reset our state to match the remote state.
		
		var contentFolder = contentService.EnsureContentPathForRealmExists(out var created, pid, manifestId);
		if (created)
		{
			await contentService.SyncLocalContent(latestManifest.GetResult(), manifestId, onContentSyncProgressUpdate: OnMessage, cancellationToken: args.Lifecycle.CancellationToken);
		}
		// Auto-sync with latest like when we react to a published manifest.
		else
		{
			_ = await contentService.SyncLocalContent(latestManifest.GetResult(), manifestId, syncCreated: false, syncModified: false, forceSyncConflicts: false, syncDeleted: false, onContentSyncProgressUpdate: OnMessage, cancellationToken: args.Lifecycle.CancellationToken);
		}

		// Refresh the local ContentFile objects based on the latest reference manifest and emit a "full-rebuild" event.
		// Full rebuild events expect the engine to discard their in-memory state for this realm+manifest id handle and rebuild the entire list of content entries.
		var localContentAgainstLatest = contentService.GetAllContentFiles(latestManifest.GetResult(), manifestId);
		await Task.WhenAll(localContentAgainstLatest);

		// Prepare the content entries between our local state and the remote states that are relevant (our reference and the latest publish in the realm).
		var entriesToEmitAgainstLatest = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstLatest.Result.ContentFiles)
			.ToArray();

		// Build and emit the event
		var eventToEmit = new ContentPsCommandEvent()
		{
			EventType = ContentPsCommandEvent.EVT_TYPE_FullRebuild,
			RelevantManifestsAgainstLatest = new()
			{
				new LocalContentManifest()
				{
					OwnerCid = cid, OwnerPid = pid, ManifestId = manifestId, Entries = entriesToEmitAgainstLatest.ToArray(),
				}
			},
			ToRemoveLocalEntries = new(),
			PublisherAccountId = "",
			PublisherEmail = "",
			SyncReports = new(),
		};
		this.SendResults<DefaultStreamResultChannel, ContentPsCommandEvent>(eventToEmit);
		this.LogResult(eventToEmit);

		// If we are meant to watch the content folder, let's set up jobs to do that.
		if (args.Watch)
		{
			// This ensure that only one of the two event streams will resolve at a time.
			var watchSemaphore = new SemaphoreSlim(1, 1);

			// Set up a task that will emit a ChangedContent event every time local files for this realm+manifestid handle are changed.
			// The events will only contain the entries for the modified content objects and expects the engine integration to only rebuild their in-memory representation of the modified object.
			var localFileChangesTask = Task.Run(async () =>
			{
				await foreach (var batchedLocalFileChanges in contentService.ListenToLocalContentFileChanges(pid, manifestId, args.Lifecycle.Source.Token))
				{
					try
					{
						await watchSemaphore.WaitAsync(args.Lifecycle.Source.Token);
					}
					catch (OperationCanceledException)
					{
						// let it go. 
						Log.Information("content ps command was cancelled. ");
					}

					try
					{
// Refresh both the reference manifest and the latest manifests.
						var latestManifestId = latestManifest.GetResult().uid.GetOrElse("");
						latestManifest = contentService.GetManifest(manifestId, latestManifestId).ToPromise();
						await latestManifest;

						// Find all locally deleted content
						var allLocalDeletions = batchedLocalFileChanges.AllFileChanges.Where(fc => fc.WasDeleted()).Select(fc => fc.ContentId).ToArray();
						var allLocalRenames = batchedLocalFileChanges.AllFileChanges.Where(fc => fc.WasRenamed()).ToArray();

						// Get the list of all content that was NOT in the remote but WAS deleted locally.
						var allLocalOnlyDeletions = allLocalDeletions.Except(latestManifest.GetResult().entries.Select(e => e.contentId)).ToArray();

						// This handles the case where:
						//  - We had a "ContentX" that we renamed to "ContentY". This shows up as "[-]ContentX" and  "[+]ContentY".
						//  - Then we rename "ContentY" to "ContentZ" (or any other name). Without the code below, this shows up as "[-]ContentX", "[+]ContentY" (but no file exists) and "[+]ContentZ".
						//  - This happens because the in-engine integrations will have a "ContentY" in their in-memory representation and because it was a rename, the "allLocalOnlyDeletions" doesn't detect it.
						//  - The correct thing to do would be to show just  "[-]ContentX" and  "[+]ContentZ" and "ContentY" should be removed.
						// So... this finds all renames whose OldContentId do NOT exist in the remote so we can remove them (since they were renamed they don't exist locally either). 
						var allRenamedFilesThatShouldBeDeleted = allLocalRenames
							.Where(c => latestManifest.GetResult().entries.Count(e => e.contentId == c.OldContentId) == 0)
							.Select(c => c.OldContentId).ToArray();

						// Find the list of ids affected by the file changes
						var allRelevantIds = batchedLocalFileChanges.AllFileChanges.SelectMany(fc => string.IsNullOrEmpty(fc.OldContentId) ? new[] { fc.ContentId } : new[] { fc.ContentId, fc.OldContentId }).ToArray();

						// Refresh the local ContentFile objects based on the latest reference manifest
						localContentAgainstLatest = contentService.GetAllContentFiles(latestManifest.GetResult(), manifestId, ContentFilterType.ExactIds, allRelevantIds);
						await localContentAgainstLatest;

						
						// If a content referenceId was changed and can be updated we don't need to wait for a content ps to be called again to reset it
						var saveTasks = new List<Task>();
						var contentToUpdateManifestReference = localContentAgainstLatest.Result.ContentFiles
							.Where(c => c.CanUpdateReferenceWithTarget)
							.ToArray();
						foreach (ContentFile c in contentToUpdateManifestReference)
						{
							ContentFile contentFile = c;
							// In some cases of conflict resolution the Reference Content could be null.
							if (c.ReferenceContent != null)
							{
								contentFile.Tags = JsonSerializer.SerializeToElement(c.ReferenceContent.tags);
							}
							contentFile.FetchedFromManifestUid = latestManifestId;
							saveTasks.Add(contentService.SaveContentFile(contentFolder, contentFile));
						}
						await Task.WhenAll(saveTasks);
						
						// Prepare a new Manifest to push out with only the changed entries.
						var fileChangeManifestToEmit = new ContentPsCommandEvent()
						{
							EventType = ContentPsCommandEvent.EVT_TYPE_ChangedContent,
							RelevantManifestsAgainstLatest = new()
							{
								new LocalContentManifest()
								{
									OwnerCid = cid,
									OwnerPid = pid,
									ManifestId = manifestId,
									Entries = ContentService.ContentFileToLocalContentManifestEntries(
										localContentAgainstLatest.Result.ContentFiles.Where(c => allRelevantIds.Contains(c.Id))
									).ToArray(),
								}
							},
							ToRemoveLocalEntries = new()
							{
								new()
								{
									OwnerCid = cid,
									OwnerPid = pid,
									ManifestId = manifestId,
									Entries = allLocalOnlyDeletions.Concat(allRenamedFilesThatShouldBeDeleted)
										.Select(id => new LocalContentManifestEntry()
										{
											FullId = id,
											Name = ContentService.GetContentName(id),
											TypeName = ContentService.GetContentType(id),
											CurrentStatus = 0,
											Hash = "",
											IsInConflict = false,
											JsonFilePath = "",
											Tags = Array.Empty<string>(),
											TagsStatus = Array.Empty<int>(),
											ReferenceManifestUid = "",
										})
										.ToArray(),
								}
							},
							PublisherAccountId = "",
							PublisherEmail = "",
							SyncReports = new(),
						};

						// Send it out.
						this.SendResults<DefaultStreamResultChannel, ContentPsCommandEvent>(fileChangeManifestToEmit);
						this.LogResult(fileChangeManifestToEmit);
					}
					finally
					{
						watchSemaphore.Release();
					}
				}
			});


			// Set up a task that will emit a RemotePublished event every time someone THAT IS NOT YOU publish a manifest to this realm+manifestid handle.
			var remoteManifestPublishTask = Task.Run(async () =>
			{
				await foreach (var remoteContentPublished in contentService.ListenToRemoteContentPublishes(args, manifestId, args.Lifecycle.Source.Token))
				{
					await watchSemaphore.WaitAsync();
					try
					{
						// Fetch the newest manifest
						var latestManifestId = remoteContentPublished.ReferenceUid;

						// Refresh both the reference manifest and the latest manifests.
						latestManifest = contentService.GetManifest(manifestId, latestManifestId).ToPromise();
						await latestManifest;

						// Rebuild the content against the new manifests.
						localContentAgainstLatest = contentService.GetAllContentFiles(latestManifest.GetResult(), manifestId);
						await localContentAgainstLatest;

						// Prepare a new Manifest to push out with only the changed entries.
						var remotePublishManifestToEmit = new ContentPsCommandEvent()
						{
							EventType = ContentPsCommandEvent.EVT_TYPE_RemotePublished,
							RelevantManifestsAgainstLatest = new()
							{
								new LocalContentManifest()
								{
									OwnerCid = cid,
									OwnerPid = pid,
									ManifestId = manifestId,
									Entries = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstLatest.Result.ContentFiles
									).ToArray(),
								}
							},
							ToRemoveLocalEntries = new(),
							PublisherEmail = remoteContentPublished.PublisherEmail,
							PublisherAccountId = remoteContentPublished.PublisherAccountId,
							SyncReports = new() { remoteContentPublished.AutoSyncReport, },
						};

						// Send it out.
						this.SendResults<DefaultStreamResultChannel, ContentPsCommandEvent>(remotePublishManifestToEmit);
						this.LogResult(remotePublishManifestToEmit);
					}
					finally
					{
						watchSemaphore.Release();
					}
				}
			});

			await localFileChangesTask;
			await remoteManifestPublishTask;
		}
	}

	protected virtual void LogResult(object result)
	{
		var json = JsonSerializer.Serialize(result, ContentService.GetContentFileSerializationOptions());
		AnsiConsole.Write(
			new Panel(new JsonText(json))
				.Collapse()
				.NoBorder());
	}
}

[Serializable]
public class ContentPsCommandArgs : CommandArgs
{
	public bool Watch;
	public int RequireProcessId;
	public string ManifestId;
}

[CliContractType, Serializable]
public class ContentPsCommandEvent
{
	/// <summary>
	/// The engine integration is expected to discard all their in-memory state about content and rebuild it with the information in this event.
	/// </summary>
	public const int EVT_TYPE_FullRebuild = 0;

	/// <summary>
	/// The engine integration is expected to discard all their in-memory state about what the local content is in relation to the latest published manifest of this realm.
	/// It should not discard the state against the reference manifest (latest pulled manifest / local "head").
	///
	/// Only <see cref="IsReferenceHeadInRealm"/> and <see cref="RelevantManifestsAgainstLatest"/> is correctly computed here.
	/// </summary>
	public const int EVT_TYPE_RemotePublished = 1;

	/// <summary>
	/// The engine integration is expected to use <see cref="ToRemoveLocalEntries"/> to update it's in-memory state regarding our reference manifest.
	/// </summary>
	public const int EVT_TYPE_ChangedContent = 2;

	/// <summary>
	/// One of <see cref="EVT_TYPE_FullRebuild"/>, <see cref="EVT_TYPE_RemotePublished"/> or <see cref="EVT_TYPE_ChangedContent"/>.
	/// The semantics of each field are defined based on the event and documented on these comments.
	/// </summary>
	public int EventType;

	/// <summary>
	/// List of manifests and entry data relevant to <see cref="EVT_TYPE_FullRebuild"/> and <see cref="EVT_TYPE_RemotePublished"/>.
	/// This contains what our local files look like related to the most recent published manifest.
	/// </summary>
	public List<LocalContentManifest> RelevantManifestsAgainstLatest;

	/// <summary>
	/// Contains a list of entries to be removed from the in-memory state, both relative to our reference manifest and our latest manifest.
	/// Imagine the case where:
	///  - I create a content locally, and it does not exist remotely yet.
	///  - I get an event that'll add it to my in-memory representation of "hey, this content status is Created (only exists locally).".
	///  - I then delete that content so it no longer exists locally (and it never existed in the remote). Now... it only exists in my in-memory representation.
	///  - I need to know that this was deleted --- it will not be contained in the <see cref="RelevantManifestsAgainstReference"/> or <see cref="RelevantManifestsAgainstLatest"/> because it no longer exists in neither
	///    locally NOR in the reference or latest manifests.
	///  - When the local deletion in such a case occurs, the ids for the deleted content is put here so we can clear our in-memory representation of it. 
	///  
	/// Only relevant when <see cref="EventType"/> is <see cref="EVT_TYPE_ChangedContent"/>.
	/// </summary>
	public List<LocalContentManifest> ToRemoveLocalEntries;

	/// <summary>
	/// This is only filled out when <see cref="EVT_TYPE_RemotePublished"/>.
	/// It contains the email of the user that made the publish. 
	/// </summary>
	public string PublisherEmail;

	/// <summary>
	/// This is only filled out when <see cref="EVT_TYPE_RemotePublished"/>.
	/// It contains the accountId of the user that made the publish. 
	/// </summary>
	public string PublisherAccountId;

	/// <summary>
	/// This is only filled out when <see cref="EVT_TYPE_RemotePublished"/>.
	/// It contains information about which content files were changed as a result of the remote publish event.
	/// </summary>
	public List<ContentSyncReport> SyncReports;
}
