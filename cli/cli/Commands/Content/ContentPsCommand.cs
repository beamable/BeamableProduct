using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.BeamCli;
using Beamable.Server;
using cli.Dotnet;
using cli.Services.Content;
using Spectre.Console;
using Spectre.Console.Json;
using System.Text.Json;

namespace cli.Content;

public class ContentPsCommand : AppCommand<ContentPsCommandArgs>,
	IResultSteam<DefaultStreamResultChannel, ContentPsCommandEvent>
{
	public int updateCount;

	public ContentPsCommand() : base("ps", "List the running status of local services not running in docker")
	{
	}

	public override void Configure()
	{
		ProjectCommand.AddWatchOption(this, (args, i) => args.Watch = i);
	}

	public override async Task Handle(ContentPsCommandArgs args)
	{
		var contentApi = args.Provider.GetService<IContentApi>();
		var cid = args.AppContext.Cid;
		var pid = args.AppContext.Pid;
		var manifestId = args.ManifestId ?? "global";

		var contentService = args.DependencyProvider.GetService<ContentService>();

		// Declarations of the manifest variables we care about during this command's lifecycle.
		Promise<ClientManifestJsonResponse> referenceManifest = null;
		Promise<ClientManifestJsonResponse> latestReferenceManifest = null;

		// First, we make sure that we have a reference manifest id for this realm+manifest id combo.
		// If we don't, we pull the content and update the reference id. This ensures we have a reference manifest and the local content is up-to-date.
		// We also keep an in-memory reference for the latest manifest currently deployed.
		var referenceManifestUid = contentService.GetCurrentReferenceManifestId(manifestId);
		if (string.IsNullOrEmpty(referenceManifestUid)) referenceManifest = contentService.PullContent(manifestId);
		else referenceManifest = contentApi.GetManifestPublicJson(manifestId, referenceManifestUid);
		latestReferenceManifest = contentApi.GetManifestPublicJson(manifestId);


		await referenceManifest;
		await latestReferenceManifest;

		// If the reference manifest is the latest manifest in the realm
		var isHeadOfRealm = referenceManifest.GetResult().uid.Value == latestReferenceManifest.GetResult().uid.Value;

		// Refresh the local ContentFile objects based on the latest reference manifest and emit a "full-rebuild" event.
		// Full rebuild events expect the engine to discard their in-memory state for this realm+manifest id handle and rebuild the entire list of content entries.
		var localContentAgainstReference = contentService.GetAllContentFiles(referenceManifest.GetResult(), manifestId);
		var localContentAgainstLatest = contentService.GetAllContentFiles(latestReferenceManifest.GetResult(), manifestId);
		await Task.WhenAll(localContentAgainstReference, localContentAgainstLatest);

		// Prepare the content entries between our local state and the remote states that are relevant (our reference and the latest publish in the realm).
		var entriesToEmitAgainstReference = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstReference.Result.ContentFiles);
		var entriesToEmitAgainstLatest = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstLatest.Result.ContentFiles);

		// Build and emit the event
		var eventToEmit = new ContentPsCommandEvent()
		{
			EventType = ContentPsCommandEvent.EVT_TYPE_FullRebuild,
			IsReferenceHeadInRealm = isHeadOfRealm,
			RelevantManifestsAgainstReference = new()
			{
				new LocalContentManifest()
				{
					OwnerCid = cid,
					OwnerPid = pid,
					ManifestId = manifestId,
					ReferenceManifestUid = referenceManifest.GetResult().uid,
					LatestManifestUid = latestReferenceManifest.GetResult().uid,
					Entries = entriesToEmitAgainstReference.ToArray(),
				}
			},
			RelevantManifestsAgainstLatest = new()
			{
				new LocalContentManifest()
				{
					OwnerCid = cid,
					OwnerPid = pid,
					ManifestId = manifestId,
					ReferenceManifestUid = referenceManifest.GetResult().uid,
					LatestManifestUid = latestReferenceManifest.GetResult().uid,
					Entries = entriesToEmitAgainstLatest.ToArray(),
				}
			},
			ToRemoveLocalEntries = new(),
		};
		this.SendResults(eventToEmit);
		this.LogResult(eventToEmit);

		// If we are meant to watch the content folder, let's set up jobs to do that.
		if (args.Watch)
		{
			// Set up a task that will emit a ChangedContent event every time local files for this realm+manifestid handle are changed.
			// The events will only contain the entries for the modified content objects and expects the engine integration to only rebuild their in-memory representation of the modified object.
			var localFileChangesTask = Task.Run(async () =>
			{
				var tokenSource = new CancellationTokenSource();
				await foreach (var batchedLocalFileChanges in contentService.ListenToLocalContentFileChanges(pid, manifestId, tokenSource.Token))
				{
					// Find all locally deleted content
					var allLocalDeletions = batchedLocalFileChanges.AllFileChanges.Where(fc => fc.WasDeleted()).Select(fc => fc.ContentId);

					// Get the list of all content that was NOT in the remote but WAS deleted locally.
					var allLocalOnlyDeletions = allLocalDeletions.Except(referenceManifest.GetResult().entries.Select(e => e.contentId)).ToArray();

					// Find the list of ids affected by the file changes
					var allRelevantIds = batchedLocalFileChanges.AllFileChanges.SelectMany(fc => string.IsNullOrEmpty(fc.OldContentId) ? new[] { fc.ContentId } : new[] { fc.ContentId, fc.OldContentId });

					// Refresh the local ContentFile objects based on the latest reference manifest
					localContentAgainstReference = contentService.GetAllContentFiles(referenceManifest.GetResult(), manifestId);
					localContentAgainstLatest = contentService.GetAllContentFiles(latestReferenceManifest.GetResult(), manifestId);
					await Task.WhenAll(localContentAgainstReference, localContentAgainstLatest);

					// Prepare a new Manifest to push out with only the changed entries.
					var fileChangeManifestToEmit = new ContentPsCommandEvent()
					{
						EventType = ContentPsCommandEvent.EVT_TYPE_ChangedContent,
						IsReferenceHeadInRealm = referenceManifest.GetResult().uid.Value == latestReferenceManifest.GetResult().uid.Value,
						RelevantManifestsAgainstReference = new()
						{
							new LocalContentManifest()
							{
								OwnerCid = cid,
								OwnerPid = pid,
								ManifestId = manifestId,
								ReferenceManifestUid = referenceManifest.GetResult().uid,
								LatestManifestUid = latestReferenceManifest.GetResult().uid,
								Entries = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstReference.Result.ContentFiles.Where(c => allRelevantIds.Contains(c.Id))).ToArray(),
							}
						},
						RelevantManifestsAgainstLatest = new()
						{
							new LocalContentManifest()
							{
								OwnerCid = cid,
								OwnerPid = pid,
								ManifestId = manifestId,
								ReferenceManifestUid = referenceManifest.GetResult().uid,
								LatestManifestUid = latestReferenceManifest.GetResult().uid,
								Entries = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstLatest.Result.ContentFiles.Where(c => allRelevantIds.Contains(c.Id))).ToArray(),
							}
						},
						ToRemoveLocalEntries = new()
						{
							new()
							{
								OwnerCid = cid,
								OwnerPid = pid,
								ManifestId = manifestId,
								ReferenceManifestUid = referenceManifest.GetResult().uid,
								LatestManifestUid = latestReferenceManifest.GetResult().uid,
								Entries = allLocalOnlyDeletions.Select(id => new LocalContentManifestEntry() { FullId = id, CurrentStatus = -1 }).ToArray(),
							}
						}
					};

					// Send it out.
					this.SendResults(fileChangeManifestToEmit);
					this.LogResult(fileChangeManifestToEmit);
				}
			});


			// Set up a task that will emit a RemotePublished event every time someone THAT IS NOT YOU publish a manifest to this realm+manifestid handle.
			// This event will 
			var remoteManifestPublishTask = Task.Run(async () =>
			{
				var tokenSource = new CancellationTokenSource();
				await foreach (var remoteContentPublished in contentService.ListenToRemoteContentPublishes(args, manifestId, tokenSource.Token))
				{
					// Fetch the newest manifest
					var postPublishReferenceManifestId = contentService.GetCurrentReferenceManifestId(manifestId);
					var latestReferenceManifestId = remoteContentPublished.ReferenceUid;

					// Refresh both the reference manifest and the latest manifests.
					referenceManifest = contentApi.GetManifestPublicJson(manifestId, postPublishReferenceManifestId);
					latestReferenceManifest = contentApi.GetManifestPublicJson(manifestId, latestReferenceManifestId);
					await referenceManifest;
					await latestReferenceManifest;

					// Rebuild the content against the new manifests.
					localContentAgainstReference = contentService.GetAllContentFiles(referenceManifest.GetResult(), manifestId);
					localContentAgainstLatest = contentService.GetAllContentFiles(latestReferenceManifest.GetResult(), manifestId);
					await Task.WhenAll(localContentAgainstReference, localContentAgainstLatest);

					// Prepare a new Manifest to push out with only the changed entries.
					var remotePublishManifestToEmit = new ContentPsCommandEvent()
					{
						EventType = ContentPsCommandEvent.EVT_TYPE_RemotePublished,
						IsReferenceHeadInRealm = referenceManifest.GetResult().uid.Value == latestReferenceManifest.GetResult().uid.Value,
						RelevantManifestsAgainstReference = new()
						{
							new LocalContentManifest()
							{
								OwnerCid = cid,
								OwnerPid = pid,
								ManifestId = manifestId,
								ReferenceManifestUid = referenceManifest.GetResult().uid,
								LatestManifestUid = latestReferenceManifest.GetResult().uid,
								Entries = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstReference.Result.ContentFiles).ToArray(),
							}
						},
						RelevantManifestsAgainstLatest = new()
						{
							new LocalContentManifest()
							{
								OwnerCid = cid,
								OwnerPid = pid,
								ManifestId = manifestId,
								ReferenceManifestUid = referenceManifest.GetResult().uid,
								LatestManifestUid = latestReferenceManifest.GetResult().uid,
								Entries = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstLatest.Result.ContentFiles).ToArray(),
							}
						},
						ToRemoveLocalEntries = new(),
					};

					// Send it out.
					this.SendResults(remotePublishManifestToEmit);
					this.LogResult(remotePublishManifestToEmit);
				}
			});

			await localFileChangesTask;
			await remoteManifestPublishTask;
		}
	}

	protected virtual void LogResult(object result)
	{
		var json = JsonSerializer.Serialize(result, ContentService.GetContentFileSerializationOptions());
		AnsiConsole.Write(
			new Panel(new JsonText(json))
				.Collapse()
				.NoBorder());
	}
}

[Serializable]
public class ContentPsCommandArgs : CommandArgs
{
	public bool Watch;
	public string ManifestId;
}

[CliContractType, Serializable]
public class ContentPsCommandEvent
{
	/// <summary>
	/// The engine integration is expected to discard all their in-memory state about content and rebuild it with the information in this event.
	/// </summary>
	public const int EVT_TYPE_FullRebuild = 0;

	/// <summary>
	/// The engine integration is expected to discard all their in-memory state about what the local content is in relation to the latest published manifest of this realm.
	/// It should not discard the state against the reference manifest (latest pulled manifest / local "head").
	///
	/// Only <see cref="IsReferenceHeadInRealm"/> and <see cref="RelevantManifestsAgainstLatest"/> is correctly computed here.
	/// </summary>
	public const int EVT_TYPE_RemotePublished = 1;

	/// <summary>
	/// The engine integration is expected to use <see cref="ToRemoveLocalEntries"/> to update it's in-memory state regarding our reference manifest.
	/// </summary>
	public const int EVT_TYPE_ChangedContent = 2;

	/// <summary>
	/// One of <see cref="EVT_TYPE_FullRebuild"/>, <see cref="EVT_TYPE_RemotePublished"/> or <see cref="EVT_TYPE_ChangedContent"/>.
	/// The semantics of each field are defined based on the event and documented on these comments.
	/// </summary>
	public int EventType;

	/// <summary>
	/// This is just a utility that informs us whether the reference realm we are working on top of is the latest one deployed to the realm.
	/// In git terms... whether our current "local branch head" is the same as the remote's branch head.
	/// </summary>
	public bool IsReferenceHeadInRealm;

	/// <summary>
	/// List of manifests and entry data relevant to the event being emitted.
	/// </summary>
	public List<LocalContentManifest> RelevantManifestsAgainstReference;

	/// <summary>
	/// Contains a list of entries to be removed from the in-memory state, both relative to our reference manifest and our latest manifest.
	/// Imagine the case where:
	///  - I create a content locally, and it does not exist remotely yet.
	///  - I get an event that'll add it to my in-memory representation of "hey, this content status is Created (only exists locally).".
	///  - I then delete that content so it no longer exists locally (and it never existed in the remote). Now... it only exists in my in-memory representation.
	///  - I need to know that this was deleted --- it will not be contained in the <see cref="RelevantManifestsAgainstReference"/> or <see cref="RelevantManifestsAgainstLatest"/> because it no longer exists in neither
	///    locally NOR in the reference or latest manifests.
	///  - When the local deletion in such a case occurs, the ids for the deleted content is put here so we can clear our in-memory representation of it. 
	///  
	/// Only relevant when <see cref="EventType"/> is <see cref="EVT_TYPE_ChangedContent"/>.
	/// </summary>
	public List<LocalContentManifest> ToRemoveLocalEntries;

	/// <summary>
	/// List of manifests and entry data relevant to <see cref="EVT_TYPE_FullRebuild"/> and <see cref="EVT_TYPE_RemotePublished"/>.
	/// This contains what our local files look like related to the most recent published manifest.
	/// </summary>
	public List<LocalContentManifest> RelevantManifestsAgainstLatest;
}

[CliContractType, Serializable]
public class LocalContentManifest
{
	public string OwnerCid;
	public string OwnerPid;

	public string ManifestId;
	public string ReferenceManifestUid;
	public string LatestManifestUid;

	public LocalContentManifestEntry[] Entries;
}

[CliContractType, Serializable]
public struct LocalContentManifestEntry
{
	/// <summary>
	/// The full content id string.
	/// </summary>
	public string FullId;

	/// <summary>
	/// The type part of the <see cref="FullId"/>.
	/// </summary>
	public string TypeName;

	/// <summary>
	/// The name part of the <see cref="FullId"/>
	/// </summary>
	public string Name;

	/// <summary>
	/// Int value of <see cref="ContentStatus"/> for this entry.
	/// </summary>
	public int CurrentStatus;

	/// <summary>
	/// The MD5 hash of the properties of this content.
	/// See <see cref="ContentService.CalculateChecksum(in cli.Content.ContentFile)"/>.
	/// </summary>
	public string Hash;

	/// <summary>
	/// The tags stored in this <see cref="ContentFile.Tags"/>.
	/// </summary>
	public string[] Tags;

	/// <summary>
	/// The path to the local <see cref="ContentFile"/>.
	/// This is empty when the file is deleted locally.
	/// </summary>
	public string JsonFilePath;
}
