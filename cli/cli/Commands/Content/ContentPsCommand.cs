using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.BeamCli;
using Beamable.Server;
using cli.Dotnet;
using Spectre.Console;
using Spectre.Console.Json;
using System.Text.Json;

namespace cli.Content;

public class ContentPsCommand : AppCommand<ContentPsCommandArgs>, IResultSteam<DefaultStreamResultChannel, ContentPsCommandEvent>, ISkipManifest
{
	public int updateCount;

	public ContentPsCommand() : base("ps", "List the running status of local services not running in docker")
	{
	}

	public override void Configure()
	{
		ProjectCommand.AddWatchOption(this, (args, i) => args.Watch = i);
	}

	public override async Task Handle(ContentPsCommandArgs args)
	{
		var contentApi = args.Provider.GetService<IContentApi>();
		var cid = args.AppContext.Cid;
		var pid = args.AppContext.Pid;
		var manifestId = args.ManifestId ?? "global";

		var contentService = args.DependencyProvider.GetService<ContentService>();

		// Declarations of the manifest variables we care about during this command's lifecycle.
		Promise<ClientManifestJsonResponse> latestManifest = contentApi.GetManifestPublicJson(manifestId);
		await latestManifest;

		// If we are just creating the local representation for this realm+manifest combo, let's reset our state to match the remote state.
		_ = contentService.EnsureContentPathForRealmExists(out var created, pid, manifestId);
		if (created) await contentService.SyncLocalContent(latestManifest.GetResult(), manifestId);

		// Refresh the local ContentFile objects based on the latest reference manifest and emit a "full-rebuild" event.
		// Full rebuild events expect the engine to discard their in-memory state for this realm+manifest id handle and rebuild the entire list of content entries.
		var localContentAgainstLatest = contentService.GetAllContentFiles(latestManifest.GetResult(), manifestId);
		await Task.WhenAll(localContentAgainstLatest);

		// Prepare the content entries between our local state and the remote states that are relevant (our reference and the latest publish in the realm).
		var entriesToEmitAgainstLatest = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstLatest.Result.ContentFiles)
			.ToArray();

		// Build and emit the event
		var eventToEmit = new ContentPsCommandEvent()
		{
			EventType = ContentPsCommandEvent.EVT_TYPE_FullRebuild,
			RelevantManifestsAgainstLatest = new()
			{
				new LocalContentManifest()
				{
					OwnerCid = cid, OwnerPid = pid, ManifestId = manifestId, Entries = entriesToEmitAgainstLatest.ToArray(),
				}
			},
			ToRemoveLocalEntries = new(),
		};
		this.SendResults(eventToEmit);
		this.LogResult(eventToEmit);

		// If we are meant to watch the content folder, let's set up jobs to do that.
		if (args.Watch)
		{
			// Set up a task that will emit a ChangedContent event every time local files for this realm+manifestid handle are changed.
			// The events will only contain the entries for the modified content objects and expects the engine integration to only rebuild their in-memory representation of the modified object.
			var localFileChangesTask = Task.Run(async () =>
			{
				var tokenSource = new CancellationTokenSource();
				await foreach (var batchedLocalFileChanges in contentService.ListenToLocalContentFileChanges(pid, manifestId, tokenSource.Token))
				{
					// Find all locally deleted content
					var allLocalDeletions = batchedLocalFileChanges.AllFileChanges.Where(fc => fc.WasDeleted()).Select(fc => fc.ContentId);

					// Get the list of all content that was NOT in the remote but WAS deleted locally.
					var allLocalOnlyDeletions = allLocalDeletions.Except(latestManifest.GetResult().entries.Select(e => e.contentId)).ToArray();

					// Find the list of ids affected by the file changes
					var allRelevantIds = batchedLocalFileChanges.AllFileChanges.SelectMany(fc => string.IsNullOrEmpty(fc.OldContentId) ? new[] { fc.ContentId } : new[] { fc.ContentId, fc.OldContentId });

					// Refresh the local ContentFile objects based on the latest reference manifest
					localContentAgainstLatest = contentService.GetAllContentFiles(latestManifest.GetResult(), manifestId);
					await localContentAgainstLatest;

					// Prepare a new Manifest to push out with only the changed entries.
					var fileChangeManifestToEmit = new ContentPsCommandEvent()
					{
						EventType = ContentPsCommandEvent.EVT_TYPE_ChangedContent,
						RelevantManifestsAgainstLatest = new()
						{
							new LocalContentManifest()
							{
								OwnerCid = cid,
								OwnerPid = pid,
								ManifestId = manifestId,
								Entries = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstLatest.Result.ContentFiles.Where(c => allRelevantIds.Contains(c.Id))
								).ToArray(),
							}
						},
						ToRemoveLocalEntries = new()
						{
							new()
							{
								OwnerCid = cid, OwnerPid = pid, ManifestId = manifestId, Entries = allLocalOnlyDeletions.Select(id => new LocalContentManifestEntry() { FullId = id, CurrentStatus = -1 }).ToArray(),
							}
						}
					};

					// Send it out.
					this.SendResults(fileChangeManifestToEmit);
					this.LogResult(fileChangeManifestToEmit);
				}
			});


			// Set up a task that will emit a RemotePublished event every time someone THAT IS NOT YOU publish a manifest to this realm+manifestid handle.
			// This event will 
			var remoteManifestPublishTask = Task.Run(async () =>
			{
				var tokenSource = new CancellationTokenSource();
				await foreach (var remoteContentPublished in contentService.ListenToRemoteContentPublishes(args, manifestId, tokenSource.Token))
				{
					// Fetch the newest manifest
					var latestManifestId = remoteContentPublished.ReferenceUid;

					// Refresh both the reference manifest and the latest manifests.
					latestManifest = contentApi.GetManifestPublicJson(manifestId, latestManifestId);
					await latestManifest;

					// Rebuild the content against the new manifests.
					localContentAgainstLatest = contentService.GetAllContentFiles(latestManifest.GetResult(), manifestId);
					await localContentAgainstLatest;

					// Prepare a new Manifest to push out with only the changed entries.
					var remotePublishManifestToEmit = new ContentPsCommandEvent()
					{
						EventType = ContentPsCommandEvent.EVT_TYPE_RemotePublished,
						RelevantManifestsAgainstLatest = new()
						{
							new LocalContentManifest()
							{
								OwnerCid = cid,
								OwnerPid = pid,
								ManifestId = manifestId,
								Entries = ContentService.ContentFileToLocalContentManifestEntries(localContentAgainstLatest.Result.ContentFiles
								).ToArray(),
							}
						},
						ToRemoveLocalEntries = new(),
					};

					// Send it out.
					this.SendResults(remotePublishManifestToEmit);
					this.LogResult(remotePublishManifestToEmit);
				}
			});

			await localFileChangesTask;
			await remoteManifestPublishTask;
		}
	}

	protected virtual void LogResult(object result)
	{
		var json = JsonSerializer.Serialize(result, ContentService.GetContentFileSerializationOptions());
		AnsiConsole.Write(
			new Panel(new JsonText(json))
				.Collapse()
				.NoBorder());
	}
}

[Serializable]
public class ContentPsCommandArgs : CommandArgs
{
	public bool Watch;
	public string ManifestId;
}

[CliContractType, Serializable]
public class ContentPsCommandEvent
{
	/// <summary>
	/// The engine integration is expected to discard all their in-memory state about content and rebuild it with the information in this event.
	/// </summary>
	public const int EVT_TYPE_FullRebuild = 0;

	/// <summary>
	/// The engine integration is expected to discard all their in-memory state about what the local content is in relation to the latest published manifest of this realm.
	/// It should not discard the state against the reference manifest (latest pulled manifest / local "head").
	///
	/// Only <see cref="IsReferenceHeadInRealm"/> and <see cref="RelevantManifestsAgainstLatest"/> is correctly computed here.
	/// </summary>
	public const int EVT_TYPE_RemotePublished = 1;

	/// <summary>
	/// The engine integration is expected to use <see cref="ToRemoveLocalEntries"/> to update it's in-memory state regarding our reference manifest.
	/// </summary>
	public const int EVT_TYPE_ChangedContent = 2;

	/// <summary>
	/// One of <see cref="EVT_TYPE_FullRebuild"/>, <see cref="EVT_TYPE_RemotePublished"/> or <see cref="EVT_TYPE_ChangedContent"/>.
	/// The semantics of each field are defined based on the event and documented on these comments.
	/// </summary>
	public int EventType;

	/// <summary>
	/// List of manifests and entry data relevant to <see cref="EVT_TYPE_FullRebuild"/> and <see cref="EVT_TYPE_RemotePublished"/>.
	/// This contains what our local files look like related to the most recent published manifest.
	/// </summary>
	public List<LocalContentManifest> RelevantManifestsAgainstLatest;

	/// <summary>
	/// Contains a list of entries to be removed from the in-memory state, both relative to our reference manifest and our latest manifest.
	/// Imagine the case where:
	///  - I create a content locally, and it does not exist remotely yet.
	///  - I get an event that'll add it to my in-memory representation of "hey, this content status is Created (only exists locally).".
	///  - I then delete that content so it no longer exists locally (and it never existed in the remote). Now... it only exists in my in-memory representation.
	///  - I need to know that this was deleted --- it will not be contained in the <see cref="RelevantManifestsAgainstReference"/> or <see cref="RelevantManifestsAgainstLatest"/> because it no longer exists in neither
	///    locally NOR in the reference or latest manifests.
	///  - When the local deletion in such a case occurs, the ids for the deleted content is put here so we can clear our in-memory representation of it. 
	///  
	/// Only relevant when <see cref="EventType"/> is <see cref="EVT_TYPE_ChangedContent"/>.
	/// </summary>
	public List<LocalContentManifest> ToRemoveLocalEntries;
}

[CliContractType, Serializable]
public class LocalContentManifest
{
	public string OwnerCid;
	public string OwnerPid;
	public string ManifestId;

	public LocalContentManifestEntry[] Entries;
}

[CliContractType, Serializable]
public struct LocalContentManifestEntry
{
	/// <summary>
	/// The full content id string.
	/// </summary>
	public string FullId;

	/// <summary>
	/// The type part of the <see cref="FullId"/>.
	/// </summary>
	public string TypeName;

	/// <summary>
	/// The name part of the <see cref="FullId"/>
	/// </summary>
	public string Name;

	/// <summary>
	/// Int value of <see cref="ContentStatus"/> for this entry.
	/// </summary>
	public int CurrentStatus;

	/// <summary>
	/// The MD5 hash of the properties of this content.
	/// See <see cref="ContentService.CalculateChecksum(in cli.Content.ContentFile)"/>.
	/// </summary>
	public string Hash;

	/// <summary>
	/// The tags stored in this <see cref="ContentFile.Tags"/>.
	/// </summary>
	public string[] Tags;

	/// <summary>
	/// The path to the local <see cref="ContentFile"/>.
	/// This is empty when the file is deleted locally.
	/// </summary>
	public string JsonFilePath;

	/// <summary>
	/// ID of the last published manifest to which this content was ever sync'ed. 
	/// </summary>
	public string ReferenceManifestUid;
}
