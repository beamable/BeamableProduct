using Beamable.Api.Autogenerated.Realms;
using Beamable.Common.Api;
using Beamable.Common.Dependencies;
using cli.Utils;
using Newtonsoft.Json;
using Serilog;
using System.Net.WebSockets;
using System.Text;

namespace cli.Notifications;

public class NotificationServerCommandArgs : CommandArgs
{
	
}

public class NotificationServerOutput
{
	public string path;
	public string body;
}
public class NotificationServerCommand : StreamCommand<NotificationServerCommandArgs, NotificationServerOutput>
{

	public NotificationServerCommand() 
		: base("server", "Listen to server events")
	{
	}

	public override void Configure()
	{
		
	}

	public override async Task Handle(NotificationServerCommandArgs args)
	{
		
		var socketAddress = GetSocketUrl(args.AppContext.Host);
		var secret = await GetRealmSecret(args);
		Log.Debug($"Connecting to {socketAddress} / {secret}");
		var ws = new ClientWebSocket();
		var cancelToken = new CancellationToken();
		await ws.ConnectAsync(new Uri(socketAddress), cancelToken);

		await Authenticate(ws, secret, args.AppContext.Cid, args.AppContext.Pid, cancelToken);
		await RegisterForEvents(ws, cancelToken);

		do
		{
			var message = await WebsocketUtil.ReadMessage(ws, cancelToken);
			var messageObj = JsonConvert.DeserializeObject<EventMessage>(message);
			var bodyJson = JsonConvert.SerializeObject(messageObj.body);
			Log.Information($"{messageObj.path} -- {bodyJson}" );
			SendResults(new NotificationServerOutput
			{
				path = messageObj.path,
				body = bodyJson
			});
		} while (ws.State == WebSocketState.Open);
	}

	private static async Task<string> GetRealmSecret(CommandArgs args)
	{
		var api = args.DependencyProvider.GetService<IRealmsApi>();
		var customer = await api.GetCustomer();
		var project = customer.customer.projects.FirstOrDefault(p => p.pid == args.AppContext.Pid);
		if (project == null) throw new CliException("Invalid PID");
		return project.secret.Value;
	}

	private static async Task Authenticate(ClientWebSocket ws, string secret, string cid, string pid, CancellationToken cancellationToken)
	{
		string CalculateSignature(string text)
		{
			System.Security.Cryptography.MD5 md5 = System.Security.Cryptography.MD5.Create();
			byte[] data = Encoding.UTF8.GetBytes(text);
			byte[] hash = md5.ComputeHash(data);
			return Convert.ToBase64String(hash);
		}

		Log.Debug($"Authorizing WS connection at ThreadID = {Thread.CurrentThread.ManagedThreadId}");
		var nonceRequest = JsonConvert.SerializeObject(new
		{
			id = 1, method = "get", path = "gateway/nonce",
		});
		Log.Debug($"Sending nonce {nonceRequest}");
		await WebsocketUtil.SendMessageAsync(ws, nonceRequest, cancellationToken);
		var nonceResponse = await WebsocketUtil.ReadMessage(ws, cancellationToken);
		Log.Debug($"Received challenge {nonceResponse}");
		var nonceObj = JsonConvert.DeserializeObject<NonceResult>(nonceResponse);
		var nonce = nonceObj.body["nonce"];
		var sig = CalculateSignature(secret + nonce);
		var authRequest = JsonConvert.SerializeObject(new
		{
			id = 2,
			method = "post",
			path = "gateway/auth",
			body = new
			{
				cid, pid, signature = sig
			}
		});
		await WebsocketUtil.SendMessageAsync(ws, authRequest, cancellationToken);
		Log.Debug($"Sending auth request {authRequest}");

		var authResponse = await WebsocketUtil.ReadMessage(ws, cancellationToken);
		Log.Debug($"Received auth response {authResponse}");

		var authResult = JsonConvert.DeserializeObject<AuthResult>(authResponse);
		if (authResult.status != 200)
		{
			throw new CliException($"Could not authenticate with Beamable status=[{authResult.status}]");
		}
	}

	private static async Task RegisterForEvents(ClientWebSocket ws, CancellationToken cancelToken)
	{
		var reqObject = new
		{
			id = 3,
			method = "post",
			path = "gateway/provider",
			body = new
			{
				type = "event", evtWhitelist = new string[] { "content.manifest", "realm-config.refresh" }
			}
		};
		var reqJson = JsonConvert.SerializeObject(reqObject);
		Log.Debug($"Registering for events - {reqJson}");

		await WebsocketUtil.SendMessageAsync(ws, reqJson, cancelToken);
		var resultJson = await WebsocketUtil.ReadMessage(ws, cancelToken);
		Log.Debug($"Received {resultJson}");
		
		var registerResult = JsonConvert.DeserializeObject<AuthResult>(resultJson);
		if (registerResult.status != 200)
		{
			throw new CliException($"Could not register with Beamable status=[{registerResult.status}]");
		}
	}
	
	private static string GetSocketUrl(string apiUrl)
	{
		string url = apiUrl
			.Replace("localhost", "host.docker.internal")
			.Replace("http://", "ws://")
			.Replace("https://", "wss://");
		return $"{url}/socket";
	}

	public struct NonceResult
	{
		public Dictionary<string, string> body;
	}

	public struct AuthResult
	{
		public int status;
	}

	public struct EventMessage
	{
		public string path;
		public object body;
	}

}
