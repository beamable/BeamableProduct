using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Realms;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.BeamCli.Contracts;
using Beamable.Common.Semantics;
using cli.Commands.Project;
using Docker.DotNet;
using Microsoft.Extensions.DependencyInjection;
using System.CommandLine;
using System.Diagnostics;
using System.Text;
using Beamable.Api.Autogenerated.Beamootel;
using Beamable.Api.Autogenerated.Models;
using Beamable.Server;
using cli.Services;
using cli.Utils;
using CustomerResponse = Beamable.Api.Autogenerated.Models.CustomerResponse;

namespace cli.Dotnet;

public class GenerateEnvFileCommandArgs : CommandArgs
{
	public string output;
	public bool includePrefix = true;
	public int instanceCount = 1;
	public ServiceName serviceId;
	public bool autoDeploy;
	public bool includeSecret;
	public bool excludeOtelCreds;
	public int autoRemoveInstancesExceptProcessId;
}

public class GenerateEnvFileCommand : AtomicCommand<GenerateEnvFileCommandArgs, GenerateEnvFileOutput>, ISkipManifest
{
	public override bool IsForInternalUse => true;

	public GenerateEnvFileCommand() : base("generate-env", "Get the connection strings required to start a Microservice. This is used when running Standalone Microservices locally without Docker")
	{
	}

	public override void Configure()
	{
		AddArgument(new Argument<ServiceName>("service", "Which service to generate the .env file for"), (args, i) => args.serviceId = i);
		AddArgument(new Argument<string>("output", "Where to output the .env file"), (args, i) => args.output = i);
		AddOption(new Option<bool>("--include-prefix", () => true, "If true, the generated .env file will include the local machine name as prefix"), (args, i) => args.includePrefix = i);
		AddOption(new Option<bool>("--exclude-otel-creds", () => false, "If true, do not ask for otel auth credentials to be put in the env"), (args, i) => args.excludeOtelCreds = i);
		AddOption(new Option<int>("--instance-count", () => 1, "How many virtual websocket connections the server will open"), (args, i) => args.instanceCount = i);
		AddOption(new Option<bool>("--auto-deploy", () => false, "When enabled, automatically deploy dependencies that aren't running"), (args, i) => args.autoDeploy = i);
		AddOption(new Option<bool>("--include-secret", () => false, "When enabled, includes the legacy SECRET realm secret environment variable"), (args, i) => args.includeSecret = i);
		AddOption(new Option<int>("--remove-all-except-pid",  "When enabled, automatically stop all other local instances of this service"), (args, i) => args.autoRemoveInstancesExceptProcessId = i);
	}

	async Promise<CustomerResponse> GetAdminCustomer(CommandArgs args)
	{
		try
		{
			var realmsApi = ServiceProviderServiceExtensions.GetService<IRealmsApi>(args.Provider);
			var res = await realmsApi.GetAdminCustomer();
			return res;
		}
		catch (RequesterException ex) when (ex.Status == 401)
		{
			throw new CliException(
				message: $"The authorization context is not sufficient to start a microservice in the current realm=[{args.AppContext.Pid}]. " +
				         $"If you have not logged into the current realm, then you must do so before running the service. " +
				         $"Run the `beam login` command and retry. ");
		}
	}

	public static GenerateEnvFileOutput CreateDockerEnv(CommandArgs args, string secret, bool includePrefix=true, int instanceCount=10)
	{
		var output = new GenerateEnvFileOutput
		{
			envVars = new List<EnvVarOutput>
			{
				EnvVarOutput.Create("HOST", args.AppContext.Host.Replace("http", "ws") + "/socket"),
				EnvVarOutput.Create("CID", args.AppContext.Cid),
				EnvVarOutput.Create("PID", args.AppContext.Pid),
				EnvVarOutput.Create("NAME_PREFIX", includePrefix ? ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine() : ""),
				EnvVarOutput.Create("BEAM_INSTANCE_COUNT", instanceCount.ToString()),
				EnvVarOutput.Create("SECRET", secret),
				
				// this is a strange one that on AMD mac is _sometimes_ required, otherwise you see strange PAL_SEH errors
				//  https://github.com/dotnet/runtime/issues/103063
				EnvVarOutput.Create("DOTNET_EnableWriteXorExecute", "0")
			}
		};
			
		return output;
	}

	public static async Task WriteEnvToFile(string file, GenerateEnvFileOutput output)
	{
		var fileContent = new StringBuilder();
				
		foreach (var envVar in output.envVars)
		{
			fileContent.Append(envVar.name);
			fileContent.Append("=");
			fileContent.AppendLine(envVar.value);
		}
		await File.WriteAllTextAsync(file, fileContent.ToString());
	}

	public override async Task<GenerateEnvFileOutput> GetResult(GenerateEnvFileCommandArgs args)
	{
		Task shutdownTask = null;
		var manifestTask = args.BeamoLocalSystem.InitManifest(fetchServerManifest: false);

		if (args.autoRemoveInstancesExceptProcessId > 0)
		{
			shutdownTask = Task.Run(async () =>
			{
				try
				{
					await manifestTask;
					await StopProjectCommand.DiscoverAndStopServices(args,
						new HashSet<string>(new string[] { args.serviceId.Value }),
						true, TimeSpan.FromMilliseconds(500), output =>
						{
							Log.Information($"Stopping other service key=[{output.instance.primaryKey}]");
						}, filter: (instance) =>
						{
							// only remove instances that aren't the one we are turning on! 
							var isSelf = instance.latestHostEvent?.processId == args.autoRemoveInstancesExceptProcessId;
							return !isSelf;
						});
				}
				catch (Exception ex)
				{
					Log.Error("Failed to shutdown existing services " + ex.Message);
				}
			});

		}


		var beamoApi = args.DependencyProvider.GetService<BeamBeamootelApi>();
		var accountApi = args.DependencyProvider.GetService<IAccountsApi>();
		var userReq = accountApi.GetAdminMe();

		Promise<CustomerResponse> custReq = null;
		if (args.includeSecret)
		{
			custReq = GetAdminCustomer(args);
		}

		Promise<OtelAuthConfig> otelAuthReq = null;
		if (!args.excludeOtelCreds)
		{
			otelAuthReq = beamoApi.GetOtelAuthWriterConfig();
		}
		
		var user = await userReq;
		await manifestTask;

		var accountId = user.id; //note; the admin/me call returns an accountId; but the /me returns a gamerTag

		var logLevel = Environment.GetEnvironmentVariable("LOG_LEVEL");
		if (string.IsNullOrEmpty(logLevel))
		{
			logLevel = "debug";
		}
		
		var output = new GenerateEnvFileOutput
		{
			envVars = new List<EnvVarOutput>
			{
				EnvVarOutput.Create("HOST", args.AppContext.Host.Replace("http", "ws") + "/socket"),
				EnvVarOutput.Create("CID", args.AppContext.Cid),
				EnvVarOutput.Create("LOG_LEVEL", logLevel),
				EnvVarOutput.Create("PID", args.AppContext.Pid),
				EnvVarOutput.Create("NAME_PREFIX", args.includePrefix ? ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine() : ""),
				EnvVarOutput.Create("BEAM_INSTANCE_COUNT", args.instanceCount.ToString()),
				EnvVarOutput.Create("REFRESH_TOKEN", args.AppContext.RefreshToken),
				EnvVarOutput.Create("USER_ACCOUNT_ID", accountId.ToString()),
				EnvVarOutput.Create("USER_EMAIL", user.email),
			}
		};

		if (args.includeSecret)
		{
			var res = await custReq;
			var proj = res.customer.projects.FirstOrDefault(p => p.name == args.AppContext.Pid);
			output.envVars.Add(EnvVarOutput.Create("SECRET", proj.secret));
		}

		if (!args.excludeOtelCreds)
		{
			var otelAuth = await otelAuthReq;
			output.envVars.Add(EnvVarOutput.Create(Beamable.Common.Constants.Features.Otel.ENV_COLLECTOR_CLICKHOUSE_ENDPOINT, otelAuth.endpoint));
			output.envVars.Add(EnvVarOutput.Create(Beamable.Common.Constants.Features.Otel.ENV_COLLECTOR_CLICKHOUSE_USERNAME, otelAuth.username));
			output.envVars.Add(EnvVarOutput.Create(Beamable.Common.Constants.Features.Otel.ENV_COLLECTOR_CLICKHOUSE_PASSWORD, otelAuth.password));
		}

		var sw = new Stopwatch();
		sw.Start();

		var manifest = args.BeamoLocalSystem.BeamoManifest;
		var service = manifest.ServiceDefinitions.FirstOrDefault(service => service.BeamoId == args.serviceId);
		if (service != null)
		{
			var deps = args.BeamoLocalSystem.GetDependencies(service.BeamoId);
			if (deps.Count > 0)
			{
				// Docker is required to be running in the case where there are dependencies
				var isDockerRunning = await args.BeamoLocalSystem.CheckIsRunning();
				if (!isDockerRunning)
				{
					throw CliExceptions.DOCKER_NOT_RUNNING;
				}

				var singleStringDeps = string.Join(",", deps.Select(d => d.name).ToList());
				output.envVars.Add(EnvVarOutput.Create($"BEAM_DEPS_{service.BeamoId}", singleStringDeps));
			}

			try
			{
				await AppendDependencyVars(deps);
			}
			catch (Exception) when (args.autoDeploy)
			{
				await args.BeamoLocalSystem.SynchronizeInstanceStatusWithDocker(args.BeamoLocalSystem.BeamoManifest, args.BeamoLocalSystem.BeamoRuntime.ExistingLocalServiceInstances);
				await args.BeamoLocalSystem.StartListeningToDocker();
				var dependencies = args.BeamoLocalSystem.GetDependencies(service.BeamoId);
				Log.Information("Starting " + string.Join(",", dependencies.Select(d => d.name).ToList()) + " " + sw.ElapsedMilliseconds);
				await args.BeamoLocalSystem.DeployToLocal(args.BeamoLocalSystem, dependencies.Select(dep => dep.name).ToArray());
				await args.BeamoLocalSystem.InitManifest();
				args.BeamoLocalSystem.SaveBeamoLocalRuntime();
				await args.BeamoLocalSystem.StopListeningToDocker();
				await AppendDependencyVars(deps);
			}

		}

		async Promise AppendDependencyVars(List<DependencyData> deps)
		{

			foreach (var dependency in deps)
			{
				try
				{
					var connEnvVar =
						await args.BeamoLocalSystem.GetLocalConnectionString(args.BeamoLocalSystem.BeamoManifest,
							dependency.name, "localhost");
					output.envVars.Add(EnvVarOutput.Create(
						name: connEnvVar.VariableName,
						value: connEnvVar.Value));
				}
				catch (DockerContainerNotFoundException)
				{
					// uh oh, the storage isn't running
					throw new CliException(
						$"Service requires storage=[{dependency.name}] but it is not running. Please execute 'beam services run --ids {dependency.name}'", Beamable.Common.Constants.Features.Services.CMD_RESULT_CODE_CONTAINER_NOT_RUNNING, true);
				}
			}
		}

		if (shutdownTask != null)
		{
			// wait for other tasks to turn off
			await shutdownTask;
		}
		
		{
			/*
			 * This command is going to write an .env file for legacy purposes.
			 * Pre 1.19.17, the .env file carried all connection details like CID/PID/etc,
			 * and Microservices with <1.19.17 expect the file to exist.
			 *
			 * After that version, the connection details transit over STDOUT and
			 * do not need to be stored on disk.
			 *
			 * However, when someone updates from 1.19.17, the Program.cs file will
			 * still have this function,
			 * `LoadEnvironmentVariables`, and if the file doesn't exist, the Program.cs
			 * will throw an exception.
			 *
			 * Post 1.19.17, the details get loaded in the Prepare method, and the
			 * `LoadEnvironmentVariables` is removed from the template.
			 *
			 * So, if we don't write an .env file, anyone updating from pre 1.19.17 will
			 * be broken until they delete the `LoadEnvironmentVariables` function by hand.
			 * 
			 */
			// BeamableLogger.Log($"WRITING ENV FILE t=[{sw.ElapsedMilliseconds}]");
			// var path = Path.Combine(args.output, ".env");
			// Directory.CreateDirectory(args.output);
			// File.WriteAllText(path, "BEAMABLE_ENV_FILE_NO_LONGER_EXISTS=1\n\n");
			
			
			/*
			 * Re-visted again for CLI 6;
			 * It has been long enough we don't need to blindly output the .env file for
			 * legacy purposes.
			 *
			 * however, now it would actually be useful for docker-compose workflows to have
			 * a real .env file.
			 *
			 * So the behaviour will change to say IF the output is given, we will actually write
			 * a valid .env file, and its up to the user to not mess it up.
			 */
			if (!string.IsNullOrEmpty(args.output) && args.output != ".")
			{
				await WriteEnvToFile(args.output, output);
			}
		}
		return output;
	}


}
