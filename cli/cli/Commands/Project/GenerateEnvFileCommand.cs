using Beamable.Api.Autogenerated.Realms;
using Beamable.Common;
using cli.Utils;
using Docker.DotNet;
using JetBrains.Annotations;
using Microsoft.Extensions.DependencyInjection;
using Serilog;
using System.CommandLine;
using System.Diagnostics;
using System.Net.NetworkInformation;

namespace cli.Dotnet;

public class GenerateEnvFileCommandArgs : CommandArgs
{
	public string output;
	public bool includePrefix = true;
	public int instanceCount = 1;
	public string serviceId;
	public bool autoDeploy;
}

public class GenerateEnvFileCommand : AppCommand<GenerateEnvFileCommandArgs>
{
	public GenerateEnvFileCommand() : base("generate-env", "Generate an .env file at a given location for a Microservice execution")
	{
	}

	public override void Configure()
	{
		AddArgument(new Argument<string>("service", "Which service to generate the .env file for"), (args, i) => args.serviceId = i);
		AddArgument(new Argument<string>("output", "Where to output the .env file"), (args, i) => args.output = i);
		AddOption(new Option<bool>("--include-prefix", () => true, "If true, the generated .env file will include the local machine name as prefix"), (args, i) => args.includePrefix = i);
		AddOption(new Option<int>("--instance-count", () => 1, "How many virtual websocket connections the server will open"), (args, i) => args.instanceCount = i);
		AddOption(new Option<bool>("--auto-deploy", () => false, "When enabled, automatically deploy dependencies that aren't running"), (args, i) => args.autoDeploy = i);
	}

	public override async Task Handle(GenerateEnvFileCommandArgs args)
	{
		var realmsApi = args.Provider.GetService<IRealmsApi>();
		var res = await realmsApi.GetAdminCustomer();
		var proj = res.customer.projects.FirstOrDefault(p => p.name == args.AppContext.Pid);

		var secret = proj.secret;
		var cid = args.AppContext.Cid;
		var pid = args.AppContext.Pid;
		var prefix = args.includePrefix ? MachineHelper.GetUniqueDeviceId() : "";
		var host = args.AppContext.Host.Replace("http", "ws") + "/socket";

		
		var fileContent = @$"SECRET={secret}
HOST={host}
CID={cid}
PID={pid}
NAME_PREFIX={prefix}
BEAM_INSTANCE_COUNT={args.instanceCount}
";
		
		var manifest = args.BeamoLocalSystem.BeamoManifest;
		var service = manifest.ServiceDefinitions.FirstOrDefault(service => service.BeamoId == args.serviceId);
		if (service == null)
		{
			throw new CliException("Service is not listed in local beamo manifest", true, true);
		}

		var sw = new Stopwatch();
		sw.Start();
		
		if (args.autoDeploy)
		{
			
		}

		async Promise AppendDependencyVars()
		{
			foreach (var dependency in service.DependsOnBeamoIds)
			{
				try
				{
					var connEnvVar =
						await args.BeamoLocalSystem.GetLocalConnectionString(args.BeamoLocalSystem.BeamoManifest,
							dependency, "localhost");
					fileContent = $"{connEnvVar.VariableName}={connEnvVar.Value}\n" + fileContent;
				}
				catch (DockerContainerNotFoundException)
				{
					// uh oh, the storage isn't running
					throw new CliException(
						$"Service requires storage=[{dependency}] but it is not running. Please execute 'beam services deploy --ids {dependency}'", true, true);
				}
			}
		}

		try
		{
			await AppendDependencyVars();
		}
		catch (Exception) when (args.autoDeploy)
		{
			await args.BeamoLocalSystem.SynchronizeInstanceStatusWithDocker(args.BeamoLocalSystem.BeamoManifest, args.BeamoLocalSystem.BeamoRuntime.ExistingLocalServiceInstances);
			await args.BeamoLocalSystem.StartListeningToDocker();
			Log.Information("Starting " + string.Join(",", service.DependsOnBeamoIds) + " " + sw.ElapsedMilliseconds);
			await args.BeamoLocalSystem.DeployToLocal(args.BeamoLocalSystem.BeamoManifest, service.DependsOnBeamoIds);
			args.BeamoLocalSystem.SaveBeamoLocalManifest();
			args.BeamoLocalSystem.SaveBeamoLocalRuntime();
			await args.BeamoLocalSystem.StopListeningToDocker();
			await AppendDependencyVars();
		}
		BeamableLogger.Log($"WRITING ENV FILE t=[{sw.ElapsedMilliseconds}] env=[{fileContent}]");
		var path = Path.Combine(args.output, ".env");
		Directory.CreateDirectory(args.output);
		File.WriteAllText(path, fileContent);
	}


}
