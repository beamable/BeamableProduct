using Beamable.Api.Autogenerated.Realms;
using Beamable.Common;
using Beamable.Common.Semantics;
using cli.Utils;
using Docker.DotNet;
using JetBrains.Annotations;
using Microsoft.Extensions.DependencyInjection;
using Serilog;
using System.CommandLine;
using System.Diagnostics;
using System.Net.NetworkInformation;

namespace cli.Dotnet;

public class GenerateEnvFileCommandArgs : CommandArgs
{
	public string output;
	public bool includePrefix = true;
	public int instanceCount = 1;
	public ServiceName serviceId;
	public bool autoDeploy;
}

public class GenerateEnvFileCommand : AppCommand<GenerateEnvFileCommandArgs>
{
	public GenerateEnvFileCommand() : base("generate-env", "Generate an .env file at a given location for a Microservice execution")
	{
	}

	public override void Configure()
	{
		AddArgument(new Argument<ServiceName>("service", "Which service to generate the .env file for"), (args, i) => args.serviceId = i);
		AddArgument(new Argument<string>("output", "Where to output the .env file"), (args, i) => args.output = i);
		AddOption(new Option<bool>("--include-prefix", () => true, "If true, the generated .env file will include the local machine name as prefix"), (args, i) => args.includePrefix = i);
		AddOption(new Option<int>("--instance-count", () => 1, "How many virtual websocket connections the server will open"), (args, i) => args.instanceCount = i);
		AddOption(new Option<bool>("--auto-deploy", () => false, "When enabled, automatically deploy dependencies that aren't running"), (args, i) => args.autoDeploy = i);
	}

	public override async Task Handle(GenerateEnvFileCommandArgs args)
	{
		var realmsApi = args.Provider.GetService<IRealmsApi>();
		var res = await realmsApi.GetAdminCustomer();
		var proj = res.customer.projects.FirstOrDefault(p => p.name == args.AppContext.Pid);

		var secret = proj.secret;
		var cid = args.AppContext.Cid;
		var pid = args.AppContext.Pid;
		var prefix = args.includePrefix ? MachineHelper.GetUniqueDeviceId() : "";
		var host = args.AppContext.Host.Replace("http", "ws") + "/socket";
		var refreshToken = args.AppContext.RefreshToken;


		var fileContent = @$"SECRET={secret}
HOST={host}
CID={cid}
PID={pid}
NAME_PREFIX={prefix}
BEAM_INSTANCE_COUNT={args.instanceCount}
REFRESH_TOKEN={refreshToken}
";


		var sw = new Stopwatch();
		sw.Start();

		var manifest = args.BeamoLocalSystem.BeamoManifest;
		var service = manifest.ServiceDefinitions.FirstOrDefault(service => service.BeamoId == args.serviceId);
		if (service != null)
		{

			try
			{
				await AppendDependencyVars();
			}
			catch (Exception) when (args.autoDeploy)
			{
				await args.BeamoLocalSystem.SynchronizeInstanceStatusWithDocker(args.BeamoLocalSystem.BeamoManifest, args.BeamoLocalSystem.BeamoRuntime.ExistingLocalServiceInstances);
				await args.BeamoLocalSystem.StartListeningToDocker();
				var dependencies = await args.BeamoLocalSystem.GetDependencies(service.BeamoId);
				Log.Information("Starting " + string.Join(",", dependencies) + " " + sw.ElapsedMilliseconds);
				await args.BeamoLocalSystem.DeployToLocal(args.BeamoLocalSystem, dependencies.ToArray());
				args.BeamoLocalSystem.SaveBeamoLocalManifest();
				args.BeamoLocalSystem.SaveBeamoLocalRuntime();
				await args.BeamoLocalSystem.StopListeningToDocker();
				await AppendDependencyVars();
			}

		}

		async Promise AppendDependencyVars()
		{
			var deps = await args.BeamoLocalSystem.GetDependencies(service.BeamoId);
			foreach (var dependency in deps)
			{
				try
				{
					var connEnvVar =
						await args.BeamoLocalSystem.GetLocalConnectionString(args.BeamoLocalSystem.BeamoManifest,
							dependency, "localhost");
					fileContent = $"{connEnvVar.VariableName}={connEnvVar.Value}\n" + fileContent;
				}
				catch (DockerContainerNotFoundException)
				{
					// uh oh, the storage isn't running
					throw new CliException(
						$"Service requires storage=[{dependency}] but it is not running. Please execute 'beam services run --ids {dependency}'", Beamable.Common.Constants.Features.Services.CMD_RESULT_CODE_CONTAINER_NOT_RUNNING, true);
				}
			}
		}

		BeamableLogger.Log($"WRITING ENV FILE t=[{sw.ElapsedMilliseconds}] env=[{fileContent}]");
		var path = Path.Combine(args.output, ".env");
		Directory.CreateDirectory(args.output);
		File.WriteAllText(path, fileContent);
	}


}
