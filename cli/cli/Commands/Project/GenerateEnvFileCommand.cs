using Beamable.Api.Autogenerated.Realms;
using Beamable.Common;
using Beamable.Common.BeamCli;
using Beamable.Common.BeamCli.Contracts;
using Beamable.Common.Semantics;
using cli.Services;
using cli.Utils;
using Docker.DotNet;
using JetBrains.Annotations;
using Microsoft.Extensions.DependencyInjection;
using Serilog;
using SharpYaml.Tokens;
using System.CommandLine;
using System.Diagnostics;
using System.Net.NetworkInformation;

namespace cli.Dotnet;

public class GenerateEnvFileCommandArgs : CommandArgs
{
	public string output;
	public bool includePrefix = true;
	public int instanceCount = 1;
	public ServiceName serviceId;
	public bool autoDeploy;
}

public class GenerateEnvFileCommand : AtomicCommand<GenerateEnvFileCommandArgs, GenerateEnvFileOutput>
{
	public override bool IsForInternalUse => true;

	public GenerateEnvFileCommand() : base("generate-env", "Get the connection strings required to start a Microservice. This is used when running Standalone Microservices locally without Docker")
	{
	}

	public override void Configure()
	{
		AddArgument(new Argument<ServiceName>("service", "Which service to generate the .env file for"), (args, i) => args.serviceId = i);
		AddArgument(new Argument<string>("output", "Where to output the .env file"), (args, i) => args.output = i);
		AddOption(new Option<bool>("--include-prefix", () => true, "If true, the generated .env file will include the local machine name as prefix"), (args, i) => args.includePrefix = i);
		AddOption(new Option<int>("--instance-count", () => 1, "How many virtual websocket connections the server will open"), (args, i) => args.instanceCount = i);
		AddOption(new Option<bool>("--auto-deploy", () => false, "When enabled, automatically deploy dependencies that aren't running"), (args, i) => args.autoDeploy = i);
	}

	public override async Task<GenerateEnvFileOutput> GetResult(GenerateEnvFileCommandArgs args)
	{
		var realmsApi = args.Provider.GetService<IRealmsApi>();
		var res = await realmsApi.GetAdminCustomer();
		var proj = res.customer.projects.FirstOrDefault(p => p.name == args.AppContext.Pid);

		var output = new GenerateEnvFileOutput
		{
			envVars = new List<EnvVarOutput>
			{
				EnvVarOutput.Create("SECRET", proj.secret),
				EnvVarOutput.Create("HOST", args.AppContext.Host.Replace("http", "ws") + "/socket"),
				EnvVarOutput.Create("CID", args.AppContext.Cid),
				EnvVarOutput.Create("PID", args.AppContext.Pid),
				EnvVarOutput.Create("NAME_PREFIX", args.includePrefix ? MachineHelper.GetUniqueDeviceId() : ""),
				EnvVarOutput.Create("BEAM_INSTANCE_COUNT", args.instanceCount.ToString()),
				EnvVarOutput.Create("REFRESH_TOKEN", args.AppContext.RefreshToken),
			}
		};

		var sw = new Stopwatch();
		sw.Start();

		var manifest = args.BeamoLocalSystem.BeamoManifest;
		var service = manifest.ServiceDefinitions.FirstOrDefault(service => service.BeamoId == args.serviceId);
		if (service != null)
		{

			try
			{
				await AppendDependencyVars();
			}
			catch (Exception) when (args.autoDeploy)
			{
				await args.BeamoLocalSystem.SynchronizeInstanceStatusWithDocker(args.BeamoLocalSystem.BeamoManifest, args.BeamoLocalSystem.BeamoRuntime.ExistingLocalServiceInstances);
				await args.BeamoLocalSystem.StartListeningToDocker();
				var dependencies = args.BeamoLocalSystem.GetDependencies(service.BeamoId);
				Log.Information("Starting " + string.Join(",", dependencies) + " " + sw.ElapsedMilliseconds);

				await args.BeamoLocalSystem.DeployToLocal(args.BeamoLocalSystem, dependencies.Select(dep => dep.name).ToArray());
				await args.BeamoLocalSystem.InitManifest();
				args.BeamoLocalSystem.SaveBeamoLocalRuntime();
				await args.BeamoLocalSystem.StopListeningToDocker();
				await AppendDependencyVars();
			}

		}

		async Promise AppendDependencyVars()
		{
			var deps = args.BeamoLocalSystem.GetDependencies(service.BeamoId);
			foreach (var dependency in deps)
			{
				try
				{
					var connEnvVar =
						await args.BeamoLocalSystem.GetLocalConnectionString(args.BeamoLocalSystem.BeamoManifest,
							dependency.name, "localhost");
					output.envVars.Add(EnvVarOutput.Create(
						name: connEnvVar.VariableName,
						value: connEnvVar.Value));
				}
				catch (DockerContainerNotFoundException)
				{
					// uh oh, the storage isn't running
					throw new CliException(
						$"Service requires storage=[{dependency}] but it is not running. Please execute 'beam services run --ids {dependency}'", Beamable.Common.Constants.Features.Services.CMD_RESULT_CODE_CONTAINER_NOT_RUNNING, true);
				}
			}
		}

		{
			/*
			 * This command is going to write an .env file for legacy purposes.
			 * Pre 1.19.17, the .env file carried all connection details like CID/PID/etc,
			 * and Microservices with <1.19.17 expect the file to exist.
			 *
			 * After that version, the connection details transit over STDOUT and
			 * do not need to be stored on disk.
			 *
			 * However, when someone updates from 1.19.17, the Program.cs file will
			 * still have this function,
			 * `LoadEnvironmentVariables`, and if the file doesn't exist, the Program.cs
			 * will throw an exception.
			 *
			 * Post 1.19.17, the details get loaded in the Prepare method, and the
			 * `LoadEnvironmentVariables` is removed from the template.
			 *
			 * So, if we don't write an .env file, anyone updating from pre 1.19.17 will
			 * be broken until they delete the `LoadEnvironmentVariables` function by hand.
			 * 
			 */
			BeamableLogger.Log($"WRITING ENV FILE t=[{sw.ElapsedMilliseconds}]");
			var path = Path.Combine(args.output, ".env");
			Directory.CreateDirectory(args.output);
			File.WriteAllText(path, "BEAMABLE_ENV_FILE_NO_LONGER_EXISTS=1\n\n");
		}
		return output;
	}


}
