using Beamable.Common;
using Beamable.Server;
using Beamable.Server.Editor;
using Beamable.Server.Generator;
using System.CommandLine;
using System.Reflection;
using System.Runtime.Loader;

namespace cli.Dotnet;

public class GenerateClientFileCommandArgs : CommandArgs
{
	public string microserviceAssemblyPath;
	public string outputDirectory;
	public bool outputToLinkedProjects = true;
}
public class GenerateClientFileCommand : AppCommand<GenerateClientFileCommandArgs>
{
	public GenerateClientFileCommand() : base("generate-client", "generate a C# client file based on a built C# microservice dll directory")
	{
	}

	public override void Configure()
	{
		AddArgument(new Argument<string>("source", "the .dll filepath for the built microservice"), (arg, i) => arg.microserviceAssemblyPath = i);
		
		// TODO: use an output flag to decide if we should auto-go to all links
		AddOption(new Option<string>("--output-dir", "the directory to write the output client at"), (arg, i) => arg.outputDirectory = i);
		
		AddOption(new Option<bool>("--output-links", () => true, "when true, generate the source client files to all associated projects"), (arg, i) => arg.outputToLinkedProjects = i);
	}

	public override Task Handle(GenerateClientFileCommandArgs args)
	{
		// load up the 
		
		// AppDomain.Cre

		var absolutePath = Path.GetFullPath(args.microserviceAssemblyPath);
		// var userAssembly = Assembly.LoadFile(absolutePath);
		var absoluteDir = Path.GetDirectoryName(absolutePath);
		AssemblyLoadContext.Default.Resolving += (context, name) =>
		{
			var assemblyPath = Path.Combine(absoluteDir, $"{name.Name}.dll");
			if (assemblyPath != null)   
				return context.LoadFromAssemblyPath(assemblyPath);     
			return null;
		};
		var userAssembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(absolutePath);

		
		var allTypes = userAssembly.GetExportedTypes();
		foreach (var type in allTypes)
		{
			if (!type.IsSubclassOf(typeof(Microservice))) continue;
			var attribute = type.GetCustomAttribute<MicroserviceAttribute>();
			if (attribute == null) continue;

			var descriptor = new MicroserviceDescriptor
			{
				Name = attribute.MicroserviceName, AttributePath = attribute.SourcePath, Type = type
			};
			
			var generator = new ClientCodeGenerator(descriptor);

			if (!string.IsNullOrEmpty(args.outputDirectory))
			{
				Directory.CreateDirectory(args.outputDirectory);
				var outputPath = Path.Combine(args.outputDirectory, $"{descriptor.Name}Client.cs");
				generator.GenerateCSharpCode(outputPath);
			}

			if (args.outputToLinkedProjects)
			{
				var linkedUnityProjects = args.ProjectService.GetLinkedUnityProjects();
				foreach (var unityProjectPath in linkedUnityProjects)
				{
					var unityAssetPath = Path.Combine(args.ConfigService.BaseDirectory, unityProjectPath, "Assets");
					if (!Directory.Exists(unityAssetPath))
					{
						BeamableLogger.LogError($"Could not generate [{descriptor.Name}] client linked unity project because directory doesn't exist [{unityAssetPath}]");
						continue;
					}
					var outputDirectory = Path.Combine(unityAssetPath, "Beamable", "Autogenerated", "Microservices");
					Directory.CreateDirectory(outputDirectory);
					var outputPath = Path.Combine(outputDirectory, $"{descriptor.Name}Client.cs");
					BeamableLogger.Log("Writing client to " + outputPath);
					generator.GenerateCSharpCode(outputPath);
				}
			}
		}
		
		return Task.CompletedTask;
	}
}
