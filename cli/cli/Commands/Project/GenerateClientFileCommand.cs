using Beamable.Common;
using Beamable.Server;
using Beamable.Server.Editor;
using Beamable.Server.Generator;
using Beamable.Tooling.Common.OpenAPI;
using cli.Unreal;
using microservice.Common;
using Microsoft.OpenApi.Models;
using System.CommandLine;
using System.Globalization;
using System.Reflection;
using System.Runtime.Loader;

namespace cli.Dotnet;

public class GenerateClientFileCommandArgs : CommandArgs
{
	public string microserviceAssemblyPath;
	public string outputDirectory;
	public bool outputToLinkedProjects = true;
}
public class GenerateClientFileCommand : AppCommand<GenerateClientFileCommandArgs>
{
	public GenerateClientFileCommand() : base("generate-client", "Generate a C# client file based on a built C# microservice dll directory")
	{
	}

	public override void Configure()
	{
		AddArgument(new Argument<string>("source", "The .dll filepath for the built microservice"), (arg, i) => arg.microserviceAssemblyPath = i);
		AddOption(new Option<string>("--output-dir", "Directory to write the output client at"), (arg, i) => arg.outputDirectory = i);
		AddOption(new Option<bool>("--output-links", () => true, "When true, generate the source client files to all associated projects"), (arg, i) => arg.outputToLinkedProjects = i);
	}

	public override Task Handle(GenerateClientFileCommandArgs args)
	{

		#region load client dll into current domain
		var absolutePath = Path.GetFullPath(args.microserviceAssemblyPath);
		var absoluteDir = Path.GetDirectoryName(absolutePath);
		AssemblyLoadContext.Default.Resolving += (context, name) =>
		{
			var assemblyPath = Path.Combine(absoluteDir, $"{name.Name}.dll");
			if (assemblyPath != null)
				return context.LoadFromAssemblyPath(assemblyPath);
			return null;
		};
		var userAssembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(absolutePath);
		#endregion

		var allTypes = userAssembly.GetExportedTypes();
		foreach (var type in allTypes)
		{
			if (!type.IsSubclassOf(typeof(Microservice))) continue;
			var attribute = type.GetCustomAttribute<MicroserviceAttribute>();
			if (attribute == null) continue;

			var descriptor = new MicroserviceDescriptor
			{
				Name = attribute.MicroserviceName,
				AttributePath = attribute.SourcePath,
				Type = type
			};

			var generator = new ClientCodeGenerator(descriptor);

			if (!string.IsNullOrEmpty(args.outputDirectory))
			{
				Directory.CreateDirectory(args.outputDirectory);
				var outputPath = Path.Combine(args.outputDirectory, $"{descriptor.Name}Client.cs");
				generator.GenerateCSharpCode(outputPath);
			}

			var gen = new ServiceDocGenerator();
			var oapiDocument = gen.Generate<Microservice>(new AdminRoutes()
			{
				MicroserviceType = type,
				MicroserviceAttribute = attribute
			});

			var unrealGenerator = new UnrealSourceGenerator();
			var docs = new List<OpenApiDocument>() { oapiDocument };
			var orderedSchemas = SwaggerService.ExtractAllSchemas(docs,
				GenerateSdkConflictResolutionStrategy.RenameUncommonConflicts);
			
			var fileDescriptors = unrealGenerator.Generate(new SwaggerService.DefaultGenerationContext
			{
				Documents = docs,
				OrderedSchemas = orderedSchemas
			});
			
			if (args.outputToLinkedProjects)
			{
				// UNITY
				
				var linkedUnityProjects = args.ProjectService.GetLinkedUnityProjects();
				
				foreach (var unityProjectPath in linkedUnityProjects)
				{
					var unityAssetPath = Path.Combine(args.ConfigService.BaseDirectory, unityProjectPath, "Assets");

					try
					{
						Task projTask = GenerateFile(generator, descriptor, args, unityAssetPath);

						if (projTask != null)
							return projTask;
					}
					catch (FileNotFoundException e)
					{
						BeamableLogger.LogError($"Could not generate [{descriptor.Name}] client linked unity project because directory doesn't exist [{unityAssetPath}]");
					}
				}
	
				// UNREAL
				
				var linkedUnrealProjects = args.ProjectService.GetLinkedUnrealProjects();
				
				foreach (var unrealProjectPath in linkedUnrealProjects)
				{
					var unrealAssetPath = Path.Combine(args.ConfigService.BaseDirectory, unrealProjectPath, "Content");

					try
					{
						Task projTask = GenerateFile(generator, descriptor, args, unrealAssetPath);

						if (projTask != null)
							return projTask;
					}
					catch (DirectoryNotExistException e)
					{
						BeamableLogger.LogError($"Could not generate [{descriptor.Name}] client linked unity project because directory doesn't exist [{unrealAssetPath}]");
					}
				}
			}
		}

		return Task.CompletedTask;
	}

	Task GenerateFile(ClientCodeGenerator generator, MicroserviceDescriptor descriptor, GenerateClientFileCommandArgs args, string projectPath)
	{
		if (!Directory.Exists(projectPath))
		{
			throw new DirectoryNotExistException();
		}
		
		var outputDirectory = Path.Combine(projectPath, "Beamable", "Autogenerated", "Microservices");
		Directory.CreateDirectory(outputDirectory);
		var outputPath = Path.Combine(outputDirectory, $"{descriptor.Name}Client.cs");

		var nextGeneratedSourceCode = generator.GetCSharpCodeString();

		if (File.Exists(outputPath))
		{
			var existingContent = File.ReadAllText(outputPath);
			if (string.Compare(existingContent, nextGeneratedSourceCode, CultureInfo.InvariantCulture, CompareOptions.IgnoreSymbols) == 0)
			{
				// don't need to write anything, because the files are identical.
				return Task.CompletedTask;
			}
		}

		File.WriteAllText(outputPath, nextGeneratedSourceCode);
		return null;
	}

	private class DirectoryNotExistException : Exception
	{
		
	}
	
}
