using Beamable.Common;
using Beamable.Server;
using Beamable.Server.Editor;
using Beamable.Server.Generator;
using System.CommandLine;
using System.Globalization;
using System.Reflection;
using System.Runtime.Loader;

namespace cli.Dotnet;

public class GenerateClientFileCommandArgs : CommandArgs
{
	public string microserviceAssemblyPath;
	public string outputDirectory;
	public bool outputToLinkedProjects = true;
}
public class GenerateClientFileCommand : AppCommand<GenerateClientFileCommandArgs>
{
	public GenerateClientFileCommand() : base("generate-client", "generate a C# client file based on a built C# microservice dll directory")
	{
	}

	public override void Configure()
	{
		AddArgument(new Argument<string>("source", "the .dll filepath for the built microservice"), (arg, i) => arg.microserviceAssemblyPath = i);
		AddOption(new Option<string>("--output-dir", "the directory to write the output client at"), (arg, i) => arg.outputDirectory = i);
		AddOption(new Option<bool>("--output-links", () => true, "when true, generate the source client files to all associated projects"), (arg, i) => arg.outputToLinkedProjects = i);
	}

	public override Task Handle(GenerateClientFileCommandArgs args)
	{

		#region load client dll into current domain
		var absolutePath = Path.GetFullPath(args.microserviceAssemblyPath);
		var absoluteDir = Path.GetDirectoryName(absolutePath);
		AssemblyLoadContext.Default.Resolving += (context, name) =>
		{
			var assemblyPath = Path.Combine(absoluteDir, $"{name.Name}.dll");
			if (assemblyPath != null)
				return context.LoadFromAssemblyPath(assemblyPath);
			return null;
		};
		var userAssembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(absolutePath);
		#endregion

		var allTypes = userAssembly.GetExportedTypes();
		foreach (var type in allTypes)
		{
			if (!type.IsSubclassOf(typeof(Microservice))) continue;
			var attribute = type.GetCustomAttribute<MicroserviceAttribute>();
			if (attribute == null) continue;

			var descriptor = new MicroserviceDescriptor
			{
				Name = attribute.MicroserviceName,
				AttributePath = attribute.SourcePath,
				Type = type
			};

			var generator = new ClientCodeGenerator(descriptor);

			if (!string.IsNullOrEmpty(args.outputDirectory))
			{
				Directory.CreateDirectory(args.outputDirectory);
				var outputPath = Path.Combine(args.outputDirectory, $"{descriptor.Name}Client.cs");
				generator.GenerateCSharpCode(outputPath);
			}

			if (args.outputToLinkedProjects)
			{
				var linkedUnityProjects = args.ProjectService.GetLinkedUnityProjects();
				foreach (var unityProjectPath in linkedUnityProjects)
				{
					var unityAssetPath = Path.Combine(args.ConfigService.BaseDirectory, unityProjectPath, "Assets");
					if (!Directory.Exists(unityAssetPath))
					{
						BeamableLogger.LogError($"Could not generate [{descriptor.Name}] client linked unity project because directory doesn't exist [{unityAssetPath}]");
						continue;
					}
					var outputDirectory = Path.Combine(unityAssetPath, "Beamable", "Autogenerated", "Microservices");
					Directory.CreateDirectory(outputDirectory);
					var outputPath = Path.Combine(outputDirectory, $"{descriptor.Name}Client.cs");

					var nextGeneratedSourceCode = generator.GetCSharpCodeString();

					if (File.Exists(outputPath))
					{
						var existingContent = File.ReadAllText(outputPath);
						if (string.Compare(existingContent, nextGeneratedSourceCode, CultureInfo.InvariantCulture, CompareOptions.IgnoreSymbols) == 0)
						{
							// don't need to write anything, because the files are identical.
							return Task.CompletedTask;
						}
					}

					File.WriteAllText(outputPath, nextGeneratedSourceCode);
				}
			}
		}

		return Task.CompletedTask;
	}
}
