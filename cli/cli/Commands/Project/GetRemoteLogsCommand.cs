using System.CommandLine;
using System.Globalization;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Content;
using Beamable.Server.Common;
using Beamable.Server;
using Microsoft.Extensions.Logging;


namespace cli.Commands.Project.Logs;

public class GetRemoteLogsCommandArgs : CommandArgs
{
    public string service;
    public string filter;
    public string level;
    public string fromTimestamp;
    public string toTimestamp;
}


public class CloudWatchLogResult
{
    public string queryLanguage;
    public string status;
    public List<List<CloudWatchLogEvent>> results;
}

public class CloudWatchLogEvent
{
    public string field;
    public string value;
}

public class CloudWatchLogMessage
{
    [JsonPropertyName("__l")]
    public string level;
    
    [JsonPropertyName("__t")]
    public string timestamp;
    
    [JsonPropertyName("__m")]
    public string message;

    [JsonExtensionData]
    public Dictionary<string, JsonElement> properties;
}

public static class CloudWatchLogEventExtensions
{
    public static bool TryGetField(this List<CloudWatchLogEvent> self, string name, out string value)
    {
        value = null;
        foreach (var evt in self)
        {
            if (name == evt.field)
            {
                value = evt.value;
                return true;
            }
        }

        return false;
    }
}

public class GetRemoteLogsCommand : StreamCommand<GetRemoteLogsCommandArgs, TailLogMessageForClient>
{
    public override bool IsForInternalUse => true;

    public GetRemoteLogsCommand() : base("remote-logs", "get remote logs for a service")
    {
    }

    public override void Configure()
    {
        const string FORMAT = "Must be an exact date time string, or a relative time string. " +
                              "Relative time strings are in the format <number><unit>. " +
                              "The unit is either s (seconds), m (minutes), h (hours), or d (days). " +
                              "To represent 5 minutes in the past, use the term '5m' ";
        AddArgument(new Argument<string>("service-id", "The beamo id for the service to get logs for"), (args, i) => args.service = i);
        AddOption(new Option<string>(new string[]{"-f", "--filter"}, "A text filter for log searching"), (args, i) => args.filter = i);
        AddOption(new Option<string>(new string[]{"-sl", "--server-log-level",}, "A log level filter for searching"), (args, i) => args.level = i);
        AddOption(new Option<string>(new string[]{"--from"}, "A timestamp filter, where logs must be newer than this time. " + FORMAT), (args, i) => args.fromTimestamp = i);
        AddOption(new Option<string>(new string[]{"--to"}, "A timestamp filter, where logs must be older than this time. " + FORMAT), (args, i) => args.toTimestamp = i);
    }

    public static bool TryParseTimeString(string timeString, out DateTimeOffset time)
    {
        if (DateTimeOffset.TryParse(timeString, out time))
        {
            return true;
        }

        if (string.Equals(timeString, "now", StringComparison.InvariantCultureIgnoreCase))
        {
            time = DateTimeOffset.UtcNow;
            return true;
        }

        var span = timeString.AsSpan();
        var number = 0;
        for (var i = 0; i < span.Length; i++)
        {
            var isDigit = char.IsDigit(span[i]);
            if (!isDigit)
            {
                var numberLength = i;
                if (!int.TryParse(span.Slice(0, numberLength), NumberStyles.Integer, CultureInfo.InvariantCulture, out number))
                {
                    return false;
                }

                var unit = span.Slice(i).ToString().Trim().ToLowerInvariant();
                switch (unit)
                {
                    case "m":
                        time = DateTimeOffset.UtcNow - TimeSpan.FromMinutes(number);
                        return true;
                    case "s":
                        time = DateTimeOffset.UtcNow - TimeSpan.FromSeconds(number);
                        return true;
                    case "h":
                        time = DateTimeOffset.UtcNow - TimeSpan.FromHours(number);
                        return true;
                    case "d":
                        time = DateTimeOffset.UtcNow - TimeSpan.FromDays(number);
                        return true;
                    default:
                        return false;
                }
            }
        }

        return false;
    }

    public override async Task Handle(GetRemoteLogsCommandArgs args)
    {
        var api = args.DependencyProvider.GetService<IBeamoApi>();
        Query query = null;

        HttpClient client = new HttpClient();

        try
        {
            Log.Information("Starting log request...");
            const int MAX_AWS_LOG_COUNT = 10000;
            var request = new GetLogsInsightUrlRequest
            {
                serviceName = args.service,
                limit = new OptionalInt(MAX_AWS_LOG_COUNT),
                startTime = 0,
                endTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
            };
            if (!string.IsNullOrEmpty(args.filter))
            {
                request.filter = args.filter;
            }

            if (!string.IsNullOrEmpty(args.fromTimestamp))
            {
                if (!TryParseTimeString(args.fromTimestamp, out var fromTime))
                {
                    throw new CliException("Cannot parse --from time");
                }

                request.startTime = fromTime.ToUniversalTime().ToUnixTimeMilliseconds();
            }
            if (!string.IsNullOrEmpty(args.toTimestamp))
            {
                if (!TryParseTimeString(args.toTimestamp, out var toTime))
                {
                    throw new CliException("Cannot parse --to time");
                }

                request.endTime = toTime.ToUniversalTime().ToUnixTimeMilliseconds();
            }

            var filterLogLevel = LogLevel.Debug;
            if (!string.IsNullOrEmpty(args.level))
            {
                if (!LogUtil.TryParseSystemLogLevel(args.level, out filterLogLevel))
                {
                    throw new CliException("Cannot parse server log level");
                }
            }
            query = await api.PostQueryLogs(request);
            
            
            var id = query.queryId;
            Log.Verbose($"log query id=[{id}]");

            Log.Information("Fetching logs from Beamable... (this may take a few seconds...)\n(Recent logs may take a few minutes to propagate)");
            var isRunning = true;
            while (isRunning)
            {
                await Task.Delay(TimeSpan.FromSeconds(2));
                var presignedRequest = await api.PostQueryLogsResult(query);
                var httpRequest = new HttpRequestMessage(HttpMethod.Parse(presignedRequest.method),
                    "https://" + presignedRequest.url);
                httpRequest.Content = new StringContent(presignedRequest.body);

                foreach (var header in presignedRequest.headers)
                {
                    if (header.key == "Content-Type")
                    {
                        httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue(header.value);
                    }
                    else
                    {
                        if (httpRequest.Headers.TryGetValues(header.key, out _))
                        {
                            httpRequest.Headers.Remove(header.key);
                        }

                        if (!httpRequest.Headers.TryAddWithoutValidation(header.key, header.value))
                        {
                            Log.Warning($"Unable to set header=[{header.key}] with value=[{header.value}]");
                        }
                    }
                }

                var data = await client.SendAsync(httpRequest);
                data.EnsureSuccessStatusCode();
                var logJson = await data.Content.ReadAsStringAsync();

                var logResult = System.Text.Json.JsonSerializer.Deserialize<CloudWatchLogResult>(logJson, new JsonSerializerOptions
                {
                    IncludeFields = true,
                });
                isRunning = logResult.status == "Running";
           
                foreach (var result in logResult.results)
                {
                    if (!result.TryGetField("@message", out var logMessage))
                    {
                        Log.Warning($"Found log event without a @message field. ");
                        continue;
                    }

                    if (!logMessage.StartsWith("{"))
                    {
                        Log.Warning($"Found unstructured log message=[{logMessage}]");
                        continue;
                    }
                    
                    var message = JsonSerializer.Deserialize<CloudWatchLogMessage>(logMessage, new JsonSerializerOptions(){IncludeFields = true});
                    if (!LogUtil.TryParseSystemLogLevel(message.level, out var logLevel))
                    {
                        Log.Warning($"Unknown log level=[{message.level}] in message=[{message.message}]");
                    }

                    if (logLevel < filterLogLevel)
                    {
                        continue;
                    }
                    

                    if (!DateTimeOffset.TryParse(message.timestamp, out var timestamp))
                    {
                        Log.Warning($"Unknown timestamp=[{message.timestamp}] in message=[{message.message}]");
                    }

                    var sb = new StringBuilder();
                    sb.AppendLine($"[{logLevel}] {timestamp.ToLocalTime():h:mm:ss tt} - {message.message}");
                    if (message.properties != null)
                    {
                        foreach (var prop in message.properties)
                        {
                            sb.AppendLine($"\t\t\t{prop.Key} = {prop.Value}");
                        }
                    }

                    SendResults(new TailLogMessageForClient
                    {
                        raw = message.message,
                        logLevel = message.level,
                        timeStamp = message.timestamp
                    });
                    Log.Information(sb.ToString());

                }
            }
        }
        catch (Exception ex)
        {
            Log.Error("Failed: " + ex.Message + ", " + ex.StackTrace);
            throw;
        }
        finally
        {
            Log.Verbose("Deleting the query.");
            try
            {
                await api.DeleteQueryLogs(query);
            }
            catch
            {
                // ignore clean up messaging
            }
            Log.Verbose("Deleted the query.");
        }

    }
}