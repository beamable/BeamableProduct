using Beamable.Common;
using Beamable.Common.Semantics;
using cli.Services;
using CliWrap;
using Serilog;
using Spectre.Console;
using System.CommandLine;
using UnityEngine;

namespace cli.Dotnet;

public class NewSolutionCommandArgs : CommandArgs
{
	public ServiceName SolutionName;
	public ServiceName ProjectName;
	public string directory;
	public bool SkipCommon;
}

public class NewSolutionCommand : AppCommand<NewSolutionCommandArgs>
{
	private readonly InitCommand _initCommand;
	private readonly AddUnityClientOutputCommand _addUnityCommand;
	private readonly AddUnrealClientOutputCommand _addUnrealCommand;

	public NewSolutionCommand(InitCommand initCommand, AddUnityClientOutputCommand addUnityCommand, AddUnrealClientOutputCommand addUnrealCommand) : base("new",
		"Start a brand new beamable solution using dotnet")
	{
		_initCommand = initCommand;
		_addUnityCommand = addUnityCommand;
		_addUnrealCommand = addUnrealCommand;
	}

	public override void Configure()
	{
		AddArgument(new Argument<ServiceName>("name", "Name of the new project"), (args, i) => args.ProjectName = i);
		AddArgument(new Argument<string>("output", () => "", description: "Where the project be created"), (args, i) => args.directory = i);
		AddOption(new ConfigurableOptionFlag("skip-common", "If you should create a common library"), (args, i) => args.SkipCommon = i);
		AddOption(new Option<ServiceName>("--solution-name", "The name of the solution of the new project"), (args, i) => args.SolutionName = i);
	}

	public override async Task Handle(NewSolutionCommandArgs args)
	{
		// Default the solution name to the project name.
		args.SolutionName = string.IsNullOrEmpty(args.SolutionName) ? args.ProjectName : args.SolutionName;

		if (string.IsNullOrEmpty(args.directory))
		{
			args.directory = args.SolutionName;
		}

		// in the current directory, create a project using dotnet. 
		var path = await args.ProjectService.CreateNewSolution(args.directory, args.SolutionName, args.ProjectName, !args.SkipCommon);

		// initialize a beamable project in that directory...
		var createdNewWorkingDir = false;
		if (!args.ConfigService.ConfigFileExists.GetValueOrDefault(false))
		{
			args.ConfigService.SetTempWorkingDir(path);


			await _initCommand.Handle(new InitCommandArgs { Provider = args.Provider, saveToFile = true });
			createdNewWorkingDir = true;
		}

		// Find path to service folders: either it is in the working directory, or it will be inside 'args.name\\services' from the working directory.
		var projectDirectory = createdNewWorkingDir
			? $"services"
			: Path.GetRelativePath(args.ConfigService.BaseDirectory,
				Directory.EnumerateDirectories(args.ConfigService.BaseDirectory, $"{args.ProjectName}\\services", SearchOption.AllDirectories).First());

		// now that a .beamable folder has been created, setup the beamo manifest
		var sd = await args.BeamoLocalSystem.AddDefinition_HttpMicroservice(args.ProjectName.Value.ToLower(),
			projectDirectory,
			Path.Combine(args.ProjectName, "Dockerfile"),
			new string[] { },
			CancellationToken.None);

		if (!args.SkipCommon)
		{
			var commonProjectName = $"{args.ProjectName}Common";
			var solutionPath = Path.Combine(args.ConfigService.WorkingDirectory, args.directory);
			var rootServicesPath = Path.Combine(solutionPath, "services");
			var commonProjectPath = Path.Combine(rootServicesPath, commonProjectName);

			var service = args.BeamoLocalSystem.BeamoManifest.HttpMicroserviceLocalProtocols[sd.BeamoId];
			var dockerfilePath = service.RelativeDockerfilePath;
			Log.Information("Docker file path is " + dockerfilePath);
			var serviceFolder = Path.GetDirectoryName(dockerfilePath);
			Log.Information("Docker file folder is " + serviceFolder);

			dockerfilePath = Path.Combine(args.directory, service.DockerBuildContextPath, dockerfilePath);
			var dockerfileText = File.ReadAllText(dockerfilePath);

			const string search =
				"# <BEAM-CLI-INSERT-FLAG:COPY_COMMON> do not delete this line. It is used by the beam CLI to insert custom actions";
			var replacement = @$"WORKDIR /subsrc/{commonProjectName}
COPY {commonProjectName}/. .
{search}";
			dockerfileText = dockerfileText.Replace(search, replacement);
			await File.WriteAllTextAsync(dockerfilePath, dockerfileText);
		}

		args.BeamoLocalSystem.SaveBeamoLocalManifest();
		args.BeamoLocalSystem.SaveBeamoLocalRuntime();

		// ask if we should link a Unity project
		var addUnityProject = AnsiConsole.Confirm(
			"Would you like to link a Unity project? A linked Unity project will receive autogenerated client updates.", true);
		if (addUnityProject)
		{
			await _addUnityCommand.Handle(new AddUnityClientOutputCommandArgs { path = ".", Provider = args.Provider });
		}

		// ask if we should link a Unity project
		var addUnrealProject = AnsiConsole.Confirm(
			"Would you like to link an Unreal project? A linked Unreal project will receive autogenerated client updates.", true);
		if (addUnrealProject)
		{
			await _addUnrealCommand.Handle(new AddUnrealClientOutputCommandArgs() { path = ".", Provider = args.Provider });
		}
	}
}
