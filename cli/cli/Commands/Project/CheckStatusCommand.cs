using Beamable.Api.Autogenerated.Accounts;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Server;
using cli.Dotnet;
using cli.Services;
using Spectre.Console;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;

// ReSharper disable InconsistentNaming

namespace cli;

[Serializable]
public class CheckStatusCommandArgs : CommandArgs
{
	public bool watch;
	public int requireProcessId;
	public List<string> services;
	public List<string> withServiceTags = new List<string>();
	public List<string> withoutServiceTags = new List<string>();
}

[Serializable]
public class CheckStatusServiceResult
{
	public string cid;
	public string pid;
	public List<ServiceStatus> services = new List<ServiceStatus>();
}

[Serializable]
public class ServiceStatus
{
	public string service;
	public string serviceType;
	public string[] groups;
	public string[] storages;
	public List<ServicesForRouteCollection> availableRoutes = new List<ServicesForRouteCollection>();
}

[Serializable]
public class ServicesForRouteCollection
{
	public bool knownToBeRunning;
	public string routingKey;
	public List<ServiceInstance> instances = new List<ServiceInstance>();
	public List<FederationInstance> federations = new();
}

[Serializable]
public class ServiceInstance
{
	public long startedByAccountId;
	public string startedByAccountEmail;
	public string primaryKey;

	// avoid polymorphism, and put all the details in the correct field. These fields will be null for the wrong type. 
	public DockerServiceDescriptor latestDockerEvent;
	public HostServiceDescriptor latestHostEvent;
	public RemoteServiceDescriptor latestRemoteEvent;
	public RemoteStorageDescriptor latestRemoteStorageEvent;
}

public static class ServiceInstanceExtensions
{
	public static bool TryGetStatus(this CheckStatusServiceResult res, string serviceName, out ServiceStatus service)
	{
		service = default;
		foreach (var x in res.services)
		{
			if (x.service == serviceName)
			{
				service = x;
				return true;
			}
		}

		return false;
	}

	public static bool TryGetRoutes(this ServiceStatus status, string routingKey,
		out ServicesForRouteCollection collection)
	{
		collection = default;
		foreach (var x in status.availableRoutes)
		{
			if (x.routingKey == routingKey)
			{
				collection = x;
				return true;
			}
		}

		return false;
	}

	public static bool TryGetInstance(this ServicesForRouteCollection collection, string primaryKey,
		out ServiceInstance instance)
	{
		instance = default;
		foreach (var x in collection.instances)
		{
			if (x.primaryKey == primaryKey)
			{
				instance = x;
				return true;
			}
		}

		return false;
	}
}

public class CheckStatusCommand : StreamCommand<CheckStatusCommandArgs, CheckStatusServiceResult>
{
	public CheckStatusCommand() : base("ps", "List the running status of local services not running in docker")
	{
	}

	public override void Configure()
	{
		ProjectCommand.AddWatchOption(this, (args, i) => args.watch = i);
		ProjectCommand.AddIdsOption(this, (args, i) => args.services = i);
		ProjectCommand.AddServiceTagsOption(this,
			bindWithTags: (args, i) => args.withServiceTags = i,
			bindWithoutTags: (args, i) => args.withoutServiceTags = i);

		AddOption(new RequireProcessIdOption(), (args, i) => args.requireProcessId = i);
	}

	public int updateCount;

	public override async Task Handle(CheckStatusCommandArgs args)
	{
		RequireProcessIdOption.ConfigureRequiredProcessIdWatcher(args.requireProcessId);

		ProjectCommand.FinalizeServicesArg(args,
			withTags: args.withServiceTags,
			withoutTags: args.withoutServiceTags,
			includeStorage: true,
			ref args.services,
			allowEmptyServices: true);

		TimeSpan timeout = TimeSpan.FromMilliseconds(250);
		if (args.watch)
		{
			timeout = default;
		}

		var first = true;
		updateCount = 0;
		Log.Debug($"running status-check with watch=[{args.watch}] timeout=[{timeout.Milliseconds}]");

		CheckStatusServiceResult latestUpdate = null;
		await foreach (var update in CheckStatus(
			               args,
			               timeout,
			               DiscoveryMode.ALL,
			               args.services,
			               args.Lifecycle.CancellationToken))
		{
			// SendResults(update);
			if (!args.watch)
			{
				latestUpdate = update;
				continue;
			}

			if (first)
			{
				// put a clock on, and emit this event if nothing else shows up...
				//  Otherwise, emit the later event.
				first = false;
				var _ = Task.Delay(TimeSpan.FromMilliseconds(150)).ContinueWith(_ =>
				{
					if (updateCount == 0)
					{
						Report(update);
					}
				});
			}
			else
			{
				updateCount++;
				Report(update);
			}
		}

		if (!args.watch)
		{
			Report(latestUpdate);
		}
	}


	void Report(CheckStatusServiceResult update)
	{
		SendResults(update);
		var table = new Table();
		table.Border(TableBorder.Simple);
		void AddColumn(string header) => table.AddColumn($"[bold]{header}[/]");

		void AddRow(ServiceStatus service, ServicesForRouteCollection route, ServiceInstance instance)
		{
			var infoValue = "";
			if (instance?.latestHostEvent != null)
			{
				infoValue = $"health={instance.latestHostEvent.healthPort},pid={instance.latestHostEvent.processId}";
			}

			if (instance?.latestDockerEvent != null)
			{
				if (service.serviceType == "service")
				{
					infoValue =
						$"health={instance.latestDockerEvent.healthPort},container={instance.latestDockerEvent.containerId.Substring(0, 12)}";
				}
				else
				{
					infoValue =
						$"data={instance.latestDockerEvent.dataPort},container={instance.latestDockerEvent.containerId.Substring(0, 12)}";
				}
			}

			var originValue = "";
			if (instance?.latestHostEvent != null) originValue = "local";
			if (instance?.latestDockerEvent != null) originValue = "docker";
			if (instance?.latestRemoteEvent != null) originValue = "remote";
			if (instance?.latestRemoteStorageEvent != null) originValue = "remote";
			table.AddRow(
				service.service,
				service.serviceType,
				originValue,
				instance?.startedByAccountEmail ?? "<?>",
				infoValue,
				string.Join(",", route?.federations?.SelectMany(f => f.FederationTypes?.Select(ft => $"{f.FederationId}/{ft}")) ?? Array.Empty<string>())
			);
		}

		AddColumn("beamoId");
		AddColumn("type");
		AddColumn("origin");
		AddColumn("email");
		AddColumn("info");
		AddColumn("federations");

		foreach (var service in update.services)
		{
			foreach (var route in service.availableRoutes)
			{
				if (route.instances != null)
				{
					if (route.knownToBeRunning)
					{
						foreach (var instance in route.instances)
						{
							AddRow(service, route, instance);
						}
					}
				}
			}
		}

		Log.Information($"Updated at {DateTimeOffset.Now:T}");
		AnsiConsole.Write(table);
	}

	public static async IAsyncEnumerable<CheckStatusServiceResult> CheckStatus(
		CommandArgs args,
		TimeSpan timeout = default,
		DiscoveryMode mode = DiscoveryMode.ALL,
		List<string> serviceFilter = null,
		[EnumeratorCancellation] CancellationToken token = default)
	{
		var discovery = args.DependencyProvider.GetService<DiscoveryService>();

		if (timeout.TotalMilliseconds <= 0)
		{
			timeout = default;
		}

		Log.Debug($"running status-check with timeout=[{timeout.Milliseconds}]");

		var result = new CheckStatusServiceResult { cid = args.AppContext.Cid, pid = args.AppContext.Pid, };

		var accountApi = args.Provider.GetService<IAccountsApi>();
		var accountIdToEmail = new ConcurrentDictionary<long, Promise<string>>();

		async Task<string> GetEmail(long accountId)
		{
			if (accountId == 0) return "";
			if (accountIdToEmail.TryGetValue(accountId, out var emailPromise))
			{
				return await emailPromise;
			}

			accountIdToEmail[accountId] = emailPromise = accountApi
				.GetFind(accountId.ToString())
				.Map(res => res.email.GetOrElse(""));
			return await emailPromise;
		}

		// Before even bothering with discovery, emit all known services
		var manifest = args.BeamoLocalSystem.BeamoManifest;
		foreach (var definition in manifest.ServiceDefinitions)
		{
			if (!definition.IsLocal) continue;
			if (serviceFilter != null && !serviceFilter.Contains(definition.BeamoId)) continue;
			
			var isMicroservice = manifest.HttpMicroserviceLocalProtocols.TryGetValue(definition.BeamoId, out var http);
			if (!result.TryGetStatus(definition.BeamoId, out var status))
			{
				status = new ServiceStatus
				{
					service = definition.BeamoId,
					serviceType = definition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
					storages = isMicroservice ? http.StorageDependencyBeamIds.ToArray() : Array.Empty<string>(),
					availableRoutes = new List<ServicesForRouteCollection>()
					{
						new()
						{
							knownToBeRunning = false,
							routingKey = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine(),
							federations = definition.Protocol is BeamoProtocolType.HttpMicroservice
								? definition.FederationsConfig.Federations.Select(kvp => new FederationInstance()
								{
									FederationId = kvp.Key,
									FederationTypes = kvp.Value.Select(f => f.Interface).ToArray(),
									LocalSettings = kvp.Value.Select(f =>
									{
										var key = FederationUtils.BuildLocalSettingKey(f.Interface, kvp.Key);
										if (manifest.HttpMicroserviceLocalProtocols[definition.BeamoId].Settings.TryGetSetting(key, out var settingsJsonVal))
											return settingsJsonVal;

										return "{}";
									}).ToArray(),
								}).ToList()
								: new List<FederationInstance>(),
						}
					},
					groups = definition.ServiceGroupTags,
				};

				result.services.Add(status);
			}
		}


		// emit the status with local services as "off" until the discovery actually runs
		yield return result;

		await foreach (var discoveryEvent in discovery.StartDiscovery(args, timeout, token, mode))
		{
			if (serviceFilter != null && !serviceFilter.Contains(discoveryEvent.Service)) continue;

			var isLocalMicroservice = manifest.HttpMicroserviceLocalProtocols.TryGetValue(discoveryEvent.Service, out var http);
			if (!result.TryGetStatus(discoveryEvent.Service, out var status))
			{
				status = new ServiceStatus
				{
					service = discoveryEvent.Service,
					serviceType = discoveryEvent.ServiceType,
					storages = isLocalMicroservice ? http.StorageDependencyBeamIds.ToArray() : Array.Empty<string>(),
					groups = discoveryEvent switch
					{
						DockerServiceEvent dockerServiceEvent => dockerServiceEvent.descriptor.groups,
						HostServiceEvent hostServiceEvent => hostServiceEvent.descriptor.groups,
						RemoteServiceEvent remoteServiceEvent => remoteServiceEvent.descriptor.groups,
						RemoteStorageEvent remoteStorageEvent => remoteStorageEvent.descriptor.groups,
						_ => throw new ArgumentOutOfRangeException(nameof(discoveryEvent))
					},
					availableRoutes = new List<ServicesForRouteCollection>()
				};
				result.services.Add(status);
			}

			if (!status.TryGetRoutes(discoveryEvent.RoutingKey, out var collection))
			{
				collection = new ServicesForRouteCollection
				{
					knownToBeRunning = true,
					routingKey = discoveryEvent.RoutingKey ?? "",
					federations = discoveryEvent switch
					{
						DockerServiceEvent dockerEvt => dockerEvt.descriptor.federations?.ToList() ?? new List<FederationInstance>(),
						HostServiceEvent hostEvt => hostEvt.descriptor.federations?.ToList() ?? new List<FederationInstance>(),
						RemoteServiceEvent remoteEvt => remoteEvt.descriptor.federations?.ToList() ?? new List<FederationInstance>(),
						RemoteStorageEvent => new List<FederationInstance>(),
						_ => throw new ArgumentOutOfRangeException()
					}
				};
				status.availableRoutes.Add(collection);
			}

			// maybe the instance already exists inside the collection of instances...
			if (!collection.TryGetInstance(discoveryEvent.PrimaryKey, out var instance))
			{
				// Make sure the collection is defined as "running" now.
				collection.knownToBeRunning = true;

				// generate an instance to describe this event.
				instance = new ServiceInstance
				{
					startedByAccountId = discoveryEvent.StartedByAccountId, primaryKey = discoveryEvent.PrimaryKey, startedByAccountEmail = await GetEmail(discoveryEvent.StartedByAccountId),
				};

				// only fill in the field that corresponds to the main data.
				switch (discoveryEvent)
				{
					case DockerServiceEvent dockerEvt:
						instance.latestDockerEvent = dockerEvt.descriptor;
						instance.latestDockerEvent.routingKey ??= "";
						break;
					case HostServiceEvent hostEvt:
						instance.latestHostEvent = hostEvt.descriptor;
						instance.latestHostEvent.routingKey ??= "";
						break;
					case RemoteServiceEvent remoteEvt:
						instance.latestRemoteEvent = remoteEvt.descriptor;
						instance.latestRemoteEvent.routingKey ??= "";
						break;
					case RemoteStorageEvent remoteStorageEvt:
						instance.latestRemoteStorageEvent = remoteStorageEvt.descriptor;
						break;
				}

				if (discoveryEvent.Type == ServiceEventType.Running)
				{
					// this is the first time we are seeing this instance (or the first time since it was shutdown)
					collection.instances.Add(instance);
					yield return result;

					// TODO: include a changelog in the update.
				}
				else
				{
					// the service is being removed, but since we never saw it in the first place,
					// we don't need to do anything.
				}
			}
			else if (discoveryEvent.Type == ServiceEventType.Stopped)
			{
				// the instance existed in our state, but now it is being stopped, so we should remove it
				collection.instances.Remove(instance);

				// Make sure the collection as "knownToBeRunning" now.
				collection.knownToBeRunning = collection.instances.Count > 0;

				yield return result;

				// TODO: include a changelog in the update
			}
			else
			{
				// the instance is running, and SOMETHING changed, but we don't know what it is.
				// this is not supported yet.
				Log.Error($"Service=[{discoveryEvent.Service}] updated but change detection is not implemented yet. Please report this to Beamable.");
			}
		}

		await discovery.Stop();
	}
}
