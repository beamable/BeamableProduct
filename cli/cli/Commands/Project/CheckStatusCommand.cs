using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Server;
using cli.Dotnet;
using cli.Services;
using Serilog;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;

// ReSharper disable InconsistentNaming

namespace cli;

[Serializable]
public class CheckStatusCommandArgs : CommandArgs
{
	public bool watch;
	public List<string> services;
	public List<string> withServiceTags = new List<string>();
	public List<string> withoutServiceTags = new List<string>();
}

[Serializable]
public class CheckStatusServiceResult
{
	public string cid;
	public string pid;
	public List<ServiceStatus> services = new List<ServiceStatus>();
}

[Serializable]
public class ServiceStatus
{
	public string service;
	public string serviceType;
	public string[] groups;
	public List<ServicesForRouteCollection> availableRoutes = new List<ServicesForRouteCollection>();
}

[Serializable]
public class ServicesForRouteCollection
{
	public bool knownToBeRunning;
	public string routingKey;
	public List<ServiceInstance> instances = new List<ServiceInstance>();
	public List<FederationInstance> federations = new();
}

[Serializable]
public class ServiceInstance
{
	public long startedByAccountId;
	public string startedByAccountEmail;
	public string primaryKey;

	// avoid polymorphism, and put all the details in the correct field. These fields will be null for the wrong type. 
	public DockerServiceDescriptor latestDockerEvent;
	public HostServiceDescriptor latestHostEvent;
	public RemoteServiceDescriptor latestRemoteEvent;
}

public static class ServiceInstanceExtensions
{
	public static bool TryGetStatus(this CheckStatusServiceResult res, string serviceName, out ServiceStatus service)
	{
		service = default;
		foreach (var x in res.services)
		{
			if (x.service == serviceName)
			{
				service = x;
				return true;
			}
		}

		return false;
	}

	public static bool TryGetRoutes(this ServiceStatus status, string routingKey,
		out ServicesForRouteCollection collection)
	{
		collection = default;
		foreach (var x in status.availableRoutes)
		{
			if (x.routingKey == routingKey)
			{
				collection = x;
				return true;
			}
		}

		return false;
	}

	public static bool TryGetInstance(this ServicesForRouteCollection collection, string primaryKey,
		out ServiceInstance instance)
	{
		instance = default;
		foreach (var x in collection.instances)
		{
			if (x.primaryKey == primaryKey)
			{
				instance = x;
				return true;
			}
		}

		return false;
	}
}

public class CheckStatusCommand : StreamCommand<CheckStatusCommandArgs, CheckStatusServiceResult>
{
	public override bool AutoLogOutput => true;

	public CheckStatusCommand() : base("ps", "List the running status of local services not running in docker")
	{
	}

	public override void Configure()
	{
		ProjectCommand.AddWatchOption(this, (args, i) => args.watch = i);
		ProjectCommand.AddIdsOption(this, (args, i) => args.services = i);
		ProjectCommand.AddServiceTagsOption(this,
			bindWithTags: (args, i) => args.withServiceTags = i,
			bindWithoutTags: (args, i) => args.withoutServiceTags = i);
	}

	public override async Task Handle(CheckStatusCommandArgs args)
	{
		ProjectCommand.FinalizeServicesArg(args,
			withTags: args.withServiceTags,
			withoutTags: args.withoutServiceTags,
			includeStorage: true,
			ref args.services);

		TimeSpan timeout = TimeSpan.FromMilliseconds(Beamable.Common.Constants.Features.Services.DISCOVERY_RECEIVE_PERIOD_MS);
		if (args.watch)
		{
			timeout = default;
		}

		Log.Debug($"running status-check with watch=[{args.watch}] timeout=[{timeout.Milliseconds}]");
		await foreach (var update in CheckStatus(
						   args,
						   timeout,
						   DiscoveryMode.ALL,
						   args.services,
						   args.Lifecycle.CancellationToken))
		{
			SendResults(update);
		}
	}

	public static async IAsyncEnumerable<CheckStatusServiceResult> CheckStatus(
		CommandArgs args,
		TimeSpan timeout = default,
		DiscoveryMode mode = DiscoveryMode.ALL,
		List<string> serviceFilter = null,
		[EnumeratorCancellation] CancellationToken token = default)
	{
		var discovery = args.DependencyProvider.GetService<DiscoveryService>();

		if (timeout.TotalMilliseconds <= 0)
		{
			timeout = default;
		}

		Log.Debug($"running status-check with timeout=[{timeout.Milliseconds}]");

		var result = new CheckStatusServiceResult { cid = args.AppContext.Cid, pid = args.AppContext.Pid, };

		var accountApi = args.Provider.GetService<IAccountsApi>();
		var accountIdToEmail = new ConcurrentDictionary<long, Promise<string>>();

		async Task<string> GetEmail(long accountId)
		{
			if (accountId == 0) return "";
			if (accountIdToEmail.TryGetValue(accountId, out var emailPromise))
			{
				return await emailPromise;
			}

			accountIdToEmail[accountId] = emailPromise = accountApi
				.GetFind(accountId.ToString())
				.Map(res => res.email.GetOrElse(""));
			return await emailPromise;
		}

		// Before even bothering with discovery, emit all known services
		foreach (var definition in args.BeamoLocalSystem.BeamoManifest.ServiceDefinitions)
		{
			if (!definition.IsLocal) continue;
			if (serviceFilter != null && !serviceFilter.Contains(definition.BeamoId)) continue;
			if (!result.TryGetStatus(definition.BeamoId, out var status))
			{
				status = new ServiceStatus
				{
					service = definition.BeamoId,
					serviceType = definition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
					availableRoutes = new List<ServicesForRouteCollection>()
					{
						new()
						{
							knownToBeRunning = false,
							routingKey = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine(),
							federations = definition.Protocol is BeamoProtocolType.HttpMicroservice ? definition.SourceGenConfig.Federations.Select(kvp => new FederationInstance()
							{
								FederationId = kvp.Key,
								FederationTypes = kvp.Value.Select(f => f.Interface).ToArray(),
							}).ToList() : new List<FederationInstance>(),
						}
					},
					groups = definition.ServiceGroupTags,
				};

				result.services.Add(status);
			}
		}


		// emit the status with local services as "off" until the discovery actually runs
		yield return result;

		await foreach (var discoveryEvent in discovery.StartDiscovery(args, timeout, token, mode))
		{
			if (serviceFilter != null && !serviceFilter.Contains(discoveryEvent.Service)) continue;

			if (!result.TryGetStatus(discoveryEvent.Service, out var status))
			{
				status = new ServiceStatus
				{
					service = discoveryEvent.Service,
					serviceType = discoveryEvent.ServiceType,
					groups = discoveryEvent switch
					{
						DockerServiceEvent dockerServiceEvent => dockerServiceEvent.descriptor.groups,
						HostServiceEvent hostServiceEvent => hostServiceEvent.descriptor.groups,
						RemoteServiceEvent remoteServiceEvent => remoteServiceEvent.descriptor.groups,
						_ => throw new ArgumentOutOfRangeException(nameof(discoveryEvent))
					},
					availableRoutes = new List<ServicesForRouteCollection>()
				};
				result.services.Add(status);
			}

			if (!status.TryGetRoutes(discoveryEvent.RoutingKey, out var collection))
			{
				collection = new ServicesForRouteCollection
				{
					knownToBeRunning = true,
					routingKey = discoveryEvent.RoutingKey ?? "",
					federations = discoveryEvent switch
					{
						DockerServiceEvent dockerEvt => dockerEvt.descriptor.federations?.ToList() ?? new List<FederationInstance>(),
						HostServiceEvent hostEvt => hostEvt.descriptor.federations?.ToList() ?? new List<FederationInstance>(),
						RemoteServiceEvent remoteEvt => remoteEvt.descriptor.federations?.ToList() ?? new List<FederationInstance>(),
						_ => throw new ArgumentOutOfRangeException()
					}
				};
				status.availableRoutes.Add(collection);
			}

			// maybe the instance already exists inside the collection of instances...
			if (!collection.TryGetInstance(discoveryEvent.PrimaryKey, out var instance))
			{
				// Make sure the collection is defined as "running" now.
				collection.knownToBeRunning = true;

				// generate an instance to describe this event.
				instance = new ServiceInstance
				{
					startedByAccountId = discoveryEvent.StartedByAccountId,
					primaryKey = discoveryEvent.PrimaryKey,
					startedByAccountEmail = await GetEmail(discoveryEvent.StartedByAccountId),
				};

				// only fill in the field that corresponds to the main data.
				switch (discoveryEvent)
				{
					case DockerServiceEvent dockerEvt:
						instance.latestDockerEvent = dockerEvt.descriptor;
						instance.latestDockerEvent.routingKey ??= "";
						break;
					case HostServiceEvent hostEvt:
						instance.latestHostEvent = hostEvt.descriptor;
						instance.latestHostEvent.routingKey ??= "";
						break;
					case RemoteServiceEvent remoteEvt:
						instance.latestRemoteEvent = remoteEvt.descriptor;
						instance.latestRemoteEvent.routingKey ??= "";
						break;
				}

				if (discoveryEvent.Type == ServiceEventType.Running)
				{
					// this is the first time we are seeing this instance (or the first time since it was shutdown)
					collection.instances.Add(instance);
					yield return result;

					// TODO: include a changelog in the update.
				}
				else
				{
					// the service is being removed, but since we never saw it in the first place,
					// we don't need to do anything.
				}
			}
			else if (discoveryEvent.Type == ServiceEventType.Stopped)
			{
				// the instance existed in our state, but now it is being stopped, so we should remove it
				collection.instances.Remove(instance);

				// Make sure the collection as "knownToBeRunning" now.
				collection.knownToBeRunning = collection.instances.Count > 0;

				yield return result;

				// TODO: include a changelog in the update
			}
			else
			{
				// the instance is running, and SOMETHING changed, but we don't know what it is.
				// this is not supported yet.
				Log.Error($"Service=[{discoveryEvent.Service}] updated but change detection is not implemented yet. Please report this to Beamable.");
			}
		}

		await discovery.Stop();
	}
}
