using Beamable.Api.Autogenerated.Accounts;
using Beamable.Common;
using Beamable.Server;
using cli.Dotnet;
using cli.Services;
using Serilog;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;

// ReSharper disable InconsistentNaming

namespace cli;

[Serializable]
public class CheckStatusCommandArgs : CommandArgs
{
	public bool watch;
}

[Serializable]
public class CheckStatusServiceResult
{
	public string cid;
	public string pid;
	public List<ServiceStatus> services = new List<ServiceStatus>();
}

[Serializable]
public class ServiceStatus
{
	public string service;
	public string serviceType;
	public List<ServicesForRouteCollection> availableRoutes = new List<ServicesForRouteCollection>();
}

[Serializable]
public class ServicesForRouteCollection
{
	public string routingKey;
	public List<ServiceInstance> instances = new List<ServiceInstance>();
}

[Serializable]
public class ServiceInstance
{
	public long startedByAccountId;
	public string startedByAccountEmail;
	public string primaryKey;

	// avoid polymorphism, and put all the details in the correct field. These fields will be null for the wrong type. 
	public DockerServiceDescriptor latestDockerEvent;
	public HostServiceDescriptor latestHostEvent;
	public RemoteServiceDescriptor latestRemoteEvent;
}

public static class ServiceInstanceExtensions
{
	public static bool TryGetStatus(this CheckStatusServiceResult res, string serviceName, out ServiceStatus service)
	{
		service = default;
		foreach (var x in res.services)
		{
			if (x.service == serviceName)
			{
				service = x;
				return true;
			}
		}

		return false;
	}

	public static bool TryGetRoutes(this ServiceStatus status, string routingKey,
		out ServicesForRouteCollection collection)
	{
		collection = default;
		foreach (var x in status.availableRoutes)
		{
			if (x.routingKey == routingKey)
			{
				collection = x;
				return true;
			}
		}
		return false;
	}

	public static bool TryGetInstance(this ServicesForRouteCollection collection, string primaryKey,
		out ServiceInstance instance)
	{
		instance = default;
		foreach (var x in collection.instances)
		{
			if (x.primaryKey == primaryKey)
			{
				instance = x;
				return true;
			}
		}
		return false;
	}
}

public class CheckStatusCommand : StreamCommand<CheckStatusCommandArgs, CheckStatusServiceResult>
{
	public override bool AutoLogOutput => true;

	public CheckStatusCommand() : base("ps", "List the running status of local services not running in docker")
	{
	}

	public override void Configure()
	{
		ProjectCommand.AddWatchOption(this, (args, i) => args.watch = i);
	}

	public override async Task Handle(CheckStatusCommandArgs args)
	{
		TimeSpan timeout = TimeSpan.FromMilliseconds(Beamable.Common.Constants.Features.Services.DISCOVERY_RECEIVE_PERIOD_MS);
		if (args.watch)
		{
			timeout = default;
		}

		Log.Debug($"running status-check with watch=[{args.watch}] timeout=[{timeout.Milliseconds}]");
		await foreach (var update in CheckStatus(args, timeout, DiscoveryMode.ALL, args.Lifecycle.CancellationToken))
		{
			SendResults(update);
		}
	}

	public static async IAsyncEnumerable<CheckStatusServiceResult> CheckStatus(
		CommandArgs args,
		TimeSpan timeout = default,
		DiscoveryMode mode = DiscoveryMode.ALL,
		[EnumeratorCancellation] CancellationToken token = default)
	{
		var discovery = args.DependencyProvider.GetService<DiscoveryService>();

		if (timeout.TotalMilliseconds <= 0)
		{
			timeout = default;
		}
		Log.Debug($"running status-check with timeout=[{timeout.Milliseconds}]");

		var result = new CheckStatusServiceResult
		{
			cid = args.AppContext.Cid,
			pid = args.AppContext.Pid,
		};

		var accountApi = args.Provider.GetService<IAccountsApi>();
		var accountIdToEmail = new ConcurrentDictionary<long, Promise<string>>();
		async Task<string> GetEmail(long accountId)
		{
			if (accountId == 0) return "";
			if (accountIdToEmail.TryGetValue(accountId, out var emailPromise))
			{
				return await emailPromise;
			}

			accountIdToEmail[accountId] = emailPromise = accountApi
				.GetFind(accountId.ToString())
				.Map(res => res.email.GetOrElse(""));
			return await emailPromise;
		}

		// before even bothering with discovery, emit all known services
		foreach (var definition in args.BeamoLocalSystem.BeamoManifest.ServiceDefinitions)
		{
			if (!definition.IsLocal) continue;
			if (!result.TryGetStatus(definition.BeamoId, out var status))
			{
				status = new ServiceStatus
				{
					service = definition.BeamoId,
					serviceType = definition.Protocol == BeamoProtocolType.HttpMicroservice ? "service" : "storage",
					availableRoutes = new List<ServicesForRouteCollection>(),
				};
				result.services.Add(status);
			}
		}
		// emit the status with local services as "off" until the discovery actually runs
		yield return result;

		await foreach (var discoveryEvent in discovery.StartDiscovery(args, timeout, token, mode))
		{

			if (!result.TryGetStatus(discoveryEvent.Service, out var status))
			{
				status = new ServiceStatus
				{
					service = discoveryEvent.Service,
					serviceType = discoveryEvent.ServiceType,
					availableRoutes = new List<ServicesForRouteCollection>()
				};
				result.services.Add(status);
			}

			if (!status.TryGetRoutes(discoveryEvent.RoutingKey, out var collection))
			{
				collection = new ServicesForRouteCollection { routingKey = discoveryEvent.RoutingKey, };
				status.availableRoutes.Add(collection);
			}

			// maybe the instance already exists inside the collection of instances...
			if (!collection.TryGetInstance(discoveryEvent.PrimaryKey, out var instance))
			{
				// generate an instance to describe this event.
				instance = new ServiceInstance
				{
					startedByAccountId = discoveryEvent.StartedByAccountId,
					primaryKey = discoveryEvent.PrimaryKey,
					startedByAccountEmail = await GetEmail(discoveryEvent.StartedByAccountId),
				};

				// only fill in the field that corresponds to the main data.
				switch (discoveryEvent)
				{
					case DockerServiceEvent dockerEvt:
						instance.latestDockerEvent = dockerEvt.descriptor;
						break;
					case HostServiceEvent hostEvt:
						instance.latestHostEvent = hostEvt.descriptor;
						break;
					case RemoteServiceEvent remoteEvt:
						instance.latestRemoteEvent = remoteEvt.descriptor;
						break;
				}

				if (discoveryEvent.Type == ServiceEventType.Running)
				{
					// this is the first time we are seeing this instance (or the first time since it was shutdown)
					collection.instances.Add(instance);
					yield return result;

					// TODO: include a changelog in the update.
				}
				else
				{
					// the service is being removed, but since we never saw it in the first place,
					// we don't need to do anything.
				}
			}
			else if (discoveryEvent.Type == ServiceEventType.Stopped)
			{
				// the instance existed in our state, but now it is being stopped, so we should remove it
				collection.instances.Remove(instance);
				yield return result;

				// TODO: include a changelog in the update
			}
			else
			{
				// the instance is running, and SOMETHING changed, but we don't know what it is.
				// this is not supported yet.
				Log.Error($"Service=[{discoveryEvent.Service}] updated but change detection is not implemented yet. Please report this to Beamable.");
			}


		}

		await discovery.Stop();
	}
}
