using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Content;
using Beamable.Common.Dependencies;
using Beamable.Server;
using Beamable.Server.Common;
using cli.Utils;
using Newtonsoft.Json;
using Serilog;
using System.Collections;
using System.CommandLine;

namespace cli.FederationCommands;

public class ListServicesCommandArgs : CommandArgs
{
	public string federationFilter;
	public string federationNamespaceFilter;
	public long authorFilter;
	public string nameFilter;
	public bool listen;
}

public class ListServicesCommandOutput
{
	public string cid;
	public string pid;
	public List<RunningService> services = new List<RunningService>();
}

public class RunningService
{
	public string serviceName;
	public string beamoName;
	public string routingKey;
	public string fullName;
	public int instanceCount;
	public bool trafficFilterEnabled;
	public long startedByAccountId;

	public List<RunningFederation> federations = new List<RunningFederation>();
}

public class RunningFederation
{
	public string nameSpace;
	public string federationType;
}

public class ListServicesCommand : StreamCommand<ListServicesCommandArgs, ListServicesCommandOutput>
{
	public ListServicesCommand() : base("list", "List all running services in the current realm")
	{
	}

	public override void Configure()
	{
		var federationFilterOpt =
			new Option<string>("--type", "Filter the services by the types of federations they provide");
		AddOption(federationFilterOpt, (args, i) => args.federationFilter = i?.ToLowerInvariant());

		var nameFilterOpt =
			new Option<string>("--name", "Filter the services by the service name");
		AddOption(nameFilterOpt, (args, i) => args.nameFilter = i?.ToLowerInvariant());

		var namespaceFilterOpt =
			new Option<string>("--namespace", "Filter the services by the federation namespace");
		namespaceFilterOpt.AddAlias("-ns");
		AddOption(namespaceFilterOpt, (args, i) => args.federationNamespaceFilter = i?.ToLowerInvariant());

		var playerIdOpt =
			new Option<long>("--player", "Filter the services by the playerId of the author");
		AddOption(playerIdOpt, (args, i) => args.authorFilter = i);

		var listenOpt =
			new Option<bool>("--listen", "After piping the current list of services, keeps on listening and pipe them again every change");
		AddOption(listenOpt, (args, i) => args.listen = i);
	}

	public override async Task Handle(ListServicesCommandArgs args)
	{
		var res = await GetRunningServices(args.DependencyProvider);
		ApplyFilters(args, res);
		SendResults(res);

		if (args.listen)
		{
			var cancelToken = new CancellationToken();

			var ws = await WebsocketUtil.ConfigureWebSocketForServerNotifications(args, new[] { "beamo.service_registration_changed" }, cancelToken);
			await WebsocketUtil.RunServerNotificationListenLoop(ws, message =>
			{
				var bodyJson = JsonConvert.SerializeObject(message.body);
				Log.Verbose($"[{nameof(ServicesListCommand)}] Received new Json Payload:\n{bodyJson}");
				var data = JsonConvert.DeserializeObject<MicroserviceRegistrationsResponse>(bodyJson, UnitySerializationSettings.Instance);
				var evt = BuildListOutput(args.AppContext, data);
				ApplyFilters(args, evt);
				Log.Verbose($"[{nameof(ServicesListCommand)}] Registered Services Changed. Here's the new list of filtered services:\n{JsonConvert.SerializeObject(evt)}");
				SendResults(evt);
			}, cancelToken);
		}
	}

	public static async Promise<ListServicesCommandOutput> GetRunningServices(IDependencyProvider provider)
	{
		var api = provider.GetService<IBeamoApi>();
		var req = new MicroserviceRegistrationsQuery { };
		var res = await api.PostMicroserviceRegistrations(req);

		Log.Verbose($"got federation response reg-count=[{res.registrations.Length}]");
		var ctx = provider.GetService<IAppContext>();

		return BuildListOutput(ctx, res);
	}

	private static ListServicesCommandOutput BuildListOutput(IAppContext ctx, MicroserviceRegistrationsResponse res)
	{
		return new ListServicesCommandOutput
		{
			cid = ctx.Cid,
			pid = ctx.Pid,
			services = res.registrations.Select(x => new RunningService
			{
				serviceName = x.serviceName.Split('.')[2], // should be micro_name (toLowered, likely)
				beamoName = x.beamoName,
				fullName = x.serviceName,
				instanceCount = x.instanceCount,
				trafficFilterEnabled = x.trafficFilterEnabled,
				routingKey = x.routingKey,
				startedByAccountId = x.startedById.GetOrElse(0),
				federations = x.federation.GetOrElse(() => null)?.Select(f => new RunningFederation { nameSpace = f.nameSpace, federationType = f.type.ToString() }).ToList()
			}).ToList()
		};
	}



	private static void ApplyFilters(ListServicesCommandArgs args, ListServicesCommandOutput res)
	{
		IEnumerable<RunningService> services = res.services;
		if (!string.IsNullOrEmpty(args.federationFilter))
		{
			Log.Verbose($"applying federation type filter=[{args.federationFilter}]");
			services = res.services.Where(x =>
				x.federations.Any(f => f.federationType.ToLowerInvariant().Contains(args.federationFilter)));
		}

		if (!string.IsNullOrEmpty(args.nameFilter))
		{
			Log.Verbose($"applying federation name filter=[{args.nameFilter}]");
			services = res.services.Where(x => x.beamoName.ToLowerInvariant().Contains(args.nameFilter));
		}

		if (args.authorFilter > 0)
		{
			Log.Verbose($"applying federation author filter=[{args.authorFilter}]");
			services = res.services.Where(x => x.startedByAccountId == args.authorFilter);
		}

		if (!string.IsNullOrEmpty(args.federationNamespaceFilter))
		{
			Log.Verbose($"applying federation namespace filter=[{args.federationNamespaceFilter}]");
			services = res.services.Where(x =>
				x.federations.Any(f => f.nameSpace.ToLowerInvariant().Contains(args.federationNamespaceFilter)));
		}

		res.services = services.ToList();
	}
}
