using Beamable.Api.Autogenerated.Models;
using Beamable.Server;
using cli.Services;
using System.CommandLine;

namespace cli.FederationCommands;

public class RemoveFederationCommandArgs : CommandArgs
{
	public string BeamoId;
	public string FederationId;
	public string FederationInterface;
}

public class RemoveFederationCommandOutput
{
}

public class RemoveFederationCommand : StreamCommand<RemoveFederationCommandArgs, RemoveFederationCommandOutput>
{
	public RemoveFederationCommand() : base("remove", "Removes a federation to a particular microservice")
	{
	}

	public override void Configure()
	{
		var microserviceArg = new Argument<string>("microservice", "The BeamoId of the microservice to add");
		AddArgument(microserviceArg, (args, i) => args.BeamoId = i);

		var federationId = new Argument<string>("fed-id", "The federation id. Empty string will remove all federation ids. This is applied as an \"AND\" filter with the `fed-type` argument");
		AddArgument(federationId, (args, i) => args.FederationId = i);

		var federationType = new Argument<FederationType>("fed-types", "The type of federation to remove. Empty string will remove all federations. This is applied as an \"AND\" filter with the `fed-id` argument");
		AddArgument(federationType, (args, i) => args.FederationInterface = i.ToString());
	}

	public override async Task Handle(RemoveFederationCommandArgs args)
	{
		var manifest = args.BeamoLocalSystem.BeamoManifest;

		// Make sure the selected service exists.
		var selectedService = manifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == args.BeamoId);
		if (selectedService == null)
		{
			var err = $"Service {args.BeamoId} was not found.";
			err += "Make sure the id of the service correctly matches an existing service.";

			var possibleServices = string.Join('\n', manifest.ServiceDefinitions.Where(sd => sd.Protocol is BeamoProtocolType.HttpMicroservice).Select(sd => sd.BeamoId));
			err += $"Here's a list of possible services:\n{possibleServices}";
			throw new CliException(err, 3, true);
		}

		var knownFederations = selectedService.FederationsConfig.Federations;
		var idsWeCareAbout = knownFederations.Keys.Where(k => args.FederationId.Length == 0 || args.FederationId.Contains(k)).ToArray();
		
		foreach (string id in idsWeCareAbout)
		{
			var federationsOfId = new List<FederationInstanceConfig>(knownFederations[id]);
			for (var i = federationsOfId.Count - 1; i >= 0; i--)
			{
				var fed = federationsOfId[i];
				if (Enum.Parse<FederationType>(args.FederationInterface) == Enum.Parse<FederationType>(fed.Interface))
				{
					federationsOfId.RemoveAt(i);
				}
			}

			// Either remove the id entirely if no federations remained OR simply update it.
			if (federationsOfId.Count == 0) knownFederations.Remove(id);
			else knownFederations[id] = federationsOfId.ToArray();
		}

		// Serialize the updated source gen config to disk
		await ProjectContextUtil.SerializeSourceGenConfigToDisk(args.ConfigService.BaseDirectory, selectedService);

		// Log out which federations were removed and remind the user to remove the actual implementations of the interfaces
		Log.Information("Removed federation: {0}/{1}", args.FederationId, args.FederationInterface.ToString());
		Log.Information("Don't forget to remove the actual implementation code for these.");
	}
}
