using Beamable.Api.Autogenerated.Models;
using Beamable.Server;
using cli.Services;
using Serilog;
using System.CommandLine;

namespace cli.FederationCommands;

public class AddFederationCommandArgs : CommandArgs
{
	public string BeamoId;
	public string FederationId;
	public string FederationInterface;
}

public class AddFederationCommandOutput
{
}

public class AddFederationCommand : StreamCommand<AddFederationCommandArgs, AddFederationCommandOutput>
{
	public AddFederationCommand() : base("add", "Adds a federation to a particular microservice")
	{
	}

	public override void Configure()
	{
		var microserviceArg = new Argument<string>("microservice", "The BeamoId of the microservice to add");
		AddArgument(microserviceArg, (args, i) => args.BeamoId = i);

		var federationId = new Argument<string>("fed-id", "A federation id. This uniquely identifies your federation. Different federation interfaces can be associated with each id");
		AddArgument(federationId, (args, i) => args.FederationId = i);


		var federationType = new Argument<FederationType>("fed-type", "The type of federation to add");
		AddArgument(federationType, (args, i) => args.FederationInterface = i.ToString());
	}

	public override async Task Handle(AddFederationCommandArgs args)
	{
		var manifest = args.BeamoLocalSystem.BeamoManifest;

		// Make sure the selected service exists.
		var selectedService = manifest.ServiceDefinitions.FirstOrDefault(sd => sd.BeamoId == args.BeamoId);
		if (selectedService == null)
		{
			var err = $"Service {args.BeamoId} was not found.";
			err += "Make sure the id of the service correctly matches an existing service.";

			var possibleServices = string.Join('\n', manifest.ServiceDefinitions.Where(sd => sd.Protocol is BeamoProtocolType.HttpMicroservice).Select(sd => sd.BeamoId));
			err += $"Here's a list of possible services:\n{possibleServices}";
			throw new CliException(err, 3, true);
		}

		// Make sure this id/federation-type pair is not in use by any existing services.  
		var numberOfServicesWithId = manifest.ServiceDefinitions
			.Where(sd => sd.Protocol is BeamoProtocolType.HttpMicroservice)
			.Where(sd => sd.FederationsConfig.Federations.ContainsKey(args.FederationId))
			.Count(sd => sd.FederationsConfig.Federations[args.FederationId].Any(f => f.Interface.Contains(args.FederationInterface)));
		if (numberOfServicesWithId >= 1)
		{
			var err = $"FederationId [{args.FederationId}] already added for federation type [{args.FederationInterface}].";
			throw new CliException(err, 4, true);
		}

		// Now that we know the id/type pair is not in use, we can add it to the selected service.
		selectedService.FederationsConfig.Federations.Add(args.FederationId, new[] { new FederationInstanceConfig { Interface = args.FederationInterface } });

		// Serialize the updated source gen config to disk
		await ProjectContextUtil.SerializeSourceGenConfigToDisk(args.ConfigService.BaseDirectory, selectedService);

		// Log out which federations were removed and remind the user to remove the actual implementations of the interfaces
		Log.Information("Added federation: {0}/{1}", args.FederationId, args.FederationInterface);
		Log.Information("Make sure you implement the required functions in your microservice now!");
	}
}
