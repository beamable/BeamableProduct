using Beamable.Api.Autogenerated.Beamo;
using Beamable.Api.Autogenerated.Models;
using Beamable.Serialization;
using Beamable.Serialization.SmallerJSON;
using cli.Commands.Project;
using cli.Deployment.Services;
using Serilog;
using Spectre.Console;
using System.CommandLine;

namespace cli.DeploymentCommands;

public class ReleaseDeploymentCommandArgs : CommandArgs, IHasDeployPlanArgs
{
	
	// [DONE] TODO: add a --from-manifest-id option that downloads a manifest directly 
	// [DONE] TODO: add safety rails so that if the user passes a plan as a manifest, or vice versa, it explodes
	// [DONE] TODO: add a "beam [re]deploy roll|restart|redeploy" or `beam deploy release --restart`
	// [DONE] TODO: automatically keep plan files (from plan and release) in the /temp/plans folder, and display it in the command output, IN ADDITION to the -o flag
	//       add a `beam deploy release --last-plan` that loads up the most recent plan from /temp/plans
	// [DONE] TODO: deprecate `beam services deploy`
	// [DONE] TODO: finish removing beamableDev dockerfile, and old docker code editing 
	// TODO: add federation support
	// TODO: research if the ENTRYPOINT can be a build-arg
	// TODO: add full data stream support to commands, specifically the progress updates
	
	public string fromPlanFile;
	public bool fromLastPlan;
	public string Comment { get; set; }
	public string[] ServiceComments { get; set; }
	public string FromManifestFile { get; set; }
	public string ManifestId { get; set; }
	public bool UseLatestDeployedManifest { get; set; }
	public DeployMode DeployMode { get; set; }
	public bool RunHealthChecks { get; set; }
}

public class ReleaseDeploymentCommandOutput
{
	
}
public class ReleaseDeploymentCommand 
	: AppCommand<ReleaseDeploymentCommandArgs>
	, IResultSteam<DefaultStreamResultChannel, DeploymentPlanMetadata>
	, IResultSteam<RunProjectBuildErrorStreamChannel, RunProjectBuildErrorStream>
	, IResultSteam<PlanReleaseProgressChannel, PlanReleaseProgress>
{
	public ReleaseDeploymentCommand() : base("release", "perform a release, this will modify remote running services")
	{
		AddAlias("fire");
	}

	public override void Configure()
	{
		DeployArgs.AddPlanOptions(this);
		AddOption(new Option<string>(new string[] { "--from-plan", "--plan", "-p" }, "the file path to a pre-generated plan file using the `deploy plan` command"),
			(args, i) => args.fromPlanFile = i);
		AddOption(new Option<bool>(new string[]{"--from-latest-plan", "--latest-plan", "--last-plan", "-lp"}, "use the most recent plan generated from the plan command"), (args, i) => args.fromLastPlan = i);

	}

	public override async Task Handle(ReleaseDeploymentCommandArgs args)
	{
		var remoteManifestTask = DeployUtil.CreateReleaseManifestFromRealm(args.DependencyProvider.GetService<IBeamoApi>());
		
		DeploymentPlan plan = null;
		string planPath = null;

		
		var isLoadingPlan = !string.IsNullOrEmpty(args.fromPlanFile);
		if (args.fromLastPlan)
		{
			if (isLoadingPlan)
			{
				throw new CliException("cannot specify both --from-latest-plan and --plan");
			}
			args.fromPlanFile = DeployUtil.GetLatestPlanFilePath(args.DependencyProvider);
			if (args.fromPlanFile == null)
			{
				throw new CliException(
					"cannot use --from-latest-plan, because there are no plan files. Please run `dotnet beam deploy plan`");
			}

			isLoadingPlan = true;
		}
		var isLoadingManifest = !string.IsNullOrEmpty(args.FromManifestFile);
		
		if (isLoadingPlan && isLoadingManifest)
		{
			throw new CliException("Cannot specify both --from-plan and --from-manifest");
		}
		
		if (isLoadingPlan)
		{
			Log.Information($"Loading release plan from file=[{args.fromPlanFile}]");
			var json = await File.ReadAllTextAsync(args.fromPlanFile);
			
			// before deserializing it as a plan, check the fields to make sure its a valid plan.
			var data = Json.Deserialize(json) as IDictionary<string, object>;
			if (!DeployUtil.IsJsonAPlan(data))
			{
				// do a special check to see if this looks like a manifest view...
				if (DeployUtil.IsJsonAManifest(data))
				{
					throw new CliException(
						$"The file {args.fromPlanFile} appears to contain a manifest, but should contain a plan. " +
						$"Use `dotnet beam deploy release --from-manifest {args.fromPlanFile}` to create a plan.");
				}
				throw new CliException(
					$"The file {args.fromPlanFile} does not contain a valid plan. Use the `dotnet beam deploy plan` command to create a plan.");
			}
			plan = JsonSerializable.FromJson<DeploymentPlan>(json);
		}
		else
		{
			Log.Information("Generating release plan...");
			(plan, planPath) = await this.InteractivePlan(
				args.DependencyProvider, 
				args);
		}
		
		var remoteManifest = await remoteManifestTask;
		if (remoteManifest.checksum != plan.builtFromRemoteChecksum)
		{
			throw new CliException(
				"The given deployment plan was created with a different configuration of remote services than exists now. Please create a new plan and try again.");
		}
		
		
		DeployUtil.PrintPlanInfo(plan, args, out var hasChanges);
		this.InteractiveComments(plan, args);
		if (!string.IsNullOrEmpty(planPath))
		{
			Log.Information("Saved plan: " + planPath);
		}
		this.SendResults<DefaultStreamResultChannel, DeploymentPlanMetadata>(new DeploymentPlanMetadata
		{
			success = true,
			plan = plan,
			planPath = planPath
		});

		var confirmationText = hasChanges
			? "Are you sure you want to release the changes?"
			: "You can still deploy the services, which will roll existing services. Do you want to continue?";
		var confirm = args.Quiet || AnsiConsole.Confirm(confirmationText);
		if (!confirm)
		{
			return;
		}

		var progressReporter = (IResultSteam<PlanReleaseProgressChannel, PlanReleaseProgress>)this;
		await AnsiConsole
			.Progress()
			.StartAsync(async ctx =>
			{

				var progressTasks = new Dictionary<string, ProgressTask>();
			
				await DeployUtil.Deploy(
					plan, 
					args.DependencyProvider, 
					progressHandler: (name, progress, isKnownLength) =>
					{
						if (!progressTasks.TryGetValue(name, out var progressTask))
						{
							progressTasks[name] = progressTask = ctx.AddTask(name, maxValue: 1);
						}
						
						if (!isKnownLength && progress > 0)
						{
							progressTask.IsIndeterminate = true;
						}
						
						progressReporter.SendResults(new PlanReleaseProgress
						{
							ratio = progress,
							name = name,
							isKnownLength = isKnownLength
						});
						
						progressTask.Value = progress;
					}, remoteManifestTask);
	
			});


		return;
	}
}
