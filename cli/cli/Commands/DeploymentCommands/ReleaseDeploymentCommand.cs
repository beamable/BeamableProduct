using Beamable.Api.Autogenerated.Beamo;
using Beamable.Serialization;
using Beamable.Serialization.SmallerJSON;
using cli.Commands.Project;
using cli.Deployment.Services;
using Spectre.Console;
using System.CommandLine;
using Beamable.Server;

namespace cli.DeploymentCommands;

public class ReleaseDeploymentCommandArgs : CommandArgs, IHasDeployPlanArgs
{
	public string fromPlanFile;
	public bool fromLastPlan;
	public string Comment { get; set; }
	public string[] ServiceComments { get; set; }
	public string FromManifestFile { get; set; }
	public string ManifestId { get; set; }
	public bool UseLatestDeployedManifest { get; set; }
	public DeployMode DeployMode { get; set; }
	public bool RunHealthChecks { get; set; }
	public bool UseSequentialBuild { get; set; }
	public string SlnFilePath;


	public string SolutionFilePath
	{
		get => SlnFilePath;
		set => SlnFilePath = value;
	}
}


public class ReleaseDeploymentCommand 
	: AppCommand<ReleaseDeploymentCommandArgs>
	, IResultSteam<DefaultStreamResultChannel, DeploymentPlanMetadata>
	, IResultSteam<RunProjectBuildErrorStreamChannel, RunProjectBuildErrorStream>
	, IResultSteam<PlanReleaseProgressChannel, PlanReleaseProgress>
{
	public ReleaseDeploymentCommand() : base("release", "Perform a release, this will modify remote running services")
	{
		AddAlias("fire");
	}

	public override void Configure()
	{
		DeployArgs.AddPlanOptions(this);
		AddOption(new Option<string>(new string[] { "--from-plan", "--plan", "-p" }, "The file path to a pre-generated plan file using the `deploy plan` command"),
			(args, i) => args.fromPlanFile = i);
		SolutionCommandArgs.ConfigureSolutionFlag(this, _ => throw new CliException("Must have a valid .beamable folder"));

		// TODO: is this really helpful?
		AddOption(new Option<bool>(new string[]{"--from-latest-plan", "--latest-plan", "--last-plan", "-lp"}, "Use the most recent plan generated from the plan command"), (args, i) => args.fromLastPlan = i);
	}

	public override async Task Handle(ReleaseDeploymentCommandArgs args)
	{
		var remoteManifestTask = DeployUtil.CreateReleaseManifestFromRealm(args.DependencyProvider.GetService<IBeamoApi>());
		
		DeployablePlan plan = null;
		string planPath = null;

		
		var isLoadingPlan = !string.IsNullOrEmpty(args.fromPlanFile);
		if (args.fromLastPlan)
		{
			if (isLoadingPlan)
			{
				throw new CliException("cannot specify both --from-latest-plan and --plan");
			}
			args.fromPlanFile = DeployUtil.GetLatestPlanFilePath(args.DependencyProvider);
			if (args.fromPlanFile == null)
			{
				throw new CliException(
					"cannot use --from-latest-plan, because there are no plan files. Please run `dotnet beam deploy plan`");
			}

			isLoadingPlan = true;
		}
		var isLoadingManifest = !string.IsNullOrEmpty(args.FromManifestFile);
		
		if (isLoadingPlan && isLoadingManifest)
		{
			throw new CliException("Cannot specify both --from-plan and --from-manifest");
		}
		
		if (isLoadingPlan)
		{
			Log.Information($"Loading release plan from file=[{args.fromPlanFile}]");
			var json = await File.ReadAllTextAsync(args.fromPlanFile);
			
			// before deserializing it as a plan, check the fields to make sure its a valid plan.
			var data = Json.Deserialize(json) as IDictionary<string, object>;
			if (!DeployUtil.IsJsonAPlan(data))
			{
				// do a special check to see if this looks like a manifest view...
				if (DeployUtil.IsJsonAManifest(data))
				{
					throw new CliException(
						$"The file {args.fromPlanFile} appears to contain a manifest, but should contain a plan. " +
						$"Use `dotnet beam deploy release --from-manifest {args.fromPlanFile}` to create a plan.");
				}
				throw new CliException(
					$"The file {args.fromPlanFile} does not contain a valid plan. Use the `dotnet beam deploy plan` command to create a plan.");
			}
			plan = JsonSerializable.FromJson<DeployablePlan>(json);
		}
		else
		{
			Log.Information("Generating release plan...");
			(plan, planPath) = await this.InteractivePlan(
				args.DependencyProvider, 
				args);
		}
		
		var remoteManifest = await remoteManifestTask;
		if (remoteManifest.checksum != plan.builtFromRemoteChecksum)
		{
			throw new CliException(
				"The given deployment plan was created with a different configuration of remote services than exists now. Please create a new plan and try again.");
		}
		
		
		DeployUtil.PrintPlanInfo(plan, args, out var hasChanges);
		this.ApplyDeployComments(plan, args);
		if (!string.IsNullOrEmpty(planPath))
		{
			Log.Information("Saved plan: " + planPath);
		}
		this.SendResults<DefaultStreamResultChannel, DeploymentPlanMetadata>(new DeploymentPlanMetadata
		{
			success = true,
			plan = plan,
			planPath = planPath
		});

		Log.Information(@$"Releasing plan to target:
 HOST={args.AppContext.Host}
 CID={args.AppContext.Cid}
 PID={args.AppContext.Pid}");
		var confirmationText = hasChanges
			? "Are you sure you want to release the changes?"
			: "You can still deploy the services, which will roll existing services. Do you want to continue?";

		confirmationText += "\nType 'yes' to continue.";
		var confirm = args.Quiet || string.Equals("yes", AnsiConsole.Prompt(new TextPrompt<string>(confirmationText)), StringComparison.InvariantCultureIgnoreCase);
		if (!confirm)
		{
			return;
		}

		var progressReporter = (IResultSteam<PlanReleaseProgressChannel, PlanReleaseProgress>)this;
		await AnsiConsole
			.Progress()
			.StartAsync(async ctx =>
			{

				var progressTasks = new Dictionary<string, ProgressTask>();
			
				await DeployUtil.Deploy(
					plan, 
					args.DependencyProvider, 
					progressHandler: (name, progress, isKnownLength, serviceName) =>
					{
						if (!progressTasks.TryGetValue(name, out var progressTask))
						{
							progressTasks[name] = progressTask = ctx.AddTask(name, maxValue: 1);
						}
						
						if (!isKnownLength && progress > 0)
						{
							progressTask.IsIndeterminate = true;
						}
						
						progressReporter.SendResults(new PlanReleaseProgress
						{
							ratio = progress,
							name = name,
							isKnownLength = isKnownLength,
							serviceName = serviceName
						});
						
						progressTask.Value = progress;
					}, 
					args.Lifecycle.Source,
					remoteManifestTask);
	
			});


		return;
	}
}
