using cli.Services;
using Serilog;
using System.CommandLine;

namespace cli.UnityCommands;

public class CopyProjectSrcToUnityCommandArgs : CommandArgs
{
	public string csProjPath;
	public string targetUnityPath;
}

public class CopyProjectSrcToUnityCommandOutput
{
	public int filesCopied;
}

public class CopyProjectSrcToUnityCommand : AtomicCommand<CopyProjectSrcToUnityCommandArgs, CopyProjectSrcToUnityCommandOutput>, IStandaloneCommand
{
	public override bool IsForInternalUse => true;

	public CopyProjectSrcToUnityCommand() : base("copy-dotnet-src", "Copy the src from a dotnet csproj project into a Unity project")
	{
	}

	public override void Configure()
	{
		AddArgument(new Argument<string>("csprojPath", "path to csproj project"), (args, csProjPath) =>
		{
			if (!File.Exists(csProjPath))
			{
				throw new CliException($"no file exists at given csProjPath=[{Path.GetFullPath(csProjPath)}]");
			}

			if (!csProjPath.EndsWith(".csproj"))
			{
				throw new CliException($"given csproj path must be a .csproj file. csProjPath=[{Path.GetFullPath(csProjPath)}]");
			}

			args.csProjPath = csProjPath;
		});

		AddArgument(new Argument<string>("unityPath", "relative path to Unity destination for src files"),
			(args, unityPath) =>
			{
				if (Path.HasExtension(unityPath))
				{
					throw new CliException($"given unityPath must be a directory, unityPath=[${unityPath}]");
				}
				args.targetUnityPath = unityPath;
			});
	}

	public override Task<CopyProjectSrcToUnityCommandOutput> GetResult(CopyProjectSrcToUnityCommandArgs args)
	{
		return Task.FromResult(CopyProject(args.csProjPath, args.targetUnityPath));
	}

	public static CopyProjectSrcToUnityCommandOutput CopyProject(string csProjPath, string targetUnityPath)
	{
		Log.Debug($"Copying src files from {csProjPath} to {targetUnityPath}");

		// TODO: at some point, this may be too much memory to hold all at once if we are copying an absolutely massive project. In that case, consider a streaming approach.
		var sourceFiles = GetAllSourceFiles(csProjPath).ToList();
		var metaFiles = UnityCliGenerator.GenerateMetaFiles(sourceFiles);

		foreach (var x in metaFiles)
		{
			Log.Debug("Found src: " + x.FileName);
		}

		// need to create meta files for the various folders, too...
		var uniqueFolders = sourceFiles.Select(x => Path.GetDirectoryName(x.FileName))
			.Distinct()
			.Where(x => !string.IsNullOrEmpty(x))
			.ToList();
		foreach (var x in uniqueFolders)
		{
			Log.Debug("Found folder: " + x);
		}
		var metaFolders = UnityCliGenerator.GenerateMetaFiles(uniqueFolders);

		WriteFilesAtDirectory(targetUnityPath, sourceFiles);
		WriteFilesAtDirectory(targetUnityPath, metaFiles);
		WriteFilesAtDirectory(targetUnityPath, metaFolders);

		return new CopyProjectSrcToUnityCommandOutput
		{
			filesCopied = sourceFiles.Count
		};
	}

	static void WriteFilesAtDirectory(string targetDirectory, List<GeneratedFileDescriptor> files)
	{
		foreach (var file in files)
		{
			var fullPath = Path.Combine(targetDirectory, file.FileName);
			var dir = Path.GetDirectoryName(fullPath);
			Directory.CreateDirectory(dir);
			Log.Debug($"Writing {file.FileName} to {fullPath}");
			File.WriteAllText(fullPath, file.Content);
		}
	}


	/// <summary>
	/// Given a path to a csproj, iterate through all the .cs files in the sub directories of the csproj.
	/// This does not honor true MSBuild configurations, this is just a file directory scan.
	///
	/// The resulting paths are relative to the csProjPath's folder
	/// </summary>
	/// <param name="csProjPath"></param>
	/// <returns></returns>
	static IEnumerable<GeneratedFileDescriptor> GetAllSourceFiles(string csProjPath)
	{
		var dir = Path.GetFullPath(Path.GetDirectoryName(csProjPath));
		var toExplore = new Queue<string>();
		toExplore.Enqueue(dir);

		while (toExplore.Count > 0)
		{
			var current = toExplore.Dequeue();

			var files = Directory.GetFiles(current, "*.cs", SearchOption.TopDirectoryOnly);
			foreach (var file in files)
			{
				if (!file.EndsWith(".cs")) continue;
				var path = Path.GetRelativePath(dir, file);
				var content = "// This file generated by a copy-operation from another project. \n // Edits to this file will be overwritten by the build process. \n\n" + File.ReadAllText(file);
				yield return new GeneratedFileDescriptor { FileName = path, Content = content };
			}

			var subDirs = Directory.GetDirectories(current);
			foreach (var subDir in subDirs)
			{
				var dirName = Path.GetFileName(subDir);
				if (dirName == "bin") continue;
				if (dirName == "obj") continue;
				toExplore.Enqueue(subDir);
			}
		}
	}
}
