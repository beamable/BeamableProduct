using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Api;
using cli.Dotnet;
using cli.Services;
using cli.Utils;

namespace cli.UnityCommands;

public class ShowManifestCommandArgs : CommandArgs
{
	
}

public class ShowManifestCommandOutput
{
	public string localRoutingKey;
	public List<ManifestServiceEntry> services = new List<ManifestServiceEntry>();
	public List<ManifestStorageEntry> storages = new List<ManifestStorageEntry>();
	
	public List<string> existingFederationIds = new List<string>();
	public List<string> availableFederationTypes = new List<string>();
}

public class ManifestServiceEntry
{
	public string beamoId;
	public bool shouldBeEnabledOnRemote;
	public string csprojPath;
	public string buildDllPath;
	public List<string> storageDependencies;
	public List<UnityAssemblyReferenceData> unityReferences;
	public List<FederationEntry> federations;
}

[Serializable]
public class FederationEntry
{
	public string interfaceName;
	public string federationId;
}

public class ManifestStorageEntry
{
	public string beamoId;
	public string csprojPath;
	public bool shouldBeEnabledOnRemote;
	public List<UnityAssemblyReferenceData> unityReferences;
}

public class ShowManifestCommand : AtomicCommand<ShowManifestCommandArgs, ShowManifestCommandOutput>
{
	public ShowManifestCommand() : base("manifest", "Read local file state and show your local manifest information")
	{
	}

	public override void Configure()
	{
		
	}

	public override Task<ShowManifestCommandOutput> GetResult(ShowManifestCommandArgs args)
	{
		var services = new List<ManifestServiceEntry>();
		var storages = new List<ManifestStorageEntry>();
		
		var manifest = args.BeamoLocalSystem.BeamoManifest;
		
		foreach (var (beamoId, http) in manifest.HttpMicroserviceLocalProtocols)
		{
			if (!manifest.TryGetDefinition(beamoId, out var definition))
			{
				throw new InvalidOperationException($"definition must exist for beamoId=[{beamoId}]");
			}
			var buildReport =  ProjectCommand.IsProjectBuiltMsBuild(http.Metadata.msbuildProject);
			
			var service = new ManifestServiceEntry
			{
				beamoId = beamoId,
				buildDllPath = Path.GetFullPath(buildReport.path),
				csprojPath = definition.ProjectPath,
				shouldBeEnabledOnRemote = definition.ShouldBeEnabledOnRemote,
				storageDependencies = http.StorageDependencyBeamIds,
				unityReferences = http.UnityAssemblyDefinitionProjectReferences,
				federations = definition.SourceGenConfig.Federations.SelectMany(kvp =>
				{
					var results = new List<FederationEntry>();
					foreach (var fed in kvp.Value)
					{
						results.Add(new FederationEntry
						{
							interfaceName = fed.Interface,
							federationId = kvp.Key
						});
					}
					return results;
				}).ToList()
			};
			

			services.Add(service);
		}

		foreach (var (beamoId, db) in manifest.EmbeddedMongoDbLocalProtocols)
		{
			if (!manifest.TryGetDefinition(beamoId, out var definition))
			{
				throw new InvalidOperationException($"definition must exist for beamoId=[{beamoId}]");
			}

			var storage = new ManifestStorageEntry
			{
				beamoId = beamoId, 
				csprojPath = definition.ProjectPath,
				shouldBeEnabledOnRemote = definition.ShouldBeEnabledOnRemote,
				unityReferences = db.UnityAssemblyDefinitionProjectReferences
			};
			storages.Add(storage);
		}

		var uniqueFederationIds = services
			.SelectMany(x => x.federations.Select(f => f.federationId))
			.Distinct()
			.ToList();

		return Task.FromResult(new ShowManifestCommandOutput
		{
			services = services,
			storages = storages,
			localRoutingKey = ServiceRoutingStrategyExtensions.GetDefaultRoutingKeyForMachine(),
			existingFederationIds = uniqueFederationIds,
			availableFederationTypes = Enum.GetValues<FederationType>().Select(FederationTypeExtensions.ToEnumString).Except(new string[]
			{
				// these federations are not actually supported yet. (Oct
				"IFederatedPlayerInit",
				"IFederatedCommerce"
			}).ToList()
		});
	}
}
