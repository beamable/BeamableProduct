using Beamable.Api.Autogenerated.Models;
using Beamable.Common.BeamCli.Contracts;
using Beamable.Server;
using cli.Services;
using Spectre.Console;
using System.CommandLine;

namespace cli.OtelCommands;

[Serializable]
public class FetchTelemetryLogsCommandArgs : CommandArgs
{
	public string ServiceName; // --service-name, does a full match with the service name
	public string LogLevel; // --log-level, does a full match with the log level
	public int LimitRows; // --limit-rows, limits the amount of rows fetched
	public string BodyMatch; // --body, string value to be matched with the log body message
	public bool FullMatch; // --full-match, partial match by default
	public string FromTime; // --from
	public bool AscendingOrder;
}

public class FetchTelemetryLogsResult
{
	public List<FetchCommandLogRecord> allLogsFound;
}

public class FetchCommandLogRecord
{
	public string Timestamp;
	public string LogLevel;
	public string ServiceName;
	public string Message;
}

public class FetchTelemetryLogsCommand : AtomicCommand<FetchTelemetryLogsCommandArgs, FetchTelemetryLogsResult>
{
	public FetchTelemetryLogsCommand() : base("logs", "Fetch logs from Clickhouse")
	{
	}

	public override void Configure()
	{
		AddArgument(new Argument<string>("filter", () => string.Empty, "Value to be matched with the log message body"){Arity = ArgumentArity.ZeroOrOne}, (args, i) => args.BodyMatch = i);
		AddOption(new Option<string>("--id", "Filter logs by doing a full match with the service name"),
			(args, i) => args.ServiceName = i);
		AddOption(new Option<string>("--log-level", "Filter logs by doing a full match with the Log Level. Available values are: [\"Trace\", \"Debug\", \"Information\", \"Warning\", \"Error\", \"Critical\", \"None\"]"),
			(args, i) => args.LogLevel = i);
		AddOption(new Option<int>("--limit", () => 100, "Sets a max number of rows to be retrieved by this command"),
			(args, i) => args.LimitRows = i);
		AddOption(new Option<bool>("--full-match", "If set, this will make the body message match be a full exact match"),
			(args, i) => args.FullMatch = i);
		AddOption(new Option<string>("--from", "The amount of time to go back and retrieve logs. Examples: 12d (12 days), 5m (5 minutes), 48h (48 hours)"),
			(args, i) => args.FromTime = i);
		AddOption(new Option<bool>(new string[]{"--ascending", "--asc"}, () => false,"If set, this will force the order to be ascending instead of the default descending order"),
			(args, i) => args.AscendingOrder = i);
	}

	public override bool AutoLogOutput => false;

	public override async Task<FetchTelemetryLogsResult> GetResult(FetchTelemetryLogsCommandArgs args)
	{
		OtelAuthConfig res = await args.OtelApi.GetOtelAuthReaderConfig();
		var result = await ClickhouseConnection.FetchLogs(res, args);

		var columnNameStyle = new Style(Color.SlateBlue1);

		var table = new Table();
		var timestampCol = new TableColumn(new Markup("Timestamp", columnNameStyle));
		var logLevelCol = new TableColumn(new Markup("Log Level", columnNameStyle));
		var serviceCol = new TableColumn(new Markup("Service Id", columnNameStyle));
		var messageCol = new TableColumn(new Markup("Message", columnNameStyle));

		table.AddColumn(timestampCol).AddColumn(logLevelCol).AddColumn(serviceCol).AddColumn(messageCol);
		foreach (var log in result)
		{
			var timestampMarkup = new Markup($"{log.Timestamp}");
			var logLevelMarkup = new Markup($"{log.LogLevel}");
			var serviceMarkup = new Markup($"{log.ServiceName}");
			var messageMarkup = new Markup($"{Markup.Escape(log.Message)}");

			table.AddRow(new TableRow(new[] { timestampMarkup, logLevelMarkup, serviceMarkup, messageMarkup}));
		}
		AnsiConsole.Write(table);

		return new FetchTelemetryLogsResult()
		{
			allLogsFound = result
		};
	}
}
