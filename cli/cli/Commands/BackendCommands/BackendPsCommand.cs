using System.CommandLine;
using System.Diagnostics;
using System.Text;
using System.Text.Json;
using Beamable.Api.Autogenerated.Models;
using Beamable.Server;
using cli.DockerCommands;
using cli.Utils;
using Docker.DotNet.Models;
using Hocon;
using MongoDB.Driver;
using Spectre.Console;
using UnityEngine;
using Message = Docker.DotNet.Models.Message;

namespace cli.BackendCommands;

public class BackendPsCommandArgs : CommandArgs
{
    public bool watch;
    public string backendHome;
}

public class BackendPsCommandResults
{
    public BackendPsInfraStatus Infra;
    public BackendPsToolStatus Tools;
}

public class BackendPsInfraStatus
{
    public List<BackendDockerContainerInfo> coreServices = new List<BackendDockerContainerInfo>();

    public bool AllRunning => coreServices.All(c => c.isRunning);
}

public class BackendPsToolStatus
{
    public List<BackendToolRuntimeInfo> tools = new List<BackendToolRuntimeInfo>();

    public string GetMeaningfulChecksum()
    {
        var sb = new StringBuilder();
        foreach (var tool in tools)
        {
            sb.Append(tool.processId);
            sb.Append(tool.toolName);
            sb.Append(tool.respondedToDebugEndpoint);
        }
        return BeamoExtensions.GetHash(sb.ToString());
    }
}

public class BackendDockerContainerInfo
{
    public string service;
    public string containerId;
    public bool isRunning;
}

[DebuggerDisplay("{serviceType}/{toolName} running=[{isRunning}]")]
public class BackendToolRuntimeInfo
{
    public bool isEssential;
    public bool isRunning;
    public string toolName;
    public string serviceName;
    public string serviceType;
    public int processId;
    public string stdOutPath;
    public string stdErrPath;
    public bool respondedToDebugEndpoint;
    public string host;
    public int port;
}

public class BackendToolProcessInfo
{
    public string toolName;
    public int processId;
    public string mainClass;
    public string stdOutPath;
    public string stdErrPath;
}

public class BackendPsCommand 
    : AppCommand<BackendPsCommandArgs>
    , IResultSteam<DefaultStreamResultChannel, BackendPsCommandResults>
    , ISkipManifest
    , IStandaloneCommand
{
    public BackendPsCommand() : base("ps", "Get the current local state")
    {
    }

    public override void Configure()
    {
        AddOption(new Option<bool>(new string[] { "--watch", "-w" }, "Listen for changes to the state"),
            (args, i) => args.watch = i);
        
        BackendCommandGroup.AddBackendHomeOption(this, (args, i) => args.backendHome = i);
    }

    public override async Task Handle(BackendPsCommandArgs args)
    {
        await DockerStatusCommand.RequireDocker(args);
        BackendCommandGroup.ValidateBackendHomeDirectoryExists(args.backendHome);
        var list = BackendListToolsCommand.GatherToolList(args.backendHome);

        var lockKey = new object();
        var latestInfraStatus = await CheckInfraStatus(list, args);
        var latestToolStatus = await CheckToolStatus(list, args);

        var action = new Debouncer(TimeSpan.FromMicroseconds(50), () =>
        {
            lock (lockKey)
            {
                Report();
            }
        });
        
        if (args.watch)
        {
            var docker = ListenForLocalDocker(list, args, args.Lifecycle.CancellationToken, infraStatus =>
            {
                lock (lockKey)
                {
                    latestInfraStatus = infraStatus;
                }
                action.Signal();
            });
            var mongo = ListenForLocalBindings(list, args, args.Lifecycle.CancellationToken, toolStatus =>
            {
                lock (lockKey)
                {
                    latestToolStatus = toolStatus;
                }
                action.Signal();

            });
            await docker;
            await mongo;
        }
        else
        {
            Report();
        }

        void Report()
        {
            var status = new BackendPsCommandResults
            {
                Infra = latestInfraStatus,
                Tools = latestToolStatus
            };
            this.SendResults(status);
            
            var table = new Table();
            table.Border(TableBorder.Simple);
            table.AddColumn("[bold]type[/]");
            table.AddColumn("[bold]name[/]");
            table.AddColumn("[bold]pid|containerId[/]");
            table.AddColumn("[bold]healthy[/]");
            // table.AddColumn("[bold]version[/]");
            // table.AddColumn("[bold]req count[/]");

            foreach (var coreService in latestInfraStatus.coreServices)
            {
                if (!coreService.isRunning) continue;
                table.AddRow(
                    new Text("infra"), 
                    new Text(coreService.service), 
                    new Text(coreService.containerId?.Substring(0, 8) ?? ""),
                    new Text("")
                );
            }

            foreach (var tool in latestToolStatus.tools)
            {
                if (!tool.isRunning) continue;
                
                table.AddRow(
                    new Text(tool.serviceType), 
                    new Text(tool.serviceName), 
                    new Text(tool.processId.ToString()),
                    new Text(tool.respondedToDebugEndpoint ? "yes" : "no")
                );
            }
		
            AnsiConsole.Write(table);

            var missingInfra = latestInfraStatus.coreServices.Where(x => !x.isRunning).ToList();
            
            if (missingInfra.Count > 0)
            {
                AnsiConsole.MarkupLine($"[bold red]Missing core infrastructure:[/]");
                AnsiConsole.MarkupLine($"[red] {string.Join(", ", missingInfra.Select(x => x.service))}[/]");
            }
            else
            {
                AnsiConsole.MarkupLine("[green]All core infrastructure is running[/]");
            }
            
            var missingEssentials = latestToolStatus.tools.Where(x => x.isEssential && !x.isRunning).ToList();
            if (missingEssentials.Count > 0)
            {
                AnsiConsole.MarkupLine($"[bold red]Missing essential tools:[/]");
                AnsiConsole.MarkupLine($"[red] {string.Join(", ", missingEssentials.Select(x => x.serviceType + "/" + x.serviceName))}[/]");
            }
            else
            {
                AnsiConsole.MarkupLine("[green]All essential tools are running[/]");
            }
        }
    }

    public static async Task ListenForLocalBindings(BackendToolList list, CommandArgs args, CancellationToken ct, Action<BackendPsToolStatus> onToolChange)
    {
        
        var client = BackendMongoUtil.GetMongo(list);
        var topCollection = BackendMongoUtil.GetTopologyCollection(client);
        var lastStatus = default(BackendPsToolStatus);
        var action = new Debouncer(TimeSpan.FromMilliseconds(250), async void () =>
        {
            try
            {
                var status = await CheckToolStatus(list, args);
                if (status.GetMeaningfulChecksum() != lastStatus?.GetMeaningfulChecksum())
                {
                    lastStatus = status;
                    onToolChange?.Invoke(status);
                }
            }
            catch (Exception e)
            {
                Log.Fatal(e, "Failed to parse tool status");
            }
        });

        Timer clock = null;
        clock = new Timer(x =>
        {
            if (ct.IsCancellationRequested)
            {
                clock?.Dispose();
                return;
            }
            action.Signal();
        }, null, TimeSpan.FromMilliseconds(0), TimeSpan.FromSeconds(1));
        await topCollection.RunWatching(ct, _ =>
        {
            // could be smart and listen to the operation, but given this is a local computer
            //  we can just slam it and ask for everything everytime. 
            action.Signal();
        });
    }

    public static async Task ListenForLocalDocker(BackendToolList list, CommandArgs args, CancellationToken ct, Action<BackendPsInfraStatus> onCoreChange)
    {
        await DockerStatusCommand.RequireDocker(args);

        var action = new Debouncer(TimeSpan.FromMilliseconds(250), async void () =>
        {
            try
            {
                var statusCheck = await CheckInfraStatus(list, args);
                onCoreChange?.Invoke(statusCheck);
            }
            catch (Exception e)
            {
                Log.Fatal(e, "Failed to parse docker status");
            }
        });

        var task = args.BeamoLocalSystem.Client.System.MonitorEventsAsync(new ContainerEventsParameters
        {
            
        }, new Progress<Message>(DockerSystemEventHandler), ct);

        void DockerSystemEventHandler(Message message)
        {
            var type = message.Type;
            
            // this only cares about containers turning on or off.
            if (!string.Equals(type, "container", StringComparison.InvariantCultureIgnoreCase))
                return;
            
            action.Signal();
        }

        try
        {
            await task;
        }
        catch (TaskCanceledException)
        {
            // let it gooooo
            Log.Verbose("docker watch was cancelled.");
        }
        catch
        {
            throw;
        }
    }

    public static async Task<List<BackendToolProcessInfo>> CheckLocalJvmDebuggables(BackendToolList list)
    {
        var programs = await JavaUtility.FindDebuggables();
        // filter the programs by the ones that match the main class. 

        var classNameToTool = list.tools.ToDictionary(t => t.mainClassName);

        var found = new List<BackendToolProcessInfo>();
        foreach (var entry in programs.entries)
        {
            if (!classNameToTool.TryGetValue(entry.mainClass, out var tool)) continue;
            var info = new BackendToolProcessInfo
            {
                processId = entry.processId,
                toolName = tool.name,
                mainClass = entry.mainClass
            };
            entry.jvmArgs.TryGetValue(BackendRunCommand.JVM_BEAM_OUT_PROPERTY, out info.stdOutPath);
            entry.jvmArgs.TryGetValue(BackendRunCommand.JVM_BEAM_ERR_PROPERTY, out info.stdErrPath);
            
            found.Add(info);
        }
        
        return found;
    }
    
    public const string BEAMABLE_LABEL = "com.beamable.local";

    public static async Task<BackendPsToolStatus> CheckToolStatus(BackendToolList list, CommandArgs args)
    {
        var client = BackendMongoUtil.GetMongo(list);
        var allEntries = await client.GetTopologies();

        var localDebuggables = await CheckLocalJvmDebuggables(list);
        
        // TODO: this is jank, but there are WAY too many object routing services to deal with
        var entries = allEntries.DistinctBy(e => e.ProcessId + e.ServiceType).ToList();

        var gateway = await FindGateways();
        
        var status = new BackendPsToolStatus();
        status.tools.Add(gateway);
        foreach (var tool in list.tools)
        {
            var foundTools = new List<BackendToolRuntimeInfo>();
            foreach (var basicName in tool.basicServiceNames)
            {
                var matched = entries.Where(e => e.ServiceType == "basic" && e.ServiceName == basicName && IsRunning(e)).ToList();
                if (matched.Count == 0)
                {
                    var matchingDebuggables = localDebuggables.Where(d => d.toolName == tool.name).ToList();
                    if (matchingDebuggables.Count == 0)
                    {
                        status.tools.Add(new BackendToolRuntimeInfo
                        {
                            toolName = tool.name,
                            serviceType = "basic",
                            serviceName = basicName,
                            isEssential = tool.profiles?.Contains("essential") ?? false,
                        });
                    }
                    else
                    {
                        foreach (var debuggable in matchingDebuggables)
                        {
                            status.tools.Add(new BackendToolRuntimeInfo
                            {
                                toolName = tool.name,
                                serviceType = "basic",
                                serviceName = basicName,
                                isEssential = tool.profiles?.Contains("essential") ?? false,
                                stdErrPath = debuggable.stdErrPath,
                                stdOutPath = debuggable.stdOutPath,
                                processId = debuggable.processId,
                                isRunning = true
                            });
                        }
                    }
                }
                else
                {
                    foreach (var entry in matched)
                    {
                        foundTools.Add(GenerateInfo(tool, entry));
                    }
                }
                
            }

            foreach (var objectName in tool.objectSerivceNames)
            {
                var matched = entries.Where(e => e.ServiceType == "object" && e.ServiceName == objectName && IsRunning(e)).ToList();
                if (matched.Count == 0)
                {
                    var matchingDebuggables = localDebuggables.Where(d => d.toolName == tool.name).ToList();
                    if (matchingDebuggables.Count == 0)
                    {
                        status.tools.Add(new BackendToolRuntimeInfo
                        {
                            toolName = tool.name,
                            serviceType = "object",
                            serviceName = objectName,
                            isEssential = tool.profiles?.Contains("essential") ?? false,
                        });
                    }
                    else
                    {
                        foreach (var debuggable in matchingDebuggables)
                        {
                            status.tools.Add(new BackendToolRuntimeInfo
                            {
                                toolName = tool.name,
                                serviceType = "object",
                                serviceName = objectName,
                                isEssential = tool.profiles?.Contains("essential") ?? false,
                                stdErrPath = debuggable.stdErrPath,
                                stdOutPath = debuggable.stdOutPath,
                                processId = debuggable.processId,
                                isRunning = true
                            });
                        }
                    }
                }
                else
                {
                    foreach (var entry in matched)
                    {
                        foundTools.Add(GenerateInfo(tool, entry));
                    }
                }
            }

            status.tools.AddRange(foundTools);
        }
        return status;

        bool IsRunning(BackendTopologyEntry entry)
        {
            try
            {
                Process.GetProcessById(entry.ProcessId);
                return true;
            }
            catch
            {
                return false;
            }
        }
        
        BackendToolRuntimeInfo GenerateInfo(BackendToolInfo tool, BackendTopologyEntry entry)
        {
            var info = new BackendToolRuntimeInfo
            {
                serviceType = entry.ServiceType,
                serviceName = entry.ServiceName,
                toolName = tool.name,
                isEssential = tool.profiles?.Contains("essential") ?? false,
                isRunning = true,
                port = entry.binding.port,
                host = entry.binding.host,
                stdOutPath = entry.StandardOutRedirection,
                stdErrPath = entry.StandardErrRedirection,
                processId = entry.ProcessId,
                respondedToDebugEndpoint = entry.respondedToDebugEndpoint
            };
            
            return info;
        }

        async Task<BackendToolRuntimeInfo> FindGateways()
        {
            var gatewayInfo = list.tools.FirstOrDefault(t => t.name == "gateway");
            if (gatewayInfo == null) throw new CliException("Tool info could not find a gateway entry");

            var confPath = Path.Combine(gatewayInfo.projectPath, "src", "main", "resources", "server.conf");
            var config = HoconConfigurationFactory.FromFile(confPath);
            var port = config.GetInt("service.port");

            var client = new HttpClient();
            var gateway = new BackendToolRuntimeInfo
            {
                toolName = "gateway",
                host = "127.0.0.1",
                port = port,
                processId = -1,
                isEssential = true,
                serviceName = "gateway",
                serviceType = "gateway"
            };
            try
            {
                var metadataJson = await client.GetStringAsync($"http://127.0.0.1:{port}/metadata");
                var metadata = JsonSerializer.Deserialize<BackendTopologyDebugInfo>(metadataJson, new JsonSerializerOptions
                {
                    IncludeFields = true
                });
                gateway.isRunning = true;
                gateway.respondedToDebugEndpoint = true;
                gateway.processId = metadata.processId;
                gateway.stdErrPath = metadata.stdErrRedirection;
                gateway.stdOutPath = metadata.stdOutRedirection;
            }
            catch
            {
                // oh well.
            }

            return gateway;
        }
    }
    
    
    public static async Task<BackendPsInfraStatus> CheckInfraStatus(BackendToolList list, CommandArgs args)
    {
        var containers = await args.BeamoLocalSystem.Client.Containers.ListContainersAsync(new ContainersListParameters
        {
            Filters = new Dictionary<string, IDictionary<string, bool>>
            {
                ["label"] = new Dictionary<string, bool>
                {
                    [BEAMABLE_LABEL] = true
                }
            }
        });

        var coreStatus = new BackendPsInfraStatus();
        foreach (var infra in list.infra)
        {
            coreStatus.coreServices.Add(new BackendDockerContainerInfo
            {
                service = infra.name
            });
        }
        
        const string serviceLabel = "com.docker.compose.service";
        foreach (var container in containers)
        {
            Log.Debug($"found container=[{container.ID}]");
            if (!container.Labels.TryGetValue(serviceLabel, out var service))
            {
                Log.Warning($"Found a docker container=[{container.ID}] with the label={BEAMABLE_LABEL}, but no {serviceLabel}.");
                continue;
            }

            var coreService = coreStatus.coreServices.FirstOrDefault(c => c.service == service);
            if (coreService == null)
            {
                Log.Warning($"Found a docker container=[{container.ID}] service=[{service}], but it does not match a known required service.");
                continue;
            }

            coreService.isRunning = true;
            coreService.containerId = container.ID;
            // maybe we need to extract other properties from docker?
        }

        return coreStatus;
    }
}