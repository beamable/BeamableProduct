using Beamable.Api.Autogenerated.Accounts;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Api.Realms;
using cli.Services;
using cli.Utils;
using Docker.DotNet.Models;
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using tests.MoqExtensions;
using CustomerResponse = Beamable.Api.Autogenerated.Models.CustomerResponse;
using IRealmsApi = Beamable.Api.Autogenerated.Realms.IRealmsApi;

namespace tests.Examples.Project;

public class BeamProjectGenerateEnvFlows : CLITestExtensions
{
	[Test]
	[TestCase("Example", ".")]
	[TestCase("Example", "services")]
	[TestCase("Example", "services/Example")]
	public void GenerateEnv_NoDeps(string serviceName, string executeFrom)
	{
		#region Arrange
		const string secret = "secret";

		var newFlow = new BeamProjectNewFlows();
		newFlow.NewProject_Init_NoSlnConfig(serviceName, ".");
		ResetConfigurator();

		// step into newly created beamable folder...
		Directory.SetCurrentDirectory(executeFrom);

		// mock call to get secret,
		Mock<IAccountsApi>(mock =>
		{
			mock.Setup(x => x.GetAdminMe(true))
				.ReturnsPromise(new AccountPortalView()
				{
					email = "tuna@tuna.com",
					id = 123
				})
				.Verifiable();
		});
		Mock<IRealmsApi>(mock =>
		{
			mock.Setup(x => x.GetAdminCustomer(true))
				.ReturnsPromise(new CustomerResponse
				{
					customer = new RealmsBasicCustomer()
					{
						projects = new Beamable.Api.Autogenerated.Models.Project[]
						{
							new Beamable.Api.Autogenerated.Models.Project
							{
								name = pid,
								secret = secret
							}
						}
					}
				})
				.Verifiable();
		});


		#endregion

		#region Act


		Run("project", "generate-env", serviceName, ".", "--auto-deploy", "--include-secret", "--exclude-otel-creds", "--quiet");

		#endregion

		#region Assert

		// there should be an .env file
		Assert.IsFalse(BFile.Exists($".env"),
			"there should not be an .env file in the current directory.");

		#endregion
	}

	[Test]
	[TestCase("Example", "DataCLITest", ".")]
	[TestCase("Example", "DataCLITest", "services")]
	[TestCase("Example", "DataCLITest", "services/Example")]
	public async Task GenerateEnv_WithADep(string serviceName, string storageName, string executeFrom)
	{
		#region Arrange
		const string secret = "secret";

		var newFlow = new BeamProjectNewFlows();
		newFlow.NewProject_UsingExistingInit_NoSlnConfig_AddStorageToExistingSln(serviceName, storageName);
		ResetConfigurator();

		// mock call to get secret,
		Mock<IAccountsApi>(mock =>
		{
			mock.Setup(x => x.GetAdminMe(true))
				.ReturnsPromise(new AccountPortalView()
				{
					email = "tuna@tuna.com",
					id = 123
				})
				.Verifiable();
		});
		Mock<BeamoService>(mock =>
		{
			mock.Setup(x => x.GetCurrentManifest())
				.ReturnsPromise(new ServiceManifest())
				.Verifiable();
		});
		Mock<IRealmsApi>(mock =>
		{
			mock.Setup(x => x.GetAdminCustomer(true))
				.ReturnsPromise(new CustomerResponse
				{
					customer = new RealmsBasicCustomer
					{
						projects = new Beamable.Api.Autogenerated.Models.Project[]
						{
							new Beamable.Api.Autogenerated.Models.Project
							{
								name = pid,
								secret = secret
							}
						}
					}
				})
				.Verifiable();
		});

		// Get list of all containers
		var containers = await _dockerClient.Containers.ListContainersAsync(
			new ContainersListParameters { All = true });

		// Check if the container with the specified name is running
		var storageContainerName = $"/{storageName}_mongoDb";
		var matchingContainer = containers.FirstOrDefault(c => c.Names.Contains(storageContainerName));
		if (matchingContainer != null)
		{
			//Assert.IsFalse(isRunning, $"Container '{storageContainerName}' should not be running yet.");
			await _dockerClient.Containers.StopContainerAsync(matchingContainer.ID, new ContainerStopParameters());
		}

		#endregion

		#region Act

		Run("project", "generate-env", serviceName, ".", "--auto-deploy", "--include-secret", "--exclude-otel-creds", "--quiet");

		#endregion

		#region Assert

		containers = await _dockerClient.Containers.ListContainersAsync(
			new ContainersListParameters { All = true });
		var isRunning = containers.Any(c => c.Names.Contains(storageContainerName));
		Assert.IsTrue(isRunning, $"Container '{storageName}' should be running, now");

		// there should be an .env file
		Assert.IsFalse(BFile.Exists($".env"),
			"there must not be an .env file in the current directory.");

		containers = await _dockerClient.Containers.ListContainersAsync(
			new ContainersListParameters { All = true });
		matchingContainer = containers.FirstOrDefault(c => c.Names.Contains(storageContainerName));

		if (matchingContainer != null)
		{
			await _dockerClient.Containers.StopContainerAsync(matchingContainer.ID, new ContainerStopParameters());
		}

		#endregion
	}
}
