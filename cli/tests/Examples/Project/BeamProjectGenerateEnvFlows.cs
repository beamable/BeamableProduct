using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Api.Realms;
using cli.Utils;
using Docker.DotNet.Models;
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using tests.MoqExtensions;
using IRealmsApi = Beamable.Api.Autogenerated.Realms.IRealmsApi;

namespace tests.Examples.Project;

public class BeamProjectGenerateEnvFlows : CLITestExtensions
{
	[Test]
	[TestCase("Example", ".")]
	[TestCase("Example", "services")]
	[TestCase("Example", "services/Example")]
	public void GenerateEnv_NoDeps(string serviceName, string executeFrom)
	{
		#region Arrange
		const string secret = "secret";

		var newFlow = new BeamProjectNewFlows();
		newFlow.NewProject_AutoInit_NoSlnConfig(serviceName);
		ResetConfigurator();

		// step into newly created beamable folder...
		Directory.SetCurrentDirectory(serviceName);
		Directory.SetCurrentDirectory(executeFrom);

		// mock call to get secret,
		Mock<IRealmsApi>(mock =>
		{
			mock.Setup(x => x.GetAdminCustomer())
				.ReturnsPromise(new CustomerResponse
				{
					customer = new Customer
					{
						projects = new Beamable.Api.Autogenerated.Models.Project[]
						{
							new Beamable.Api.Autogenerated.Models.Project
							{
								name = pid,
								secret = secret
							}
						}
					}
				})
				.Verifiable();
		});


		#endregion

		#region Act


		Run("project", "generate-env", serviceName, ".", "--auto-deploy");

		#endregion

		#region Assert

		// there should be an .env file
		Assert.That(BFile.Exists($".env"),
			"there must be an .env file in the current directory.");

		// the contents of the file should include various ENV secrets...
		var envContent = BFile.ReadAllText(".env");
		Assert.That(envContent.Contains($"CID={cid}"),
			$"the env file must have a CID=[{cid}]. Content=[{envContent}]");
		Assert.That(envContent.Contains($"PID={pid}"),
			$"the env file must have a PID=[{pid}]. Content=[{envContent}]");
		Assert.That(envContent.Contains($"SECRET={secret}"),
			$"the env file must have a SECRET=[{secret}]. Content=[{envContent}]");
		Assert.That(envContent.Contains($"NAME_PREFIX="), // this is different on each machine, so not worth testing the value
			$"the env file must have a NAME_PREFIX. Content=[{envContent}]");
		Assert.That(envContent.Contains($"REFRESH_TOKEN=refresh"),
			$"the env file must have a REFRESH_TOKEN. Content=[{envContent}]");
		Assert.That(envContent.Contains($"BEAM_INSTANCE_COUNT=1"),
			$"the env file must have a BEAM_INSTANCE_COUNT. Content=[{envContent}]");
		Assert.That(envContent.Contains($"HOST=wss://api.beamable.com/socket"),
			$"the env file must have a HOST. Content=[{envContent}]");

		#endregion
	}

	[Test]
	[TestCase("Example", "DataCLITest", ".")]
	[TestCase("Example", "DataCLITest", "services")]
	[TestCase("Example", "DataCLITest", "services/Example")]
	public async Task GenerateEnv_WithADep(string serviceName, string storageName, string executeFrom)
	{
		#region Arrange
		const string secret = "secret";

		var newFlow = new BeamProjectNewFlows();
		newFlow.NewProject_UsingExistingInit_NoSlnConfig_AddStorageToExistingSln(serviceName, storageName);
		ResetConfigurator();

		// step into newly created beamable folder...
		Directory.SetCurrentDirectory(serviceName);
		Directory.SetCurrentDirectory(executeFrom);

		// mock call to get secret,
		Mock<IRealmsApi>(mock =>
		{
			mock.Setup(x => x.GetAdminCustomer())
				.ReturnsPromise(new CustomerResponse
				{
					customer = new Customer
					{
						projects = new Beamable.Api.Autogenerated.Models.Project[]
						{
							new Beamable.Api.Autogenerated.Models.Project
							{
								name = pid,
								secret = secret
							}
						}
					}
				})
				.Verifiable();
		});

		// Get list of all containers
		var containers = await _dockerClient.Containers.ListContainersAsync(
			new ContainersListParameters { All = true });

		// Check if the container with the specified name is running
		var storageContainerName = $"/{storageName}_mongoDb";
		var matchingContainer = containers.FirstOrDefault(c => c.Names.Contains(storageContainerName));
		if (matchingContainer != null)
		{
			//Assert.IsFalse(isRunning, $"Container '{storageContainerName}' should not be running yet.");
			await _dockerClient.Containers.StopContainerAsync(matchingContainer.ID, new ContainerStopParameters());
		}

		#endregion

		#region Act

		Run("project", "generate-env", serviceName, ".", "--auto-deploy");

		#endregion

		#region Assert

		containers = await _dockerClient.Containers.ListContainersAsync(
			new ContainersListParameters { All = true });
		var isRunning = containers.Any(c => c.Names.Contains(storageContainerName));
		Assert.IsTrue(isRunning, $"Container '{storageName}' should be running, now");

		// there should be an .env file
		Assert.That(BFile.Exists($".env"),
			"there must be an .env file in the current directory.");

		// the contents of the file should include various ENV secrets...
		var envContent = BFile.ReadAllText(".env");
		Assert.That(envContent.Contains($"CID={cid}"),
			$"the env file must have a CID=[{cid}]. Content=[{envContent}]");
		Assert.That(envContent.Contains($"PID={pid}"),
			$"the env file must have a PID=[{pid}]. Content=[{envContent}]");
		Assert.That(envContent.Contains($"SECRET={secret}"),
			$"the env file must have a SECRET=[{secret}]. Content=[{envContent}]");
		Assert.That(envContent.Contains($"NAME_PREFIX="), // this is different on each machine, so not worth testing the value
			$"the env file must have a NAME_PREFIX. Content=[{envContent}]");
		Assert.That(envContent.Contains($"REFRESH_TOKEN=refresh"),
			$"the env file must have a REFRESH_TOKEN. Content=[{envContent}]");
		Assert.That(envContent.Contains($"BEAM_INSTANCE_COUNT=1"),
			$"the env file must have a BEAM_INSTANCE_COUNT. Content=[{envContent}]");
		Assert.That(envContent.Contains($"HOST=wss://api.beamable.com/socket"),
			$"the env file must have a HOST. Content=[{envContent}]");

		containers = await _dockerClient.Containers.ListContainersAsync(
			new ContainersListParameters { All = true });
		matchingContainer = containers.FirstOrDefault(c => c.Names.Contains(storageContainerName));

		if (matchingContainer != null)
		{
			await _dockerClient.Containers.StopContainerAsync(matchingContainer.ID, new ContainerStopParameters());
		}

		#endregion
	}
}
