using Beamable.Api.Autogenerated.Beamo;
using Beamable.Server;
using Beamable.Tooling.Common.OpenAPI;
using cli;
using cli.FederationCommands;
using cli.Unreal;
using Microsoft.OpenApi.Models;
using Moq;
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.CommandLine;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Beamable.Common.Dependencies;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using ZLogger;
using tests.Examples;

namespace tests;

public class Tests : CLITest
{
	[Test]
	public void PrintVersion()
	{
		var status = Run("--version");
		Assert.AreEqual(0, status);
	}

	[Test]
	public void NamingPass()
	{
		var commandsThatDontNeedKebab = new HashSet<Type>
		{
			typeof(GetLocalSettingsIFederatedGameServerCommand),
			typeof(SetLocalSettingsIFederatedGameServerCommand)
		};
		
		
		List<(Func<bool>, string)> CheckNaming(Command command, string commandName, string description, string? optionName = null)
		{
			const string KEBAB_CASE_PATTERN = "^([a-z]|[0-9])+(?:[-]([a-z]|[0-9])+)*$";
			var isOption = !string.IsNullOrWhiteSpace(optionName);
			var logPrefix = isOption ?
				$"{optionName} argument for command {command.GetType().Name}" :
				$"{commandName} command";
			logPrefix = $"command-type=[{command.GetType().Name}] " + logPrefix;
			var assertions = new List<(Func<bool>, string)>();
			if (string.IsNullOrWhiteSpace(description))
			{
				assertions.Add((() => false, $"{logPrefix} description should be provided."));
			}
			if (!char.IsUpper(description[0]) && description[0] != '[')
			{
				assertions.Add((() => false, $"{logPrefix} description should start with upper letter."));
			}
			if (description.TrimEnd()[^1] == '.')
			{
				assertions.Add((() => false, $"{logPrefix} description should not end with dot."));
			}

			if (!commandsThatDontNeedKebab.Contains(command.GetType()))
			{
				var valueToCheck = isOption ? optionName! : commandName;
				var match = Regex.Match(valueToCheck, KEBAB_CASE_PATTERN);
				assertions.Add((() => match.Success == true, $"{logPrefix} - {valueToCheck} does not match kebab case naming."));
			}
			
			return assertions;
			// Assert.AreEqual(match.Success, true, $"{valueToCheck} does not match kebab case naming.");
		}
		var app = new App();
		app.Configure();
		app.Build();
		var commandsList = app.InstantiateAllCommands();

		var errorBuilder = new StringBuilder();
		var hasFailed = false;
		foreach (var command in commandsList)
		{
			var assertions = CheckNaming(command, command.Name, command.Description!);
			foreach (var (assertion, failMessage) in assertions)
			{
				if (!assertion())
				{
					hasFailed = true;
					errorBuilder.AppendLine(failMessage);
				}
			}
			
			var sameDescriptionCommand = commandsList.FirstOrDefault(c =>
				c.Name != command.Name &&
				c.Description != null &&
				c.Description.Equals(command.Description, StringComparison.InvariantCultureIgnoreCase));

			if (sameDescriptionCommand != null)
			{
				hasFailed = true;
				errorBuilder.AppendLine($"{command.Name} and {sameDescriptionCommand.Name} have the same description.");
				// Assert.Fail($"{command.Name} and {sameDescriptionCommand.Name} have the same description.", command, sameDescriptionCommand);
			}

			foreach (Option option in command.Options)
			{
				var optionAssertions = CheckNaming(command, command.Name, option.Description!, option.Name);
				foreach (var (assertion, failMessage) in optionAssertions)
				{
					if (!assertion())
					{
						hasFailed = true;
						errorBuilder.AppendLine(failMessage);
					}
				}
				
			}
		}

		if (hasFailed)
		{
			Assert.Fail(errorBuilder.ToString());
		}


	}

	// // use this test to help identify live issues
	// [Test]
	// public async Task TestBrokenOrder()
	// {
	// 	var status = await Cli.RunAsyncWithParams("--host", "https://dev.api.beamable.com", "oapi", "generate", "--conflict-strategy", "RenameUncommonConflicts", "--engine", "unity");
	// }

	[Test]
	public void TestUnrealMicroserviceGen()
	{
		BeamableZLoggerProvider.Provider = new BeamableZLoggerProvider();
		BeamableZLoggerProvider.LogContext.Value = LoggerFactory.Create(builder =>
		{
			builder.AddZLoggerConsole();
		}).CreateLogger<Tests>();
		
		var gen = new ServiceDocGenerator();
		
		var builder = new DependencyBuilder();
		
		builder.AddSingleton<BeamStandardTelemetryAttributeProvider>();
		builder.AddSingleton<SingletonDependencyList<ITelemetryAttributeProvider>>();
		builder.AddSingleton<IMicroserviceArgs>(new MicroserviceArgs());
		var provider = builder.Build();
		var doc = gen.Generate<TroublesomeService>(provider);

		UnrealSourceGenerator.exportMacro = "TROUBLESOMEPROJECT_API";
		UnrealSourceGenerator.blueprintExportMacro = "TROUBLESOMEPROJECTBLUEPRINTNODES_API";
		UnrealSourceGenerator.headerFileOutputPath = "/";
		UnrealSourceGenerator.cppFileOutputPath = "/";
		UnrealSourceGenerator.blueprintHeaderFileOutputPath = "/Public/";
		UnrealSourceGenerator.blueprintCppFileOutputPath = "/Private/";
		UnrealSourceGenerator.genType = UnrealSourceGenerator.GenerationType.Microservice;
		var generator = new UnrealSourceGenerator();
		var docs = new List<OpenApiDocument>() { doc };
		var orderedSchemas = SwaggerService.ExtractAllSchemas(docs,
			GenerateSdkConflictResolutionStrategy.RenameUncommonConflicts);
		var ctx = new SwaggerService.DefaultGenerationContext
		{
			Documents = docs,
			OrderedSchemas = orderedSchemas,
			ReplacementTypes = new Dictionary<OpenApiReferenceId, ReplacementTypeInfo>()
		};
		var descriptors = generator.Generate(ctx);

		Console.WriteLine("----- OUTPUT ----");
		Console.WriteLine(string.Join("\n", descriptors.Select(d => $"{d.FileName}\n\n{d.Content}\n")));

		Assert.AreEqual(15, descriptors.Count);
	}

	[Microservice("troublesome")]
	public class TroublesomeService : Microservice
	{
		[Callable]
		public int Add(int a, int b) => a + b;
	}

	[Test]
	public void GenerateSocialBasic() // TODO: better name please
	{
		Mock<ISwaggerStreamDownloader>(mock =>
		{
			mock.Setup(x => x.GetStreamAsync(It.Is<string>(x => x.Contains("basic") && x.Contains("social"))))
				.ReturnsAsync(GenerateStreamFromString(OpenApiFixtures.SocialBasicOpenApi));
		});

		var status = Run("oapi", "generate", "--filter", "social,t:basic", "--engine", "unity");
		Assert.AreEqual(0, status);
	}
	
	[Test]
	public void GenerateInventoryBasic() // TODO: better name please
	{
		Mock<ISwaggerStreamDownloader>(mock =>
		{
			mock.Setup(x => x.GetStreamAsync(It.Is<string>(x => x.Contains("basic") && x.Contains("inventory"))))
				.ReturnsAsync(GenerateStreamFromString(OpenApiFixtures.InventoryBasicOpenApi));
		});

		var status = Run("oapi", "generate", "--filter", "inventory,t:basic", "--engine", "unity");
		Assert.AreEqual(0, status);
	}

	[Test]
	public void GenerateInventoryObject() // TODO: better name please
	{
		Mock<ISwaggerStreamDownloader>(mock =>
		{
			mock.Setup(x => x.GetStreamAsync(It.Is<string>(x => x.Contains("object") && x.Contains("inventory"))))
				.ReturnsAsync(GenerateStreamFromString(OpenApiFixtures.InventoryObjectOpenApi));
		});

		var status = Run("oapi", "generate", "--filter", "inventory,t:object", "--engine", "unity");
		Assert.AreEqual(0, status);
	}
	
	[Test]
	public void GenerateAccountsBasic() // TODO: better name please
	{
		Mock<ISwaggerStreamDownloader>(mock =>
		{
			mock.Setup(x => x.GetStreamAsync(It.Is<string>(x => x.Contains("basic") && x.Contains("accounts"))))
				.ReturnsAsync(GenerateStreamFromString(OpenApiFixtures.AccountBasicOpenApi));
		});

		var status = Run("oapi", "generate", "--filter", "accounts,t:basic", "--engine", "unity");
		Assert.AreEqual(0, status);
	}
	
	[Test]
	public void GenerateAccountsObject() // TODO: better name please
	{
		Mock<ISwaggerStreamDownloader>(mock =>
		{
			mock.Setup(x => x.GetStreamAsync(It.Is<string>(x => x.Contains("object") && x.Contains("accounts"))))
				.ReturnsAsync(GenerateStreamFromString(OpenApiFixtures.AccountObjectOpenApi));
		});

		var status = Run("oapi", "generate", "--filter", "accounts,t:object", "--engine", "unity");
		Assert.AreEqual(0, status);
	}
	
	[Test]
	public void GenerateEventPlayersObject() // TODO: better name please
	{
		Mock<ISwaggerStreamDownloader>(mock =>
		{
			mock.Setup(x => x.GetStreamAsync(It.Is<string>(x => x.Contains("object") && x.Contains("event-players"))))
				.ReturnsAsync(GenerateStreamFromString(OpenApiFixtures.EventPlayersObjectApi));
		});

		var status = Run("oapi", "generate", "--filter", "event-players,t:object", "--engine", "unity");
		Assert.AreEqual(0, status);
	}

	[Test]
	public void GenerateContent()
	{
		Mock<ISwaggerStreamDownloader>(mock =>
		{
			mock.Setup(x => x.GetStreamAsync(It.Is<string>(x => x.Contains("basic") && x.Contains("content"))))
				.ReturnsAsync(GenerateStreamFromString(OpenApiFixtures.ContentBasicApi));
		});
		
		var status = Run("oapi", "generate", "--filter", "content,t:basic", "--engine", "unity");
		Assert.AreEqual(0, status);
	}


	[Test]
	public void GenerateSession()
	{
		Mock<ISwaggerStreamDownloader>(mock =>
		{
			mock.Setup(x => x.GetStreamAsync(It.Is<string>(x => x.Contains("basic") && x.Contains("session"))))
				.ReturnsAsync(GenerateStreamFromString(OpenApiFixtures.SessionBasic));
		});

		var status = Run("oapi", "generate", "--filter", "session,t:basic", "--engine", "unity");
		Assert.AreEqual(0, status);
	}
	
	[Test]
	public void GenerateBeamo()
	{
		// no mocking is required, because the beamo service is now hardcoded. 
		var status = Run("oapi", "generate", "--filter", "beamo,t:basic", "--engine", "unity");
		Assert.AreEqual(0, status);
	}


	[Test]
	public void GenerateProtoActor()
	{
		Mock<ISwaggerStreamDownloader>(mock =>
		{
			mock.Setup(x => x.GetStreamAsync(It.Is<string>(x => x.Contains("api"))))
				.ReturnsAsync(GenerateStreamFromString(OpenApiFixtures.ProtoActor));
		});
		var status = Run("oapi", "generate", "--filter", "t:api", "--engine", "unity", "--conflict-strategy", "RenameUncommonConflicts");
		Assert.AreEqual(0, status);
	}

	//dotnet run --project ./cli/cli -- --host https://dev.api.beamable.com oapi generate --filter t:api --engine unity --conflict-strategy RenameUncommonConflicts --output ./client/Packages/com.beamable/Runtime/OpenApi2

	public static Stream GenerateStreamFromString(string s)
	{
		var stream = new MemoryStream();
		var writer = new StreamWriter(stream);
		writer.Write(s);
		writer.Flush();
		stream.Position = 0;
		return stream;
	}
}
